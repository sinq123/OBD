/* soapC.cpp
   Generated by gSOAP 2.8.21 from onvif.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.21 2020-10-29 03:46:20 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__cgjLSPSelfcheckResponse:
		return soap_in_ns1__cgjLSPSelfcheckResponse(soap, NULL, NULL, "ns1:cgjLSPSelfcheckResponse");
	case SOAP_TYPE_ns1__cgjLSPSelfcheck:
		return soap_in_ns1__cgjLSPSelfcheck(soap, NULL, NULL, "ns1:cgjLSPSelfcheck");
	case SOAP_TYPE_ns1__lljSelfcheckResponse:
		return soap_in_ns1__lljSelfcheckResponse(soap, NULL, NULL, "ns1:lljSelfcheckResponse");
	case SOAP_TYPE_ns1__lljSelfcheck:
		return soap_in_ns1__lljSelfcheck(soap, NULL, NULL, "ns1:lljSelfcheck");
	case SOAP_TYPE_ns1__cgjALPSelfcheckResponse:
		return soap_in_ns1__cgjALPSelfcheckResponse(soap, NULL, NULL, "ns1:cgjALPSelfcheckResponse");
	case SOAP_TYPE_ns1__cgjALPSelfcheck:
		return soap_in_ns1__cgjALPSelfcheck(soap, NULL, NULL, "ns1:cgjALPSelfcheck");
	case SOAP_TYPE_ns1__wqfxySelfcheckResponse:
		return soap_in_ns1__wqfxySelfcheckResponse(soap, NULL, NULL, "ns1:wqfxySelfcheckResponse");
	case SOAP_TYPE_ns1__wqfxySelfcheck:
		return soap_in_ns1__wqfxySelfcheck(soap, NULL, NULL, "ns1:wqfxySelfcheck");
	case SOAP_TYPE_ns1__sendMessage_USCOREFC:
		return soap_in_ns1__sendMessage_USCOREFC(soap, NULL, NULL, "ns1:sendMessage_FC");
	case SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse:
		return soap_in_ns1__sdsqtfxySelfcheckResponse(soap, NULL, NULL, "ns1:sdsqtfxySelfcheckResponse");
	case SOAP_TYPE_ns1__sdsqtfxySelfcheck:
		return soap_in_ns1__sdsqtfxySelfcheck(soap, NULL, NULL, "ns1:sdsqtfxySelfcheck");
	case SOAP_TYPE_ns1__qyfxSelfcheckResponse:
		return soap_in_ns1__qyfxSelfcheckResponse(soap, NULL, NULL, "ns1:qyfxSelfcheckResponse");
	case SOAP_TYPE_ns1__qyfxSelfcheck:
		return soap_in_ns1__qyfxSelfcheck(soap, NULL, NULL, "ns1:qyfxSelfcheck");
	case SOAP_TYPE_ns1__lightproofSmokeData:
		return soap_in_ns1__lightproofSmokeData(soap, NULL, NULL, "ns1:lightproofSmokeData");
	case SOAP_TYPE_ns1__lightproofSmokeDataResponse:
		return soap_in_ns1__lightproofSmokeDataResponse(soap, NULL, NULL, "ns1:lightproofSmokeDataResponse");
	case SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC:
		return soap_in_ns1__lightproofSmokeData_USCOREFC(soap, NULL, NULL, "ns1:lightproofSmokeData_FC");
	case SOAP_TYPE_ns1__wqfxyAdjustResponse:
		return soap_in_ns1__wqfxyAdjustResponse(soap, NULL, NULL, "ns1:wqfxyAdjustResponse");
	case SOAP_TYPE_ns1__wqfxyAdjust:
		return soap_in_ns1__wqfxyAdjust(soap, NULL, NULL, "ns1:wqfxyAdjust");
	case SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse:
		return soap_in_ns1__cgjPLHPSelfcheckResponse(soap, NULL, NULL, "ns1:cgjPLHPSelfcheckResponse");
	case SOAP_TYPE_ns1__cgjPLHPSelfcheck:
		return soap_in_ns1__cgjPLHPSelfcheck(soap, NULL, NULL, "ns1:cgjPLHPSelfcheck");
	case SOAP_TYPE_ns1__doubleIdleLog:
		return soap_in_ns1__doubleIdleLog(soap, NULL, NULL, "ns1:doubleIdleLog");
	case SOAP_TYPE_ns1__doubleIdleData:
		return soap_in_ns1__doubleIdleData(soap, NULL, NULL, "ns1:doubleIdleData");
	case SOAP_TYPE_ns1__stateInfo:
		return soap_in_ns1__stateInfo(soap, NULL, NULL, "ns1:stateInfo");
	case SOAP_TYPE_ns1__getSatateResponse:
		return soap_in_ns1__getSatateResponse(soap, NULL, NULL, "ns1:getSatateResponse");
	case SOAP_TYPE_ns1__getSatate:
		return soap_in_ns1__getSatate(soap, NULL, NULL, "ns1:getSatate");
	case SOAP_TYPE_ns1__motoDbIdleDataResponse:
		return soap_in_ns1__motoDbIdleDataResponse(soap, NULL, NULL, "ns1:motoDbIdleDataResponse");
	case SOAP_TYPE_ns1__motoDbIdleData:
		return soap_in_ns1__motoDbIdleData(soap, NULL, NULL, "ns1:motoDbIdleData");
	case SOAP_TYPE_ns1__vmasDataResponse:
		return soap_in_ns1__vmasDataResponse(soap, NULL, NULL, "ns1:vmasDataResponse");
	case SOAP_TYPE_ns1__vmasData:
		return soap_in_ns1__vmasData(soap, NULL, NULL, "ns1:vmasData");
	case SOAP_TYPE_ns1__loadDownDataResponse:
		return soap_in_ns1__loadDownDataResponse(soap, NULL, NULL, "ns1:loadDownDataResponse");
	case SOAP_TYPE_ns1__loadDownData:
		return soap_in_ns1__loadDownData(soap, NULL, NULL, "ns1:loadDownData");
	case SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse:
		return soap_in_ns1__lightproofSmokeDataLog_USCOREFCResponse(soap, NULL, NULL, "ns1:lightproofSmokeDataLog_FCResponse");
	case SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC:
		return soap_in_ns1__lightproofSmokeDataLog_USCOREFC(soap, NULL, NULL, "ns1:lightproofSmokeDataLog_FC");
	case SOAP_TYPE_ns1__pqfxySelfcheckResponse:
		return soap_in_ns1__pqfxySelfcheckResponse(soap, NULL, NULL, "ns1:pqfxySelfcheckResponse");
	case SOAP_TYPE_ns1__pqfxySelfcheck:
		return soap_in_ns1__pqfxySelfcheck(soap, NULL, NULL, "ns1:pqfxySelfcheck");
	case SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse:
		return soap_in_ns1__hjcsgyqSelfcheckResponse(soap, NULL, NULL, "ns1:hjcsgyqSelfcheckResponse");
	case SOAP_TYPE_ns1__hjcsgyqSelfcheck:
		return soap_in_ns1__hjcsgyqSelfcheck(soap, NULL, NULL, "ns1:hjcsgyqSelfcheck");
	case SOAP_TYPE_ns1__cycdyhwAdjustResponse:
		return soap_in_ns1__cycdyhwAdjustResponse(soap, NULL, NULL, "ns1:cycdyhwAdjustResponse");
	case SOAP_TYPE_ns1__cycdyhwAdjust:
		return soap_in_ns1__cycdyhwAdjust(soap, NULL, NULL, "ns1:cycdyhwAdjust");
	case SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse:
		return soap_in_ns1__software2centerNew_USCOREFCResponse(soap, NULL, NULL, "ns1:software2centerNew_FCResponse");
	case SOAP_TYPE_ns1__software2centerNew_USCOREFC:
		return soap_in_ns1__software2centerNew_USCOREFC(soap, NULL, NULL, "ns1:software2centerNew_FC");
	case SOAP_TYPE_ns1__getCarInfo_USCOREFC:
		return soap_in_ns1__getCarInfo_USCOREFC(soap, NULL, NULL, "ns1:getCarInfo_FC");
	case SOAP_TYPE_ns1__obdResultLogResponse:
		return soap_in_ns1__obdResultLogResponse(soap, NULL, NULL, "ns1:obdResultLogResponse");
	case SOAP_TYPE_ns1__obdResultLog:
		return soap_in_ns1__obdResultLog(soap, NULL, NULL, "ns1:obdResultLog");
	case SOAP_TYPE_ns1__dyhwAdjustResponse:
		return soap_in_ns1__dyhwAdjustResponse(soap, NULL, NULL, "ns1:dyhwAdjustResponse");
	case SOAP_TYPE_ns1__dyhwAdjust:
		return soap_in_ns1__dyhwAdjust(soap, NULL, NULL, "ns1:dyhwAdjust");
	case SOAP_TYPE_ns1__loadDownLogResponse:
		return soap_in_ns1__loadDownLogResponse(soap, NULL, NULL, "ns1:loadDownLogResponse");
	case SOAP_TYPE_ns1__loadDownLog:
		return soap_in_ns1__loadDownLog(soap, NULL, NULL, "ns1:loadDownLog");
	case SOAP_TYPE_ns1__dyhwSelfcheckResponse:
		return soap_in_ns1__dyhwSelfcheckResponse(soap, NULL, NULL, "ns1:dyhwSelfcheckResponse");
	case SOAP_TYPE_ns1__dyhwSelfcheck:
		return soap_in_ns1__dyhwSelfcheck(soap, NULL, NULL, "ns1:dyhwSelfcheck");
	case SOAP_TYPE_ns1__ydjSelfcheckResponse:
		return soap_in_ns1__ydjSelfcheckResponse(soap, NULL, NULL, "ns1:ydjSelfcheckResponse");
	case SOAP_TYPE_ns1__ydjSelfcheck:
		return soap_in_ns1__ydjSelfcheck(soap, NULL, NULL, "ns1:ydjSelfcheck");
	case SOAP_TYPE_ns1__vmasLogResponse:
		return soap_in_ns1__vmasLogResponse(soap, NULL, NULL, "ns1:vmasLogResponse");
	case SOAP_TYPE_ns1__vmasLog:
		return soap_in_ns1__vmasLog(soap, NULL, NULL, "ns1:vmasLog");
	case SOAP_TYPE_ns1__doubleIdleLogResponse:
		return soap_in_ns1__doubleIdleLogResponse(soap, NULL, NULL, "ns1:doubleIdleLogResponse");
	case SOAP_TYPE_ns1__doubleIdleLog_USCOREFC:
		return soap_in_ns1__doubleIdleLog_USCOREFC(soap, NULL, NULL, "ns1:doubleIdleLog_FC");
	case SOAP_TYPE_ns1__obdResultResponse:
		return soap_in_ns1__obdResultResponse(soap, NULL, NULL, "ns1:obdResultResponse");
	case SOAP_TYPE_ns1__obdResult:
		return soap_in_ns1__obdResult(soap, NULL, NULL, "ns1:obdResult");
	case SOAP_TYPE_ns1__cgjSelfcheckResponse:
		return soap_in_ns1__cgjSelfcheckResponse(soap, NULL, NULL, "ns1:cgjSelfcheckResponse");
	case SOAP_TYPE_ns1__cgjSelfcheck:
		return soap_in_ns1__cgjSelfcheck(soap, NULL, NULL, "ns1:cgjSelfcheck");
	case SOAP_TYPE_ns1__cgjLASelfcheckResponse:
		return soap_in_ns1__cgjLASelfcheckResponse(soap, NULL, NULL, "ns1:cgjLASelfcheckResponse");
	case SOAP_TYPE_ns1__cgjLASelfcheck:
		return soap_in_ns1__cgjLASelfcheck(soap, NULL, NULL, "ns1:cgjLASelfcheck");
	case SOAP_TYPE_ns1__doubleIdleDataResponse:
		return soap_in_ns1__doubleIdleDataResponse(soap, NULL, NULL, "ns1:doubleIdleDataResponse");
	case SOAP_TYPE_ns1__doubleIdleData_USCOREFC:
		return soap_in_ns1__doubleIdleData_USCOREFC(soap, NULL, NULL, "ns1:doubleIdleData_FC");
	case SOAP_TYPE_ns1__bgAirHCResponse:
		return soap_in_ns1__bgAirHCResponse(soap, NULL, NULL, "ns1:bgAirHCResponse");
	case SOAP_TYPE_ns1__bgAirHC:
		return soap_in_ns1__bgAirHC(soap, NULL, NULL, "ns1:bgAirHC");
	case SOAP_TYPE_ns1__sendMessageResponse:
		return soap_in_ns1__sendMessageResponse(soap, NULL, NULL, "ns1:sendMessageResponse");
	case SOAP_TYPE_ns1__sendMessage:
		return soap_in_ns1__sendMessage(soap, NULL, NULL, "ns1:sendMessage");
	case SOAP_TYPE_ns1__carInfo:
		return soap_in_ns1__carInfo(soap, NULL, NULL, "ns1:carInfo");
	case SOAP_TYPE_ns1__getCarInfoResponse:
		return soap_in_ns1__getCarInfoResponse(soap, NULL, NULL, "ns1:getCarInfoResponse");
	case SOAP_TYPE_ns1__getCarInfo:
		return soap_in_ns1__getCarInfo(soap, NULL, NULL, "ns1:getCarInfo");
	case SOAP_TYPE_ns1__lightproofSmokeLogResponse:
		return soap_in_ns1__lightproofSmokeLogResponse(soap, NULL, NULL, "ns1:lightproofSmokeLogResponse");
	case SOAP_TYPE_ns1__lightproofSmokeLog:
		return soap_in_ns1__lightproofSmokeLog(soap, NULL, NULL, "ns1:lightproofSmokeLog");
	case SOAP_TYPE_ns1__argChangResponse:
		return soap_in_ns1__argChangResponse(soap, NULL, NULL, "ns1:argChangResponse");
	case SOAP_TYPE_ns1__argChang:
		return soap_in_ns1__argChang(soap, NULL, NULL, "ns1:argChang");
	case SOAP_TYPE_PointerTons1__cgjLSPSelfcheck:
		return soap_in_PointerTons1__cgjLSPSelfcheck(soap, NULL, NULL, "ns1:cgjLSPSelfcheck");
	case SOAP_TYPE_PointerTons1__lljSelfcheck:
		return soap_in_PointerTons1__lljSelfcheck(soap, NULL, NULL, "ns1:lljSelfcheck");
	case SOAP_TYPE_PointerTons1__cgjALPSelfcheck:
		return soap_in_PointerTons1__cgjALPSelfcheck(soap, NULL, NULL, "ns1:cgjALPSelfcheck");
	case SOAP_TYPE_PointerTons1__wqfxySelfcheck:
		return soap_in_PointerTons1__wqfxySelfcheck(soap, NULL, NULL, "ns1:wqfxySelfcheck");
	case SOAP_TYPE_PointerTons1__sendMessage_USCOREFC:
		return soap_in_PointerTons1__sendMessage_USCOREFC(soap, NULL, NULL, "ns1:sendMessage_FC");
	case SOAP_TYPE_PointerTons1__sdsqtfxySelfcheck:
		return soap_in_PointerTons1__sdsqtfxySelfcheck(soap, NULL, NULL, "ns1:sdsqtfxySelfcheck");
	case SOAP_TYPE_PointerTons1__qyfxSelfcheck:
		return soap_in_PointerTons1__qyfxSelfcheck(soap, NULL, NULL, "ns1:qyfxSelfcheck");
	case SOAP_TYPE_PointerTons1__lightproofSmokeData:
		return soap_in_PointerTons1__lightproofSmokeData(soap, NULL, NULL, "ns1:lightproofSmokeData");
	case SOAP_TYPE_PointerTons1__lightproofSmokeData_USCOREFC:
		return soap_in_PointerTons1__lightproofSmokeData_USCOREFC(soap, NULL, NULL, "ns1:lightproofSmokeData_FC");
	case SOAP_TYPE_PointerTons1__wqfxyAdjust:
		return soap_in_PointerTons1__wqfxyAdjust(soap, NULL, NULL, "ns1:wqfxyAdjust");
	case SOAP_TYPE_PointerTons1__cgjPLHPSelfcheck:
		return soap_in_PointerTons1__cgjPLHPSelfcheck(soap, NULL, NULL, "ns1:cgjPLHPSelfcheck");
	case SOAP_TYPE_PointerTons1__doubleIdleLog:
		return soap_in_PointerTons1__doubleIdleLog(soap, NULL, NULL, "ns1:doubleIdleLog");
	case SOAP_TYPE_PointerTons1__doubleIdleData:
		return soap_in_PointerTons1__doubleIdleData(soap, NULL, NULL, "ns1:doubleIdleData");
	case SOAP_TYPE_PointerTons1__getSatate:
		return soap_in_PointerTons1__getSatate(soap, NULL, NULL, "ns1:getSatate");
	case SOAP_TYPE_PointerTons1__motoDbIdleData:
		return soap_in_PointerTons1__motoDbIdleData(soap, NULL, NULL, "ns1:motoDbIdleData");
	case SOAP_TYPE_PointerTons1__vmasData:
		return soap_in_PointerTons1__vmasData(soap, NULL, NULL, "ns1:vmasData");
	case SOAP_TYPE_PointerTons1__loadDownData:
		return soap_in_PointerTons1__loadDownData(soap, NULL, NULL, "ns1:loadDownData");
	case SOAP_TYPE_PointerTons1__lightproofSmokeDataLog_USCOREFC:
		return soap_in_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, NULL, NULL, "ns1:lightproofSmokeDataLog_FC");
	case SOAP_TYPE_PointerTons1__pqfxySelfcheck:
		return soap_in_PointerTons1__pqfxySelfcheck(soap, NULL, NULL, "ns1:pqfxySelfcheck");
	case SOAP_TYPE_PointerTons1__hjcsgyqSelfcheck:
		return soap_in_PointerTons1__hjcsgyqSelfcheck(soap, NULL, NULL, "ns1:hjcsgyqSelfcheck");
	case SOAP_TYPE_PointerTons1__cycdyhwAdjust:
		return soap_in_PointerTons1__cycdyhwAdjust(soap, NULL, NULL, "ns1:cycdyhwAdjust");
	case SOAP_TYPE_PointerTons1__software2centerNew_USCOREFC:
		return soap_in_PointerTons1__software2centerNew_USCOREFC(soap, NULL, NULL, "ns1:software2centerNew_FC");
	case SOAP_TYPE_PointerTons1__getCarInfo_USCOREFC:
		return soap_in_PointerTons1__getCarInfo_USCOREFC(soap, NULL, NULL, "ns1:getCarInfo_FC");
	case SOAP_TYPE_PointerTons1__obdResultLog:
		return soap_in_PointerTons1__obdResultLog(soap, NULL, NULL, "ns1:obdResultLog");
	case SOAP_TYPE_PointerTons1__dyhwAdjust:
		return soap_in_PointerTons1__dyhwAdjust(soap, NULL, NULL, "ns1:dyhwAdjust");
	case SOAP_TYPE_PointerTons1__loadDownLog:
		return soap_in_PointerTons1__loadDownLog(soap, NULL, NULL, "ns1:loadDownLog");
	case SOAP_TYPE_PointerTons1__dyhwSelfcheck:
		return soap_in_PointerTons1__dyhwSelfcheck(soap, NULL, NULL, "ns1:dyhwSelfcheck");
	case SOAP_TYPE_PointerTons1__ydjSelfcheck:
		return soap_in_PointerTons1__ydjSelfcheck(soap, NULL, NULL, "ns1:ydjSelfcheck");
	case SOAP_TYPE_PointerTons1__vmasLog:
		return soap_in_PointerTons1__vmasLog(soap, NULL, NULL, "ns1:vmasLog");
	case SOAP_TYPE_PointerTons1__doubleIdleLog_USCOREFC:
		return soap_in_PointerTons1__doubleIdleLog_USCOREFC(soap, NULL, NULL, "ns1:doubleIdleLog_FC");
	case SOAP_TYPE_PointerTons1__obdResult:
		return soap_in_PointerTons1__obdResult(soap, NULL, NULL, "ns1:obdResult");
	case SOAP_TYPE_PointerTons1__cgjSelfcheck:
		return soap_in_PointerTons1__cgjSelfcheck(soap, NULL, NULL, "ns1:cgjSelfcheck");
	case SOAP_TYPE_PointerTons1__cgjLASelfcheck:
		return soap_in_PointerTons1__cgjLASelfcheck(soap, NULL, NULL, "ns1:cgjLASelfcheck");
	case SOAP_TYPE_PointerTons1__doubleIdleData_USCOREFC:
		return soap_in_PointerTons1__doubleIdleData_USCOREFC(soap, NULL, NULL, "ns1:doubleIdleData_FC");
	case SOAP_TYPE_PointerTons1__bgAirHC:
		return soap_in_PointerTons1__bgAirHC(soap, NULL, NULL, "ns1:bgAirHC");
	case SOAP_TYPE_PointerTons1__sendMessage:
		return soap_in_PointerTons1__sendMessage(soap, NULL, NULL, "ns1:sendMessage");
	case SOAP_TYPE_PointerTons1__getCarInfo:
		return soap_in_PointerTons1__getCarInfo(soap, NULL, NULL, "ns1:getCarInfo");
	case SOAP_TYPE_PointerTons1__lightproofSmokeLog:
		return soap_in_PointerTons1__lightproofSmokeLog(soap, NULL, NULL, "ns1:lightproofSmokeLog");
	case SOAP_TYPE_PointerTons1__argChang:
		return soap_in_PointerTons1__argChang(soap, NULL, NULL, "ns1:argChang");
	case SOAP_TYPE_PointerTons1__stateInfo:
		return soap_in_PointerTons1__stateInfo(soap, NULL, NULL, "ns1:stateInfo");
	case SOAP_TYPE_PointerTons1__carInfo:
		return soap_in_PointerTons1__carInfo(soap, NULL, NULL, "ns1:carInfo");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_in_PointerTostd__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjLSPSelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__cgjLSPSelfcheckResponse;
			return soap_in_ns1__cgjLSPSelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjLSPSelfcheck"))
		{	*type = SOAP_TYPE_ns1__cgjLSPSelfcheck;
			return soap_in_ns1__cgjLSPSelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lljSelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__lljSelfcheckResponse;
			return soap_in_ns1__lljSelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lljSelfcheck"))
		{	*type = SOAP_TYPE_ns1__lljSelfcheck;
			return soap_in_ns1__lljSelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjALPSelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__cgjALPSelfcheckResponse;
			return soap_in_ns1__cgjALPSelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjALPSelfcheck"))
		{	*type = SOAP_TYPE_ns1__cgjALPSelfcheck;
			return soap_in_ns1__cgjALPSelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wqfxySelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__wqfxySelfcheckResponse;
			return soap_in_ns1__wqfxySelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wqfxySelfcheck"))
		{	*type = SOAP_TYPE_ns1__wqfxySelfcheck;
			return soap_in_ns1__wqfxySelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendMessage_FC"))
		{	*type = SOAP_TYPE_ns1__sendMessage_USCOREFC;
			return soap_in_ns1__sendMessage_USCOREFC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sdsqtfxySelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse;
			return soap_in_ns1__sdsqtfxySelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sdsqtfxySelfcheck"))
		{	*type = SOAP_TYPE_ns1__sdsqtfxySelfcheck;
			return soap_in_ns1__sdsqtfxySelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:qyfxSelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__qyfxSelfcheckResponse;
			return soap_in_ns1__qyfxSelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:qyfxSelfcheck"))
		{	*type = SOAP_TYPE_ns1__qyfxSelfcheck;
			return soap_in_ns1__qyfxSelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lightproofSmokeData"))
		{	*type = SOAP_TYPE_ns1__lightproofSmokeData;
			return soap_in_ns1__lightproofSmokeData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lightproofSmokeDataResponse"))
		{	*type = SOAP_TYPE_ns1__lightproofSmokeDataResponse;
			return soap_in_ns1__lightproofSmokeDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lightproofSmokeData_FC"))
		{	*type = SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC;
			return soap_in_ns1__lightproofSmokeData_USCOREFC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wqfxyAdjustResponse"))
		{	*type = SOAP_TYPE_ns1__wqfxyAdjustResponse;
			return soap_in_ns1__wqfxyAdjustResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wqfxyAdjust"))
		{	*type = SOAP_TYPE_ns1__wqfxyAdjust;
			return soap_in_ns1__wqfxyAdjust(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjPLHPSelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse;
			return soap_in_ns1__cgjPLHPSelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjPLHPSelfcheck"))
		{	*type = SOAP_TYPE_ns1__cgjPLHPSelfcheck;
			return soap_in_ns1__cgjPLHPSelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doubleIdleLog"))
		{	*type = SOAP_TYPE_ns1__doubleIdleLog;
			return soap_in_ns1__doubleIdleLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doubleIdleData"))
		{	*type = SOAP_TYPE_ns1__doubleIdleData;
			return soap_in_ns1__doubleIdleData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:stateInfo"))
		{	*type = SOAP_TYPE_ns1__stateInfo;
			return soap_in_ns1__stateInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSatateResponse"))
		{	*type = SOAP_TYPE_ns1__getSatateResponse;
			return soap_in_ns1__getSatateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSatate"))
		{	*type = SOAP_TYPE_ns1__getSatate;
			return soap_in_ns1__getSatate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:motoDbIdleDataResponse"))
		{	*type = SOAP_TYPE_ns1__motoDbIdleDataResponse;
			return soap_in_ns1__motoDbIdleDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:motoDbIdleData"))
		{	*type = SOAP_TYPE_ns1__motoDbIdleData;
			return soap_in_ns1__motoDbIdleData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:vmasDataResponse"))
		{	*type = SOAP_TYPE_ns1__vmasDataResponse;
			return soap_in_ns1__vmasDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:vmasData"))
		{	*type = SOAP_TYPE_ns1__vmasData;
			return soap_in_ns1__vmasData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loadDownDataResponse"))
		{	*type = SOAP_TYPE_ns1__loadDownDataResponse;
			return soap_in_ns1__loadDownDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loadDownData"))
		{	*type = SOAP_TYPE_ns1__loadDownData;
			return soap_in_ns1__loadDownData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lightproofSmokeDataLog_FCResponse"))
		{	*type = SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse;
			return soap_in_ns1__lightproofSmokeDataLog_USCOREFCResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lightproofSmokeDataLog_FC"))
		{	*type = SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC;
			return soap_in_ns1__lightproofSmokeDataLog_USCOREFC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:pqfxySelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__pqfxySelfcheckResponse;
			return soap_in_ns1__pqfxySelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:pqfxySelfcheck"))
		{	*type = SOAP_TYPE_ns1__pqfxySelfcheck;
			return soap_in_ns1__pqfxySelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hjcsgyqSelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse;
			return soap_in_ns1__hjcsgyqSelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hjcsgyqSelfcheck"))
		{	*type = SOAP_TYPE_ns1__hjcsgyqSelfcheck;
			return soap_in_ns1__hjcsgyqSelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cycdyhwAdjustResponse"))
		{	*type = SOAP_TYPE_ns1__cycdyhwAdjustResponse;
			return soap_in_ns1__cycdyhwAdjustResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cycdyhwAdjust"))
		{	*type = SOAP_TYPE_ns1__cycdyhwAdjust;
			return soap_in_ns1__cycdyhwAdjust(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:software2centerNew_FCResponse"))
		{	*type = SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse;
			return soap_in_ns1__software2centerNew_USCOREFCResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:software2centerNew_FC"))
		{	*type = SOAP_TYPE_ns1__software2centerNew_USCOREFC;
			return soap_in_ns1__software2centerNew_USCOREFC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCarInfo_FC"))
		{	*type = SOAP_TYPE_ns1__getCarInfo_USCOREFC;
			return soap_in_ns1__getCarInfo_USCOREFC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:obdResultLogResponse"))
		{	*type = SOAP_TYPE_ns1__obdResultLogResponse;
			return soap_in_ns1__obdResultLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:obdResultLog"))
		{	*type = SOAP_TYPE_ns1__obdResultLog;
			return soap_in_ns1__obdResultLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:dyhwAdjustResponse"))
		{	*type = SOAP_TYPE_ns1__dyhwAdjustResponse;
			return soap_in_ns1__dyhwAdjustResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:dyhwAdjust"))
		{	*type = SOAP_TYPE_ns1__dyhwAdjust;
			return soap_in_ns1__dyhwAdjust(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loadDownLogResponse"))
		{	*type = SOAP_TYPE_ns1__loadDownLogResponse;
			return soap_in_ns1__loadDownLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loadDownLog"))
		{	*type = SOAP_TYPE_ns1__loadDownLog;
			return soap_in_ns1__loadDownLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:dyhwSelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__dyhwSelfcheckResponse;
			return soap_in_ns1__dyhwSelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:dyhwSelfcheck"))
		{	*type = SOAP_TYPE_ns1__dyhwSelfcheck;
			return soap_in_ns1__dyhwSelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ydjSelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__ydjSelfcheckResponse;
			return soap_in_ns1__ydjSelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ydjSelfcheck"))
		{	*type = SOAP_TYPE_ns1__ydjSelfcheck;
			return soap_in_ns1__ydjSelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:vmasLogResponse"))
		{	*type = SOAP_TYPE_ns1__vmasLogResponse;
			return soap_in_ns1__vmasLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:vmasLog"))
		{	*type = SOAP_TYPE_ns1__vmasLog;
			return soap_in_ns1__vmasLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doubleIdleLogResponse"))
		{	*type = SOAP_TYPE_ns1__doubleIdleLogResponse;
			return soap_in_ns1__doubleIdleLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doubleIdleLog_FC"))
		{	*type = SOAP_TYPE_ns1__doubleIdleLog_USCOREFC;
			return soap_in_ns1__doubleIdleLog_USCOREFC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:obdResultResponse"))
		{	*type = SOAP_TYPE_ns1__obdResultResponse;
			return soap_in_ns1__obdResultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:obdResult"))
		{	*type = SOAP_TYPE_ns1__obdResult;
			return soap_in_ns1__obdResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjSelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__cgjSelfcheckResponse;
			return soap_in_ns1__cgjSelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjSelfcheck"))
		{	*type = SOAP_TYPE_ns1__cgjSelfcheck;
			return soap_in_ns1__cgjSelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjLASelfcheckResponse"))
		{	*type = SOAP_TYPE_ns1__cgjLASelfcheckResponse;
			return soap_in_ns1__cgjLASelfcheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjLASelfcheck"))
		{	*type = SOAP_TYPE_ns1__cgjLASelfcheck;
			return soap_in_ns1__cgjLASelfcheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doubleIdleDataResponse"))
		{	*type = SOAP_TYPE_ns1__doubleIdleDataResponse;
			return soap_in_ns1__doubleIdleDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:doubleIdleData_FC"))
		{	*type = SOAP_TYPE_ns1__doubleIdleData_USCOREFC;
			return soap_in_ns1__doubleIdleData_USCOREFC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bgAirHCResponse"))
		{	*type = SOAP_TYPE_ns1__bgAirHCResponse;
			return soap_in_ns1__bgAirHCResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bgAirHC"))
		{	*type = SOAP_TYPE_ns1__bgAirHC;
			return soap_in_ns1__bgAirHC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendMessageResponse"))
		{	*type = SOAP_TYPE_ns1__sendMessageResponse;
			return soap_in_ns1__sendMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendMessage"))
		{	*type = SOAP_TYPE_ns1__sendMessage;
			return soap_in_ns1__sendMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:carInfo"))
		{	*type = SOAP_TYPE_ns1__carInfo;
			return soap_in_ns1__carInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCarInfoResponse"))
		{	*type = SOAP_TYPE_ns1__getCarInfoResponse;
			return soap_in_ns1__getCarInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCarInfo"))
		{	*type = SOAP_TYPE_ns1__getCarInfo;
			return soap_in_ns1__getCarInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lightproofSmokeLogResponse"))
		{	*type = SOAP_TYPE_ns1__lightproofSmokeLogResponse;
			return soap_in_ns1__lightproofSmokeLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lightproofSmokeLog"))
		{	*type = SOAP_TYPE_ns1__lightproofSmokeLog;
			return soap_in_ns1__lightproofSmokeLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:argChangResponse"))
		{	*type = SOAP_TYPE_ns1__argChangResponse;
			return soap_in_ns1__argChangResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:argChang"))
		{	*type = SOAP_TYPE_ns1__argChang;
			return soap_in_ns1__argChang(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__cgjLSPSelfcheckResponse:
		return ((ns1__cgjLSPSelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:cgjLSPSelfcheckResponse");
	case SOAP_TYPE_ns1__cgjLSPSelfcheck:
		return ((ns1__cgjLSPSelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:cgjLSPSelfcheck");
	case SOAP_TYPE_ns1__lljSelfcheckResponse:
		return ((ns1__lljSelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:lljSelfcheckResponse");
	case SOAP_TYPE_ns1__lljSelfcheck:
		return ((ns1__lljSelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:lljSelfcheck");
	case SOAP_TYPE_ns1__cgjALPSelfcheckResponse:
		return ((ns1__cgjALPSelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:cgjALPSelfcheckResponse");
	case SOAP_TYPE_ns1__cgjALPSelfcheck:
		return ((ns1__cgjALPSelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:cgjALPSelfcheck");
	case SOAP_TYPE_ns1__wqfxySelfcheckResponse:
		return ((ns1__wqfxySelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:wqfxySelfcheckResponse");
	case SOAP_TYPE_ns1__wqfxySelfcheck:
		return ((ns1__wqfxySelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:wqfxySelfcheck");
	case SOAP_TYPE_ns1__sendMessage_USCOREFC:
		return ((ns1__sendMessage_USCOREFC *)ptr)->soap_out(soap, tag, id, "ns1:sendMessage_FC");
	case SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse:
		return ((ns1__sdsqtfxySelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:sdsqtfxySelfcheckResponse");
	case SOAP_TYPE_ns1__sdsqtfxySelfcheck:
		return ((ns1__sdsqtfxySelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:sdsqtfxySelfcheck");
	case SOAP_TYPE_ns1__qyfxSelfcheckResponse:
		return ((ns1__qyfxSelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:qyfxSelfcheckResponse");
	case SOAP_TYPE_ns1__qyfxSelfcheck:
		return ((ns1__qyfxSelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:qyfxSelfcheck");
	case SOAP_TYPE_ns1__lightproofSmokeData:
		return ((ns1__lightproofSmokeData *)ptr)->soap_out(soap, tag, id, "ns1:lightproofSmokeData");
	case SOAP_TYPE_ns1__lightproofSmokeDataResponse:
		return ((ns1__lightproofSmokeDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:lightproofSmokeDataResponse");
	case SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC:
		return ((ns1__lightproofSmokeData_USCOREFC *)ptr)->soap_out(soap, tag, id, "ns1:lightproofSmokeData_FC");
	case SOAP_TYPE_ns1__wqfxyAdjustResponse:
		return ((ns1__wqfxyAdjustResponse *)ptr)->soap_out(soap, tag, id, "ns1:wqfxyAdjustResponse");
	case SOAP_TYPE_ns1__wqfxyAdjust:
		return ((ns1__wqfxyAdjust *)ptr)->soap_out(soap, tag, id, "ns1:wqfxyAdjust");
	case SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse:
		return ((ns1__cgjPLHPSelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:cgjPLHPSelfcheckResponse");
	case SOAP_TYPE_ns1__cgjPLHPSelfcheck:
		return ((ns1__cgjPLHPSelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:cgjPLHPSelfcheck");
	case SOAP_TYPE_ns1__doubleIdleLog:
		return ((ns1__doubleIdleLog *)ptr)->soap_out(soap, tag, id, "ns1:doubleIdleLog");
	case SOAP_TYPE_ns1__doubleIdleData:
		return ((ns1__doubleIdleData *)ptr)->soap_out(soap, tag, id, "ns1:doubleIdleData");
	case SOAP_TYPE_ns1__stateInfo:
		return ((ns1__stateInfo *)ptr)->soap_out(soap, tag, id, "ns1:stateInfo");
	case SOAP_TYPE_ns1__getSatateResponse:
		return ((ns1__getSatateResponse *)ptr)->soap_out(soap, tag, id, "ns1:getSatateResponse");
	case SOAP_TYPE_ns1__getSatate:
		return ((ns1__getSatate *)ptr)->soap_out(soap, tag, id, "ns1:getSatate");
	case SOAP_TYPE_ns1__motoDbIdleDataResponse:
		return ((ns1__motoDbIdleDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:motoDbIdleDataResponse");
	case SOAP_TYPE_ns1__motoDbIdleData:
		return ((ns1__motoDbIdleData *)ptr)->soap_out(soap, tag, id, "ns1:motoDbIdleData");
	case SOAP_TYPE_ns1__vmasDataResponse:
		return ((ns1__vmasDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:vmasDataResponse");
	case SOAP_TYPE_ns1__vmasData:
		return ((ns1__vmasData *)ptr)->soap_out(soap, tag, id, "ns1:vmasData");
	case SOAP_TYPE_ns1__loadDownDataResponse:
		return ((ns1__loadDownDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:loadDownDataResponse");
	case SOAP_TYPE_ns1__loadDownData:
		return ((ns1__loadDownData *)ptr)->soap_out(soap, tag, id, "ns1:loadDownData");
	case SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse:
		return ((ns1__lightproofSmokeDataLog_USCOREFCResponse *)ptr)->soap_out(soap, tag, id, "ns1:lightproofSmokeDataLog_FCResponse");
	case SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC:
		return ((ns1__lightproofSmokeDataLog_USCOREFC *)ptr)->soap_out(soap, tag, id, "ns1:lightproofSmokeDataLog_FC");
	case SOAP_TYPE_ns1__pqfxySelfcheckResponse:
		return ((ns1__pqfxySelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:pqfxySelfcheckResponse");
	case SOAP_TYPE_ns1__pqfxySelfcheck:
		return ((ns1__pqfxySelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:pqfxySelfcheck");
	case SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse:
		return ((ns1__hjcsgyqSelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:hjcsgyqSelfcheckResponse");
	case SOAP_TYPE_ns1__hjcsgyqSelfcheck:
		return ((ns1__hjcsgyqSelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:hjcsgyqSelfcheck");
	case SOAP_TYPE_ns1__cycdyhwAdjustResponse:
		return ((ns1__cycdyhwAdjustResponse *)ptr)->soap_out(soap, tag, id, "ns1:cycdyhwAdjustResponse");
	case SOAP_TYPE_ns1__cycdyhwAdjust:
		return ((ns1__cycdyhwAdjust *)ptr)->soap_out(soap, tag, id, "ns1:cycdyhwAdjust");
	case SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse:
		return ((ns1__software2centerNew_USCOREFCResponse *)ptr)->soap_out(soap, tag, id, "ns1:software2centerNew_FCResponse");
	case SOAP_TYPE_ns1__software2centerNew_USCOREFC:
		return ((ns1__software2centerNew_USCOREFC *)ptr)->soap_out(soap, tag, id, "ns1:software2centerNew_FC");
	case SOAP_TYPE_ns1__getCarInfo_USCOREFC:
		return ((ns1__getCarInfo_USCOREFC *)ptr)->soap_out(soap, tag, id, "ns1:getCarInfo_FC");
	case SOAP_TYPE_ns1__obdResultLogResponse:
		return ((ns1__obdResultLogResponse *)ptr)->soap_out(soap, tag, id, "ns1:obdResultLogResponse");
	case SOAP_TYPE_ns1__obdResultLog:
		return ((ns1__obdResultLog *)ptr)->soap_out(soap, tag, id, "ns1:obdResultLog");
	case SOAP_TYPE_ns1__dyhwAdjustResponse:
		return ((ns1__dyhwAdjustResponse *)ptr)->soap_out(soap, tag, id, "ns1:dyhwAdjustResponse");
	case SOAP_TYPE_ns1__dyhwAdjust:
		return ((ns1__dyhwAdjust *)ptr)->soap_out(soap, tag, id, "ns1:dyhwAdjust");
	case SOAP_TYPE_ns1__loadDownLogResponse:
		return ((ns1__loadDownLogResponse *)ptr)->soap_out(soap, tag, id, "ns1:loadDownLogResponse");
	case SOAP_TYPE_ns1__loadDownLog:
		return ((ns1__loadDownLog *)ptr)->soap_out(soap, tag, id, "ns1:loadDownLog");
	case SOAP_TYPE_ns1__dyhwSelfcheckResponse:
		return ((ns1__dyhwSelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:dyhwSelfcheckResponse");
	case SOAP_TYPE_ns1__dyhwSelfcheck:
		return ((ns1__dyhwSelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:dyhwSelfcheck");
	case SOAP_TYPE_ns1__ydjSelfcheckResponse:
		return ((ns1__ydjSelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:ydjSelfcheckResponse");
	case SOAP_TYPE_ns1__ydjSelfcheck:
		return ((ns1__ydjSelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:ydjSelfcheck");
	case SOAP_TYPE_ns1__vmasLogResponse:
		return ((ns1__vmasLogResponse *)ptr)->soap_out(soap, tag, id, "ns1:vmasLogResponse");
	case SOAP_TYPE_ns1__vmasLog:
		return ((ns1__vmasLog *)ptr)->soap_out(soap, tag, id, "ns1:vmasLog");
	case SOAP_TYPE_ns1__doubleIdleLogResponse:
		return ((ns1__doubleIdleLogResponse *)ptr)->soap_out(soap, tag, id, "ns1:doubleIdleLogResponse");
	case SOAP_TYPE_ns1__doubleIdleLog_USCOREFC:
		return ((ns1__doubleIdleLog_USCOREFC *)ptr)->soap_out(soap, tag, id, "ns1:doubleIdleLog_FC");
	case SOAP_TYPE_ns1__obdResultResponse:
		return ((ns1__obdResultResponse *)ptr)->soap_out(soap, tag, id, "ns1:obdResultResponse");
	case SOAP_TYPE_ns1__obdResult:
		return ((ns1__obdResult *)ptr)->soap_out(soap, tag, id, "ns1:obdResult");
	case SOAP_TYPE_ns1__cgjSelfcheckResponse:
		return ((ns1__cgjSelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:cgjSelfcheckResponse");
	case SOAP_TYPE_ns1__cgjSelfcheck:
		return ((ns1__cgjSelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:cgjSelfcheck");
	case SOAP_TYPE_ns1__cgjLASelfcheckResponse:
		return ((ns1__cgjLASelfcheckResponse *)ptr)->soap_out(soap, tag, id, "ns1:cgjLASelfcheckResponse");
	case SOAP_TYPE_ns1__cgjLASelfcheck:
		return ((ns1__cgjLASelfcheck *)ptr)->soap_out(soap, tag, id, "ns1:cgjLASelfcheck");
	case SOAP_TYPE_ns1__doubleIdleDataResponse:
		return ((ns1__doubleIdleDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:doubleIdleDataResponse");
	case SOAP_TYPE_ns1__doubleIdleData_USCOREFC:
		return ((ns1__doubleIdleData_USCOREFC *)ptr)->soap_out(soap, tag, id, "ns1:doubleIdleData_FC");
	case SOAP_TYPE_ns1__bgAirHCResponse:
		return ((ns1__bgAirHCResponse *)ptr)->soap_out(soap, tag, id, "ns1:bgAirHCResponse");
	case SOAP_TYPE_ns1__bgAirHC:
		return ((ns1__bgAirHC *)ptr)->soap_out(soap, tag, id, "ns1:bgAirHC");
	case SOAP_TYPE_ns1__sendMessageResponse:
		return ((ns1__sendMessageResponse *)ptr)->soap_out(soap, tag, id, "ns1:sendMessageResponse");
	case SOAP_TYPE_ns1__sendMessage:
		return ((ns1__sendMessage *)ptr)->soap_out(soap, tag, id, "ns1:sendMessage");
	case SOAP_TYPE_ns1__carInfo:
		return ((ns1__carInfo *)ptr)->soap_out(soap, tag, id, "ns1:carInfo");
	case SOAP_TYPE_ns1__getCarInfoResponse:
		return ((ns1__getCarInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:getCarInfoResponse");
	case SOAP_TYPE_ns1__getCarInfo:
		return ((ns1__getCarInfo *)ptr)->soap_out(soap, tag, id, "ns1:getCarInfo");
	case SOAP_TYPE_ns1__lightproofSmokeLogResponse:
		return ((ns1__lightproofSmokeLogResponse *)ptr)->soap_out(soap, tag, id, "ns1:lightproofSmokeLogResponse");
	case SOAP_TYPE_ns1__lightproofSmokeLog:
		return ((ns1__lightproofSmokeLog *)ptr)->soap_out(soap, tag, id, "ns1:lightproofSmokeLog");
	case SOAP_TYPE_ns1__argChangResponse:
		return ((ns1__argChangResponse *)ptr)->soap_out(soap, tag, id, "ns1:argChangResponse");
	case SOAP_TYPE_ns1__argChang:
		return ((ns1__argChang *)ptr)->soap_out(soap, tag, id, "ns1:argChang");
	case SOAP_TYPE_PointerTons1__cgjLSPSelfcheck:
		return soap_out_PointerTons1__cgjLSPSelfcheck(soap, tag, id, (ns1__cgjLSPSelfcheck *const*)ptr, "ns1:cgjLSPSelfcheck");
	case SOAP_TYPE_PointerTons1__lljSelfcheck:
		return soap_out_PointerTons1__lljSelfcheck(soap, tag, id, (ns1__lljSelfcheck *const*)ptr, "ns1:lljSelfcheck");
	case SOAP_TYPE_PointerTons1__cgjALPSelfcheck:
		return soap_out_PointerTons1__cgjALPSelfcheck(soap, tag, id, (ns1__cgjALPSelfcheck *const*)ptr, "ns1:cgjALPSelfcheck");
	case SOAP_TYPE_PointerTons1__wqfxySelfcheck:
		return soap_out_PointerTons1__wqfxySelfcheck(soap, tag, id, (ns1__wqfxySelfcheck *const*)ptr, "ns1:wqfxySelfcheck");
	case SOAP_TYPE_PointerTons1__sendMessage_USCOREFC:
		return soap_out_PointerTons1__sendMessage_USCOREFC(soap, tag, id, (ns1__sendMessage_USCOREFC *const*)ptr, "ns1:sendMessage_FC");
	case SOAP_TYPE_PointerTons1__sdsqtfxySelfcheck:
		return soap_out_PointerTons1__sdsqtfxySelfcheck(soap, tag, id, (ns1__sdsqtfxySelfcheck *const*)ptr, "ns1:sdsqtfxySelfcheck");
	case SOAP_TYPE_PointerTons1__qyfxSelfcheck:
		return soap_out_PointerTons1__qyfxSelfcheck(soap, tag, id, (ns1__qyfxSelfcheck *const*)ptr, "ns1:qyfxSelfcheck");
	case SOAP_TYPE_PointerTons1__lightproofSmokeData:
		return soap_out_PointerTons1__lightproofSmokeData(soap, tag, id, (ns1__lightproofSmokeData *const*)ptr, "ns1:lightproofSmokeData");
	case SOAP_TYPE_PointerTons1__lightproofSmokeData_USCOREFC:
		return soap_out_PointerTons1__lightproofSmokeData_USCOREFC(soap, tag, id, (ns1__lightproofSmokeData_USCOREFC *const*)ptr, "ns1:lightproofSmokeData_FC");
	case SOAP_TYPE_PointerTons1__wqfxyAdjust:
		return soap_out_PointerTons1__wqfxyAdjust(soap, tag, id, (ns1__wqfxyAdjust *const*)ptr, "ns1:wqfxyAdjust");
	case SOAP_TYPE_PointerTons1__cgjPLHPSelfcheck:
		return soap_out_PointerTons1__cgjPLHPSelfcheck(soap, tag, id, (ns1__cgjPLHPSelfcheck *const*)ptr, "ns1:cgjPLHPSelfcheck");
	case SOAP_TYPE_PointerTons1__doubleIdleLog:
		return soap_out_PointerTons1__doubleIdleLog(soap, tag, id, (ns1__doubleIdleLog *const*)ptr, "ns1:doubleIdleLog");
	case SOAP_TYPE_PointerTons1__doubleIdleData:
		return soap_out_PointerTons1__doubleIdleData(soap, tag, id, (ns1__doubleIdleData *const*)ptr, "ns1:doubleIdleData");
	case SOAP_TYPE_PointerTons1__getSatate:
		return soap_out_PointerTons1__getSatate(soap, tag, id, (ns1__getSatate *const*)ptr, "ns1:getSatate");
	case SOAP_TYPE_PointerTons1__motoDbIdleData:
		return soap_out_PointerTons1__motoDbIdleData(soap, tag, id, (ns1__motoDbIdleData *const*)ptr, "ns1:motoDbIdleData");
	case SOAP_TYPE_PointerTons1__vmasData:
		return soap_out_PointerTons1__vmasData(soap, tag, id, (ns1__vmasData *const*)ptr, "ns1:vmasData");
	case SOAP_TYPE_PointerTons1__loadDownData:
		return soap_out_PointerTons1__loadDownData(soap, tag, id, (ns1__loadDownData *const*)ptr, "ns1:loadDownData");
	case SOAP_TYPE_PointerTons1__lightproofSmokeDataLog_USCOREFC:
		return soap_out_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, tag, id, (ns1__lightproofSmokeDataLog_USCOREFC *const*)ptr, "ns1:lightproofSmokeDataLog_FC");
	case SOAP_TYPE_PointerTons1__pqfxySelfcheck:
		return soap_out_PointerTons1__pqfxySelfcheck(soap, tag, id, (ns1__pqfxySelfcheck *const*)ptr, "ns1:pqfxySelfcheck");
	case SOAP_TYPE_PointerTons1__hjcsgyqSelfcheck:
		return soap_out_PointerTons1__hjcsgyqSelfcheck(soap, tag, id, (ns1__hjcsgyqSelfcheck *const*)ptr, "ns1:hjcsgyqSelfcheck");
	case SOAP_TYPE_PointerTons1__cycdyhwAdjust:
		return soap_out_PointerTons1__cycdyhwAdjust(soap, tag, id, (ns1__cycdyhwAdjust *const*)ptr, "ns1:cycdyhwAdjust");
	case SOAP_TYPE_PointerTons1__software2centerNew_USCOREFC:
		return soap_out_PointerTons1__software2centerNew_USCOREFC(soap, tag, id, (ns1__software2centerNew_USCOREFC *const*)ptr, "ns1:software2centerNew_FC");
	case SOAP_TYPE_PointerTons1__getCarInfo_USCOREFC:
		return soap_out_PointerTons1__getCarInfo_USCOREFC(soap, tag, id, (ns1__getCarInfo_USCOREFC *const*)ptr, "ns1:getCarInfo_FC");
	case SOAP_TYPE_PointerTons1__obdResultLog:
		return soap_out_PointerTons1__obdResultLog(soap, tag, id, (ns1__obdResultLog *const*)ptr, "ns1:obdResultLog");
	case SOAP_TYPE_PointerTons1__dyhwAdjust:
		return soap_out_PointerTons1__dyhwAdjust(soap, tag, id, (ns1__dyhwAdjust *const*)ptr, "ns1:dyhwAdjust");
	case SOAP_TYPE_PointerTons1__loadDownLog:
		return soap_out_PointerTons1__loadDownLog(soap, tag, id, (ns1__loadDownLog *const*)ptr, "ns1:loadDownLog");
	case SOAP_TYPE_PointerTons1__dyhwSelfcheck:
		return soap_out_PointerTons1__dyhwSelfcheck(soap, tag, id, (ns1__dyhwSelfcheck *const*)ptr, "ns1:dyhwSelfcheck");
	case SOAP_TYPE_PointerTons1__ydjSelfcheck:
		return soap_out_PointerTons1__ydjSelfcheck(soap, tag, id, (ns1__ydjSelfcheck *const*)ptr, "ns1:ydjSelfcheck");
	case SOAP_TYPE_PointerTons1__vmasLog:
		return soap_out_PointerTons1__vmasLog(soap, tag, id, (ns1__vmasLog *const*)ptr, "ns1:vmasLog");
	case SOAP_TYPE_PointerTons1__doubleIdleLog_USCOREFC:
		return soap_out_PointerTons1__doubleIdleLog_USCOREFC(soap, tag, id, (ns1__doubleIdleLog_USCOREFC *const*)ptr, "ns1:doubleIdleLog_FC");
	case SOAP_TYPE_PointerTons1__obdResult:
		return soap_out_PointerTons1__obdResult(soap, tag, id, (ns1__obdResult *const*)ptr, "ns1:obdResult");
	case SOAP_TYPE_PointerTons1__cgjSelfcheck:
		return soap_out_PointerTons1__cgjSelfcheck(soap, tag, id, (ns1__cgjSelfcheck *const*)ptr, "ns1:cgjSelfcheck");
	case SOAP_TYPE_PointerTons1__cgjLASelfcheck:
		return soap_out_PointerTons1__cgjLASelfcheck(soap, tag, id, (ns1__cgjLASelfcheck *const*)ptr, "ns1:cgjLASelfcheck");
	case SOAP_TYPE_PointerTons1__doubleIdleData_USCOREFC:
		return soap_out_PointerTons1__doubleIdleData_USCOREFC(soap, tag, id, (ns1__doubleIdleData_USCOREFC *const*)ptr, "ns1:doubleIdleData_FC");
	case SOAP_TYPE_PointerTons1__bgAirHC:
		return soap_out_PointerTons1__bgAirHC(soap, tag, id, (ns1__bgAirHC *const*)ptr, "ns1:bgAirHC");
	case SOAP_TYPE_PointerTons1__sendMessage:
		return soap_out_PointerTons1__sendMessage(soap, tag, id, (ns1__sendMessage *const*)ptr, "ns1:sendMessage");
	case SOAP_TYPE_PointerTons1__getCarInfo:
		return soap_out_PointerTons1__getCarInfo(soap, tag, id, (ns1__getCarInfo *const*)ptr, "ns1:getCarInfo");
	case SOAP_TYPE_PointerTons1__lightproofSmokeLog:
		return soap_out_PointerTons1__lightproofSmokeLog(soap, tag, id, (ns1__lightproofSmokeLog *const*)ptr, "ns1:lightproofSmokeLog");
	case SOAP_TYPE_PointerTons1__argChang:
		return soap_out_PointerTons1__argChang(soap, tag, id, (ns1__argChang *const*)ptr, "ns1:argChang");
	case SOAP_TYPE_PointerTons1__stateInfo:
		return soap_out_PointerTons1__stateInfo(soap, tag, id, (ns1__stateInfo *const*)ptr, "ns1:stateInfo");
	case SOAP_TYPE_PointerTons1__carInfo:
		return soap_out_PointerTons1__carInfo(soap, tag, id, (ns1__carInfo *const*)ptr, "ns1:carInfo");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_out_PointerTostd__wstring(soap, tag, id, (std::wstring *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_ns1__cgjLSPSelfcheckResponse:
		((ns1__cgjLSPSelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjLSPSelfcheck:
		((ns1__cgjLSPSelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lljSelfcheckResponse:
		((ns1__lljSelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lljSelfcheck:
		((ns1__lljSelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjALPSelfcheckResponse:
		((ns1__cgjALPSelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjALPSelfcheck:
		((ns1__cgjALPSelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wqfxySelfcheckResponse:
		((ns1__wqfxySelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wqfxySelfcheck:
		((ns1__wqfxySelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sendMessage_USCOREFC:
		((ns1__sendMessage_USCOREFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse:
		((ns1__sdsqtfxySelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sdsqtfxySelfcheck:
		((ns1__sdsqtfxySelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__qyfxSelfcheckResponse:
		((ns1__qyfxSelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__qyfxSelfcheck:
		((ns1__qyfxSelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeData:
		((ns1__lightproofSmokeData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeDataResponse:
		((ns1__lightproofSmokeDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC:
		((ns1__lightproofSmokeData_USCOREFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wqfxyAdjustResponse:
		((ns1__wqfxyAdjustResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wqfxyAdjust:
		((ns1__wqfxyAdjust *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse:
		((ns1__cgjPLHPSelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjPLHPSelfcheck:
		((ns1__cgjPLHPSelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__doubleIdleLog:
		((ns1__doubleIdleLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__doubleIdleData:
		((ns1__doubleIdleData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__stateInfo:
		((ns1__stateInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getSatateResponse:
		((ns1__getSatateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getSatate:
		((ns1__getSatate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__motoDbIdleDataResponse:
		((ns1__motoDbIdleDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__motoDbIdleData:
		((ns1__motoDbIdleData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__vmasDataResponse:
		((ns1__vmasDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__vmasData:
		((ns1__vmasData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__loadDownDataResponse:
		((ns1__loadDownDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__loadDownData:
		((ns1__loadDownData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse:
		((ns1__lightproofSmokeDataLog_USCOREFCResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC:
		((ns1__lightproofSmokeDataLog_USCOREFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__pqfxySelfcheckResponse:
		((ns1__pqfxySelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__pqfxySelfcheck:
		((ns1__pqfxySelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse:
		((ns1__hjcsgyqSelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__hjcsgyqSelfcheck:
		((ns1__hjcsgyqSelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cycdyhwAdjustResponse:
		((ns1__cycdyhwAdjustResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cycdyhwAdjust:
		((ns1__cycdyhwAdjust *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse:
		((ns1__software2centerNew_USCOREFCResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__software2centerNew_USCOREFC:
		((ns1__software2centerNew_USCOREFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getCarInfo_USCOREFC:
		((ns1__getCarInfo_USCOREFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__obdResultLogResponse:
		((ns1__obdResultLogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__obdResultLog:
		((ns1__obdResultLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__dyhwAdjustResponse:
		((ns1__dyhwAdjustResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__dyhwAdjust:
		((ns1__dyhwAdjust *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__loadDownLogResponse:
		((ns1__loadDownLogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__loadDownLog:
		((ns1__loadDownLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__dyhwSelfcheckResponse:
		((ns1__dyhwSelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__dyhwSelfcheck:
		((ns1__dyhwSelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ydjSelfcheckResponse:
		((ns1__ydjSelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ydjSelfcheck:
		((ns1__ydjSelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__vmasLogResponse:
		((ns1__vmasLogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__vmasLog:
		((ns1__vmasLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__doubleIdleLogResponse:
		((ns1__doubleIdleLogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__doubleIdleLog_USCOREFC:
		((ns1__doubleIdleLog_USCOREFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__obdResultResponse:
		((ns1__obdResultResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__obdResult:
		((ns1__obdResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjSelfcheckResponse:
		((ns1__cgjSelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjSelfcheck:
		((ns1__cgjSelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjLASelfcheckResponse:
		((ns1__cgjLASelfcheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjLASelfcheck:
		((ns1__cgjLASelfcheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__doubleIdleDataResponse:
		((ns1__doubleIdleDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__doubleIdleData_USCOREFC:
		((ns1__doubleIdleData_USCOREFC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__bgAirHCResponse:
		((ns1__bgAirHCResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__bgAirHC:
		((ns1__bgAirHC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sendMessageResponse:
		((ns1__sendMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sendMessage:
		((ns1__sendMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__carInfo:
		((ns1__carInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getCarInfoResponse:
		((ns1__getCarInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getCarInfo:
		((ns1__getCarInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeLogResponse:
		((ns1__lightproofSmokeLogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeLog:
		((ns1__lightproofSmokeLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__argChangResponse:
		((ns1__argChangResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__argChang:
		((ns1__argChang *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__cgjLSPSelfcheck_:
		soap_serialize___ns1__cgjLSPSelfcheck_(soap, (const struct __ns1__cgjLSPSelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__lljSelfcheck_:
		soap_serialize___ns1__lljSelfcheck_(soap, (const struct __ns1__lljSelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__cgjALPSelfcheck_:
		soap_serialize___ns1__cgjALPSelfcheck_(soap, (const struct __ns1__cgjALPSelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__wqfxySelfcheck_:
		soap_serialize___ns1__wqfxySelfcheck_(soap, (const struct __ns1__wqfxySelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__sendMessage_USCOREFC_:
		soap_serialize___ns1__sendMessage_USCOREFC_(soap, (const struct __ns1__sendMessage_USCOREFC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__sdsqtfxySelfcheck_:
		soap_serialize___ns1__sdsqtfxySelfcheck_(soap, (const struct __ns1__sdsqtfxySelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__qyfxSelfcheck_:
		soap_serialize___ns1__qyfxSelfcheck_(soap, (const struct __ns1__qyfxSelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeData_:
		soap_serialize___ns1__lightproofSmokeData_(soap, (const struct __ns1__lightproofSmokeData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC_:
		soap_serialize___ns1__lightproofSmokeData_USCOREFC_(soap, (const struct __ns1__lightproofSmokeData_USCOREFC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__wqfxyAdjust_:
		soap_serialize___ns1__wqfxyAdjust_(soap, (const struct __ns1__wqfxyAdjust_ *)ptr);
		break;
	case SOAP_TYPE___ns1__cgjPLHPSelfcheck_:
		soap_serialize___ns1__cgjPLHPSelfcheck_(soap, (const struct __ns1__cgjPLHPSelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleLog_:
		soap_serialize___ns1__doubleIdleLog_(soap, (const struct __ns1__doubleIdleLog_ *)ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleData_:
		soap_serialize___ns1__doubleIdleData_(soap, (const struct __ns1__doubleIdleData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getSatate_:
		soap_serialize___ns1__getSatate_(soap, (const struct __ns1__getSatate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__motoDbIdleData_:
		soap_serialize___ns1__motoDbIdleData_(soap, (const struct __ns1__motoDbIdleData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__vmasData_:
		soap_serialize___ns1__vmasData_(soap, (const struct __ns1__vmasData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__loadDownData_:
		soap_serialize___ns1__loadDownData_(soap, (const struct __ns1__loadDownData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC_:
		soap_serialize___ns1__lightproofSmokeDataLog_USCOREFC_(soap, (const struct __ns1__lightproofSmokeDataLog_USCOREFC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__pqfxySelfcheck_:
		soap_serialize___ns1__pqfxySelfcheck_(soap, (const struct __ns1__pqfxySelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__hjcsgyqSelfcheck_:
		soap_serialize___ns1__hjcsgyqSelfcheck_(soap, (const struct __ns1__hjcsgyqSelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__cycdyhwAdjust_:
		soap_serialize___ns1__cycdyhwAdjust_(soap, (const struct __ns1__cycdyhwAdjust_ *)ptr);
		break;
	case SOAP_TYPE___ns1__software2centerNew_USCOREFC_:
		soap_serialize___ns1__software2centerNew_USCOREFC_(soap, (const struct __ns1__software2centerNew_USCOREFC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getCarInfo_USCOREFC_:
		soap_serialize___ns1__getCarInfo_USCOREFC_(soap, (const struct __ns1__getCarInfo_USCOREFC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__obdResultLog_:
		soap_serialize___ns1__obdResultLog_(soap, (const struct __ns1__obdResultLog_ *)ptr);
		break;
	case SOAP_TYPE___ns1__dyhwAdjust_:
		soap_serialize___ns1__dyhwAdjust_(soap, (const struct __ns1__dyhwAdjust_ *)ptr);
		break;
	case SOAP_TYPE___ns1__loadDownLog_:
		soap_serialize___ns1__loadDownLog_(soap, (const struct __ns1__loadDownLog_ *)ptr);
		break;
	case SOAP_TYPE___ns1__dyhwSelfcheck_:
		soap_serialize___ns1__dyhwSelfcheck_(soap, (const struct __ns1__dyhwSelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ydjSelfcheck_:
		soap_serialize___ns1__ydjSelfcheck_(soap, (const struct __ns1__ydjSelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__vmasLog_:
		soap_serialize___ns1__vmasLog_(soap, (const struct __ns1__vmasLog_ *)ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleLog_USCOREFC_:
		soap_serialize___ns1__doubleIdleLog_USCOREFC_(soap, (const struct __ns1__doubleIdleLog_USCOREFC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__obdResult_:
		soap_serialize___ns1__obdResult_(soap, (const struct __ns1__obdResult_ *)ptr);
		break;
	case SOAP_TYPE___ns1__cgjSelfcheck_:
		soap_serialize___ns1__cgjSelfcheck_(soap, (const struct __ns1__cgjSelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__cgjLASelfcheck_:
		soap_serialize___ns1__cgjLASelfcheck_(soap, (const struct __ns1__cgjLASelfcheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleData_USCOREFC_:
		soap_serialize___ns1__doubleIdleData_USCOREFC_(soap, (const struct __ns1__doubleIdleData_USCOREFC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__bgAirHC_:
		soap_serialize___ns1__bgAirHC_(soap, (const struct __ns1__bgAirHC_ *)ptr);
		break;
	case SOAP_TYPE___ns1__sendMessage_:
		soap_serialize___ns1__sendMessage_(soap, (const struct __ns1__sendMessage_ *)ptr);
		break;
	case SOAP_TYPE___ns1__getCarInfo_:
		soap_serialize___ns1__getCarInfo_(soap, (const struct __ns1__getCarInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeLog_:
		soap_serialize___ns1__lightproofSmokeLog_(soap, (const struct __ns1__lightproofSmokeLog_ *)ptr);
		break;
	case SOAP_TYPE___ns1__argChang_:
		soap_serialize___ns1__argChang_(soap, (const struct __ns1__argChang_ *)ptr);
		break;
	case SOAP_TYPE___ns1__cgjLSPSelfcheck:
		soap_serialize___ns1__cgjLSPSelfcheck(soap, (const struct __ns1__cgjLSPSelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__lljSelfcheck:
		soap_serialize___ns1__lljSelfcheck(soap, (const struct __ns1__lljSelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__cgjALPSelfcheck:
		soap_serialize___ns1__cgjALPSelfcheck(soap, (const struct __ns1__cgjALPSelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__wqfxySelfcheck:
		soap_serialize___ns1__wqfxySelfcheck(soap, (const struct __ns1__wqfxySelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__sendMessage_USCOREFC:
		soap_serialize___ns1__sendMessage_USCOREFC(soap, (const struct __ns1__sendMessage_USCOREFC *)ptr);
		break;
	case SOAP_TYPE___ns1__sdsqtfxySelfcheck:
		soap_serialize___ns1__sdsqtfxySelfcheck(soap, (const struct __ns1__sdsqtfxySelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__qyfxSelfcheck:
		soap_serialize___ns1__qyfxSelfcheck(soap, (const struct __ns1__qyfxSelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeData:
		soap_serialize___ns1__lightproofSmokeData(soap, (const struct __ns1__lightproofSmokeData *)ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC:
		soap_serialize___ns1__lightproofSmokeData_USCOREFC(soap, (const struct __ns1__lightproofSmokeData_USCOREFC *)ptr);
		break;
	case SOAP_TYPE___ns1__wqfxyAdjust:
		soap_serialize___ns1__wqfxyAdjust(soap, (const struct __ns1__wqfxyAdjust *)ptr);
		break;
	case SOAP_TYPE___ns1__cgjPLHPSelfcheck:
		soap_serialize___ns1__cgjPLHPSelfcheck(soap, (const struct __ns1__cgjPLHPSelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleLog:
		soap_serialize___ns1__doubleIdleLog(soap, (const struct __ns1__doubleIdleLog *)ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleData:
		soap_serialize___ns1__doubleIdleData(soap, (const struct __ns1__doubleIdleData *)ptr);
		break;
	case SOAP_TYPE___ns1__getSatate:
		soap_serialize___ns1__getSatate(soap, (const struct __ns1__getSatate *)ptr);
		break;
	case SOAP_TYPE___ns1__motoDbIdleData:
		soap_serialize___ns1__motoDbIdleData(soap, (const struct __ns1__motoDbIdleData *)ptr);
		break;
	case SOAP_TYPE___ns1__vmasData:
		soap_serialize___ns1__vmasData(soap, (const struct __ns1__vmasData *)ptr);
		break;
	case SOAP_TYPE___ns1__loadDownData:
		soap_serialize___ns1__loadDownData(soap, (const struct __ns1__loadDownData *)ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC:
		soap_serialize___ns1__lightproofSmokeDataLog_USCOREFC(soap, (const struct __ns1__lightproofSmokeDataLog_USCOREFC *)ptr);
		break;
	case SOAP_TYPE___ns1__pqfxySelfcheck:
		soap_serialize___ns1__pqfxySelfcheck(soap, (const struct __ns1__pqfxySelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__hjcsgyqSelfcheck:
		soap_serialize___ns1__hjcsgyqSelfcheck(soap, (const struct __ns1__hjcsgyqSelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__cycdyhwAdjust:
		soap_serialize___ns1__cycdyhwAdjust(soap, (const struct __ns1__cycdyhwAdjust *)ptr);
		break;
	case SOAP_TYPE___ns1__software2centerNew_USCOREFC:
		soap_serialize___ns1__software2centerNew_USCOREFC(soap, (const struct __ns1__software2centerNew_USCOREFC *)ptr);
		break;
	case SOAP_TYPE___ns1__getCarInfo_USCOREFC:
		soap_serialize___ns1__getCarInfo_USCOREFC(soap, (const struct __ns1__getCarInfo_USCOREFC *)ptr);
		break;
	case SOAP_TYPE___ns1__obdResultLog:
		soap_serialize___ns1__obdResultLog(soap, (const struct __ns1__obdResultLog *)ptr);
		break;
	case SOAP_TYPE___ns1__dyhwAdjust:
		soap_serialize___ns1__dyhwAdjust(soap, (const struct __ns1__dyhwAdjust *)ptr);
		break;
	case SOAP_TYPE___ns1__loadDownLog:
		soap_serialize___ns1__loadDownLog(soap, (const struct __ns1__loadDownLog *)ptr);
		break;
	case SOAP_TYPE___ns1__dyhwSelfcheck:
		soap_serialize___ns1__dyhwSelfcheck(soap, (const struct __ns1__dyhwSelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__ydjSelfcheck:
		soap_serialize___ns1__ydjSelfcheck(soap, (const struct __ns1__ydjSelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__vmasLog:
		soap_serialize___ns1__vmasLog(soap, (const struct __ns1__vmasLog *)ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleLog_USCOREFC:
		soap_serialize___ns1__doubleIdleLog_USCOREFC(soap, (const struct __ns1__doubleIdleLog_USCOREFC *)ptr);
		break;
	case SOAP_TYPE___ns1__obdResult:
		soap_serialize___ns1__obdResult(soap, (const struct __ns1__obdResult *)ptr);
		break;
	case SOAP_TYPE___ns1__cgjSelfcheck:
		soap_serialize___ns1__cgjSelfcheck(soap, (const struct __ns1__cgjSelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__cgjLASelfcheck:
		soap_serialize___ns1__cgjLASelfcheck(soap, (const struct __ns1__cgjLASelfcheck *)ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleData_USCOREFC:
		soap_serialize___ns1__doubleIdleData_USCOREFC(soap, (const struct __ns1__doubleIdleData_USCOREFC *)ptr);
		break;
	case SOAP_TYPE___ns1__bgAirHC:
		soap_serialize___ns1__bgAirHC(soap, (const struct __ns1__bgAirHC *)ptr);
		break;
	case SOAP_TYPE___ns1__sendMessage:
		soap_serialize___ns1__sendMessage(soap, (const struct __ns1__sendMessage *)ptr);
		break;
	case SOAP_TYPE___ns1__getCarInfo:
		soap_serialize___ns1__getCarInfo(soap, (const struct __ns1__getCarInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeLog:
		soap_serialize___ns1__lightproofSmokeLog(soap, (const struct __ns1__lightproofSmokeLog *)ptr);
		break;
	case SOAP_TYPE___ns1__argChang:
		soap_serialize___ns1__argChang(soap, (const struct __ns1__argChang *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cgjLSPSelfcheck:
		soap_serialize_PointerTons1__cgjLSPSelfcheck(soap, (ns1__cgjLSPSelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__lljSelfcheck:
		soap_serialize_PointerTons1__lljSelfcheck(soap, (ns1__lljSelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cgjALPSelfcheck:
		soap_serialize_PointerTons1__cgjALPSelfcheck(soap, (ns1__cgjALPSelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wqfxySelfcheck:
		soap_serialize_PointerTons1__wqfxySelfcheck(soap, (ns1__wqfxySelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sendMessage_USCOREFC:
		soap_serialize_PointerTons1__sendMessage_USCOREFC(soap, (ns1__sendMessage_USCOREFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sdsqtfxySelfcheck:
		soap_serialize_PointerTons1__sdsqtfxySelfcheck(soap, (ns1__sdsqtfxySelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__qyfxSelfcheck:
		soap_serialize_PointerTons1__qyfxSelfcheck(soap, (ns1__qyfxSelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__lightproofSmokeData:
		soap_serialize_PointerTons1__lightproofSmokeData(soap, (ns1__lightproofSmokeData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__lightproofSmokeData_USCOREFC:
		soap_serialize_PointerTons1__lightproofSmokeData_USCOREFC(soap, (ns1__lightproofSmokeData_USCOREFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wqfxyAdjust:
		soap_serialize_PointerTons1__wqfxyAdjust(soap, (ns1__wqfxyAdjust *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cgjPLHPSelfcheck:
		soap_serialize_PointerTons1__cgjPLHPSelfcheck(soap, (ns1__cgjPLHPSelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__doubleIdleLog:
		soap_serialize_PointerTons1__doubleIdleLog(soap, (ns1__doubleIdleLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__doubleIdleData:
		soap_serialize_PointerTons1__doubleIdleData(soap, (ns1__doubleIdleData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getSatate:
		soap_serialize_PointerTons1__getSatate(soap, (ns1__getSatate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__motoDbIdleData:
		soap_serialize_PointerTons1__motoDbIdleData(soap, (ns1__motoDbIdleData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__vmasData:
		soap_serialize_PointerTons1__vmasData(soap, (ns1__vmasData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__loadDownData:
		soap_serialize_PointerTons1__loadDownData(soap, (ns1__loadDownData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__lightproofSmokeDataLog_USCOREFC:
		soap_serialize_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, (ns1__lightproofSmokeDataLog_USCOREFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__pqfxySelfcheck:
		soap_serialize_PointerTons1__pqfxySelfcheck(soap, (ns1__pqfxySelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__hjcsgyqSelfcheck:
		soap_serialize_PointerTons1__hjcsgyqSelfcheck(soap, (ns1__hjcsgyqSelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cycdyhwAdjust:
		soap_serialize_PointerTons1__cycdyhwAdjust(soap, (ns1__cycdyhwAdjust *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__software2centerNew_USCOREFC:
		soap_serialize_PointerTons1__software2centerNew_USCOREFC(soap, (ns1__software2centerNew_USCOREFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getCarInfo_USCOREFC:
		soap_serialize_PointerTons1__getCarInfo_USCOREFC(soap, (ns1__getCarInfo_USCOREFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__obdResultLog:
		soap_serialize_PointerTons1__obdResultLog(soap, (ns1__obdResultLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__dyhwAdjust:
		soap_serialize_PointerTons1__dyhwAdjust(soap, (ns1__dyhwAdjust *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__loadDownLog:
		soap_serialize_PointerTons1__loadDownLog(soap, (ns1__loadDownLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__dyhwSelfcheck:
		soap_serialize_PointerTons1__dyhwSelfcheck(soap, (ns1__dyhwSelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ydjSelfcheck:
		soap_serialize_PointerTons1__ydjSelfcheck(soap, (ns1__ydjSelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__vmasLog:
		soap_serialize_PointerTons1__vmasLog(soap, (ns1__vmasLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__doubleIdleLog_USCOREFC:
		soap_serialize_PointerTons1__doubleIdleLog_USCOREFC(soap, (ns1__doubleIdleLog_USCOREFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__obdResult:
		soap_serialize_PointerTons1__obdResult(soap, (ns1__obdResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cgjSelfcheck:
		soap_serialize_PointerTons1__cgjSelfcheck(soap, (ns1__cgjSelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cgjLASelfcheck:
		soap_serialize_PointerTons1__cgjLASelfcheck(soap, (ns1__cgjLASelfcheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__doubleIdleData_USCOREFC:
		soap_serialize_PointerTons1__doubleIdleData_USCOREFC(soap, (ns1__doubleIdleData_USCOREFC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__bgAirHC:
		soap_serialize_PointerTons1__bgAirHC(soap, (ns1__bgAirHC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sendMessage:
		soap_serialize_PointerTons1__sendMessage(soap, (ns1__sendMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getCarInfo:
		soap_serialize_PointerTons1__getCarInfo(soap, (ns1__getCarInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__lightproofSmokeLog:
		soap_serialize_PointerTons1__lightproofSmokeLog(soap, (ns1__lightproofSmokeLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__argChang:
		soap_serialize_PointerTons1__argChang(soap, (ns1__argChang *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__stateInfo:
		soap_serialize_PointerTons1__stateInfo(soap, (ns1__stateInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__carInfo:
		soap_serialize_PointerTons1__carInfo(soap, (ns1__carInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__wstring:
		soap_serialize_PointerTostd__wstring(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__argChang:
		return (void*)soap_instantiate_ns1__argChang(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__argChangResponse:
		return (void*)soap_instantiate_ns1__argChangResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lightproofSmokeLog:
		return (void*)soap_instantiate_ns1__lightproofSmokeLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lightproofSmokeLogResponse:
		return (void*)soap_instantiate_ns1__lightproofSmokeLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCarInfo:
		return (void*)soap_instantiate_ns1__getCarInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCarInfoResponse:
		return (void*)soap_instantiate_ns1__getCarInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__carInfo:
		return (void*)soap_instantiate_ns1__carInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sendMessage:
		return (void*)soap_instantiate_ns1__sendMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sendMessageResponse:
		return (void*)soap_instantiate_ns1__sendMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bgAirHC:
		return (void*)soap_instantiate_ns1__bgAirHC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bgAirHCResponse:
		return (void*)soap_instantiate_ns1__bgAirHCResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__doubleIdleData_USCOREFC:
		return (void*)soap_instantiate_ns1__doubleIdleData_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__doubleIdleDataResponse:
		return (void*)soap_instantiate_ns1__doubleIdleDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjLASelfcheck:
		return (void*)soap_instantiate_ns1__cgjLASelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjLASelfcheckResponse:
		return (void*)soap_instantiate_ns1__cgjLASelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjSelfcheck:
		return (void*)soap_instantiate_ns1__cgjSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjSelfcheckResponse:
		return (void*)soap_instantiate_ns1__cgjSelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__obdResult:
		return (void*)soap_instantiate_ns1__obdResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__obdResultResponse:
		return (void*)soap_instantiate_ns1__obdResultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__doubleIdleLog_USCOREFC:
		return (void*)soap_instantiate_ns1__doubleIdleLog_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__doubleIdleLogResponse:
		return (void*)soap_instantiate_ns1__doubleIdleLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__vmasLog:
		return (void*)soap_instantiate_ns1__vmasLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__vmasLogResponse:
		return (void*)soap_instantiate_ns1__vmasLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ydjSelfcheck:
		return (void*)soap_instantiate_ns1__ydjSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ydjSelfcheckResponse:
		return (void*)soap_instantiate_ns1__ydjSelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__dyhwSelfcheck:
		return (void*)soap_instantiate_ns1__dyhwSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__dyhwSelfcheckResponse:
		return (void*)soap_instantiate_ns1__dyhwSelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loadDownLog:
		return (void*)soap_instantiate_ns1__loadDownLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loadDownLogResponse:
		return (void*)soap_instantiate_ns1__loadDownLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__dyhwAdjust:
		return (void*)soap_instantiate_ns1__dyhwAdjust(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__dyhwAdjustResponse:
		return (void*)soap_instantiate_ns1__dyhwAdjustResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__obdResultLog:
		return (void*)soap_instantiate_ns1__obdResultLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__obdResultLogResponse:
		return (void*)soap_instantiate_ns1__obdResultLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCarInfo_USCOREFC:
		return (void*)soap_instantiate_ns1__getCarInfo_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__software2centerNew_USCOREFC:
		return (void*)soap_instantiate_ns1__software2centerNew_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse:
		return (void*)soap_instantiate_ns1__software2centerNew_USCOREFCResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cycdyhwAdjust:
		return (void*)soap_instantiate_ns1__cycdyhwAdjust(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cycdyhwAdjustResponse:
		return (void*)soap_instantiate_ns1__cycdyhwAdjustResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__hjcsgyqSelfcheck:
		return (void*)soap_instantiate_ns1__hjcsgyqSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse:
		return (void*)soap_instantiate_ns1__hjcsgyqSelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__pqfxySelfcheck:
		return (void*)soap_instantiate_ns1__pqfxySelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__pqfxySelfcheckResponse:
		return (void*)soap_instantiate_ns1__pqfxySelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC:
		return (void*)soap_instantiate_ns1__lightproofSmokeDataLog_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse:
		return (void*)soap_instantiate_ns1__lightproofSmokeDataLog_USCOREFCResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loadDownData:
		return (void*)soap_instantiate_ns1__loadDownData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loadDownDataResponse:
		return (void*)soap_instantiate_ns1__loadDownDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__vmasData:
		return (void*)soap_instantiate_ns1__vmasData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__vmasDataResponse:
		return (void*)soap_instantiate_ns1__vmasDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__motoDbIdleData:
		return (void*)soap_instantiate_ns1__motoDbIdleData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__motoDbIdleDataResponse:
		return (void*)soap_instantiate_ns1__motoDbIdleDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSatate:
		return (void*)soap_instantiate_ns1__getSatate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSatateResponse:
		return (void*)soap_instantiate_ns1__getSatateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__stateInfo:
		return (void*)soap_instantiate_ns1__stateInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__doubleIdleData:
		return (void*)soap_instantiate_ns1__doubleIdleData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__doubleIdleLog:
		return (void*)soap_instantiate_ns1__doubleIdleLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjPLHPSelfcheck:
		return (void*)soap_instantiate_ns1__cgjPLHPSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse:
		return (void*)soap_instantiate_ns1__cgjPLHPSelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wqfxyAdjust:
		return (void*)soap_instantiate_ns1__wqfxyAdjust(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wqfxyAdjustResponse:
		return (void*)soap_instantiate_ns1__wqfxyAdjustResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC:
		return (void*)soap_instantiate_ns1__lightproofSmokeData_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lightproofSmokeDataResponse:
		return (void*)soap_instantiate_ns1__lightproofSmokeDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lightproofSmokeData:
		return (void*)soap_instantiate_ns1__lightproofSmokeData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__qyfxSelfcheck:
		return (void*)soap_instantiate_ns1__qyfxSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__qyfxSelfcheckResponse:
		return (void*)soap_instantiate_ns1__qyfxSelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sdsqtfxySelfcheck:
		return (void*)soap_instantiate_ns1__sdsqtfxySelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse:
		return (void*)soap_instantiate_ns1__sdsqtfxySelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sendMessage_USCOREFC:
		return (void*)soap_instantiate_ns1__sendMessage_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wqfxySelfcheck:
		return (void*)soap_instantiate_ns1__wqfxySelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wqfxySelfcheckResponse:
		return (void*)soap_instantiate_ns1__wqfxySelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjALPSelfcheck:
		return (void*)soap_instantiate_ns1__cgjALPSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjALPSelfcheckResponse:
		return (void*)soap_instantiate_ns1__cgjALPSelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lljSelfcheck:
		return (void*)soap_instantiate_ns1__lljSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lljSelfcheckResponse:
		return (void*)soap_instantiate_ns1__lljSelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjLSPSelfcheck:
		return (void*)soap_instantiate_ns1__cgjLSPSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjLSPSelfcheckResponse:
		return (void*)soap_instantiate_ns1__cgjLSPSelfcheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__argChang:
		return (void*)soap_instantiate___ns1__argChang(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lightproofSmokeLog:
		return (void*)soap_instantiate___ns1__lightproofSmokeLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCarInfo:
		return (void*)soap_instantiate___ns1__getCarInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendMessage:
		return (void*)soap_instantiate___ns1__sendMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__bgAirHC:
		return (void*)soap_instantiate___ns1__bgAirHC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doubleIdleData_USCOREFC:
		return (void*)soap_instantiate___ns1__doubleIdleData_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjLASelfcheck:
		return (void*)soap_instantiate___ns1__cgjLASelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjSelfcheck:
		return (void*)soap_instantiate___ns1__cgjSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__obdResult:
		return (void*)soap_instantiate___ns1__obdResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doubleIdleLog_USCOREFC:
		return (void*)soap_instantiate___ns1__doubleIdleLog_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__vmasLog:
		return (void*)soap_instantiate___ns1__vmasLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ydjSelfcheck:
		return (void*)soap_instantiate___ns1__ydjSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__dyhwSelfcheck:
		return (void*)soap_instantiate___ns1__dyhwSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__loadDownLog:
		return (void*)soap_instantiate___ns1__loadDownLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__dyhwAdjust:
		return (void*)soap_instantiate___ns1__dyhwAdjust(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__obdResultLog:
		return (void*)soap_instantiate___ns1__obdResultLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCarInfo_USCOREFC:
		return (void*)soap_instantiate___ns1__getCarInfo_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__software2centerNew_USCOREFC:
		return (void*)soap_instantiate___ns1__software2centerNew_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cycdyhwAdjust:
		return (void*)soap_instantiate___ns1__cycdyhwAdjust(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__hjcsgyqSelfcheck:
		return (void*)soap_instantiate___ns1__hjcsgyqSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__pqfxySelfcheck:
		return (void*)soap_instantiate___ns1__pqfxySelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC:
		return (void*)soap_instantiate___ns1__lightproofSmokeDataLog_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__loadDownData:
		return (void*)soap_instantiate___ns1__loadDownData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__vmasData:
		return (void*)soap_instantiate___ns1__vmasData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__motoDbIdleData:
		return (void*)soap_instantiate___ns1__motoDbIdleData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSatate:
		return (void*)soap_instantiate___ns1__getSatate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doubleIdleData:
		return (void*)soap_instantiate___ns1__doubleIdleData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doubleIdleLog:
		return (void*)soap_instantiate___ns1__doubleIdleLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjPLHPSelfcheck:
		return (void*)soap_instantiate___ns1__cgjPLHPSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__wqfxyAdjust:
		return (void*)soap_instantiate___ns1__wqfxyAdjust(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC:
		return (void*)soap_instantiate___ns1__lightproofSmokeData_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lightproofSmokeData:
		return (void*)soap_instantiate___ns1__lightproofSmokeData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__qyfxSelfcheck:
		return (void*)soap_instantiate___ns1__qyfxSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sdsqtfxySelfcheck:
		return (void*)soap_instantiate___ns1__sdsqtfxySelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendMessage_USCOREFC:
		return (void*)soap_instantiate___ns1__sendMessage_USCOREFC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__wqfxySelfcheck:
		return (void*)soap_instantiate___ns1__wqfxySelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjALPSelfcheck:
		return (void*)soap_instantiate___ns1__cgjALPSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lljSelfcheck:
		return (void*)soap_instantiate___ns1__lljSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjLSPSelfcheck:
		return (void*)soap_instantiate___ns1__cgjLSPSelfcheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__argChang_:
		return (void*)soap_instantiate___ns1__argChang_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lightproofSmokeLog_:
		return (void*)soap_instantiate___ns1__lightproofSmokeLog_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCarInfo_:
		return (void*)soap_instantiate___ns1__getCarInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendMessage_:
		return (void*)soap_instantiate___ns1__sendMessage_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__bgAirHC_:
		return (void*)soap_instantiate___ns1__bgAirHC_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doubleIdleData_USCOREFC_:
		return (void*)soap_instantiate___ns1__doubleIdleData_USCOREFC_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjLASelfcheck_:
		return (void*)soap_instantiate___ns1__cgjLASelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjSelfcheck_:
		return (void*)soap_instantiate___ns1__cgjSelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__obdResult_:
		return (void*)soap_instantiate___ns1__obdResult_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doubleIdleLog_USCOREFC_:
		return (void*)soap_instantiate___ns1__doubleIdleLog_USCOREFC_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__vmasLog_:
		return (void*)soap_instantiate___ns1__vmasLog_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ydjSelfcheck_:
		return (void*)soap_instantiate___ns1__ydjSelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__dyhwSelfcheck_:
		return (void*)soap_instantiate___ns1__dyhwSelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__loadDownLog_:
		return (void*)soap_instantiate___ns1__loadDownLog_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__dyhwAdjust_:
		return (void*)soap_instantiate___ns1__dyhwAdjust_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__obdResultLog_:
		return (void*)soap_instantiate___ns1__obdResultLog_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCarInfo_USCOREFC_:
		return (void*)soap_instantiate___ns1__getCarInfo_USCOREFC_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__software2centerNew_USCOREFC_:
		return (void*)soap_instantiate___ns1__software2centerNew_USCOREFC_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cycdyhwAdjust_:
		return (void*)soap_instantiate___ns1__cycdyhwAdjust_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__hjcsgyqSelfcheck_:
		return (void*)soap_instantiate___ns1__hjcsgyqSelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__pqfxySelfcheck_:
		return (void*)soap_instantiate___ns1__pqfxySelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC_:
		return (void*)soap_instantiate___ns1__lightproofSmokeDataLog_USCOREFC_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__loadDownData_:
		return (void*)soap_instantiate___ns1__loadDownData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__vmasData_:
		return (void*)soap_instantiate___ns1__vmasData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__motoDbIdleData_:
		return (void*)soap_instantiate___ns1__motoDbIdleData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSatate_:
		return (void*)soap_instantiate___ns1__getSatate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doubleIdleData_:
		return (void*)soap_instantiate___ns1__doubleIdleData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__doubleIdleLog_:
		return (void*)soap_instantiate___ns1__doubleIdleLog_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjPLHPSelfcheck_:
		return (void*)soap_instantiate___ns1__cgjPLHPSelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__wqfxyAdjust_:
		return (void*)soap_instantiate___ns1__wqfxyAdjust_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC_:
		return (void*)soap_instantiate___ns1__lightproofSmokeData_USCOREFC_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lightproofSmokeData_:
		return (void*)soap_instantiate___ns1__lightproofSmokeData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__qyfxSelfcheck_:
		return (void*)soap_instantiate___ns1__qyfxSelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sdsqtfxySelfcheck_:
		return (void*)soap_instantiate___ns1__sdsqtfxySelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendMessage_USCOREFC_:
		return (void*)soap_instantiate___ns1__sendMessage_USCOREFC_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__wqfxySelfcheck_:
		return (void*)soap_instantiate___ns1__wqfxySelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjALPSelfcheck_:
		return (void*)soap_instantiate___ns1__cgjALPSelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lljSelfcheck_:
		return (void*)soap_instantiate___ns1__lljSelfcheck_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjLSPSelfcheck_:
		return (void*)soap_instantiate___ns1__cgjLSPSelfcheck_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_ns1__argChang:
		if (p->size < 0)
			SOAP_DELETE((ns1__argChang*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__argChang*)p->ptr);
		break;
	case SOAP_TYPE_ns1__argChangResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__argChangResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__argChangResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeLog:
		if (p->size < 0)
			SOAP_DELETE((ns1__lightproofSmokeLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lightproofSmokeLog*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeLogResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__lightproofSmokeLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lightproofSmokeLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCarInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__getCarInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getCarInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCarInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getCarInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getCarInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__carInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__carInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__carInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sendMessage:
		if (p->size < 0)
			SOAP_DELETE((ns1__sendMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sendMessage*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sendMessageResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__sendMessageResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sendMessageResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__bgAirHC:
		if (p->size < 0)
			SOAP_DELETE((ns1__bgAirHC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__bgAirHC*)p->ptr);
		break;
	case SOAP_TYPE_ns1__bgAirHCResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__bgAirHCResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__bgAirHCResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__doubleIdleData_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((ns1__doubleIdleData_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__doubleIdleData_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE_ns1__doubleIdleDataResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__doubleIdleDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__doubleIdleDataResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjLASelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjLASelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjLASelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjLASelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjLASelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjLASelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjSelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjSelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjSelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__obdResult:
		if (p->size < 0)
			SOAP_DELETE((ns1__obdResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__obdResult*)p->ptr);
		break;
	case SOAP_TYPE_ns1__obdResultResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__obdResultResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__obdResultResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__doubleIdleLog_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((ns1__doubleIdleLog_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__doubleIdleLog_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE_ns1__doubleIdleLogResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__doubleIdleLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__doubleIdleLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__vmasLog:
		if (p->size < 0)
			SOAP_DELETE((ns1__vmasLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__vmasLog*)p->ptr);
		break;
	case SOAP_TYPE_ns1__vmasLogResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__vmasLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__vmasLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ydjSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__ydjSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ydjSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ydjSelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__ydjSelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ydjSelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__dyhwSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__dyhwSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__dyhwSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__dyhwSelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__dyhwSelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__dyhwSelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__loadDownLog:
		if (p->size < 0)
			SOAP_DELETE((ns1__loadDownLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__loadDownLog*)p->ptr);
		break;
	case SOAP_TYPE_ns1__loadDownLogResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__loadDownLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__loadDownLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__dyhwAdjust:
		if (p->size < 0)
			SOAP_DELETE((ns1__dyhwAdjust*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__dyhwAdjust*)p->ptr);
		break;
	case SOAP_TYPE_ns1__dyhwAdjustResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__dyhwAdjustResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__dyhwAdjustResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__obdResultLog:
		if (p->size < 0)
			SOAP_DELETE((ns1__obdResultLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__obdResultLog*)p->ptr);
		break;
	case SOAP_TYPE_ns1__obdResultLogResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__obdResultLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__obdResultLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCarInfo_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((ns1__getCarInfo_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getCarInfo_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE_ns1__software2centerNew_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((ns1__software2centerNew_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__software2centerNew_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__software2centerNew_USCOREFCResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__software2centerNew_USCOREFCResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cycdyhwAdjust:
		if (p->size < 0)
			SOAP_DELETE((ns1__cycdyhwAdjust*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cycdyhwAdjust*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cycdyhwAdjustResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__cycdyhwAdjustResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cycdyhwAdjustResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__hjcsgyqSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__hjcsgyqSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__hjcsgyqSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__hjcsgyqSelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__hjcsgyqSelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__pqfxySelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__pqfxySelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__pqfxySelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__pqfxySelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__pqfxySelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__pqfxySelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((ns1__lightproofSmokeDataLog_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lightproofSmokeDataLog_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__lightproofSmokeDataLog_USCOREFCResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lightproofSmokeDataLog_USCOREFCResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__loadDownData:
		if (p->size < 0)
			SOAP_DELETE((ns1__loadDownData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__loadDownData*)p->ptr);
		break;
	case SOAP_TYPE_ns1__loadDownDataResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__loadDownDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__loadDownDataResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__vmasData:
		if (p->size < 0)
			SOAP_DELETE((ns1__vmasData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__vmasData*)p->ptr);
		break;
	case SOAP_TYPE_ns1__vmasDataResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__vmasDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__vmasDataResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__motoDbIdleData:
		if (p->size < 0)
			SOAP_DELETE((ns1__motoDbIdleData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__motoDbIdleData*)p->ptr);
		break;
	case SOAP_TYPE_ns1__motoDbIdleDataResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__motoDbIdleDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__motoDbIdleDataResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSatate:
		if (p->size < 0)
			SOAP_DELETE((ns1__getSatate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getSatate*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSatateResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getSatateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getSatateResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__stateInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__stateInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__stateInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__doubleIdleData:
		if (p->size < 0)
			SOAP_DELETE((ns1__doubleIdleData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__doubleIdleData*)p->ptr);
		break;
	case SOAP_TYPE_ns1__doubleIdleLog:
		if (p->size < 0)
			SOAP_DELETE((ns1__doubleIdleLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__doubleIdleLog*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjPLHPSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjPLHPSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjPLHPSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjPLHPSelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjPLHPSelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wqfxyAdjust:
		if (p->size < 0)
			SOAP_DELETE((ns1__wqfxyAdjust*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wqfxyAdjust*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wqfxyAdjustResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__wqfxyAdjustResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wqfxyAdjustResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((ns1__lightproofSmokeData_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lightproofSmokeData_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeDataResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__lightproofSmokeDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lightproofSmokeDataResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lightproofSmokeData:
		if (p->size < 0)
			SOAP_DELETE((ns1__lightproofSmokeData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lightproofSmokeData*)p->ptr);
		break;
	case SOAP_TYPE_ns1__qyfxSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__qyfxSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__qyfxSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__qyfxSelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__qyfxSelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__qyfxSelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sdsqtfxySelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__sdsqtfxySelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sdsqtfxySelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__sdsqtfxySelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sdsqtfxySelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sendMessage_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((ns1__sendMessage_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sendMessage_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wqfxySelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__wqfxySelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wqfxySelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wqfxySelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__wqfxySelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wqfxySelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjALPSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjALPSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjALPSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjALPSelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjALPSelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjALPSelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lljSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__lljSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lljSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lljSelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__lljSelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lljSelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjLSPSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjLSPSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjLSPSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjLSPSelfcheckResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjLSPSelfcheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjLSPSelfcheckResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__argChang:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__argChang*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__argChang*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeLog:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lightproofSmokeLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lightproofSmokeLog*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getCarInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getCarInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getCarInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sendMessage:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sendMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sendMessage*)p->ptr);
		break;
	case SOAP_TYPE___ns1__bgAirHC:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__bgAirHC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__bgAirHC*)p->ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleData_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__doubleIdleData_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__doubleIdleData_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjLASelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjLASelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjLASelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__obdResult:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__obdResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__obdResult*)p->ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleLog_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__doubleIdleLog_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__doubleIdleLog_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE___ns1__vmasLog:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__vmasLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__vmasLog*)p->ptr);
		break;
	case SOAP_TYPE___ns1__ydjSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__ydjSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__ydjSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__dyhwSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__dyhwSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__dyhwSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__loadDownLog:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__loadDownLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__loadDownLog*)p->ptr);
		break;
	case SOAP_TYPE___ns1__dyhwAdjust:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__dyhwAdjust*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__dyhwAdjust*)p->ptr);
		break;
	case SOAP_TYPE___ns1__obdResultLog:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__obdResultLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__obdResultLog*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getCarInfo_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getCarInfo_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getCarInfo_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE___ns1__software2centerNew_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__software2centerNew_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__software2centerNew_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cycdyhwAdjust:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cycdyhwAdjust*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cycdyhwAdjust*)p->ptr);
		break;
	case SOAP_TYPE___ns1__hjcsgyqSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__hjcsgyqSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__hjcsgyqSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__pqfxySelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__pqfxySelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__pqfxySelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lightproofSmokeDataLog_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lightproofSmokeDataLog_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE___ns1__loadDownData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__loadDownData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__loadDownData*)p->ptr);
		break;
	case SOAP_TYPE___ns1__vmasData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__vmasData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__vmasData*)p->ptr);
		break;
	case SOAP_TYPE___ns1__motoDbIdleData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__motoDbIdleData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__motoDbIdleData*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSatate:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSatate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSatate*)p->ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__doubleIdleData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__doubleIdleData*)p->ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleLog:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__doubleIdleLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__doubleIdleLog*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjPLHPSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjPLHPSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjPLHPSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__wqfxyAdjust:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__wqfxyAdjust*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__wqfxyAdjust*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lightproofSmokeData_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lightproofSmokeData_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lightproofSmokeData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lightproofSmokeData*)p->ptr);
		break;
	case SOAP_TYPE___ns1__qyfxSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__qyfxSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__qyfxSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sdsqtfxySelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sdsqtfxySelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sdsqtfxySelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sendMessage_USCOREFC:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sendMessage_USCOREFC*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sendMessage_USCOREFC*)p->ptr);
		break;
	case SOAP_TYPE___ns1__wqfxySelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__wqfxySelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__wqfxySelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjALPSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjALPSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjALPSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lljSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lljSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lljSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjLSPSelfcheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjLSPSelfcheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjLSPSelfcheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__argChang_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__argChang_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__argChang_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeLog_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lightproofSmokeLog_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lightproofSmokeLog_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getCarInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getCarInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getCarInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sendMessage_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sendMessage_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sendMessage_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__bgAirHC_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__bgAirHC_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__bgAirHC_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleData_USCOREFC_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__doubleIdleData_USCOREFC_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__doubleIdleData_USCOREFC_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjLASelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjLASelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjLASelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjSelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjSelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjSelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__obdResult_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__obdResult_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__obdResult_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleLog_USCOREFC_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__doubleIdleLog_USCOREFC_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__doubleIdleLog_USCOREFC_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__vmasLog_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__vmasLog_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__vmasLog_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__ydjSelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__ydjSelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__ydjSelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__dyhwSelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__dyhwSelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__dyhwSelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__loadDownLog_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__loadDownLog_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__loadDownLog_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__dyhwAdjust_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__dyhwAdjust_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__dyhwAdjust_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__obdResultLog_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__obdResultLog_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__obdResultLog_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getCarInfo_USCOREFC_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getCarInfo_USCOREFC_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getCarInfo_USCOREFC_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__software2centerNew_USCOREFC_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__software2centerNew_USCOREFC_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__software2centerNew_USCOREFC_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cycdyhwAdjust_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cycdyhwAdjust_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cycdyhwAdjust_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__hjcsgyqSelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__hjcsgyqSelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__hjcsgyqSelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__pqfxySelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__pqfxySelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__pqfxySelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lightproofSmokeDataLog_USCOREFC_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lightproofSmokeDataLog_USCOREFC_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__loadDownData_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__loadDownData_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__loadDownData_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__vmasData_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__vmasData_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__vmasData_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__motoDbIdleData_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__motoDbIdleData_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__motoDbIdleData_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSatate_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSatate_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSatate_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleData_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__doubleIdleData_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__doubleIdleData_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__doubleIdleLog_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__doubleIdleLog_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__doubleIdleLog_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjPLHPSelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjPLHPSelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjPLHPSelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__wqfxyAdjust_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__wqfxyAdjust_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__wqfxyAdjust_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lightproofSmokeData_USCOREFC_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lightproofSmokeData_USCOREFC_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lightproofSmokeData_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lightproofSmokeData_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lightproofSmokeData_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__qyfxSelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__qyfxSelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__qyfxSelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sdsqtfxySelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sdsqtfxySelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sdsqtfxySelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sendMessage_USCOREFC_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sendMessage_USCOREFC_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sendMessage_USCOREFC_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__wqfxySelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__wqfxySelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__wqfxySelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjALPSelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjALPSelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjALPSelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lljSelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lljSelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lljSelfcheck_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjLSPSelfcheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjLSPSelfcheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjLSPSelfcheck_*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_std__wstring, 0, sizeof(std::wstring), 0, soap_copy_std__wstring);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_std__wstring);
	if (soap_out_std__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__wstring, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::wstring);
		if (size)
			*size = sizeof(std::wstring);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::wstring, n);
		if (size)
			*size = n * sizeof(std::wstring);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::wstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::wstring %p -> %p\n", q, p));
	*(std::wstring*)p = *(std::wstring*)q;
}

void ns1__cgjLSPSelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__cgjLSPSelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__cgjLSPSelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__cgjLSPSelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjLSPSelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjLSPSelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__cgjLSPSelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjLSPSelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__cgjLSPSelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjLSPSelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjLSPSelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjLSPSelfcheckResponse * SOAP_FMAC4 soap_in_ns1__cgjLSPSelfcheckResponse(struct soap *soap, const char *tag, ns1__cgjLSPSelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjLSPSelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjLSPSelfcheckResponse, sizeof(ns1__cgjLSPSelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjLSPSelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjLSPSelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__cgjLSPSelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjLSPSelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjLSPSelfcheckResponse, 0, sizeof(ns1__cgjLSPSelfcheckResponse), 0, soap_copy_ns1__cgjLSPSelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjLSPSelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjLSPSelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:cgjLSPSelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjLSPSelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjLSPSelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjLSPSelfcheckResponse * SOAP_FMAC4 soap_get_ns1__cgjLSPSelfcheckResponse(struct soap *soap, ns1__cgjLSPSelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjLSPSelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjLSPSelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__cgjLSPSelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjLSPSelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjLSPSelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjLSPSelfcheckResponse);
		if (size)
			*size = sizeof(ns1__cgjLSPSelfcheckResponse);
		((ns1__cgjLSPSelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjLSPSelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__cgjLSPSelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjLSPSelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjLSPSelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjLSPSelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjLSPSelfcheckResponse %p -> %p\n", q, p));
	*(ns1__cgjLSPSelfcheckResponse*)p = *(ns1__cgjLSPSelfcheckResponse*)q;
}

void ns1__cgjLSPSelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__cgjLSPSelfcheck::registCode = NULL;
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::AvitualTime);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::ArealTime);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::BvitualTime);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::BrealTime);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::CvitualTime);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::CrealTime);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::DvitualTime);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::DrealTime);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::ALSpower);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::BLSpower);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::CLSpower);
	soap_default_double(soap, &this->ns1__cgjLSPSelfcheck::DLSpower);
	this->ns1__cgjLSPSelfcheck::checkResult = NULL;
	this->ns1__cgjLSPSelfcheck::checkTimeStart = NULL;
	this->ns1__cgjLSPSelfcheck::checkTimeEnd = NULL;
	this->ns1__cgjLSPSelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__cgjLSPSelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjLSPSelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjLSPSelfcheck::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjLSPSelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjLSPSelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjLSPSelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__cgjLSPSelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjLSPSelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjLSPSelfcheck(struct soap *soap, const char *tag, int id, const ns1__cgjLSPSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjLSPSelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__cgjLSPSelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "AvitualTime", -1, &(a->ns1__cgjLSPSelfcheck::AvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "ArealTime", -1, &(a->ns1__cgjLSPSelfcheck::ArealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "BvitualTime", -1, &(a->ns1__cgjLSPSelfcheck::BvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "BrealTime", -1, &(a->ns1__cgjLSPSelfcheck::BrealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "CvitualTime", -1, &(a->ns1__cgjLSPSelfcheck::CvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "CrealTime", -1, &(a->ns1__cgjLSPSelfcheck::CrealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "DvitualTime", -1, &(a->ns1__cgjLSPSelfcheck::DvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "DrealTime", -1, &(a->ns1__cgjLSPSelfcheck::DrealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "ALSpower", -1, &(a->ns1__cgjLSPSelfcheck::ALSpower), ""))
		return soap->error;
	if (soap_out_double(soap, "BLSpower", -1, &(a->ns1__cgjLSPSelfcheck::BLSpower), ""))
		return soap->error;
	if (soap_out_double(soap, "CLSpower", -1, &(a->ns1__cgjLSPSelfcheck::CLSpower), ""))
		return soap->error;
	if (soap_out_double(soap, "DLSpower", -1, &(a->ns1__cgjLSPSelfcheck::DLSpower), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__cgjLSPSelfcheck::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__cgjLSPSelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__cgjLSPSelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__cgjLSPSelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjLSPSelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjLSPSelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjLSPSelfcheck * SOAP_FMAC4 soap_in_ns1__cgjLSPSelfcheck(struct soap *soap, const char *tag, ns1__cgjLSPSelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjLSPSelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjLSPSelfcheck, sizeof(ns1__cgjLSPSelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjLSPSelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjLSPSelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_AvitualTime1 = 1;
	size_t soap_flag_ArealTime1 = 1;
	size_t soap_flag_BvitualTime1 = 1;
	size_t soap_flag_BrealTime1 = 1;
	size_t soap_flag_CvitualTime1 = 1;
	size_t soap_flag_CrealTime1 = 1;
	size_t soap_flag_DvitualTime1 = 1;
	size_t soap_flag_DrealTime1 = 1;
	size_t soap_flag_ALSpower1 = 1;
	size_t soap_flag_BLSpower1 = 1;
	size_t soap_flag_CLSpower1 = 1;
	size_t soap_flag_DLSpower1 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__cgjLSPSelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_AvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "AvitualTime", &(a->ns1__cgjLSPSelfcheck::AvitualTime), "xsd:double"))
				{	soap_flag_AvitualTime1--;
					continue;
				}
			if (soap_flag_ArealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ArealTime", &(a->ns1__cgjLSPSelfcheck::ArealTime), "xsd:double"))
				{	soap_flag_ArealTime1--;
					continue;
				}
			if (soap_flag_BvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BvitualTime", &(a->ns1__cgjLSPSelfcheck::BvitualTime), "xsd:double"))
				{	soap_flag_BvitualTime1--;
					continue;
				}
			if (soap_flag_BrealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BrealTime", &(a->ns1__cgjLSPSelfcheck::BrealTime), "xsd:double"))
				{	soap_flag_BrealTime1--;
					continue;
				}
			if (soap_flag_CvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CvitualTime", &(a->ns1__cgjLSPSelfcheck::CvitualTime), "xsd:double"))
				{	soap_flag_CvitualTime1--;
					continue;
				}
			if (soap_flag_CrealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CrealTime", &(a->ns1__cgjLSPSelfcheck::CrealTime), "xsd:double"))
				{	soap_flag_CrealTime1--;
					continue;
				}
			if (soap_flag_DvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "DvitualTime", &(a->ns1__cgjLSPSelfcheck::DvitualTime), "xsd:double"))
				{	soap_flag_DvitualTime1--;
					continue;
				}
			if (soap_flag_DrealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "DrealTime", &(a->ns1__cgjLSPSelfcheck::DrealTime), "xsd:double"))
				{	soap_flag_DrealTime1--;
					continue;
				}
			if (soap_flag_ALSpower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ALSpower", &(a->ns1__cgjLSPSelfcheck::ALSpower), "xsd:double"))
				{	soap_flag_ALSpower1--;
					continue;
				}
			if (soap_flag_BLSpower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BLSpower", &(a->ns1__cgjLSPSelfcheck::BLSpower), "xsd:double"))
				{	soap_flag_BLSpower1--;
					continue;
				}
			if (soap_flag_CLSpower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CLSpower", &(a->ns1__cgjLSPSelfcheck::CLSpower), "xsd:double"))
				{	soap_flag_CLSpower1--;
					continue;
				}
			if (soap_flag_DLSpower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "DLSpower", &(a->ns1__cgjLSPSelfcheck::DLSpower), "xsd:double"))
				{	soap_flag_DLSpower1--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__cgjLSPSelfcheck::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__cgjLSPSelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__cgjLSPSelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__cgjLSPSelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjLSPSelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjLSPSelfcheck, 0, sizeof(ns1__cgjLSPSelfcheck), 0, soap_copy_ns1__cgjLSPSelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AvitualTime1 > 0 || soap_flag_ArealTime1 > 0 || soap_flag_BvitualTime1 > 0 || soap_flag_BrealTime1 > 0 || soap_flag_CvitualTime1 > 0 || soap_flag_CrealTime1 > 0 || soap_flag_DvitualTime1 > 0 || soap_flag_DrealTime1 > 0 || soap_flag_ALSpower1 > 0 || soap_flag_BLSpower1 > 0 || soap_flag_CLSpower1 > 0 || soap_flag_DLSpower1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjLSPSelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjLSPSelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:cgjLSPSelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjLSPSelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjLSPSelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjLSPSelfcheck * SOAP_FMAC4 soap_get_ns1__cgjLSPSelfcheck(struct soap *soap, ns1__cgjLSPSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjLSPSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjLSPSelfcheck * SOAP_FMAC2 soap_instantiate_ns1__cgjLSPSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjLSPSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjLSPSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjLSPSelfcheck);
		if (size)
			*size = sizeof(ns1__cgjLSPSelfcheck);
		((ns1__cgjLSPSelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjLSPSelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__cgjLSPSelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjLSPSelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjLSPSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjLSPSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjLSPSelfcheck %p -> %p\n", q, p));
	*(ns1__cgjLSPSelfcheck*)p = *(ns1__cgjLSPSelfcheck*)q;
}

void ns1__lljSelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__lljSelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__lljSelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__lljSelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lljSelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lljSelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__lljSelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lljSelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__lljSelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lljSelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lljSelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lljSelfcheckResponse * SOAP_FMAC4 soap_in_ns1__lljSelfcheckResponse(struct soap *soap, const char *tag, ns1__lljSelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lljSelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lljSelfcheckResponse, sizeof(ns1__lljSelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lljSelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lljSelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__lljSelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lljSelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lljSelfcheckResponse, 0, sizeof(ns1__lljSelfcheckResponse), 0, soap_copy_ns1__lljSelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lljSelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lljSelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:lljSelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lljSelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lljSelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lljSelfcheckResponse * SOAP_FMAC4 soap_get_ns1__lljSelfcheckResponse(struct soap *soap, ns1__lljSelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lljSelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lljSelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__lljSelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lljSelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lljSelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lljSelfcheckResponse);
		if (size)
			*size = sizeof(ns1__lljSelfcheckResponse);
		((ns1__lljSelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lljSelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__lljSelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lljSelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lljSelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lljSelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lljSelfcheckResponse %p -> %p\n", q, p));
	*(ns1__lljSelfcheckResponse*)p = *(ns1__lljSelfcheckResponse*)q;
}

void ns1__lljSelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lljSelfcheck::registCode = NULL;
	soap_default_double(soap, &this->ns1__lljSelfcheck::avgFlow);
	soap_default_double(soap, &this->ns1__lljSelfcheck::O2Avg);
	this->ns1__lljSelfcheck::checkResult = NULL;
	this->ns1__lljSelfcheck::checkTimeStart = NULL;
	this->ns1__lljSelfcheck::checkTimeEnd = NULL;
	this->ns1__lljSelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__lljSelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljSelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljSelfcheck::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljSelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljSelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljSelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__lljSelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lljSelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lljSelfcheck(struct soap *soap, const char *tag, int id, const ns1__lljSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lljSelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__lljSelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "avgFlow", -1, &(a->ns1__lljSelfcheck::avgFlow), ""))
		return soap->error;
	if (soap_out_double(soap, "O2Avg", -1, &(a->ns1__lljSelfcheck::O2Avg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__lljSelfcheck::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__lljSelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__lljSelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__lljSelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lljSelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lljSelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lljSelfcheck * SOAP_FMAC4 soap_in_ns1__lljSelfcheck(struct soap *soap, const char *tag, ns1__lljSelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lljSelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lljSelfcheck, sizeof(ns1__lljSelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lljSelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lljSelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_avgFlow1 = 1;
	size_t soap_flag_O2Avg1 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__lljSelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_avgFlow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "avgFlow", &(a->ns1__lljSelfcheck::avgFlow), "xsd:double"))
				{	soap_flag_avgFlow1--;
					continue;
				}
			if (soap_flag_O2Avg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "O2Avg", &(a->ns1__lljSelfcheck::O2Avg), "xsd:double"))
				{	soap_flag_O2Avg1--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__lljSelfcheck::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__lljSelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__lljSelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__lljSelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lljSelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lljSelfcheck, 0, sizeof(ns1__lljSelfcheck), 0, soap_copy_ns1__lljSelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_avgFlow1 > 0 || soap_flag_O2Avg1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lljSelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lljSelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:lljSelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lljSelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lljSelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lljSelfcheck * SOAP_FMAC4 soap_get_ns1__lljSelfcheck(struct soap *soap, ns1__lljSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lljSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lljSelfcheck * SOAP_FMAC2 soap_instantiate_ns1__lljSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lljSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lljSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lljSelfcheck);
		if (size)
			*size = sizeof(ns1__lljSelfcheck);
		((ns1__lljSelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lljSelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__lljSelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lljSelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lljSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lljSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lljSelfcheck %p -> %p\n", q, p));
	*(ns1__lljSelfcheck*)p = *(ns1__lljSelfcheck*)q;
}

void ns1__cgjALPSelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__cgjALPSelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__cgjALPSelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__cgjALPSelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjALPSelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjALPSelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__cgjALPSelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjALPSelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__cgjALPSelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjALPSelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjALPSelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjALPSelfcheckResponse * SOAP_FMAC4 soap_in_ns1__cgjALPSelfcheckResponse(struct soap *soap, const char *tag, ns1__cgjALPSelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjALPSelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjALPSelfcheckResponse, sizeof(ns1__cgjALPSelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjALPSelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjALPSelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__cgjALPSelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjALPSelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjALPSelfcheckResponse, 0, sizeof(ns1__cgjALPSelfcheckResponse), 0, soap_copy_ns1__cgjALPSelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjALPSelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjALPSelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:cgjALPSelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjALPSelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjALPSelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjALPSelfcheckResponse * SOAP_FMAC4 soap_get_ns1__cgjALPSelfcheckResponse(struct soap *soap, ns1__cgjALPSelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjALPSelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjALPSelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__cgjALPSelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjALPSelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjALPSelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjALPSelfcheckResponse);
		if (size)
			*size = sizeof(ns1__cgjALPSelfcheckResponse);
		((ns1__cgjALPSelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjALPSelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__cgjALPSelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjALPSelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjALPSelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjALPSelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjALPSelfcheckResponse %p -> %p\n", q, p));
	*(ns1__cgjALPSelfcheckResponse*)p = *(ns1__cgjALPSelfcheckResponse*)q;
}

void ns1__cgjALPSelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__cgjALPSelfcheck::registCode = NULL;
	soap_default_double(soap, &this->ns1__cgjALPSelfcheck::AvitualTime);
	soap_default_double(soap, &this->ns1__cgjALPSelfcheck::ArealTime);
	soap_default_double(soap, &this->ns1__cgjALPSelfcheck::BvitualTime);
	soap_default_double(soap, &this->ns1__cgjALPSelfcheck::BrealTime);
	soap_default_double(soap, &this->ns1__cgjALPSelfcheck::CvitualTime);
	soap_default_double(soap, &this->ns1__cgjALPSelfcheck::CrealTime);
	soap_default_double(soap, &this->ns1__cgjALPSelfcheck::ALpower1);
	soap_default_double(soap, &this->ns1__cgjALPSelfcheck::ALpower2);
	this->ns1__cgjALPSelfcheck::checkResult = NULL;
	this->ns1__cgjALPSelfcheck::checkTimeStart = NULL;
	this->ns1__cgjALPSelfcheck::checkTimeEnd = NULL;
	this->ns1__cgjALPSelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__cgjALPSelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjALPSelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjALPSelfcheck::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjALPSelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjALPSelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjALPSelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__cgjALPSelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjALPSelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjALPSelfcheck(struct soap *soap, const char *tag, int id, const ns1__cgjALPSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjALPSelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__cgjALPSelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "AvitualTime", -1, &(a->ns1__cgjALPSelfcheck::AvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "ArealTime", -1, &(a->ns1__cgjALPSelfcheck::ArealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "BvitualTime", -1, &(a->ns1__cgjALPSelfcheck::BvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "BrealTime", -1, &(a->ns1__cgjALPSelfcheck::BrealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "CvitualTime", -1, &(a->ns1__cgjALPSelfcheck::CvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "CrealTime", -1, &(a->ns1__cgjALPSelfcheck::CrealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "ALpower1", -1, &(a->ns1__cgjALPSelfcheck::ALpower1), ""))
		return soap->error;
	if (soap_out_double(soap, "ALpower2", -1, &(a->ns1__cgjALPSelfcheck::ALpower2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__cgjALPSelfcheck::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__cgjALPSelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__cgjALPSelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__cgjALPSelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjALPSelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjALPSelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjALPSelfcheck * SOAP_FMAC4 soap_in_ns1__cgjALPSelfcheck(struct soap *soap, const char *tag, ns1__cgjALPSelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjALPSelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjALPSelfcheck, sizeof(ns1__cgjALPSelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjALPSelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjALPSelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_AvitualTime1 = 1;
	size_t soap_flag_ArealTime1 = 1;
	size_t soap_flag_BvitualTime1 = 1;
	size_t soap_flag_BrealTime1 = 1;
	size_t soap_flag_CvitualTime1 = 1;
	size_t soap_flag_CrealTime1 = 1;
	size_t soap_flag_ALpower11 = 1;
	size_t soap_flag_ALpower21 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__cgjALPSelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_AvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "AvitualTime", &(a->ns1__cgjALPSelfcheck::AvitualTime), "xsd:double"))
				{	soap_flag_AvitualTime1--;
					continue;
				}
			if (soap_flag_ArealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ArealTime", &(a->ns1__cgjALPSelfcheck::ArealTime), "xsd:double"))
				{	soap_flag_ArealTime1--;
					continue;
				}
			if (soap_flag_BvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BvitualTime", &(a->ns1__cgjALPSelfcheck::BvitualTime), "xsd:double"))
				{	soap_flag_BvitualTime1--;
					continue;
				}
			if (soap_flag_BrealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BrealTime", &(a->ns1__cgjALPSelfcheck::BrealTime), "xsd:double"))
				{	soap_flag_BrealTime1--;
					continue;
				}
			if (soap_flag_CvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CvitualTime", &(a->ns1__cgjALPSelfcheck::CvitualTime), "xsd:double"))
				{	soap_flag_CvitualTime1--;
					continue;
				}
			if (soap_flag_CrealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CrealTime", &(a->ns1__cgjALPSelfcheck::CrealTime), "xsd:double"))
				{	soap_flag_CrealTime1--;
					continue;
				}
			if (soap_flag_ALpower11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ALpower1", &(a->ns1__cgjALPSelfcheck::ALpower1), "xsd:double"))
				{	soap_flag_ALpower11--;
					continue;
				}
			if (soap_flag_ALpower21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ALpower2", &(a->ns1__cgjALPSelfcheck::ALpower2), "xsd:double"))
				{	soap_flag_ALpower21--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__cgjALPSelfcheck::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__cgjALPSelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__cgjALPSelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__cgjALPSelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjALPSelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjALPSelfcheck, 0, sizeof(ns1__cgjALPSelfcheck), 0, soap_copy_ns1__cgjALPSelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AvitualTime1 > 0 || soap_flag_ArealTime1 > 0 || soap_flag_BvitualTime1 > 0 || soap_flag_BrealTime1 > 0 || soap_flag_CvitualTime1 > 0 || soap_flag_CrealTime1 > 0 || soap_flag_ALpower11 > 0 || soap_flag_ALpower21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjALPSelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjALPSelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:cgjALPSelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjALPSelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjALPSelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjALPSelfcheck * SOAP_FMAC4 soap_get_ns1__cgjALPSelfcheck(struct soap *soap, ns1__cgjALPSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjALPSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjALPSelfcheck * SOAP_FMAC2 soap_instantiate_ns1__cgjALPSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjALPSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjALPSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjALPSelfcheck);
		if (size)
			*size = sizeof(ns1__cgjALPSelfcheck);
		((ns1__cgjALPSelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjALPSelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__cgjALPSelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjALPSelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjALPSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjALPSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjALPSelfcheck %p -> %p\n", q, p));
	*(ns1__cgjALPSelfcheck*)p = *(ns1__cgjALPSelfcheck*)q;
}

void ns1__wqfxySelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__wqfxySelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__wqfxySelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__wqfxySelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wqfxySelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wqfxySelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__wqfxySelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wqfxySelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__wqfxySelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wqfxySelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wqfxySelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wqfxySelfcheckResponse * SOAP_FMAC4 soap_in_ns1__wqfxySelfcheckResponse(struct soap *soap, const char *tag, ns1__wqfxySelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wqfxySelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wqfxySelfcheckResponse, sizeof(ns1__wqfxySelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wqfxySelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wqfxySelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__wqfxySelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wqfxySelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wqfxySelfcheckResponse, 0, sizeof(ns1__wqfxySelfcheckResponse), 0, soap_copy_ns1__wqfxySelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__wqfxySelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wqfxySelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:wqfxySelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wqfxySelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wqfxySelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wqfxySelfcheckResponse * SOAP_FMAC4 soap_get_ns1__wqfxySelfcheckResponse(struct soap *soap, ns1__wqfxySelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wqfxySelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wqfxySelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__wqfxySelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wqfxySelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wqfxySelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wqfxySelfcheckResponse);
		if (size)
			*size = sizeof(ns1__wqfxySelfcheckResponse);
		((ns1__wqfxySelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wqfxySelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__wqfxySelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wqfxySelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wqfxySelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wqfxySelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wqfxySelfcheckResponse %p -> %p\n", q, p));
	*(ns1__wqfxySelfcheckResponse*)p = *(ns1__wqfxySelfcheckResponse*)q;
}

void ns1__wqfxySelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wqfxySelfcheck::registCode = NULL;
	this->ns1__wqfxySelfcheck::tightnessResult = NULL;
	this->ns1__wqfxySelfcheck::checkTimeStart = NULL;
	this->ns1__wqfxySelfcheck::checkTimeEnd = NULL;
	this->ns1__wqfxySelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__wqfxySelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxySelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxySelfcheck::tightnessResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxySelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxySelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxySelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__wqfxySelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wqfxySelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wqfxySelfcheck(struct soap *soap, const char *tag, int id, const ns1__wqfxySelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wqfxySelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__wqfxySelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "tightnessResult", -1, &(a->ns1__wqfxySelfcheck::tightnessResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__wqfxySelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__wqfxySelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__wqfxySelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wqfxySelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wqfxySelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wqfxySelfcheck * SOAP_FMAC4 soap_in_ns1__wqfxySelfcheck(struct soap *soap, const char *tag, ns1__wqfxySelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wqfxySelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wqfxySelfcheck, sizeof(ns1__wqfxySelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wqfxySelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wqfxySelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_tightnessResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__wqfxySelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_tightnessResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "tightnessResult", &(a->ns1__wqfxySelfcheck::tightnessResult), "xsd:string"))
				{	soap_flag_tightnessResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__wqfxySelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__wqfxySelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__wqfxySelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wqfxySelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wqfxySelfcheck, 0, sizeof(ns1__wqfxySelfcheck), 0, soap_copy_ns1__wqfxySelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wqfxySelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wqfxySelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:wqfxySelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wqfxySelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wqfxySelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wqfxySelfcheck * SOAP_FMAC4 soap_get_ns1__wqfxySelfcheck(struct soap *soap, ns1__wqfxySelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wqfxySelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wqfxySelfcheck * SOAP_FMAC2 soap_instantiate_ns1__wqfxySelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wqfxySelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wqfxySelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wqfxySelfcheck);
		if (size)
			*size = sizeof(ns1__wqfxySelfcheck);
		((ns1__wqfxySelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wqfxySelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__wqfxySelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wqfxySelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wqfxySelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wqfxySelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wqfxySelfcheck %p -> %p\n", q, p));
	*(ns1__wqfxySelfcheck*)p = *(ns1__wqfxySelfcheck*)q;
}

void ns1__sendMessage_USCOREFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sendMessage_USCOREFC::businessId = NULL;
	this->ns1__sendMessage_USCOREFC::registCode = NULL;
	this->ns1__sendMessage_USCOREFC::code = NULL;
	this->ns1__sendMessage_USCOREFC::message = NULL;
	/* transient soap skipped */
}

void ns1__sendMessage_USCOREFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sendMessage_USCOREFC::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sendMessage_USCOREFC::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sendMessage_USCOREFC::code);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sendMessage_USCOREFC::message);
	/* transient soap skipped */
#endif
}

int ns1__sendMessage_USCOREFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sendMessage_USCOREFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sendMessage_USCOREFC(struct soap *soap, const char *tag, int id, const ns1__sendMessage_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sendMessage_USCOREFC), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__sendMessage_USCOREFC::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__sendMessage_USCOREFC::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "code", -1, &(a->ns1__sendMessage_USCOREFC::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__sendMessage_USCOREFC::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sendMessage_USCOREFC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sendMessage_USCOREFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sendMessage_USCOREFC * SOAP_FMAC4 soap_in_ns1__sendMessage_USCOREFC(struct soap *soap, const char *tag, ns1__sendMessage_USCOREFC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sendMessage_USCOREFC *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sendMessage_USCOREFC, sizeof(ns1__sendMessage_USCOREFC), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sendMessage_USCOREFC)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sendMessage_USCOREFC *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__sendMessage_USCOREFC::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__sendMessage_USCOREFC::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "code", &(a->ns1__sendMessage_USCOREFC::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__sendMessage_USCOREFC::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sendMessage_USCOREFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sendMessage_USCOREFC, 0, sizeof(ns1__sendMessage_USCOREFC), 0, soap_copy_ns1__sendMessage_USCOREFC);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__sendMessage_USCOREFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__sendMessage_USCOREFC);
	if (this->soap_out(soap, tag?tag:"ns1:sendMessage_FC", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sendMessage_USCOREFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sendMessage_USCOREFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sendMessage_USCOREFC * SOAP_FMAC4 soap_get_ns1__sendMessage_USCOREFC(struct soap *soap, ns1__sendMessage_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sendMessage_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sendMessage_USCOREFC * SOAP_FMAC2 soap_instantiate_ns1__sendMessage_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sendMessage_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sendMessage_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sendMessage_USCOREFC);
		if (size)
			*size = sizeof(ns1__sendMessage_USCOREFC);
		((ns1__sendMessage_USCOREFC*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sendMessage_USCOREFC, n);
		if (size)
			*size = n * sizeof(ns1__sendMessage_USCOREFC);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sendMessage_USCOREFC*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sendMessage_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sendMessage_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sendMessage_USCOREFC %p -> %p\n", q, p));
	*(ns1__sendMessage_USCOREFC*)p = *(ns1__sendMessage_USCOREFC*)q;
}

void ns1__sdsqtfxySelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__sdsqtfxySelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__sdsqtfxySelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__sdsqtfxySelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sdsqtfxySelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sdsqtfxySelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__sdsqtfxySelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__sdsqtfxySelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sdsqtfxySelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sdsqtfxySelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sdsqtfxySelfcheckResponse * SOAP_FMAC4 soap_in_ns1__sdsqtfxySelfcheckResponse(struct soap *soap, const char *tag, ns1__sdsqtfxySelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sdsqtfxySelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse, sizeof(ns1__sdsqtfxySelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sdsqtfxySelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__sdsqtfxySelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sdsqtfxySelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse, 0, sizeof(ns1__sdsqtfxySelfcheckResponse), 0, soap_copy_ns1__sdsqtfxySelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__sdsqtfxySelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:sdsqtfxySelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sdsqtfxySelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sdsqtfxySelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sdsqtfxySelfcheckResponse * SOAP_FMAC4 soap_get_ns1__sdsqtfxySelfcheckResponse(struct soap *soap, ns1__sdsqtfxySelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sdsqtfxySelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sdsqtfxySelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__sdsqtfxySelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sdsqtfxySelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sdsqtfxySelfcheckResponse);
		if (size)
			*size = sizeof(ns1__sdsqtfxySelfcheckResponse);
		((ns1__sdsqtfxySelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sdsqtfxySelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__sdsqtfxySelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sdsqtfxySelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sdsqtfxySelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sdsqtfxySelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sdsqtfxySelfcheckResponse %p -> %p\n", q, p));
	*(ns1__sdsqtfxySelfcheckResponse*)p = *(ns1__sdsqtfxySelfcheckResponse*)q;
}

void ns1__sdsqtfxySelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sdsqtfxySelfcheck::registCode = NULL;
	this->ns1__sdsqtfxySelfcheck::tightnessResult = NULL;
	this->ns1__sdsqtfxySelfcheck::lFlowResult = NULL;
	soap_default_double(soap, &this->ns1__sdsqtfxySelfcheck::canliuHC);
	this->ns1__sdsqtfxySelfcheck::checkResult = NULL;
	this->ns1__sdsqtfxySelfcheck::checkTimeStart = NULL;
	this->ns1__sdsqtfxySelfcheck::checkTimeEnd = NULL;
	this->ns1__sdsqtfxySelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__sdsqtfxySelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsqtfxySelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsqtfxySelfcheck::tightnessResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsqtfxySelfcheck::lFlowResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsqtfxySelfcheck::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsqtfxySelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsqtfxySelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsqtfxySelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__sdsqtfxySelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sdsqtfxySelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sdsqtfxySelfcheck(struct soap *soap, const char *tag, int id, const ns1__sdsqtfxySelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sdsqtfxySelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__sdsqtfxySelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "tightnessResult", -1, &(a->ns1__sdsqtfxySelfcheck::tightnessResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lFlowResult", -1, &(a->ns1__sdsqtfxySelfcheck::lFlowResult), ""))
		return soap->error;
	if (soap_out_double(soap, "canliuHC", -1, &(a->ns1__sdsqtfxySelfcheck::canliuHC), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__sdsqtfxySelfcheck::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__sdsqtfxySelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__sdsqtfxySelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__sdsqtfxySelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sdsqtfxySelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sdsqtfxySelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sdsqtfxySelfcheck * SOAP_FMAC4 soap_in_ns1__sdsqtfxySelfcheck(struct soap *soap, const char *tag, ns1__sdsqtfxySelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sdsqtfxySelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sdsqtfxySelfcheck, sizeof(ns1__sdsqtfxySelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sdsqtfxySelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sdsqtfxySelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_tightnessResult1 = 1;
	size_t soap_flag_lFlowResult1 = 1;
	size_t soap_flag_canliuHC1 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__sdsqtfxySelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_tightnessResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "tightnessResult", &(a->ns1__sdsqtfxySelfcheck::tightnessResult), "xsd:string"))
				{	soap_flag_tightnessResult1--;
					continue;
				}
			if (soap_flag_lFlowResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lFlowResult", &(a->ns1__sdsqtfxySelfcheck::lFlowResult), "xsd:string"))
				{	soap_flag_lFlowResult1--;
					continue;
				}
			if (soap_flag_canliuHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "canliuHC", &(a->ns1__sdsqtfxySelfcheck::canliuHC), "xsd:double"))
				{	soap_flag_canliuHC1--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__sdsqtfxySelfcheck::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__sdsqtfxySelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__sdsqtfxySelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__sdsqtfxySelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sdsqtfxySelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sdsqtfxySelfcheck, 0, sizeof(ns1__sdsqtfxySelfcheck), 0, soap_copy_ns1__sdsqtfxySelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_canliuHC1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__sdsqtfxySelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__sdsqtfxySelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:sdsqtfxySelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sdsqtfxySelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sdsqtfxySelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sdsqtfxySelfcheck * SOAP_FMAC4 soap_get_ns1__sdsqtfxySelfcheck(struct soap *soap, ns1__sdsqtfxySelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sdsqtfxySelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sdsqtfxySelfcheck * SOAP_FMAC2 soap_instantiate_ns1__sdsqtfxySelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sdsqtfxySelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sdsqtfxySelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sdsqtfxySelfcheck);
		if (size)
			*size = sizeof(ns1__sdsqtfxySelfcheck);
		((ns1__sdsqtfxySelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sdsqtfxySelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__sdsqtfxySelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sdsqtfxySelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sdsqtfxySelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sdsqtfxySelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sdsqtfxySelfcheck %p -> %p\n", q, p));
	*(ns1__sdsqtfxySelfcheck*)p = *(ns1__sdsqtfxySelfcheck*)q;
}

void ns1__qyfxSelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__qyfxSelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__qyfxSelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__qyfxSelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__qyfxSelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__qyfxSelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__qyfxSelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__qyfxSelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__qyfxSelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__qyfxSelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__qyfxSelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__qyfxSelfcheckResponse * SOAP_FMAC4 soap_in_ns1__qyfxSelfcheckResponse(struct soap *soap, const char *tag, ns1__qyfxSelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__qyfxSelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__qyfxSelfcheckResponse, sizeof(ns1__qyfxSelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__qyfxSelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__qyfxSelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__qyfxSelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__qyfxSelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__qyfxSelfcheckResponse, 0, sizeof(ns1__qyfxSelfcheckResponse), 0, soap_copy_ns1__qyfxSelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__qyfxSelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__qyfxSelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:qyfxSelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__qyfxSelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__qyfxSelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__qyfxSelfcheckResponse * SOAP_FMAC4 soap_get_ns1__qyfxSelfcheckResponse(struct soap *soap, ns1__qyfxSelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__qyfxSelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__qyfxSelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__qyfxSelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__qyfxSelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__qyfxSelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__qyfxSelfcheckResponse);
		if (size)
			*size = sizeof(ns1__qyfxSelfcheckResponse);
		((ns1__qyfxSelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__qyfxSelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__qyfxSelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__qyfxSelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__qyfxSelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__qyfxSelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__qyfxSelfcheckResponse %p -> %p\n", q, p));
	*(ns1__qyfxSelfcheckResponse*)p = *(ns1__qyfxSelfcheckResponse*)q;
}

void ns1__qyfxSelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__qyfxSelfcheck::registCode = NULL;
	this->ns1__qyfxSelfcheck::carryTimeStart = NULL;
	this->ns1__qyfxSelfcheck::carryTimeEnd = NULL;
	soap_default_double(soap, &this->ns1__qyfxSelfcheck::carryTimenumber);
	this->ns1__qyfxSelfcheck::respondTimeStartHC_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndHC_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartCO_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndCO_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartCO2_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndCO2_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartNO_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndNO_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartNO2_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndNO2_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartO2_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndO2_USCORE1 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartHC_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndHC_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartCO_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndCO_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartCO2_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndCO2_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartNO_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndNO_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartNO2_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndNO2_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeStartO2_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::respondTimeEndO2_USCORE2 = NULL;
	this->ns1__qyfxSelfcheck::checkTimeStart = NULL;
	this->ns1__qyfxSelfcheck::checkTimeEnd = NULL;
	this->ns1__qyfxSelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__qyfxSelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::carryTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::carryTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartHC_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndHC_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartCO_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndCO_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartCO2_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndCO2_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartNO_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndNO_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartNO2_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndNO2_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartO2_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndO2_USCORE1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartHC_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndHC_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartCO_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndCO_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartCO2_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndCO2_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartNO_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndNO_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartNO2_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndNO2_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeStartO2_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::respondTimeEndO2_USCORE2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qyfxSelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__qyfxSelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__qyfxSelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__qyfxSelfcheck(struct soap *soap, const char *tag, int id, const ns1__qyfxSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__qyfxSelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__qyfxSelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "carryTimeStart", -1, &(a->ns1__qyfxSelfcheck::carryTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "carryTimeEnd", -1, &(a->ns1__qyfxSelfcheck::carryTimeEnd), ""))
		return soap->error;
	if (soap_out_double(soap, "carryTimenumber", -1, &(a->ns1__qyfxSelfcheck::carryTimenumber), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartHC_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartHC_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndHC_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndHC_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartCO_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartCO_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndCO_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndCO_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartCO2_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartCO2_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndCO2_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndCO2_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartNO_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartNO_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndNO_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndNO_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartNO2_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartNO2_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndNO2_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndNO2_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartO2_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartO2_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndO2_1", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndO2_USCORE1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartHC_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartHC_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndHC_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndHC_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartCO_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartCO_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndCO_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndCO_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartCO2_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartCO2_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndCO2_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndCO2_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartNO_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartNO_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndNO_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndNO_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartNO2_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartNO2_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndNO2_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndNO2_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeStartO2_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeStartO2_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "respondTimeEndO2_2", -1, &(a->ns1__qyfxSelfcheck::respondTimeEndO2_USCORE2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__qyfxSelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__qyfxSelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__qyfxSelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__qyfxSelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__qyfxSelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__qyfxSelfcheck * SOAP_FMAC4 soap_in_ns1__qyfxSelfcheck(struct soap *soap, const char *tag, ns1__qyfxSelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__qyfxSelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__qyfxSelfcheck, sizeof(ns1__qyfxSelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__qyfxSelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__qyfxSelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_carryTimeStart1 = 1;
	size_t soap_flag_carryTimeEnd1 = 1;
	size_t soap_flag_carryTimenumber1 = 1;
	size_t soap_flag_respondTimeStartHC_USCORE11 = 1;
	size_t soap_flag_respondTimeEndHC_USCORE11 = 1;
	size_t soap_flag_respondTimeStartCO_USCORE11 = 1;
	size_t soap_flag_respondTimeEndCO_USCORE11 = 1;
	size_t soap_flag_respondTimeStartCO2_USCORE11 = 1;
	size_t soap_flag_respondTimeEndCO2_USCORE11 = 1;
	size_t soap_flag_respondTimeStartNO_USCORE11 = 1;
	size_t soap_flag_respondTimeEndNO_USCORE11 = 1;
	size_t soap_flag_respondTimeStartNO2_USCORE11 = 1;
	size_t soap_flag_respondTimeEndNO2_USCORE11 = 1;
	size_t soap_flag_respondTimeStartO2_USCORE11 = 1;
	size_t soap_flag_respondTimeEndO2_USCORE11 = 1;
	size_t soap_flag_respondTimeStartHC_USCORE21 = 1;
	size_t soap_flag_respondTimeEndHC_USCORE21 = 1;
	size_t soap_flag_respondTimeStartCO_USCORE21 = 1;
	size_t soap_flag_respondTimeEndCO_USCORE21 = 1;
	size_t soap_flag_respondTimeStartCO2_USCORE21 = 1;
	size_t soap_flag_respondTimeEndCO2_USCORE21 = 1;
	size_t soap_flag_respondTimeStartNO_USCORE21 = 1;
	size_t soap_flag_respondTimeEndNO_USCORE21 = 1;
	size_t soap_flag_respondTimeStartNO2_USCORE21 = 1;
	size_t soap_flag_respondTimeEndNO2_USCORE21 = 1;
	size_t soap_flag_respondTimeStartO2_USCORE21 = 1;
	size_t soap_flag_respondTimeEndO2_USCORE21 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__qyfxSelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_carryTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "carryTimeStart", &(a->ns1__qyfxSelfcheck::carryTimeStart), "xsd:string"))
				{	soap_flag_carryTimeStart1--;
					continue;
				}
			if (soap_flag_carryTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "carryTimeEnd", &(a->ns1__qyfxSelfcheck::carryTimeEnd), "xsd:string"))
				{	soap_flag_carryTimeEnd1--;
					continue;
				}
			if (soap_flag_carryTimenumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "carryTimenumber", &(a->ns1__qyfxSelfcheck::carryTimenumber), "xsd:double"))
				{	soap_flag_carryTimenumber1--;
					continue;
				}
			if (soap_flag_respondTimeStartHC_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartHC_1", &(a->ns1__qyfxSelfcheck::respondTimeStartHC_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeStartHC_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeEndHC_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndHC_1", &(a->ns1__qyfxSelfcheck::respondTimeEndHC_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeEndHC_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeStartCO_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartCO_1", &(a->ns1__qyfxSelfcheck::respondTimeStartCO_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeStartCO_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeEndCO_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndCO_1", &(a->ns1__qyfxSelfcheck::respondTimeEndCO_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeEndCO_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeStartCO2_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartCO2_1", &(a->ns1__qyfxSelfcheck::respondTimeStartCO2_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeStartCO2_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeEndCO2_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndCO2_1", &(a->ns1__qyfxSelfcheck::respondTimeEndCO2_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeEndCO2_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeStartNO_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartNO_1", &(a->ns1__qyfxSelfcheck::respondTimeStartNO_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeStartNO_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeEndNO_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndNO_1", &(a->ns1__qyfxSelfcheck::respondTimeEndNO_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeEndNO_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeStartNO2_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartNO2_1", &(a->ns1__qyfxSelfcheck::respondTimeStartNO2_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeStartNO2_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeEndNO2_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndNO2_1", &(a->ns1__qyfxSelfcheck::respondTimeEndNO2_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeEndNO2_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeStartO2_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartO2_1", &(a->ns1__qyfxSelfcheck::respondTimeStartO2_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeStartO2_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeEndO2_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndO2_1", &(a->ns1__qyfxSelfcheck::respondTimeEndO2_USCORE1), "xsd:string"))
				{	soap_flag_respondTimeEndO2_USCORE11--;
					continue;
				}
			if (soap_flag_respondTimeStartHC_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartHC_2", &(a->ns1__qyfxSelfcheck::respondTimeStartHC_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeStartHC_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeEndHC_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndHC_2", &(a->ns1__qyfxSelfcheck::respondTimeEndHC_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeEndHC_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeStartCO_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartCO_2", &(a->ns1__qyfxSelfcheck::respondTimeStartCO_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeStartCO_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeEndCO_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndCO_2", &(a->ns1__qyfxSelfcheck::respondTimeEndCO_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeEndCO_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeStartCO2_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartCO2_2", &(a->ns1__qyfxSelfcheck::respondTimeStartCO2_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeStartCO2_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeEndCO2_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndCO2_2", &(a->ns1__qyfxSelfcheck::respondTimeEndCO2_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeEndCO2_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeStartNO_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartNO_2", &(a->ns1__qyfxSelfcheck::respondTimeStartNO_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeStartNO_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeEndNO_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndNO_2", &(a->ns1__qyfxSelfcheck::respondTimeEndNO_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeEndNO_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeStartNO2_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartNO2_2", &(a->ns1__qyfxSelfcheck::respondTimeStartNO2_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeStartNO2_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeEndNO2_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndNO2_2", &(a->ns1__qyfxSelfcheck::respondTimeEndNO2_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeEndNO2_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeStartO2_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeStartO2_2", &(a->ns1__qyfxSelfcheck::respondTimeStartO2_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeStartO2_USCORE21--;
					continue;
				}
			if (soap_flag_respondTimeEndO2_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "respondTimeEndO2_2", &(a->ns1__qyfxSelfcheck::respondTimeEndO2_USCORE2), "xsd:string"))
				{	soap_flag_respondTimeEndO2_USCORE21--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__qyfxSelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__qyfxSelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__qyfxSelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__qyfxSelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__qyfxSelfcheck, 0, sizeof(ns1__qyfxSelfcheck), 0, soap_copy_ns1__qyfxSelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_carryTimenumber1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__qyfxSelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__qyfxSelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:qyfxSelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__qyfxSelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__qyfxSelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__qyfxSelfcheck * SOAP_FMAC4 soap_get_ns1__qyfxSelfcheck(struct soap *soap, ns1__qyfxSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__qyfxSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__qyfxSelfcheck * SOAP_FMAC2 soap_instantiate_ns1__qyfxSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__qyfxSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__qyfxSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__qyfxSelfcheck);
		if (size)
			*size = sizeof(ns1__qyfxSelfcheck);
		((ns1__qyfxSelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__qyfxSelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__qyfxSelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__qyfxSelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__qyfxSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__qyfxSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__qyfxSelfcheck %p -> %p\n", q, p));
	*(ns1__qyfxSelfcheck*)p = *(ns1__qyfxSelfcheck*)q;
}

void ns1__lightproofSmokeData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lightproofSmokeData::businessId = NULL;
	this->ns1__lightproofSmokeData::registCode = NULL;
	soap_default_double(soap, &this->ns1__lightproofSmokeData::smokeValue1);
	soap_default_double(soap, &this->ns1__lightproofSmokeData::smokeValue2);
	soap_default_double(soap, &this->ns1__lightproofSmokeData::smokeValue3);
	soap_default_double(soap, &this->ns1__lightproofSmokeData::tempreture);
	soap_default_double(soap, &this->ns1__lightproofSmokeData::humidity);
	soap_default_double(soap, &this->ns1__lightproofSmokeData::airPressure);
	this->ns1__lightproofSmokeData::timeStart = NULL;
	this->ns1__lightproofSmokeData::timeEnd = NULL;
	soap_default_int(soap, &this->ns1__lightproofSmokeData::zs1);
	soap_default_int(soap, &this->ns1__lightproofSmokeData::zs2);
	soap_default_int(soap, &this->ns1__lightproofSmokeData::zs3);
	/* transient soap skipped */
}

void ns1__lightproofSmokeData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeData::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeData::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeData::timeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeData::timeEnd);
	/* transient soap skipped */
#endif
}

int ns1__lightproofSmokeData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lightproofSmokeData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lightproofSmokeData(struct soap *soap, const char *tag, int id, const ns1__lightproofSmokeData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lightproofSmokeData), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__lightproofSmokeData::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__lightproofSmokeData::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeValue1", -1, &(a->ns1__lightproofSmokeData::smokeValue1), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeValue2", -1, &(a->ns1__lightproofSmokeData::smokeValue2), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeValue3", -1, &(a->ns1__lightproofSmokeData::smokeValue3), ""))
		return soap->error;
	if (soap_out_double(soap, "tempreture", -1, &(a->ns1__lightproofSmokeData::tempreture), ""))
		return soap->error;
	if (soap_out_double(soap, "humidity", -1, &(a->ns1__lightproofSmokeData::humidity), ""))
		return soap->error;
	if (soap_out_double(soap, "airPressure", -1, &(a->ns1__lightproofSmokeData::airPressure), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeStart", -1, &(a->ns1__lightproofSmokeData::timeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeEnd", -1, &(a->ns1__lightproofSmokeData::timeEnd), ""))
		return soap->error;
	if (soap_out_int(soap, "zs1", -1, &(a->ns1__lightproofSmokeData::zs1), ""))
		return soap->error;
	if (soap_out_int(soap, "zs2", -1, &(a->ns1__lightproofSmokeData::zs2), ""))
		return soap->error;
	if (soap_out_int(soap, "zs3", -1, &(a->ns1__lightproofSmokeData::zs3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lightproofSmokeData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lightproofSmokeData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lightproofSmokeData * SOAP_FMAC4 soap_in_ns1__lightproofSmokeData(struct soap *soap, const char *tag, ns1__lightproofSmokeData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lightproofSmokeData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lightproofSmokeData, sizeof(ns1__lightproofSmokeData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lightproofSmokeData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lightproofSmokeData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_smokeValue11 = 1;
	size_t soap_flag_smokeValue21 = 1;
	size_t soap_flag_smokeValue31 = 1;
	size_t soap_flag_tempreture1 = 1;
	size_t soap_flag_humidity1 = 1;
	size_t soap_flag_airPressure1 = 1;
	size_t soap_flag_timeStart1 = 1;
	size_t soap_flag_timeEnd1 = 1;
	size_t soap_flag_zs11 = 1;
	size_t soap_flag_zs21 = 1;
	size_t soap_flag_zs31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__lightproofSmokeData::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__lightproofSmokeData::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_smokeValue11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeValue1", &(a->ns1__lightproofSmokeData::smokeValue1), "xsd:double"))
				{	soap_flag_smokeValue11--;
					continue;
				}
			if (soap_flag_smokeValue21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeValue2", &(a->ns1__lightproofSmokeData::smokeValue2), "xsd:double"))
				{	soap_flag_smokeValue21--;
					continue;
				}
			if (soap_flag_smokeValue31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeValue3", &(a->ns1__lightproofSmokeData::smokeValue3), "xsd:double"))
				{	soap_flag_smokeValue31--;
					continue;
				}
			if (soap_flag_tempreture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "tempreture", &(a->ns1__lightproofSmokeData::tempreture), "xsd:double"))
				{	soap_flag_tempreture1--;
					continue;
				}
			if (soap_flag_humidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "humidity", &(a->ns1__lightproofSmokeData::humidity), "xsd:double"))
				{	soap_flag_humidity1--;
					continue;
				}
			if (soap_flag_airPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "airPressure", &(a->ns1__lightproofSmokeData::airPressure), "xsd:double"))
				{	soap_flag_airPressure1--;
					continue;
				}
			if (soap_flag_timeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeStart", &(a->ns1__lightproofSmokeData::timeStart), "xsd:string"))
				{	soap_flag_timeStart1--;
					continue;
				}
			if (soap_flag_timeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeEnd", &(a->ns1__lightproofSmokeData::timeEnd), "xsd:string"))
				{	soap_flag_timeEnd1--;
					continue;
				}
			if (soap_flag_zs11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zs1", &(a->ns1__lightproofSmokeData::zs1), "xsd:int"))
				{	soap_flag_zs11--;
					continue;
				}
			if (soap_flag_zs21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zs2", &(a->ns1__lightproofSmokeData::zs2), "xsd:int"))
				{	soap_flag_zs21--;
					continue;
				}
			if (soap_flag_zs31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zs3", &(a->ns1__lightproofSmokeData::zs3), "xsd:int"))
				{	soap_flag_zs31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lightproofSmokeData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lightproofSmokeData, 0, sizeof(ns1__lightproofSmokeData), 0, soap_copy_ns1__lightproofSmokeData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_smokeValue11 > 0 || soap_flag_smokeValue21 > 0 || soap_flag_smokeValue31 > 0 || soap_flag_tempreture1 > 0 || soap_flag_humidity1 > 0 || soap_flag_airPressure1 > 0 || soap_flag_zs11 > 0 || soap_flag_zs21 > 0 || soap_flag_zs31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lightproofSmokeData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lightproofSmokeData);
	if (this->soap_out(soap, tag?tag:"ns1:lightproofSmokeData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lightproofSmokeData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lightproofSmokeData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lightproofSmokeData * SOAP_FMAC4 soap_get_ns1__lightproofSmokeData(struct soap *soap, ns1__lightproofSmokeData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lightproofSmokeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lightproofSmokeData * SOAP_FMAC2 soap_instantiate_ns1__lightproofSmokeData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lightproofSmokeData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lightproofSmokeData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lightproofSmokeData);
		if (size)
			*size = sizeof(ns1__lightproofSmokeData);
		((ns1__lightproofSmokeData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lightproofSmokeData, n);
		if (size)
			*size = n * sizeof(ns1__lightproofSmokeData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lightproofSmokeData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lightproofSmokeData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lightproofSmokeData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lightproofSmokeData %p -> %p\n", q, p));
	*(ns1__lightproofSmokeData*)p = *(ns1__lightproofSmokeData*)q;
}

void ns1__lightproofSmokeDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__lightproofSmokeDataResponse::return_);
	/* transient soap skipped */
}

void ns1__lightproofSmokeDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__lightproofSmokeDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lightproofSmokeDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lightproofSmokeDataResponse(struct soap *soap, const char *tag, int id, const ns1__lightproofSmokeDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lightproofSmokeDataResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__lightproofSmokeDataResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lightproofSmokeDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lightproofSmokeDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lightproofSmokeDataResponse * SOAP_FMAC4 soap_in_ns1__lightproofSmokeDataResponse(struct soap *soap, const char *tag, ns1__lightproofSmokeDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lightproofSmokeDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lightproofSmokeDataResponse, sizeof(ns1__lightproofSmokeDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lightproofSmokeDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lightproofSmokeDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__lightproofSmokeDataResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lightproofSmokeDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lightproofSmokeDataResponse, 0, sizeof(ns1__lightproofSmokeDataResponse), 0, soap_copy_ns1__lightproofSmokeDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lightproofSmokeDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lightproofSmokeDataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:lightproofSmokeDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lightproofSmokeDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lightproofSmokeDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lightproofSmokeDataResponse * SOAP_FMAC4 soap_get_ns1__lightproofSmokeDataResponse(struct soap *soap, ns1__lightproofSmokeDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lightproofSmokeDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lightproofSmokeDataResponse * SOAP_FMAC2 soap_instantiate_ns1__lightproofSmokeDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lightproofSmokeDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lightproofSmokeDataResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lightproofSmokeDataResponse);
		if (size)
			*size = sizeof(ns1__lightproofSmokeDataResponse);
		((ns1__lightproofSmokeDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lightproofSmokeDataResponse, n);
		if (size)
			*size = n * sizeof(ns1__lightproofSmokeDataResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lightproofSmokeDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lightproofSmokeDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lightproofSmokeDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lightproofSmokeDataResponse %p -> %p\n", q, p));
	*(ns1__lightproofSmokeDataResponse*)p = *(ns1__lightproofSmokeDataResponse*)q;
}

void ns1__lightproofSmokeData_USCOREFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lightproofSmokeData_USCOREFC::businessId = NULL;
	this->ns1__lightproofSmokeData_USCOREFC::registCode = NULL;
	soap_default_double(soap, &this->ns1__lightproofSmokeData_USCOREFC::smokeValue1);
	soap_default_double(soap, &this->ns1__lightproofSmokeData_USCOREFC::smokeValue2);
	soap_default_double(soap, &this->ns1__lightproofSmokeData_USCOREFC::smokeValue3);
	soap_default_double(soap, &this->ns1__lightproofSmokeData_USCOREFC::tempreture);
	soap_default_double(soap, &this->ns1__lightproofSmokeData_USCOREFC::humidity);
	soap_default_double(soap, &this->ns1__lightproofSmokeData_USCOREFC::airPressure);
	this->ns1__lightproofSmokeData_USCOREFC::timeStart = NULL;
	this->ns1__lightproofSmokeData_USCOREFC::timeEnd = NULL;
	soap_default_int(soap, &this->ns1__lightproofSmokeData_USCOREFC::zs1);
	soap_default_int(soap, &this->ns1__lightproofSmokeData_USCOREFC::zs2);
	soap_default_int(soap, &this->ns1__lightproofSmokeData_USCOREFC::zs3);
	/* transient soap skipped */
}

void ns1__lightproofSmokeData_USCOREFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeData_USCOREFC::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeData_USCOREFC::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeData_USCOREFC::timeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeData_USCOREFC::timeEnd);
	/* transient soap skipped */
#endif
}

int ns1__lightproofSmokeData_USCOREFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lightproofSmokeData_USCOREFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lightproofSmokeData_USCOREFC(struct soap *soap, const char *tag, int id, const ns1__lightproofSmokeData_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__lightproofSmokeData_USCOREFC::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__lightproofSmokeData_USCOREFC::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeValue1", -1, &(a->ns1__lightproofSmokeData_USCOREFC::smokeValue1), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeValue2", -1, &(a->ns1__lightproofSmokeData_USCOREFC::smokeValue2), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeValue3", -1, &(a->ns1__lightproofSmokeData_USCOREFC::smokeValue3), ""))
		return soap->error;
	if (soap_out_double(soap, "tempreture", -1, &(a->ns1__lightproofSmokeData_USCOREFC::tempreture), ""))
		return soap->error;
	if (soap_out_double(soap, "humidity", -1, &(a->ns1__lightproofSmokeData_USCOREFC::humidity), ""))
		return soap->error;
	if (soap_out_double(soap, "airPressure", -1, &(a->ns1__lightproofSmokeData_USCOREFC::airPressure), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeStart", -1, &(a->ns1__lightproofSmokeData_USCOREFC::timeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeEnd", -1, &(a->ns1__lightproofSmokeData_USCOREFC::timeEnd), ""))
		return soap->error;
	if (soap_out_int(soap, "zs1", -1, &(a->ns1__lightproofSmokeData_USCOREFC::zs1), ""))
		return soap->error;
	if (soap_out_int(soap, "zs2", -1, &(a->ns1__lightproofSmokeData_USCOREFC::zs2), ""))
		return soap->error;
	if (soap_out_int(soap, "zs3", -1, &(a->ns1__lightproofSmokeData_USCOREFC::zs3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lightproofSmokeData_USCOREFC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lightproofSmokeData_USCOREFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lightproofSmokeData_USCOREFC * SOAP_FMAC4 soap_in_ns1__lightproofSmokeData_USCOREFC(struct soap *soap, const char *tag, ns1__lightproofSmokeData_USCOREFC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lightproofSmokeData_USCOREFC *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC, sizeof(ns1__lightproofSmokeData_USCOREFC), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lightproofSmokeData_USCOREFC *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_smokeValue11 = 1;
	size_t soap_flag_smokeValue21 = 1;
	size_t soap_flag_smokeValue31 = 1;
	size_t soap_flag_tempreture1 = 1;
	size_t soap_flag_humidity1 = 1;
	size_t soap_flag_airPressure1 = 1;
	size_t soap_flag_timeStart1 = 1;
	size_t soap_flag_timeEnd1 = 1;
	size_t soap_flag_zs11 = 1;
	size_t soap_flag_zs21 = 1;
	size_t soap_flag_zs31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__lightproofSmokeData_USCOREFC::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__lightproofSmokeData_USCOREFC::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_smokeValue11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeValue1", &(a->ns1__lightproofSmokeData_USCOREFC::smokeValue1), "xsd:double"))
				{	soap_flag_smokeValue11--;
					continue;
				}
			if (soap_flag_smokeValue21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeValue2", &(a->ns1__lightproofSmokeData_USCOREFC::smokeValue2), "xsd:double"))
				{	soap_flag_smokeValue21--;
					continue;
				}
			if (soap_flag_smokeValue31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeValue3", &(a->ns1__lightproofSmokeData_USCOREFC::smokeValue3), "xsd:double"))
				{	soap_flag_smokeValue31--;
					continue;
				}
			if (soap_flag_tempreture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "tempreture", &(a->ns1__lightproofSmokeData_USCOREFC::tempreture), "xsd:double"))
				{	soap_flag_tempreture1--;
					continue;
				}
			if (soap_flag_humidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "humidity", &(a->ns1__lightproofSmokeData_USCOREFC::humidity), "xsd:double"))
				{	soap_flag_humidity1--;
					continue;
				}
			if (soap_flag_airPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "airPressure", &(a->ns1__lightproofSmokeData_USCOREFC::airPressure), "xsd:double"))
				{	soap_flag_airPressure1--;
					continue;
				}
			if (soap_flag_timeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeStart", &(a->ns1__lightproofSmokeData_USCOREFC::timeStart), "xsd:string"))
				{	soap_flag_timeStart1--;
					continue;
				}
			if (soap_flag_timeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeEnd", &(a->ns1__lightproofSmokeData_USCOREFC::timeEnd), "xsd:string"))
				{	soap_flag_timeEnd1--;
					continue;
				}
			if (soap_flag_zs11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zs1", &(a->ns1__lightproofSmokeData_USCOREFC::zs1), "xsd:int"))
				{	soap_flag_zs11--;
					continue;
				}
			if (soap_flag_zs21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zs2", &(a->ns1__lightproofSmokeData_USCOREFC::zs2), "xsd:int"))
				{	soap_flag_zs21--;
					continue;
				}
			if (soap_flag_zs31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zs3", &(a->ns1__lightproofSmokeData_USCOREFC::zs3), "xsd:int"))
				{	soap_flag_zs31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lightproofSmokeData_USCOREFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC, 0, sizeof(ns1__lightproofSmokeData_USCOREFC), 0, soap_copy_ns1__lightproofSmokeData_USCOREFC);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_smokeValue11 > 0 || soap_flag_smokeValue21 > 0 || soap_flag_smokeValue31 > 0 || soap_flag_tempreture1 > 0 || soap_flag_humidity1 > 0 || soap_flag_airPressure1 > 0 || soap_flag_zs11 > 0 || soap_flag_zs21 > 0 || soap_flag_zs31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lightproofSmokeData_USCOREFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC);
	if (this->soap_out(soap, tag?tag:"ns1:lightproofSmokeData_FC", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lightproofSmokeData_USCOREFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lightproofSmokeData_USCOREFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lightproofSmokeData_USCOREFC * SOAP_FMAC4 soap_get_ns1__lightproofSmokeData_USCOREFC(struct soap *soap, ns1__lightproofSmokeData_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lightproofSmokeData_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lightproofSmokeData_USCOREFC * SOAP_FMAC2 soap_instantiate_ns1__lightproofSmokeData_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lightproofSmokeData_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lightproofSmokeData_USCOREFC);
		if (size)
			*size = sizeof(ns1__lightproofSmokeData_USCOREFC);
		((ns1__lightproofSmokeData_USCOREFC*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lightproofSmokeData_USCOREFC, n);
		if (size)
			*size = n * sizeof(ns1__lightproofSmokeData_USCOREFC);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lightproofSmokeData_USCOREFC*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lightproofSmokeData_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lightproofSmokeData_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lightproofSmokeData_USCOREFC %p -> %p\n", q, p));
	*(ns1__lightproofSmokeData_USCOREFC*)p = *(ns1__lightproofSmokeData_USCOREFC*)q;
}

void ns1__wqfxyAdjustResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__wqfxyAdjustResponse::return_);
	/* transient soap skipped */
}

void ns1__wqfxyAdjustResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__wqfxyAdjustResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wqfxyAdjustResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wqfxyAdjustResponse(struct soap *soap, const char *tag, int id, const ns1__wqfxyAdjustResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wqfxyAdjustResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__wqfxyAdjustResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wqfxyAdjustResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wqfxyAdjustResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wqfxyAdjustResponse * SOAP_FMAC4 soap_in_ns1__wqfxyAdjustResponse(struct soap *soap, const char *tag, ns1__wqfxyAdjustResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wqfxyAdjustResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wqfxyAdjustResponse, sizeof(ns1__wqfxyAdjustResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wqfxyAdjustResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wqfxyAdjustResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__wqfxyAdjustResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wqfxyAdjustResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wqfxyAdjustResponse, 0, sizeof(ns1__wqfxyAdjustResponse), 0, soap_copy_ns1__wqfxyAdjustResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__wqfxyAdjustResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wqfxyAdjustResponse);
	if (this->soap_out(soap, tag?tag:"ns1:wqfxyAdjustResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wqfxyAdjustResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wqfxyAdjustResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wqfxyAdjustResponse * SOAP_FMAC4 soap_get_ns1__wqfxyAdjustResponse(struct soap *soap, ns1__wqfxyAdjustResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wqfxyAdjustResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wqfxyAdjustResponse * SOAP_FMAC2 soap_instantiate_ns1__wqfxyAdjustResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wqfxyAdjustResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wqfxyAdjustResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wqfxyAdjustResponse);
		if (size)
			*size = sizeof(ns1__wqfxyAdjustResponse);
		((ns1__wqfxyAdjustResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wqfxyAdjustResponse, n);
		if (size)
			*size = n * sizeof(ns1__wqfxyAdjustResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wqfxyAdjustResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wqfxyAdjustResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wqfxyAdjustResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wqfxyAdjustResponse %p -> %p\n", q, p));
	*(ns1__wqfxyAdjustResponse*)p = *(ns1__wqfxyAdjustResponse*)q;
}

void ns1__wqfxyAdjust::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wqfxyAdjust::registCode = NULL;
	this->ns1__wqfxyAdjust::gasType = NULL;
	soap_default_double(soap, &this->ns1__wqfxyAdjust::labelValueCO2);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::detectValueCO2);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::labelValueCO);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::detectValueCO);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::labelValueNO);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::detectValueNO);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::labelValueNO2);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::detectValueNO2);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::labelValueHC);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::detectValueHC);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::labelValueO2);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::detectValueO2);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::labelValuePEF);
	soap_default_double(soap, &this->ns1__wqfxyAdjust::labelValueC3H8);
	this->ns1__wqfxyAdjust::adjustResult = NULL;
	this->ns1__wqfxyAdjust::adjustTimeStart = NULL;
	this->ns1__wqfxyAdjust::adjustTimeEnd = NULL;
	this->ns1__wqfxyAdjust::remark = NULL;
	/* transient soap skipped */
}

void ns1__wqfxyAdjust::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyAdjust::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyAdjust::gasType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyAdjust::adjustResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyAdjust::adjustTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyAdjust::adjustTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyAdjust::remark);
	/* transient soap skipped */
#endif
}

int ns1__wqfxyAdjust::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wqfxyAdjust(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wqfxyAdjust(struct soap *soap, const char *tag, int id, const ns1__wqfxyAdjust *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wqfxyAdjust), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__wqfxyAdjust::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gasType", -1, &(a->ns1__wqfxyAdjust::gasType), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueCO2", -1, &(a->ns1__wqfxyAdjust::labelValueCO2), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueCO2", -1, &(a->ns1__wqfxyAdjust::detectValueCO2), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueCO", -1, &(a->ns1__wqfxyAdjust::labelValueCO), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueCO", -1, &(a->ns1__wqfxyAdjust::detectValueCO), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueNO", -1, &(a->ns1__wqfxyAdjust::labelValueNO), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueNO", -1, &(a->ns1__wqfxyAdjust::detectValueNO), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueNO2", -1, &(a->ns1__wqfxyAdjust::labelValueNO2), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueNO2", -1, &(a->ns1__wqfxyAdjust::detectValueNO2), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueHC", -1, &(a->ns1__wqfxyAdjust::labelValueHC), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueHC", -1, &(a->ns1__wqfxyAdjust::detectValueHC), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueO2", -1, &(a->ns1__wqfxyAdjust::labelValueO2), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueO2", -1, &(a->ns1__wqfxyAdjust::detectValueO2), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValuePEF", -1, &(a->ns1__wqfxyAdjust::labelValuePEF), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueC3H8", -1, &(a->ns1__wqfxyAdjust::labelValueC3H8), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "adjustResult", -1, &(a->ns1__wqfxyAdjust::adjustResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "adjustTimeStart", -1, &(a->ns1__wqfxyAdjust::adjustTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "adjustTimeEnd", -1, &(a->ns1__wqfxyAdjust::adjustTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__wqfxyAdjust::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wqfxyAdjust::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wqfxyAdjust(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wqfxyAdjust * SOAP_FMAC4 soap_in_ns1__wqfxyAdjust(struct soap *soap, const char *tag, ns1__wqfxyAdjust *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wqfxyAdjust *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wqfxyAdjust, sizeof(ns1__wqfxyAdjust), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wqfxyAdjust)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wqfxyAdjust *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_gasType1 = 1;
	size_t soap_flag_labelValueCO21 = 1;
	size_t soap_flag_detectValueCO21 = 1;
	size_t soap_flag_labelValueCO1 = 1;
	size_t soap_flag_detectValueCO1 = 1;
	size_t soap_flag_labelValueNO1 = 1;
	size_t soap_flag_detectValueNO1 = 1;
	size_t soap_flag_labelValueNO21 = 1;
	size_t soap_flag_detectValueNO21 = 1;
	size_t soap_flag_labelValueHC1 = 1;
	size_t soap_flag_detectValueHC1 = 1;
	size_t soap_flag_labelValueO21 = 1;
	size_t soap_flag_detectValueO21 = 1;
	size_t soap_flag_labelValuePEF1 = 1;
	size_t soap_flag_labelValueC3H81 = 1;
	size_t soap_flag_adjustResult1 = 1;
	size_t soap_flag_adjustTimeStart1 = 1;
	size_t soap_flag_adjustTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__wqfxyAdjust::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_gasType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gasType", &(a->ns1__wqfxyAdjust::gasType), "xsd:string"))
				{	soap_flag_gasType1--;
					continue;
				}
			if (soap_flag_labelValueCO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueCO2", &(a->ns1__wqfxyAdjust::labelValueCO2), "xsd:double"))
				{	soap_flag_labelValueCO21--;
					continue;
				}
			if (soap_flag_detectValueCO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueCO2", &(a->ns1__wqfxyAdjust::detectValueCO2), "xsd:double"))
				{	soap_flag_detectValueCO21--;
					continue;
				}
			if (soap_flag_labelValueCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueCO", &(a->ns1__wqfxyAdjust::labelValueCO), "xsd:double"))
				{	soap_flag_labelValueCO1--;
					continue;
				}
			if (soap_flag_detectValueCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueCO", &(a->ns1__wqfxyAdjust::detectValueCO), "xsd:double"))
				{	soap_flag_detectValueCO1--;
					continue;
				}
			if (soap_flag_labelValueNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueNO", &(a->ns1__wqfxyAdjust::labelValueNO), "xsd:double"))
				{	soap_flag_labelValueNO1--;
					continue;
				}
			if (soap_flag_detectValueNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueNO", &(a->ns1__wqfxyAdjust::detectValueNO), "xsd:double"))
				{	soap_flag_detectValueNO1--;
					continue;
				}
			if (soap_flag_labelValueNO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueNO2", &(a->ns1__wqfxyAdjust::labelValueNO2), "xsd:double"))
				{	soap_flag_labelValueNO21--;
					continue;
				}
			if (soap_flag_detectValueNO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueNO2", &(a->ns1__wqfxyAdjust::detectValueNO2), "xsd:double"))
				{	soap_flag_detectValueNO21--;
					continue;
				}
			if (soap_flag_labelValueHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueHC", &(a->ns1__wqfxyAdjust::labelValueHC), "xsd:double"))
				{	soap_flag_labelValueHC1--;
					continue;
				}
			if (soap_flag_detectValueHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueHC", &(a->ns1__wqfxyAdjust::detectValueHC), "xsd:double"))
				{	soap_flag_detectValueHC1--;
					continue;
				}
			if (soap_flag_labelValueO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueO2", &(a->ns1__wqfxyAdjust::labelValueO2), "xsd:double"))
				{	soap_flag_labelValueO21--;
					continue;
				}
			if (soap_flag_detectValueO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueO2", &(a->ns1__wqfxyAdjust::detectValueO2), "xsd:double"))
				{	soap_flag_detectValueO21--;
					continue;
				}
			if (soap_flag_labelValuePEF1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValuePEF", &(a->ns1__wqfxyAdjust::labelValuePEF), "xsd:double"))
				{	soap_flag_labelValuePEF1--;
					continue;
				}
			if (soap_flag_labelValueC3H81 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueC3H8", &(a->ns1__wqfxyAdjust::labelValueC3H8), "xsd:double"))
				{	soap_flag_labelValueC3H81--;
					continue;
				}
			if (soap_flag_adjustResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "adjustResult", &(a->ns1__wqfxyAdjust::adjustResult), "xsd:string"))
				{	soap_flag_adjustResult1--;
					continue;
				}
			if (soap_flag_adjustTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "adjustTimeStart", &(a->ns1__wqfxyAdjust::adjustTimeStart), "xsd:string"))
				{	soap_flag_adjustTimeStart1--;
					continue;
				}
			if (soap_flag_adjustTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "adjustTimeEnd", &(a->ns1__wqfxyAdjust::adjustTimeEnd), "xsd:string"))
				{	soap_flag_adjustTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__wqfxyAdjust::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wqfxyAdjust *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wqfxyAdjust, 0, sizeof(ns1__wqfxyAdjust), 0, soap_copy_ns1__wqfxyAdjust);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_labelValueCO21 > 0 || soap_flag_detectValueCO21 > 0 || soap_flag_labelValueCO1 > 0 || soap_flag_detectValueCO1 > 0 || soap_flag_labelValueNO1 > 0 || soap_flag_detectValueNO1 > 0 || soap_flag_labelValueNO21 > 0 || soap_flag_detectValueNO21 > 0 || soap_flag_labelValueHC1 > 0 || soap_flag_detectValueHC1 > 0 || soap_flag_labelValueO21 > 0 || soap_flag_detectValueO21 > 0 || soap_flag_labelValuePEF1 > 0 || soap_flag_labelValueC3H81 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__wqfxyAdjust::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wqfxyAdjust);
	if (this->soap_out(soap, tag?tag:"ns1:wqfxyAdjust", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wqfxyAdjust::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wqfxyAdjust(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wqfxyAdjust * SOAP_FMAC4 soap_get_ns1__wqfxyAdjust(struct soap *soap, ns1__wqfxyAdjust *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wqfxyAdjust(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wqfxyAdjust * SOAP_FMAC2 soap_instantiate_ns1__wqfxyAdjust(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wqfxyAdjust(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wqfxyAdjust, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wqfxyAdjust);
		if (size)
			*size = sizeof(ns1__wqfxyAdjust);
		((ns1__wqfxyAdjust*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wqfxyAdjust, n);
		if (size)
			*size = n * sizeof(ns1__wqfxyAdjust);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wqfxyAdjust*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wqfxyAdjust*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wqfxyAdjust(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wqfxyAdjust %p -> %p\n", q, p));
	*(ns1__wqfxyAdjust*)p = *(ns1__wqfxyAdjust*)q;
}

void ns1__cgjPLHPSelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__cgjPLHPSelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__cgjPLHPSelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__cgjPLHPSelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjPLHPSelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjPLHPSelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__cgjPLHPSelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__cgjPLHPSelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjPLHPSelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjPLHPSelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjPLHPSelfcheckResponse * SOAP_FMAC4 soap_in_ns1__cgjPLHPSelfcheckResponse(struct soap *soap, const char *tag, ns1__cgjPLHPSelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjPLHPSelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse, sizeof(ns1__cgjPLHPSelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjPLHPSelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__cgjPLHPSelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjPLHPSelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse, 0, sizeof(ns1__cgjPLHPSelfcheckResponse), 0, soap_copy_ns1__cgjPLHPSelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjPLHPSelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:cgjPLHPSelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjPLHPSelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjPLHPSelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjPLHPSelfcheckResponse * SOAP_FMAC4 soap_get_ns1__cgjPLHPSelfcheckResponse(struct soap *soap, ns1__cgjPLHPSelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjPLHPSelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjPLHPSelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__cgjPLHPSelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjPLHPSelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjPLHPSelfcheckResponse);
		if (size)
			*size = sizeof(ns1__cgjPLHPSelfcheckResponse);
		((ns1__cgjPLHPSelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjPLHPSelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__cgjPLHPSelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjPLHPSelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjPLHPSelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjPLHPSelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjPLHPSelfcheckResponse %p -> %p\n", q, p));
	*(ns1__cgjPLHPSelfcheckResponse*)p = *(ns1__cgjPLHPSelfcheckResponse*)q;
}

void ns1__cgjPLHPSelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__cgjPLHPSelfcheck::registCode = NULL;
	this->ns1__cgjPLHPSelfcheck::speedQJ1 = NULL;
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::nameSpeed1);
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::PLHP1);
	this->ns1__cgjPLHPSelfcheck::speedQJ2 = NULL;
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::nameSpeed2);
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::PLHP2);
	this->ns1__cgjPLHPSelfcheck::speedQJ3 = NULL;
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::nameSpeed3);
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::PLHP3);
	this->ns1__cgjPLHPSelfcheck::speedQJ4 = NULL;
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::nameSpeed4);
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::PLHP4);
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::maxSpeed);
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::ALpower1);
	soap_default_double(soap, &this->ns1__cgjPLHPSelfcheck::ALpower2);
	this->ns1__cgjPLHPSelfcheck::checkResult = NULL;
	this->ns1__cgjPLHPSelfcheck::checkTimeStart = NULL;
	this->ns1__cgjPLHPSelfcheck::checkTimeEnd = NULL;
	this->ns1__cgjPLHPSelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__cgjPLHPSelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjPLHPSelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjPLHPSelfcheck::speedQJ1);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjPLHPSelfcheck::speedQJ2);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjPLHPSelfcheck::speedQJ3);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjPLHPSelfcheck::speedQJ4);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjPLHPSelfcheck::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjPLHPSelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjPLHPSelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjPLHPSelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__cgjPLHPSelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjPLHPSelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjPLHPSelfcheck(struct soap *soap, const char *tag, int id, const ns1__cgjPLHPSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjPLHPSelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__cgjPLHPSelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "speedQJ1", -1, &(a->ns1__cgjPLHPSelfcheck::speedQJ1), ""))
		return soap->error;
	if (soap_out_double(soap, "nameSpeed1", -1, &(a->ns1__cgjPLHPSelfcheck::nameSpeed1), ""))
		return soap->error;
	if (soap_out_double(soap, "PLHP1", -1, &(a->ns1__cgjPLHPSelfcheck::PLHP1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "speedQJ2", -1, &(a->ns1__cgjPLHPSelfcheck::speedQJ2), ""))
		return soap->error;
	if (soap_out_double(soap, "nameSpeed2", -1, &(a->ns1__cgjPLHPSelfcheck::nameSpeed2), ""))
		return soap->error;
	if (soap_out_double(soap, "PLHP2", -1, &(a->ns1__cgjPLHPSelfcheck::PLHP2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "speedQJ3", -1, &(a->ns1__cgjPLHPSelfcheck::speedQJ3), ""))
		return soap->error;
	if (soap_out_double(soap, "nameSpeed3", -1, &(a->ns1__cgjPLHPSelfcheck::nameSpeed3), ""))
		return soap->error;
	if (soap_out_double(soap, "PLHP3", -1, &(a->ns1__cgjPLHPSelfcheck::PLHP3), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "speedQJ4", -1, &(a->ns1__cgjPLHPSelfcheck::speedQJ4), ""))
		return soap->error;
	if (soap_out_double(soap, "nameSpeed4", -1, &(a->ns1__cgjPLHPSelfcheck::nameSpeed4), ""))
		return soap->error;
	if (soap_out_double(soap, "PLHP4", -1, &(a->ns1__cgjPLHPSelfcheck::PLHP4), ""))
		return soap->error;
	if (soap_out_double(soap, "maxSpeed", -1, &(a->ns1__cgjPLHPSelfcheck::maxSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "ALpower1", -1, &(a->ns1__cgjPLHPSelfcheck::ALpower1), ""))
		return soap->error;
	if (soap_out_double(soap, "ALpower2", -1, &(a->ns1__cgjPLHPSelfcheck::ALpower2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__cgjPLHPSelfcheck::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__cgjPLHPSelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__cgjPLHPSelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__cgjPLHPSelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjPLHPSelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjPLHPSelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjPLHPSelfcheck * SOAP_FMAC4 soap_in_ns1__cgjPLHPSelfcheck(struct soap *soap, const char *tag, ns1__cgjPLHPSelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjPLHPSelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjPLHPSelfcheck, sizeof(ns1__cgjPLHPSelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjPLHPSelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjPLHPSelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_speedQJ11 = 1;
	size_t soap_flag_nameSpeed11 = 1;
	size_t soap_flag_PLHP11 = 1;
	size_t soap_flag_speedQJ21 = 1;
	size_t soap_flag_nameSpeed21 = 1;
	size_t soap_flag_PLHP21 = 1;
	size_t soap_flag_speedQJ31 = 1;
	size_t soap_flag_nameSpeed31 = 1;
	size_t soap_flag_PLHP31 = 1;
	size_t soap_flag_speedQJ41 = 1;
	size_t soap_flag_nameSpeed41 = 1;
	size_t soap_flag_PLHP41 = 1;
	size_t soap_flag_maxSpeed1 = 1;
	size_t soap_flag_ALpower11 = 1;
	size_t soap_flag_ALpower21 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__cgjPLHPSelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_speedQJ11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "speedQJ1", &(a->ns1__cgjPLHPSelfcheck::speedQJ1), "xsd:string"))
				{	soap_flag_speedQJ11--;
					continue;
				}
			if (soap_flag_nameSpeed11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nameSpeed1", &(a->ns1__cgjPLHPSelfcheck::nameSpeed1), "xsd:double"))
				{	soap_flag_nameSpeed11--;
					continue;
				}
			if (soap_flag_PLHP11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "PLHP1", &(a->ns1__cgjPLHPSelfcheck::PLHP1), "xsd:double"))
				{	soap_flag_PLHP11--;
					continue;
				}
			if (soap_flag_speedQJ21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "speedQJ2", &(a->ns1__cgjPLHPSelfcheck::speedQJ2), "xsd:string"))
				{	soap_flag_speedQJ21--;
					continue;
				}
			if (soap_flag_nameSpeed21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nameSpeed2", &(a->ns1__cgjPLHPSelfcheck::nameSpeed2), "xsd:double"))
				{	soap_flag_nameSpeed21--;
					continue;
				}
			if (soap_flag_PLHP21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "PLHP2", &(a->ns1__cgjPLHPSelfcheck::PLHP2), "xsd:double"))
				{	soap_flag_PLHP21--;
					continue;
				}
			if (soap_flag_speedQJ31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "speedQJ3", &(a->ns1__cgjPLHPSelfcheck::speedQJ3), "xsd:string"))
				{	soap_flag_speedQJ31--;
					continue;
				}
			if (soap_flag_nameSpeed31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nameSpeed3", &(a->ns1__cgjPLHPSelfcheck::nameSpeed3), "xsd:double"))
				{	soap_flag_nameSpeed31--;
					continue;
				}
			if (soap_flag_PLHP31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "PLHP3", &(a->ns1__cgjPLHPSelfcheck::PLHP3), "xsd:double"))
				{	soap_flag_PLHP31--;
					continue;
				}
			if (soap_flag_speedQJ41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "speedQJ4", &(a->ns1__cgjPLHPSelfcheck::speedQJ4), "xsd:string"))
				{	soap_flag_speedQJ41--;
					continue;
				}
			if (soap_flag_nameSpeed41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nameSpeed4", &(a->ns1__cgjPLHPSelfcheck::nameSpeed4), "xsd:double"))
				{	soap_flag_nameSpeed41--;
					continue;
				}
			if (soap_flag_PLHP41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "PLHP4", &(a->ns1__cgjPLHPSelfcheck::PLHP4), "xsd:double"))
				{	soap_flag_PLHP41--;
					continue;
				}
			if (soap_flag_maxSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "maxSpeed", &(a->ns1__cgjPLHPSelfcheck::maxSpeed), "xsd:double"))
				{	soap_flag_maxSpeed1--;
					continue;
				}
			if (soap_flag_ALpower11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ALpower1", &(a->ns1__cgjPLHPSelfcheck::ALpower1), "xsd:double"))
				{	soap_flag_ALpower11--;
					continue;
				}
			if (soap_flag_ALpower21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ALpower2", &(a->ns1__cgjPLHPSelfcheck::ALpower2), "xsd:double"))
				{	soap_flag_ALpower21--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__cgjPLHPSelfcheck::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__cgjPLHPSelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__cgjPLHPSelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__cgjPLHPSelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjPLHPSelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjPLHPSelfcheck, 0, sizeof(ns1__cgjPLHPSelfcheck), 0, soap_copy_ns1__cgjPLHPSelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nameSpeed11 > 0 || soap_flag_PLHP11 > 0 || soap_flag_nameSpeed21 > 0 || soap_flag_PLHP21 > 0 || soap_flag_nameSpeed31 > 0 || soap_flag_PLHP31 > 0 || soap_flag_nameSpeed41 > 0 || soap_flag_PLHP41 > 0 || soap_flag_maxSpeed1 > 0 || soap_flag_ALpower11 > 0 || soap_flag_ALpower21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjPLHPSelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjPLHPSelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:cgjPLHPSelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjPLHPSelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjPLHPSelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjPLHPSelfcheck * SOAP_FMAC4 soap_get_ns1__cgjPLHPSelfcheck(struct soap *soap, ns1__cgjPLHPSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjPLHPSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjPLHPSelfcheck * SOAP_FMAC2 soap_instantiate_ns1__cgjPLHPSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjPLHPSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjPLHPSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjPLHPSelfcheck);
		if (size)
			*size = sizeof(ns1__cgjPLHPSelfcheck);
		((ns1__cgjPLHPSelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjPLHPSelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__cgjPLHPSelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjPLHPSelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjPLHPSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjPLHPSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjPLHPSelfcheck %p -> %p\n", q, p));
	*(ns1__cgjPLHPSelfcheck*)p = *(ns1__cgjPLHPSelfcheck*)q;
}

void ns1__doubleIdleLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__doubleIdleLog::businessId = NULL;
	this->ns1__doubleIdleLog::registCode = NULL;
	soap_default_int(soap, &this->ns1__doubleIdleLog::inspectNum);
	soap_default_double(soap, &this->ns1__doubleIdleLog::flowHC);
	soap_default_double(soap, &this->ns1__doubleIdleLog::flowCO);
	soap_default_double(soap, &this->ns1__doubleIdleLog::flowCO2);
	soap_default_double(soap, &this->ns1__doubleIdleLog::analyserO2);
	soap_default_double(soap, &this->ns1__doubleIdleLog::oilTemperature);
	this->ns1__doubleIdleLog::rotateSpeed = NULL;
	soap_default_double(soap, &this->ns1__doubleIdleLog::lambdaValue);
	soap_default_double(soap, &this->ns1__doubleIdleLog::qtfxyjcswd);
	soap_default_double(soap, &this->ns1__doubleIdleLog::zhlwd);
	/* transient soap skipped */
}

void ns1__doubleIdleLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleLog::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleLog::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleLog::rotateSpeed);
	/* transient soap skipped */
#endif
}

int ns1__doubleIdleLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__doubleIdleLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__doubleIdleLog(struct soap *soap, const char *tag, int id, const ns1__doubleIdleLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__doubleIdleLog), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__doubleIdleLog::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__doubleIdleLog::registCode), ""))
		return soap->error;
	if (soap_out_int(soap, "inspectNum", -1, &(a->ns1__doubleIdleLog::inspectNum), ""))
		return soap->error;
	if (soap_out_double(soap, "flowHC", -1, &(a->ns1__doubleIdleLog::flowHC), ""))
		return soap->error;
	if (soap_out_double(soap, "flowCO", -1, &(a->ns1__doubleIdleLog::flowCO), ""))
		return soap->error;
	if (soap_out_double(soap, "flowCO2", -1, &(a->ns1__doubleIdleLog::flowCO2), ""))
		return soap->error;
	if (soap_out_double(soap, "analyserO2", -1, &(a->ns1__doubleIdleLog::analyserO2), ""))
		return soap->error;
	if (soap_out_double(soap, "oilTemperature", -1, &(a->ns1__doubleIdleLog::oilTemperature), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "rotateSpeed", -1, &(a->ns1__doubleIdleLog::rotateSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "lambdaValue", -1, &(a->ns1__doubleIdleLog::lambdaValue), ""))
		return soap->error;
	if (soap_out_double(soap, "qtfxyjcswd", -1, &(a->ns1__doubleIdleLog::qtfxyjcswd), ""))
		return soap->error;
	if (soap_out_double(soap, "zhlwd", -1, &(a->ns1__doubleIdleLog::zhlwd), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__doubleIdleLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__doubleIdleLog(soap, tag, this, type);
}

SOAP_FMAC3 ns1__doubleIdleLog * SOAP_FMAC4 soap_in_ns1__doubleIdleLog(struct soap *soap, const char *tag, ns1__doubleIdleLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__doubleIdleLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__doubleIdleLog, sizeof(ns1__doubleIdleLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__doubleIdleLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__doubleIdleLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_inspectNum1 = 1;
	size_t soap_flag_flowHC1 = 1;
	size_t soap_flag_flowCO1 = 1;
	size_t soap_flag_flowCO21 = 1;
	size_t soap_flag_analyserO21 = 1;
	size_t soap_flag_oilTemperature1 = 1;
	size_t soap_flag_rotateSpeed1 = 1;
	size_t soap_flag_lambdaValue1 = 1;
	size_t soap_flag_qtfxyjcswd1 = 1;
	size_t soap_flag_zhlwd1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__doubleIdleLog::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__doubleIdleLog::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_inspectNum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inspectNum", &(a->ns1__doubleIdleLog::inspectNum), "xsd:int"))
				{	soap_flag_inspectNum1--;
					continue;
				}
			if (soap_flag_flowHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowHC", &(a->ns1__doubleIdleLog::flowHC), "xsd:double"))
				{	soap_flag_flowHC1--;
					continue;
				}
			if (soap_flag_flowCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowCO", &(a->ns1__doubleIdleLog::flowCO), "xsd:double"))
				{	soap_flag_flowCO1--;
					continue;
				}
			if (soap_flag_flowCO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowCO2", &(a->ns1__doubleIdleLog::flowCO2), "xsd:double"))
				{	soap_flag_flowCO21--;
					continue;
				}
			if (soap_flag_analyserO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "analyserO2", &(a->ns1__doubleIdleLog::analyserO2), "xsd:double"))
				{	soap_flag_analyserO21--;
					continue;
				}
			if (soap_flag_oilTemperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "oilTemperature", &(a->ns1__doubleIdleLog::oilTemperature), "xsd:double"))
				{	soap_flag_oilTemperature1--;
					continue;
				}
			if (soap_flag_rotateSpeed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "rotateSpeed", &(a->ns1__doubleIdleLog::rotateSpeed), "xsd:string"))
				{	soap_flag_rotateSpeed1--;
					continue;
				}
			if (soap_flag_lambdaValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lambdaValue", &(a->ns1__doubleIdleLog::lambdaValue), "xsd:double"))
				{	soap_flag_lambdaValue1--;
					continue;
				}
			if (soap_flag_qtfxyjcswd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "qtfxyjcswd", &(a->ns1__doubleIdleLog::qtfxyjcswd), "xsd:double"))
				{	soap_flag_qtfxyjcswd1--;
					continue;
				}
			if (soap_flag_zhlwd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zhlwd", &(a->ns1__doubleIdleLog::zhlwd), "xsd:double"))
				{	soap_flag_zhlwd1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__doubleIdleLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__doubleIdleLog, 0, sizeof(ns1__doubleIdleLog), 0, soap_copy_ns1__doubleIdleLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_inspectNum1 > 0 || soap_flag_flowHC1 > 0 || soap_flag_flowCO1 > 0 || soap_flag_flowCO21 > 0 || soap_flag_analyserO21 > 0 || soap_flag_oilTemperature1 > 0 || soap_flag_lambdaValue1 > 0 || soap_flag_qtfxyjcswd1 > 0 || soap_flag_zhlwd1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__doubleIdleLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__doubleIdleLog);
	if (this->soap_out(soap, tag?tag:"ns1:doubleIdleLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__doubleIdleLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__doubleIdleLog(soap, this, tag, type);
}

SOAP_FMAC3 ns1__doubleIdleLog * SOAP_FMAC4 soap_get_ns1__doubleIdleLog(struct soap *soap, ns1__doubleIdleLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__doubleIdleLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__doubleIdleLog * SOAP_FMAC2 soap_instantiate_ns1__doubleIdleLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__doubleIdleLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__doubleIdleLog, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__doubleIdleLog);
		if (size)
			*size = sizeof(ns1__doubleIdleLog);
		((ns1__doubleIdleLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__doubleIdleLog, n);
		if (size)
			*size = n * sizeof(ns1__doubleIdleLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__doubleIdleLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__doubleIdleLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__doubleIdleLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__doubleIdleLog %p -> %p\n", q, p));
	*(ns1__doubleIdleLog*)p = *(ns1__doubleIdleLog*)q;
}

void ns1__doubleIdleData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__doubleIdleData::businessId = NULL;
	this->ns1__doubleIdleData::registCode = NULL;
	soap_default_double(soap, &this->ns1__doubleIdleData::lrotateSpeed);
	soap_default_double(soap, &this->ns1__doubleIdleData::hrotateSpeed);
	soap_default_double(soap, &this->ns1__doubleIdleData::coLowValue);
	soap_default_double(soap, &this->ns1__doubleIdleData::hcLowValue);
	soap_default_double(soap, &this->ns1__doubleIdleData::coHighValue);
	soap_default_double(soap, &this->ns1__doubleIdleData::hcHighValue);
	soap_default_double(soap, &this->ns1__doubleIdleData::lambdaValue);
	soap_default_double(soap, &this->ns1__doubleIdleData::tempreture);
	soap_default_double(soap, &this->ns1__doubleIdleData::humidity);
	soap_default_double(soap, &this->ns1__doubleIdleData::airPressure);
	this->ns1__doubleIdleData::timeStart = NULL;
	this->ns1__doubleIdleData::timeEnd = NULL;
	/* transient soap skipped */
}

void ns1__doubleIdleData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleData::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleData::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleData::timeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleData::timeEnd);
	/* transient soap skipped */
#endif
}

int ns1__doubleIdleData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__doubleIdleData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__doubleIdleData(struct soap *soap, const char *tag, int id, const ns1__doubleIdleData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__doubleIdleData), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__doubleIdleData::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__doubleIdleData::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "lrotateSpeed", -1, &(a->ns1__doubleIdleData::lrotateSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "hrotateSpeed", -1, &(a->ns1__doubleIdleData::hrotateSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "coLowValue", -1, &(a->ns1__doubleIdleData::coLowValue), ""))
		return soap->error;
	if (soap_out_double(soap, "hcLowValue", -1, &(a->ns1__doubleIdleData::hcLowValue), ""))
		return soap->error;
	if (soap_out_double(soap, "coHighValue", -1, &(a->ns1__doubleIdleData::coHighValue), ""))
		return soap->error;
	if (soap_out_double(soap, "hcHighValue", -1, &(a->ns1__doubleIdleData::hcHighValue), ""))
		return soap->error;
	if (soap_out_double(soap, "lambdaValue", -1, &(a->ns1__doubleIdleData::lambdaValue), ""))
		return soap->error;
	if (soap_out_double(soap, "tempreture", -1, &(a->ns1__doubleIdleData::tempreture), ""))
		return soap->error;
	if (soap_out_double(soap, "humidity", -1, &(a->ns1__doubleIdleData::humidity), ""))
		return soap->error;
	if (soap_out_double(soap, "airPressure", -1, &(a->ns1__doubleIdleData::airPressure), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeStart", -1, &(a->ns1__doubleIdleData::timeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeEnd", -1, &(a->ns1__doubleIdleData::timeEnd), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__doubleIdleData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__doubleIdleData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__doubleIdleData * SOAP_FMAC4 soap_in_ns1__doubleIdleData(struct soap *soap, const char *tag, ns1__doubleIdleData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__doubleIdleData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__doubleIdleData, sizeof(ns1__doubleIdleData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__doubleIdleData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__doubleIdleData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_lrotateSpeed1 = 1;
	size_t soap_flag_hrotateSpeed1 = 1;
	size_t soap_flag_coLowValue1 = 1;
	size_t soap_flag_hcLowValue1 = 1;
	size_t soap_flag_coHighValue1 = 1;
	size_t soap_flag_hcHighValue1 = 1;
	size_t soap_flag_lambdaValue1 = 1;
	size_t soap_flag_tempreture1 = 1;
	size_t soap_flag_humidity1 = 1;
	size_t soap_flag_airPressure1 = 1;
	size_t soap_flag_timeStart1 = 1;
	size_t soap_flag_timeEnd1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__doubleIdleData::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__doubleIdleData::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_lrotateSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lrotateSpeed", &(a->ns1__doubleIdleData::lrotateSpeed), "xsd:double"))
				{	soap_flag_lrotateSpeed1--;
					continue;
				}
			if (soap_flag_hrotateSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hrotateSpeed", &(a->ns1__doubleIdleData::hrotateSpeed), "xsd:double"))
				{	soap_flag_hrotateSpeed1--;
					continue;
				}
			if (soap_flag_coLowValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "coLowValue", &(a->ns1__doubleIdleData::coLowValue), "xsd:double"))
				{	soap_flag_coLowValue1--;
					continue;
				}
			if (soap_flag_hcLowValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hcLowValue", &(a->ns1__doubleIdleData::hcLowValue), "xsd:double"))
				{	soap_flag_hcLowValue1--;
					continue;
				}
			if (soap_flag_coHighValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "coHighValue", &(a->ns1__doubleIdleData::coHighValue), "xsd:double"))
				{	soap_flag_coHighValue1--;
					continue;
				}
			if (soap_flag_hcHighValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hcHighValue", &(a->ns1__doubleIdleData::hcHighValue), "xsd:double"))
				{	soap_flag_hcHighValue1--;
					continue;
				}
			if (soap_flag_lambdaValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lambdaValue", &(a->ns1__doubleIdleData::lambdaValue), "xsd:double"))
				{	soap_flag_lambdaValue1--;
					continue;
				}
			if (soap_flag_tempreture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "tempreture", &(a->ns1__doubleIdleData::tempreture), "xsd:double"))
				{	soap_flag_tempreture1--;
					continue;
				}
			if (soap_flag_humidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "humidity", &(a->ns1__doubleIdleData::humidity), "xsd:double"))
				{	soap_flag_humidity1--;
					continue;
				}
			if (soap_flag_airPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "airPressure", &(a->ns1__doubleIdleData::airPressure), "xsd:double"))
				{	soap_flag_airPressure1--;
					continue;
				}
			if (soap_flag_timeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeStart", &(a->ns1__doubleIdleData::timeStart), "xsd:string"))
				{	soap_flag_timeStart1--;
					continue;
				}
			if (soap_flag_timeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeEnd", &(a->ns1__doubleIdleData::timeEnd), "xsd:string"))
				{	soap_flag_timeEnd1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__doubleIdleData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__doubleIdleData, 0, sizeof(ns1__doubleIdleData), 0, soap_copy_ns1__doubleIdleData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lrotateSpeed1 > 0 || soap_flag_hrotateSpeed1 > 0 || soap_flag_coLowValue1 > 0 || soap_flag_hcLowValue1 > 0 || soap_flag_coHighValue1 > 0 || soap_flag_hcHighValue1 > 0 || soap_flag_lambdaValue1 > 0 || soap_flag_tempreture1 > 0 || soap_flag_humidity1 > 0 || soap_flag_airPressure1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__doubleIdleData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__doubleIdleData);
	if (this->soap_out(soap, tag?tag:"ns1:doubleIdleData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__doubleIdleData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__doubleIdleData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__doubleIdleData * SOAP_FMAC4 soap_get_ns1__doubleIdleData(struct soap *soap, ns1__doubleIdleData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__doubleIdleData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__doubleIdleData * SOAP_FMAC2 soap_instantiate_ns1__doubleIdleData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__doubleIdleData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__doubleIdleData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__doubleIdleData);
		if (size)
			*size = sizeof(ns1__doubleIdleData);
		((ns1__doubleIdleData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__doubleIdleData, n);
		if (size)
			*size = n * sizeof(ns1__doubleIdleData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__doubleIdleData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__doubleIdleData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__doubleIdleData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__doubleIdleData %p -> %p\n", q, p));
	*(ns1__doubleIdleData*)p = *(ns1__doubleIdleData*)q;
}

void ns1__stateInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__stateInfo::businessId = NULL;
	this->ns1__stateInfo::methodId = NULL;
	this->ns1__stateInfo::state = NULL;
	/* transient soap skipped */
}

void ns1__stateInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__stateInfo::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__stateInfo::methodId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__stateInfo::state);
	/* transient soap skipped */
#endif
}

int ns1__stateInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__stateInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__stateInfo(struct soap *soap, const char *tag, int id, const ns1__stateInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__stateInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__stateInfo::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "methodId", -1, &(a->ns1__stateInfo::methodId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "state", -1, &(a->ns1__stateInfo::state), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__stateInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__stateInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__stateInfo * SOAP_FMAC4 soap_in_ns1__stateInfo(struct soap *soap, const char *tag, ns1__stateInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__stateInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__stateInfo, sizeof(ns1__stateInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__stateInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__stateInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_methodId1 = 1;
	size_t soap_flag_state1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__stateInfo::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_methodId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "methodId", &(a->ns1__stateInfo::methodId), "xsd:string"))
				{	soap_flag_methodId1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "state", &(a->ns1__stateInfo::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__stateInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__stateInfo, 0, sizeof(ns1__stateInfo), 0, soap_copy_ns1__stateInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__stateInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__stateInfo);
	if (this->soap_out(soap, tag?tag:"ns1:stateInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__stateInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__stateInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__stateInfo * SOAP_FMAC4 soap_get_ns1__stateInfo(struct soap *soap, ns1__stateInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__stateInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__stateInfo * SOAP_FMAC2 soap_instantiate_ns1__stateInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__stateInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__stateInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__stateInfo);
		if (size)
			*size = sizeof(ns1__stateInfo);
		((ns1__stateInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__stateInfo, n);
		if (size)
			*size = n * sizeof(ns1__stateInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__stateInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__stateInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__stateInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__stateInfo %p -> %p\n", q, p));
	*(ns1__stateInfo*)p = *(ns1__stateInfo*)q;
}

void ns1__getSatateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getSatateResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getSatateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__stateInfo(soap, &this->ns1__getSatateResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__getSatateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getSatateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSatateResponse(struct soap *soap, const char *tag, int id, const ns1__getSatateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSatateResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__stateInfo(soap, "return", -1, &(a->ns1__getSatateResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getSatateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getSatateResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getSatateResponse * SOAP_FMAC4 soap_in_ns1__getSatateResponse(struct soap *soap, const char *tag, ns1__getSatateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getSatateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSatateResponse, sizeof(ns1__getSatateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getSatateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getSatateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__stateInfo(soap, "return", &(a->ns1__getSatateResponse::return_), "ns1:stateInfo"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getSatateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSatateResponse, 0, sizeof(ns1__getSatateResponse), 0, soap_copy_ns1__getSatateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getSatateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getSatateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getSatateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getSatateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getSatateResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getSatateResponse * SOAP_FMAC4 soap_get_ns1__getSatateResponse(struct soap *soap, ns1__getSatateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSatateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getSatateResponse * SOAP_FMAC2 soap_instantiate_ns1__getSatateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSatateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSatateResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getSatateResponse);
		if (size)
			*size = sizeof(ns1__getSatateResponse);
		((ns1__getSatateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSatateResponse, n);
		if (size)
			*size = n * sizeof(ns1__getSatateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getSatateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getSatateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSatateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getSatateResponse %p -> %p\n", q, p));
	*(ns1__getSatateResponse*)p = *(ns1__getSatateResponse*)q;
}

void ns1__getSatate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getSatate::registCode = NULL;
	/* transient soap skipped */
}

void ns1__getSatate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getSatate::registCode);
	/* transient soap skipped */
#endif
}

int ns1__getSatate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getSatate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSatate(struct soap *soap, const char *tag, int id, const ns1__getSatate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSatate), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__getSatate::registCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getSatate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getSatate(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getSatate * SOAP_FMAC4 soap_in_ns1__getSatate(struct soap *soap, const char *tag, ns1__getSatate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getSatate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSatate, sizeof(ns1__getSatate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getSatate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getSatate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__getSatate::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getSatate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSatate, 0, sizeof(ns1__getSatate), 0, soap_copy_ns1__getSatate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getSatate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getSatate);
	if (this->soap_out(soap, tag?tag:"ns1:getSatate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getSatate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getSatate(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getSatate * SOAP_FMAC4 soap_get_ns1__getSatate(struct soap *soap, ns1__getSatate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSatate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getSatate * SOAP_FMAC2 soap_instantiate_ns1__getSatate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSatate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSatate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getSatate);
		if (size)
			*size = sizeof(ns1__getSatate);
		((ns1__getSatate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSatate, n);
		if (size)
			*size = n * sizeof(ns1__getSatate);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getSatate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getSatate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSatate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getSatate %p -> %p\n", q, p));
	*(ns1__getSatate*)p = *(ns1__getSatate*)q;
}

void ns1__motoDbIdleDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__motoDbIdleDataResponse::return_);
	/* transient soap skipped */
}

void ns1__motoDbIdleDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__motoDbIdleDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__motoDbIdleDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__motoDbIdleDataResponse(struct soap *soap, const char *tag, int id, const ns1__motoDbIdleDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__motoDbIdleDataResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__motoDbIdleDataResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__motoDbIdleDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__motoDbIdleDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__motoDbIdleDataResponse * SOAP_FMAC4 soap_in_ns1__motoDbIdleDataResponse(struct soap *soap, const char *tag, ns1__motoDbIdleDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__motoDbIdleDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__motoDbIdleDataResponse, sizeof(ns1__motoDbIdleDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__motoDbIdleDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__motoDbIdleDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__motoDbIdleDataResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__motoDbIdleDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__motoDbIdleDataResponse, 0, sizeof(ns1__motoDbIdleDataResponse), 0, soap_copy_ns1__motoDbIdleDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__motoDbIdleDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__motoDbIdleDataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:motoDbIdleDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__motoDbIdleDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__motoDbIdleDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__motoDbIdleDataResponse * SOAP_FMAC4 soap_get_ns1__motoDbIdleDataResponse(struct soap *soap, ns1__motoDbIdleDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__motoDbIdleDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__motoDbIdleDataResponse * SOAP_FMAC2 soap_instantiate_ns1__motoDbIdleDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__motoDbIdleDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__motoDbIdleDataResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__motoDbIdleDataResponse);
		if (size)
			*size = sizeof(ns1__motoDbIdleDataResponse);
		((ns1__motoDbIdleDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__motoDbIdleDataResponse, n);
		if (size)
			*size = n * sizeof(ns1__motoDbIdleDataResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__motoDbIdleDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__motoDbIdleDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__motoDbIdleDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__motoDbIdleDataResponse %p -> %p\n", q, p));
	*(ns1__motoDbIdleDataResponse*)p = *(ns1__motoDbIdleDataResponse*)q;
}

void ns1__motoDbIdleData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__motoDbIdleData::businessId = NULL;
	this->ns1__motoDbIdleData::registCode = NULL;
	soap_default_double(soap, &this->ns1__motoDbIdleData::hHC);
	soap_default_double(soap, &this->ns1__motoDbIdleData::hCO);
	soap_default_double(soap, &this->ns1__motoDbIdleData::hCO2);
	soap_default_double(soap, &this->ns1__motoDbIdleData::hIdleSpeed);
	soap_default_double(soap, &this->ns1__motoDbIdleData::HC);
	soap_default_double(soap, &this->ns1__motoDbIdleData::CO);
	soap_default_double(soap, &this->ns1__motoDbIdleData::CO2);
	soap_default_double(soap, &this->ns1__motoDbIdleData::idleSpeed);
	soap_default_double(soap, &this->ns1__motoDbIdleData::tempreture);
	soap_default_double(soap, &this->ns1__motoDbIdleData::humidity);
	soap_default_double(soap, &this->ns1__motoDbIdleData::airPressure);
	this->ns1__motoDbIdleData::timeStart = NULL;
	this->ns1__motoDbIdleData::timeEnd = NULL;
	/* transient soap skipped */
}

void ns1__motoDbIdleData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__motoDbIdleData::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__motoDbIdleData::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__motoDbIdleData::timeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__motoDbIdleData::timeEnd);
	/* transient soap skipped */
#endif
}

int ns1__motoDbIdleData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__motoDbIdleData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__motoDbIdleData(struct soap *soap, const char *tag, int id, const ns1__motoDbIdleData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__motoDbIdleData), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__motoDbIdleData::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__motoDbIdleData::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "hHC", -1, &(a->ns1__motoDbIdleData::hHC), ""))
		return soap->error;
	if (soap_out_double(soap, "hCO", -1, &(a->ns1__motoDbIdleData::hCO), ""))
		return soap->error;
	if (soap_out_double(soap, "hCO2", -1, &(a->ns1__motoDbIdleData::hCO2), ""))
		return soap->error;
	if (soap_out_double(soap, "hIdleSpeed", -1, &(a->ns1__motoDbIdleData::hIdleSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "HC", -1, &(a->ns1__motoDbIdleData::HC), ""))
		return soap->error;
	if (soap_out_double(soap, "CO", -1, &(a->ns1__motoDbIdleData::CO), ""))
		return soap->error;
	if (soap_out_double(soap, "CO2", -1, &(a->ns1__motoDbIdleData::CO2), ""))
		return soap->error;
	if (soap_out_double(soap, "idleSpeed", -1, &(a->ns1__motoDbIdleData::idleSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "tempreture", -1, &(a->ns1__motoDbIdleData::tempreture), ""))
		return soap->error;
	if (soap_out_double(soap, "humidity", -1, &(a->ns1__motoDbIdleData::humidity), ""))
		return soap->error;
	if (soap_out_double(soap, "airPressure", -1, &(a->ns1__motoDbIdleData::airPressure), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeStart", -1, &(a->ns1__motoDbIdleData::timeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeEnd", -1, &(a->ns1__motoDbIdleData::timeEnd), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__motoDbIdleData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__motoDbIdleData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__motoDbIdleData * SOAP_FMAC4 soap_in_ns1__motoDbIdleData(struct soap *soap, const char *tag, ns1__motoDbIdleData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__motoDbIdleData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__motoDbIdleData, sizeof(ns1__motoDbIdleData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__motoDbIdleData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__motoDbIdleData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_hHC1 = 1;
	size_t soap_flag_hCO1 = 1;
	size_t soap_flag_hCO21 = 1;
	size_t soap_flag_hIdleSpeed1 = 1;
	size_t soap_flag_HC1 = 1;
	size_t soap_flag_CO1 = 1;
	size_t soap_flag_CO21 = 1;
	size_t soap_flag_idleSpeed1 = 1;
	size_t soap_flag_tempreture1 = 1;
	size_t soap_flag_humidity1 = 1;
	size_t soap_flag_airPressure1 = 1;
	size_t soap_flag_timeStart1 = 1;
	size_t soap_flag_timeEnd1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__motoDbIdleData::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__motoDbIdleData::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_hHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hHC", &(a->ns1__motoDbIdleData::hHC), "xsd:double"))
				{	soap_flag_hHC1--;
					continue;
				}
			if (soap_flag_hCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hCO", &(a->ns1__motoDbIdleData::hCO), "xsd:double"))
				{	soap_flag_hCO1--;
					continue;
				}
			if (soap_flag_hCO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hCO2", &(a->ns1__motoDbIdleData::hCO2), "xsd:double"))
				{	soap_flag_hCO21--;
					continue;
				}
			if (soap_flag_hIdleSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hIdleSpeed", &(a->ns1__motoDbIdleData::hIdleSpeed), "xsd:double"))
				{	soap_flag_hIdleSpeed1--;
					continue;
				}
			if (soap_flag_HC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "HC", &(a->ns1__motoDbIdleData::HC), "xsd:double"))
				{	soap_flag_HC1--;
					continue;
				}
			if (soap_flag_CO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CO", &(a->ns1__motoDbIdleData::CO), "xsd:double"))
				{	soap_flag_CO1--;
					continue;
				}
			if (soap_flag_CO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CO2", &(a->ns1__motoDbIdleData::CO2), "xsd:double"))
				{	soap_flag_CO21--;
					continue;
				}
			if (soap_flag_idleSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "idleSpeed", &(a->ns1__motoDbIdleData::idleSpeed), "xsd:double"))
				{	soap_flag_idleSpeed1--;
					continue;
				}
			if (soap_flag_tempreture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "tempreture", &(a->ns1__motoDbIdleData::tempreture), "xsd:double"))
				{	soap_flag_tempreture1--;
					continue;
				}
			if (soap_flag_humidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "humidity", &(a->ns1__motoDbIdleData::humidity), "xsd:double"))
				{	soap_flag_humidity1--;
					continue;
				}
			if (soap_flag_airPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "airPressure", &(a->ns1__motoDbIdleData::airPressure), "xsd:double"))
				{	soap_flag_airPressure1--;
					continue;
				}
			if (soap_flag_timeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeStart", &(a->ns1__motoDbIdleData::timeStart), "xsd:string"))
				{	soap_flag_timeStart1--;
					continue;
				}
			if (soap_flag_timeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeEnd", &(a->ns1__motoDbIdleData::timeEnd), "xsd:string"))
				{	soap_flag_timeEnd1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__motoDbIdleData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__motoDbIdleData, 0, sizeof(ns1__motoDbIdleData), 0, soap_copy_ns1__motoDbIdleData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hHC1 > 0 || soap_flag_hCO1 > 0 || soap_flag_hCO21 > 0 || soap_flag_hIdleSpeed1 > 0 || soap_flag_HC1 > 0 || soap_flag_CO1 > 0 || soap_flag_CO21 > 0 || soap_flag_idleSpeed1 > 0 || soap_flag_tempreture1 > 0 || soap_flag_humidity1 > 0 || soap_flag_airPressure1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__motoDbIdleData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__motoDbIdleData);
	if (this->soap_out(soap, tag?tag:"ns1:motoDbIdleData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__motoDbIdleData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__motoDbIdleData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__motoDbIdleData * SOAP_FMAC4 soap_get_ns1__motoDbIdleData(struct soap *soap, ns1__motoDbIdleData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__motoDbIdleData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__motoDbIdleData * SOAP_FMAC2 soap_instantiate_ns1__motoDbIdleData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__motoDbIdleData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__motoDbIdleData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__motoDbIdleData);
		if (size)
			*size = sizeof(ns1__motoDbIdleData);
		((ns1__motoDbIdleData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__motoDbIdleData, n);
		if (size)
			*size = n * sizeof(ns1__motoDbIdleData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__motoDbIdleData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__motoDbIdleData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__motoDbIdleData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__motoDbIdleData %p -> %p\n", q, p));
	*(ns1__motoDbIdleData*)p = *(ns1__motoDbIdleData*)q;
}

void ns1__vmasDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__vmasDataResponse::return_);
	/* transient soap skipped */
}

void ns1__vmasDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__vmasDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__vmasDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__vmasDataResponse(struct soap *soap, const char *tag, int id, const ns1__vmasDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__vmasDataResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__vmasDataResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__vmasDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__vmasDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__vmasDataResponse * SOAP_FMAC4 soap_in_ns1__vmasDataResponse(struct soap *soap, const char *tag, ns1__vmasDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__vmasDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__vmasDataResponse, sizeof(ns1__vmasDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__vmasDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__vmasDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__vmasDataResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__vmasDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__vmasDataResponse, 0, sizeof(ns1__vmasDataResponse), 0, soap_copy_ns1__vmasDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__vmasDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__vmasDataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:vmasDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__vmasDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__vmasDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__vmasDataResponse * SOAP_FMAC4 soap_get_ns1__vmasDataResponse(struct soap *soap, ns1__vmasDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__vmasDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__vmasDataResponse * SOAP_FMAC2 soap_instantiate_ns1__vmasDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__vmasDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__vmasDataResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__vmasDataResponse);
		if (size)
			*size = sizeof(ns1__vmasDataResponse);
		((ns1__vmasDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__vmasDataResponse, n);
		if (size)
			*size = n * sizeof(ns1__vmasDataResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__vmasDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__vmasDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__vmasDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__vmasDataResponse %p -> %p\n", q, p));
	*(ns1__vmasDataResponse*)p = *(ns1__vmasDataResponse*)q;
}

void ns1__vmasData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__vmasData::businessId = NULL;
	this->ns1__vmasData::registCode = NULL;
	soap_default_double(soap, &this->ns1__vmasData::valueCO);
	soap_default_double(soap, &this->ns1__vmasData::valueHC);
	soap_default_double(soap, &this->ns1__vmasData::valueNO);
	soap_default_double(soap, &this->ns1__vmasData::testSetPower);
	soap_default_double(soap, &this->ns1__vmasData::totalDistance);
	soap_default_double(soap, &this->ns1__vmasData::tempreture);
	soap_default_double(soap, &this->ns1__vmasData::humidity);
	soap_default_double(soap, &this->ns1__vmasData::airPressure);
	this->ns1__vmasData::timeStart = NULL;
	this->ns1__vmasData::timeEnd = NULL;
	soap_default_double(soap, &this->ns1__vmasData::lambdaValue);
	soap_default_double(soap, &this->ns1__vmasData::valueNO1);
	soap_default_double(soap, &this->ns1__vmasData::valueNO2);
	/* transient soap skipped */
}

void ns1__vmasData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__vmasData::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__vmasData::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__vmasData::timeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__vmasData::timeEnd);
	/* transient soap skipped */
#endif
}

int ns1__vmasData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__vmasData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__vmasData(struct soap *soap, const char *tag, int id, const ns1__vmasData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__vmasData), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__vmasData::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__vmasData::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "valueCO", -1, &(a->ns1__vmasData::valueCO), ""))
		return soap->error;
	if (soap_out_double(soap, "valueHC", -1, &(a->ns1__vmasData::valueHC), ""))
		return soap->error;
	if (soap_out_double(soap, "valueNO", -1, &(a->ns1__vmasData::valueNO), ""))
		return soap->error;
	if (soap_out_double(soap, "testSetPower", -1, &(a->ns1__vmasData::testSetPower), ""))
		return soap->error;
	if (soap_out_double(soap, "totalDistance", -1, &(a->ns1__vmasData::totalDistance), ""))
		return soap->error;
	if (soap_out_double(soap, "tempreture", -1, &(a->ns1__vmasData::tempreture), ""))
		return soap->error;
	if (soap_out_double(soap, "humidity", -1, &(a->ns1__vmasData::humidity), ""))
		return soap->error;
	if (soap_out_double(soap, "airPressure", -1, &(a->ns1__vmasData::airPressure), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeStart", -1, &(a->ns1__vmasData::timeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeEnd", -1, &(a->ns1__vmasData::timeEnd), ""))
		return soap->error;
	if (soap_out_double(soap, "lambdaValue", -1, &(a->ns1__vmasData::lambdaValue), ""))
		return soap->error;
	if (soap_out_double(soap, "valueNO1", -1, &(a->ns1__vmasData::valueNO1), ""))
		return soap->error;
	if (soap_out_double(soap, "valueNO2", -1, &(a->ns1__vmasData::valueNO2), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__vmasData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__vmasData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__vmasData * SOAP_FMAC4 soap_in_ns1__vmasData(struct soap *soap, const char *tag, ns1__vmasData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__vmasData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__vmasData, sizeof(ns1__vmasData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__vmasData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__vmasData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_valueCO1 = 1;
	size_t soap_flag_valueHC1 = 1;
	size_t soap_flag_valueNO1 = 1;
	size_t soap_flag_testSetPower1 = 1;
	size_t soap_flag_totalDistance1 = 1;
	size_t soap_flag_tempreture1 = 1;
	size_t soap_flag_humidity1 = 1;
	size_t soap_flag_airPressure1 = 1;
	size_t soap_flag_timeStart1 = 1;
	size_t soap_flag_timeEnd1 = 1;
	size_t soap_flag_lambdaValue1 = 1;
	size_t soap_flag_valueNO11 = 1;
	size_t soap_flag_valueNO21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__vmasData::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__vmasData::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_valueCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "valueCO", &(a->ns1__vmasData::valueCO), "xsd:double"))
				{	soap_flag_valueCO1--;
					continue;
				}
			if (soap_flag_valueHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "valueHC", &(a->ns1__vmasData::valueHC), "xsd:double"))
				{	soap_flag_valueHC1--;
					continue;
				}
			if (soap_flag_valueNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "valueNO", &(a->ns1__vmasData::valueNO), "xsd:double"))
				{	soap_flag_valueNO1--;
					continue;
				}
			if (soap_flag_testSetPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "testSetPower", &(a->ns1__vmasData::testSetPower), "xsd:double"))
				{	soap_flag_testSetPower1--;
					continue;
				}
			if (soap_flag_totalDistance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "totalDistance", &(a->ns1__vmasData::totalDistance), "xsd:double"))
				{	soap_flag_totalDistance1--;
					continue;
				}
			if (soap_flag_tempreture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "tempreture", &(a->ns1__vmasData::tempreture), "xsd:double"))
				{	soap_flag_tempreture1--;
					continue;
				}
			if (soap_flag_humidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "humidity", &(a->ns1__vmasData::humidity), "xsd:double"))
				{	soap_flag_humidity1--;
					continue;
				}
			if (soap_flag_airPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "airPressure", &(a->ns1__vmasData::airPressure), "xsd:double"))
				{	soap_flag_airPressure1--;
					continue;
				}
			if (soap_flag_timeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeStart", &(a->ns1__vmasData::timeStart), "xsd:string"))
				{	soap_flag_timeStart1--;
					continue;
				}
			if (soap_flag_timeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeEnd", &(a->ns1__vmasData::timeEnd), "xsd:string"))
				{	soap_flag_timeEnd1--;
					continue;
				}
			if (soap_flag_lambdaValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lambdaValue", &(a->ns1__vmasData::lambdaValue), "xsd:double"))
				{	soap_flag_lambdaValue1--;
					continue;
				}
			if (soap_flag_valueNO11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "valueNO1", &(a->ns1__vmasData::valueNO1), "xsd:double"))
				{	soap_flag_valueNO11--;
					continue;
				}
			if (soap_flag_valueNO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "valueNO2", &(a->ns1__vmasData::valueNO2), "xsd:double"))
				{	soap_flag_valueNO21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__vmasData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__vmasData, 0, sizeof(ns1__vmasData), 0, soap_copy_ns1__vmasData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_valueCO1 > 0 || soap_flag_valueHC1 > 0 || soap_flag_valueNO1 > 0 || soap_flag_testSetPower1 > 0 || soap_flag_totalDistance1 > 0 || soap_flag_tempreture1 > 0 || soap_flag_humidity1 > 0 || soap_flag_airPressure1 > 0 || soap_flag_lambdaValue1 > 0 || soap_flag_valueNO11 > 0 || soap_flag_valueNO21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__vmasData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__vmasData);
	if (this->soap_out(soap, tag?tag:"ns1:vmasData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__vmasData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__vmasData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__vmasData * SOAP_FMAC4 soap_get_ns1__vmasData(struct soap *soap, ns1__vmasData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__vmasData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__vmasData * SOAP_FMAC2 soap_instantiate_ns1__vmasData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__vmasData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__vmasData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__vmasData);
		if (size)
			*size = sizeof(ns1__vmasData);
		((ns1__vmasData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__vmasData, n);
		if (size)
			*size = n * sizeof(ns1__vmasData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__vmasData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__vmasData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__vmasData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__vmasData %p -> %p\n", q, p));
	*(ns1__vmasData*)p = *(ns1__vmasData*)q;
}

void ns1__loadDownDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__loadDownDataResponse::return_);
	/* transient soap skipped */
}

void ns1__loadDownDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__loadDownDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__loadDownDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loadDownDataResponse(struct soap *soap, const char *tag, int id, const ns1__loadDownDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loadDownDataResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__loadDownDataResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__loadDownDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__loadDownDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__loadDownDataResponse * SOAP_FMAC4 soap_in_ns1__loadDownDataResponse(struct soap *soap, const char *tag, ns1__loadDownDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__loadDownDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loadDownDataResponse, sizeof(ns1__loadDownDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__loadDownDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__loadDownDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__loadDownDataResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__loadDownDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loadDownDataResponse, 0, sizeof(ns1__loadDownDataResponse), 0, soap_copy_ns1__loadDownDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__loadDownDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__loadDownDataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:loadDownDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__loadDownDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__loadDownDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__loadDownDataResponse * SOAP_FMAC4 soap_get_ns1__loadDownDataResponse(struct soap *soap, ns1__loadDownDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loadDownDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__loadDownDataResponse * SOAP_FMAC2 soap_instantiate_ns1__loadDownDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loadDownDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__loadDownDataResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__loadDownDataResponse);
		if (size)
			*size = sizeof(ns1__loadDownDataResponse);
		((ns1__loadDownDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__loadDownDataResponse, n);
		if (size)
			*size = n * sizeof(ns1__loadDownDataResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__loadDownDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__loadDownDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__loadDownDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__loadDownDataResponse %p -> %p\n", q, p));
	*(ns1__loadDownDataResponse*)p = *(ns1__loadDownDataResponse*)q;
}

void ns1__loadDownData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__loadDownData::businessId = NULL;
	this->ns1__loadDownData::registCode = NULL;
	soap_default_double(soap, &this->ns1__loadDownData::smokeK100);
	soap_default_double(soap, &this->ns1__loadDownData::smokeK90);
	soap_default_double(soap, &this->ns1__loadDownData::smokeK80);
	soap_default_double(soap, &this->ns1__loadDownData::power);
	soap_default_double(soap, &this->ns1__loadDownData::speed);
	soap_default_double(soap, &this->ns1__loadDownData::mortorSpeed);
	soap_default_double(soap, &this->ns1__loadDownData::idleRotateSpeed);
	soap_default_double(soap, &this->ns1__loadDownData::valueNO);
	soap_default_double(soap, &this->ns1__loadDownData::tempreture);
	soap_default_double(soap, &this->ns1__loadDownData::humidity);
	soap_default_double(soap, &this->ns1__loadDownData::airPressure);
	this->ns1__loadDownData::timeStart = NULL;
	this->ns1__loadDownData::timeEnd = NULL;
	/* transient soap skipped */
}

void ns1__loadDownData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__loadDownData::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__loadDownData::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__loadDownData::timeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__loadDownData::timeEnd);
	/* transient soap skipped */
#endif
}

int ns1__loadDownData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__loadDownData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loadDownData(struct soap *soap, const char *tag, int id, const ns1__loadDownData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loadDownData), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__loadDownData::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__loadDownData::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeK100", -1, &(a->ns1__loadDownData::smokeK100), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeK90", -1, &(a->ns1__loadDownData::smokeK90), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeK80", -1, &(a->ns1__loadDownData::smokeK80), ""))
		return soap->error;
	if (soap_out_double(soap, "power", -1, &(a->ns1__loadDownData::power), ""))
		return soap->error;
	if (soap_out_double(soap, "speed", -1, &(a->ns1__loadDownData::speed), ""))
		return soap->error;
	if (soap_out_double(soap, "mortorSpeed", -1, &(a->ns1__loadDownData::mortorSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "idleRotateSpeed", -1, &(a->ns1__loadDownData::idleRotateSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "valueNO", -1, &(a->ns1__loadDownData::valueNO), ""))
		return soap->error;
	if (soap_out_double(soap, "tempreture", -1, &(a->ns1__loadDownData::tempreture), ""))
		return soap->error;
	if (soap_out_double(soap, "humidity", -1, &(a->ns1__loadDownData::humidity), ""))
		return soap->error;
	if (soap_out_double(soap, "airPressure", -1, &(a->ns1__loadDownData::airPressure), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeStart", -1, &(a->ns1__loadDownData::timeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeEnd", -1, &(a->ns1__loadDownData::timeEnd), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__loadDownData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__loadDownData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__loadDownData * SOAP_FMAC4 soap_in_ns1__loadDownData(struct soap *soap, const char *tag, ns1__loadDownData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__loadDownData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loadDownData, sizeof(ns1__loadDownData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__loadDownData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__loadDownData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_smokeK1001 = 1;
	size_t soap_flag_smokeK901 = 1;
	size_t soap_flag_smokeK801 = 1;
	size_t soap_flag_power1 = 1;
	size_t soap_flag_speed1 = 1;
	size_t soap_flag_mortorSpeed1 = 1;
	size_t soap_flag_idleRotateSpeed1 = 1;
	size_t soap_flag_valueNO1 = 1;
	size_t soap_flag_tempreture1 = 1;
	size_t soap_flag_humidity1 = 1;
	size_t soap_flag_airPressure1 = 1;
	size_t soap_flag_timeStart1 = 1;
	size_t soap_flag_timeEnd1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__loadDownData::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__loadDownData::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_smokeK1001 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeK100", &(a->ns1__loadDownData::smokeK100), "xsd:double"))
				{	soap_flag_smokeK1001--;
					continue;
				}
			if (soap_flag_smokeK901 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeK90", &(a->ns1__loadDownData::smokeK90), "xsd:double"))
				{	soap_flag_smokeK901--;
					continue;
				}
			if (soap_flag_smokeK801 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeK80", &(a->ns1__loadDownData::smokeK80), "xsd:double"))
				{	soap_flag_smokeK801--;
					continue;
				}
			if (soap_flag_power1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "power", &(a->ns1__loadDownData::power), "xsd:double"))
				{	soap_flag_power1--;
					continue;
				}
			if (soap_flag_speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "speed", &(a->ns1__loadDownData::speed), "xsd:double"))
				{	soap_flag_speed1--;
					continue;
				}
			if (soap_flag_mortorSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "mortorSpeed", &(a->ns1__loadDownData::mortorSpeed), "xsd:double"))
				{	soap_flag_mortorSpeed1--;
					continue;
				}
			if (soap_flag_idleRotateSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "idleRotateSpeed", &(a->ns1__loadDownData::idleRotateSpeed), "xsd:double"))
				{	soap_flag_idleRotateSpeed1--;
					continue;
				}
			if (soap_flag_valueNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "valueNO", &(a->ns1__loadDownData::valueNO), "xsd:double"))
				{	soap_flag_valueNO1--;
					continue;
				}
			if (soap_flag_tempreture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "tempreture", &(a->ns1__loadDownData::tempreture), "xsd:double"))
				{	soap_flag_tempreture1--;
					continue;
				}
			if (soap_flag_humidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "humidity", &(a->ns1__loadDownData::humidity), "xsd:double"))
				{	soap_flag_humidity1--;
					continue;
				}
			if (soap_flag_airPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "airPressure", &(a->ns1__loadDownData::airPressure), "xsd:double"))
				{	soap_flag_airPressure1--;
					continue;
				}
			if (soap_flag_timeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeStart", &(a->ns1__loadDownData::timeStart), "xsd:string"))
				{	soap_flag_timeStart1--;
					continue;
				}
			if (soap_flag_timeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeEnd", &(a->ns1__loadDownData::timeEnd), "xsd:string"))
				{	soap_flag_timeEnd1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__loadDownData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loadDownData, 0, sizeof(ns1__loadDownData), 0, soap_copy_ns1__loadDownData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_smokeK1001 > 0 || soap_flag_smokeK901 > 0 || soap_flag_smokeK801 > 0 || soap_flag_power1 > 0 || soap_flag_speed1 > 0 || soap_flag_mortorSpeed1 > 0 || soap_flag_idleRotateSpeed1 > 0 || soap_flag_valueNO1 > 0 || soap_flag_tempreture1 > 0 || soap_flag_humidity1 > 0 || soap_flag_airPressure1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__loadDownData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__loadDownData);
	if (this->soap_out(soap, tag?tag:"ns1:loadDownData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__loadDownData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__loadDownData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__loadDownData * SOAP_FMAC4 soap_get_ns1__loadDownData(struct soap *soap, ns1__loadDownData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loadDownData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__loadDownData * SOAP_FMAC2 soap_instantiate_ns1__loadDownData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loadDownData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__loadDownData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__loadDownData);
		if (size)
			*size = sizeof(ns1__loadDownData);
		((ns1__loadDownData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__loadDownData, n);
		if (size)
			*size = n * sizeof(ns1__loadDownData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__loadDownData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__loadDownData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__loadDownData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__loadDownData %p -> %p\n", q, p));
	*(ns1__loadDownData*)p = *(ns1__loadDownData*)q;
}

void ns1__lightproofSmokeDataLog_USCOREFCResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__lightproofSmokeDataLog_USCOREFCResponse::return_);
	/* transient soap skipped */
}

void ns1__lightproofSmokeDataLog_USCOREFCResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__lightproofSmokeDataLog_USCOREFCResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lightproofSmokeDataLog_USCOREFCResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lightproofSmokeDataLog_USCOREFCResponse(struct soap *soap, const char *tag, int id, const ns1__lightproofSmokeDataLog_USCOREFCResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__lightproofSmokeDataLog_USCOREFCResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lightproofSmokeDataLog_USCOREFCResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lightproofSmokeDataLog_USCOREFCResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lightproofSmokeDataLog_USCOREFCResponse * SOAP_FMAC4 soap_in_ns1__lightproofSmokeDataLog_USCOREFCResponse(struct soap *soap, const char *tag, ns1__lightproofSmokeDataLog_USCOREFCResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lightproofSmokeDataLog_USCOREFCResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse, sizeof(ns1__lightproofSmokeDataLog_USCOREFCResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lightproofSmokeDataLog_USCOREFCResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__lightproofSmokeDataLog_USCOREFCResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lightproofSmokeDataLog_USCOREFCResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse, 0, sizeof(ns1__lightproofSmokeDataLog_USCOREFCResponse), 0, soap_copy_ns1__lightproofSmokeDataLog_USCOREFCResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lightproofSmokeDataLog_USCOREFCResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse);
	if (this->soap_out(soap, tag?tag:"ns1:lightproofSmokeDataLog_FCResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lightproofSmokeDataLog_USCOREFCResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lightproofSmokeDataLog_USCOREFCResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lightproofSmokeDataLog_USCOREFCResponse * SOAP_FMAC4 soap_get_ns1__lightproofSmokeDataLog_USCOREFCResponse(struct soap *soap, ns1__lightproofSmokeDataLog_USCOREFCResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lightproofSmokeDataLog_USCOREFCResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lightproofSmokeDataLog_USCOREFCResponse * SOAP_FMAC2 soap_instantiate_ns1__lightproofSmokeDataLog_USCOREFCResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lightproofSmokeDataLog_USCOREFCResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lightproofSmokeDataLog_USCOREFCResponse);
		if (size)
			*size = sizeof(ns1__lightproofSmokeDataLog_USCOREFCResponse);
		((ns1__lightproofSmokeDataLog_USCOREFCResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lightproofSmokeDataLog_USCOREFCResponse, n);
		if (size)
			*size = n * sizeof(ns1__lightproofSmokeDataLog_USCOREFCResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lightproofSmokeDataLog_USCOREFCResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lightproofSmokeDataLog_USCOREFCResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lightproofSmokeDataLog_USCOREFCResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lightproofSmokeDataLog_USCOREFCResponse %p -> %p\n", q, p));
	*(ns1__lightproofSmokeDataLog_USCOREFCResponse*)p = *(ns1__lightproofSmokeDataLog_USCOREFCResponse*)q;
}

void ns1__lightproofSmokeDataLog_USCOREFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lightproofSmokeDataLog_USCOREFC::businessId = NULL;
	this->ns1__lightproofSmokeDataLog_USCOREFC::registCode = NULL;
	this->ns1__lightproofSmokeDataLog_USCOREFC::cytimestart = NULL;
	soap_default_double(soap, &this->ns1__lightproofSmokeDataLog_USCOREFC::labelvalue);
	soap_default_double(soap, &this->ns1__lightproofSmokeDataLog_USCOREFC::zs);
	/* transient soap skipped */
}

void ns1__lightproofSmokeDataLog_USCOREFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeDataLog_USCOREFC::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeDataLog_USCOREFC::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeDataLog_USCOREFC::cytimestart);
	/* transient soap skipped */
#endif
}

int ns1__lightproofSmokeDataLog_USCOREFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lightproofSmokeDataLog_USCOREFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, const char *tag, int id, const ns1__lightproofSmokeDataLog_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__lightproofSmokeDataLog_USCOREFC::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__lightproofSmokeDataLog_USCOREFC::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "cytimestart", -1, &(a->ns1__lightproofSmokeDataLog_USCOREFC::cytimestart), ""))
		return soap->error;
	if (soap_out_double(soap, "labelvalue", -1, &(a->ns1__lightproofSmokeDataLog_USCOREFC::labelvalue), ""))
		return soap->error;
	if (soap_out_double(soap, "zs", -1, &(a->ns1__lightproofSmokeDataLog_USCOREFC::zs), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lightproofSmokeDataLog_USCOREFC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lightproofSmokeDataLog_USCOREFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lightproofSmokeDataLog_USCOREFC * SOAP_FMAC4 soap_in_ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, const char *tag, ns1__lightproofSmokeDataLog_USCOREFC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lightproofSmokeDataLog_USCOREFC *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC, sizeof(ns1__lightproofSmokeDataLog_USCOREFC), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lightproofSmokeDataLog_USCOREFC *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_cytimestart1 = 1;
	size_t soap_flag_labelvalue1 = 1;
	size_t soap_flag_zs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__lightproofSmokeDataLog_USCOREFC::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__lightproofSmokeDataLog_USCOREFC::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_cytimestart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "cytimestart", &(a->ns1__lightproofSmokeDataLog_USCOREFC::cytimestart), "xsd:string"))
				{	soap_flag_cytimestart1--;
					continue;
				}
			if (soap_flag_labelvalue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelvalue", &(a->ns1__lightproofSmokeDataLog_USCOREFC::labelvalue), "xsd:double"))
				{	soap_flag_labelvalue1--;
					continue;
				}
			if (soap_flag_zs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zs", &(a->ns1__lightproofSmokeDataLog_USCOREFC::zs), "xsd:double"))
				{	soap_flag_zs1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lightproofSmokeDataLog_USCOREFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC, 0, sizeof(ns1__lightproofSmokeDataLog_USCOREFC), 0, soap_copy_ns1__lightproofSmokeDataLog_USCOREFC);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_labelvalue1 > 0 || soap_flag_zs1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lightproofSmokeDataLog_USCOREFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC);
	if (this->soap_out(soap, tag?tag:"ns1:lightproofSmokeDataLog_FC", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lightproofSmokeDataLog_USCOREFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lightproofSmokeDataLog_USCOREFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lightproofSmokeDataLog_USCOREFC * SOAP_FMAC4 soap_get_ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, ns1__lightproofSmokeDataLog_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lightproofSmokeDataLog_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lightproofSmokeDataLog_USCOREFC * SOAP_FMAC2 soap_instantiate_ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lightproofSmokeDataLog_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lightproofSmokeDataLog_USCOREFC);
		if (size)
			*size = sizeof(ns1__lightproofSmokeDataLog_USCOREFC);
		((ns1__lightproofSmokeDataLog_USCOREFC*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lightproofSmokeDataLog_USCOREFC, n);
		if (size)
			*size = n * sizeof(ns1__lightproofSmokeDataLog_USCOREFC);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lightproofSmokeDataLog_USCOREFC*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lightproofSmokeDataLog_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lightproofSmokeDataLog_USCOREFC %p -> %p\n", q, p));
	*(ns1__lightproofSmokeDataLog_USCOREFC*)p = *(ns1__lightproofSmokeDataLog_USCOREFC*)q;
}

void ns1__pqfxySelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__pqfxySelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__pqfxySelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__pqfxySelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__pqfxySelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__pqfxySelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__pqfxySelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__pqfxySelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__pqfxySelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__pqfxySelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__pqfxySelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__pqfxySelfcheckResponse * SOAP_FMAC4 soap_in_ns1__pqfxySelfcheckResponse(struct soap *soap, const char *tag, ns1__pqfxySelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__pqfxySelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__pqfxySelfcheckResponse, sizeof(ns1__pqfxySelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__pqfxySelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__pqfxySelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__pqfxySelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__pqfxySelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__pqfxySelfcheckResponse, 0, sizeof(ns1__pqfxySelfcheckResponse), 0, soap_copy_ns1__pqfxySelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__pqfxySelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__pqfxySelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:pqfxySelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__pqfxySelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__pqfxySelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__pqfxySelfcheckResponse * SOAP_FMAC4 soap_get_ns1__pqfxySelfcheckResponse(struct soap *soap, ns1__pqfxySelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__pqfxySelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__pqfxySelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__pqfxySelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__pqfxySelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__pqfxySelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__pqfxySelfcheckResponse);
		if (size)
			*size = sizeof(ns1__pqfxySelfcheckResponse);
		((ns1__pqfxySelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__pqfxySelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__pqfxySelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__pqfxySelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__pqfxySelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__pqfxySelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__pqfxySelfcheckResponse %p -> %p\n", q, p));
	*(ns1__pqfxySelfcheckResponse*)p = *(ns1__pqfxySelfcheckResponse*)q;
}

void ns1__pqfxySelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__pqfxySelfcheck::registCode = NULL;
	soap_default_double(soap, &this->ns1__pqfxySelfcheck::noxRTime1);
	this->ns1__pqfxySelfcheck::noxRTime1Start = NULL;
	this->ns1__pqfxySelfcheck::noxRTime1End = NULL;
	soap_default_double(soap, &this->ns1__pqfxySelfcheck::noxRTime2);
	this->ns1__pqfxySelfcheck::noxRTime2Start = NULL;
	this->ns1__pqfxySelfcheck::noxRTime2End = NULL;
	soap_default_double(soap, &this->ns1__pqfxySelfcheck::co2RTime1);
	this->ns1__pqfxySelfcheck::co2RTime1Start = NULL;
	this->ns1__pqfxySelfcheck::co2RTime1End = NULL;
	soap_default_double(soap, &this->ns1__pqfxySelfcheck::co2RTime2);
	this->ns1__pqfxySelfcheck::co2RTime2Start = NULL;
	this->ns1__pqfxySelfcheck::co2RTime2End = NULL;
	soap_default_double(soap, &this->ns1__pqfxySelfcheck::CEconverte);
	this->ns1__pqfxySelfcheck::CETimeStart = NULL;
	this->ns1__pqfxySelfcheck::CETimeEnd = NULL;
	this->ns1__pqfxySelfcheck::checkResult = NULL;
	this->ns1__pqfxySelfcheck::checkTimeStart = NULL;
	this->ns1__pqfxySelfcheck::checkTimeEnd = NULL;
	this->ns1__pqfxySelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__pqfxySelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::noxRTime1Start);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::noxRTime1End);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::noxRTime2Start);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::noxRTime2End);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::co2RTime1Start);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::co2RTime1End);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::co2RTime2Start);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::co2RTime2End);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::CETimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::CETimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__pqfxySelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__pqfxySelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__pqfxySelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__pqfxySelfcheck(struct soap *soap, const char *tag, int id, const ns1__pqfxySelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__pqfxySelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__pqfxySelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "noxRTime1", -1, &(a->ns1__pqfxySelfcheck::noxRTime1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "noxRTime1Start", -1, &(a->ns1__pqfxySelfcheck::noxRTime1Start), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "noxRTime1End", -1, &(a->ns1__pqfxySelfcheck::noxRTime1End), ""))
		return soap->error;
	if (soap_out_double(soap, "noxRTime2", -1, &(a->ns1__pqfxySelfcheck::noxRTime2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "noxRTime2Start", -1, &(a->ns1__pqfxySelfcheck::noxRTime2Start), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "noxRTime2End", -1, &(a->ns1__pqfxySelfcheck::noxRTime2End), ""))
		return soap->error;
	if (soap_out_double(soap, "co2RTime1", -1, &(a->ns1__pqfxySelfcheck::co2RTime1), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "co2RTime1Start", -1, &(a->ns1__pqfxySelfcheck::co2RTime1Start), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "co2RTime1End", -1, &(a->ns1__pqfxySelfcheck::co2RTime1End), ""))
		return soap->error;
	if (soap_out_double(soap, "co2RTime2", -1, &(a->ns1__pqfxySelfcheck::co2RTime2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "co2RTime2Start", -1, &(a->ns1__pqfxySelfcheck::co2RTime2Start), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "co2RTime2End", -1, &(a->ns1__pqfxySelfcheck::co2RTime2End), ""))
		return soap->error;
	if (soap_out_double(soap, "CEconverte", -1, &(a->ns1__pqfxySelfcheck::CEconverte), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "CETimeStart", -1, &(a->ns1__pqfxySelfcheck::CETimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "CETimeEnd", -1, &(a->ns1__pqfxySelfcheck::CETimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__pqfxySelfcheck::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__pqfxySelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__pqfxySelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__pqfxySelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__pqfxySelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__pqfxySelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__pqfxySelfcheck * SOAP_FMAC4 soap_in_ns1__pqfxySelfcheck(struct soap *soap, const char *tag, ns1__pqfxySelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__pqfxySelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__pqfxySelfcheck, sizeof(ns1__pqfxySelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__pqfxySelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__pqfxySelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_noxRTime11 = 1;
	size_t soap_flag_noxRTime1Start1 = 1;
	size_t soap_flag_noxRTime1End1 = 1;
	size_t soap_flag_noxRTime21 = 1;
	size_t soap_flag_noxRTime2Start1 = 1;
	size_t soap_flag_noxRTime2End1 = 1;
	size_t soap_flag_co2RTime11 = 1;
	size_t soap_flag_co2RTime1Start1 = 1;
	size_t soap_flag_co2RTime1End1 = 1;
	size_t soap_flag_co2RTime21 = 1;
	size_t soap_flag_co2RTime2Start1 = 1;
	size_t soap_flag_co2RTime2End1 = 1;
	size_t soap_flag_CEconverte1 = 1;
	size_t soap_flag_CETimeStart1 = 1;
	size_t soap_flag_CETimeEnd1 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__pqfxySelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_noxRTime11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "noxRTime1", &(a->ns1__pqfxySelfcheck::noxRTime1), "xsd:double"))
				{	soap_flag_noxRTime11--;
					continue;
				}
			if (soap_flag_noxRTime1Start1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "noxRTime1Start", &(a->ns1__pqfxySelfcheck::noxRTime1Start), "xsd:string"))
				{	soap_flag_noxRTime1Start1--;
					continue;
				}
			if (soap_flag_noxRTime1End1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "noxRTime1End", &(a->ns1__pqfxySelfcheck::noxRTime1End), "xsd:string"))
				{	soap_flag_noxRTime1End1--;
					continue;
				}
			if (soap_flag_noxRTime21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "noxRTime2", &(a->ns1__pqfxySelfcheck::noxRTime2), "xsd:double"))
				{	soap_flag_noxRTime21--;
					continue;
				}
			if (soap_flag_noxRTime2Start1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "noxRTime2Start", &(a->ns1__pqfxySelfcheck::noxRTime2Start), "xsd:string"))
				{	soap_flag_noxRTime2Start1--;
					continue;
				}
			if (soap_flag_noxRTime2End1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "noxRTime2End", &(a->ns1__pqfxySelfcheck::noxRTime2End), "xsd:string"))
				{	soap_flag_noxRTime2End1--;
					continue;
				}
			if (soap_flag_co2RTime11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co2RTime1", &(a->ns1__pqfxySelfcheck::co2RTime1), "xsd:double"))
				{	soap_flag_co2RTime11--;
					continue;
				}
			if (soap_flag_co2RTime1Start1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "co2RTime1Start", &(a->ns1__pqfxySelfcheck::co2RTime1Start), "xsd:string"))
				{	soap_flag_co2RTime1Start1--;
					continue;
				}
			if (soap_flag_co2RTime1End1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "co2RTime1End", &(a->ns1__pqfxySelfcheck::co2RTime1End), "xsd:string"))
				{	soap_flag_co2RTime1End1--;
					continue;
				}
			if (soap_flag_co2RTime21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co2RTime2", &(a->ns1__pqfxySelfcheck::co2RTime2), "xsd:double"))
				{	soap_flag_co2RTime21--;
					continue;
				}
			if (soap_flag_co2RTime2Start1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "co2RTime2Start", &(a->ns1__pqfxySelfcheck::co2RTime2Start), "xsd:string"))
				{	soap_flag_co2RTime2Start1--;
					continue;
				}
			if (soap_flag_co2RTime2End1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "co2RTime2End", &(a->ns1__pqfxySelfcheck::co2RTime2End), "xsd:string"))
				{	soap_flag_co2RTime2End1--;
					continue;
				}
			if (soap_flag_CEconverte1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CEconverte", &(a->ns1__pqfxySelfcheck::CEconverte), "xsd:double"))
				{	soap_flag_CEconverte1--;
					continue;
				}
			if (soap_flag_CETimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "CETimeStart", &(a->ns1__pqfxySelfcheck::CETimeStart), "xsd:string"))
				{	soap_flag_CETimeStart1--;
					continue;
				}
			if (soap_flag_CETimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "CETimeEnd", &(a->ns1__pqfxySelfcheck::CETimeEnd), "xsd:string"))
				{	soap_flag_CETimeEnd1--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__pqfxySelfcheck::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__pqfxySelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__pqfxySelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__pqfxySelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__pqfxySelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__pqfxySelfcheck, 0, sizeof(ns1__pqfxySelfcheck), 0, soap_copy_ns1__pqfxySelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_noxRTime11 > 0 || soap_flag_noxRTime21 > 0 || soap_flag_co2RTime11 > 0 || soap_flag_co2RTime21 > 0 || soap_flag_CEconverte1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__pqfxySelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__pqfxySelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:pqfxySelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__pqfxySelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__pqfxySelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__pqfxySelfcheck * SOAP_FMAC4 soap_get_ns1__pqfxySelfcheck(struct soap *soap, ns1__pqfxySelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__pqfxySelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__pqfxySelfcheck * SOAP_FMAC2 soap_instantiate_ns1__pqfxySelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__pqfxySelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__pqfxySelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__pqfxySelfcheck);
		if (size)
			*size = sizeof(ns1__pqfxySelfcheck);
		((ns1__pqfxySelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__pqfxySelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__pqfxySelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__pqfxySelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__pqfxySelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__pqfxySelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__pqfxySelfcheck %p -> %p\n", q, p));
	*(ns1__pqfxySelfcheck*)p = *(ns1__pqfxySelfcheck*)q;
}

void ns1__hjcsgyqSelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__hjcsgyqSelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__hjcsgyqSelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__hjcsgyqSelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__hjcsgyqSelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__hjcsgyqSelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__hjcsgyqSelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__hjcsgyqSelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__hjcsgyqSelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__hjcsgyqSelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__hjcsgyqSelfcheckResponse * SOAP_FMAC4 soap_in_ns1__hjcsgyqSelfcheckResponse(struct soap *soap, const char *tag, ns1__hjcsgyqSelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__hjcsgyqSelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse, sizeof(ns1__hjcsgyqSelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__hjcsgyqSelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__hjcsgyqSelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__hjcsgyqSelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse, 0, sizeof(ns1__hjcsgyqSelfcheckResponse), 0, soap_copy_ns1__hjcsgyqSelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__hjcsgyqSelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:hjcsgyqSelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__hjcsgyqSelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__hjcsgyqSelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__hjcsgyqSelfcheckResponse * SOAP_FMAC4 soap_get_ns1__hjcsgyqSelfcheckResponse(struct soap *soap, ns1__hjcsgyqSelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__hjcsgyqSelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__hjcsgyqSelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__hjcsgyqSelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__hjcsgyqSelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__hjcsgyqSelfcheckResponse);
		if (size)
			*size = sizeof(ns1__hjcsgyqSelfcheckResponse);
		((ns1__hjcsgyqSelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__hjcsgyqSelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__hjcsgyqSelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__hjcsgyqSelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__hjcsgyqSelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__hjcsgyqSelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__hjcsgyqSelfcheckResponse %p -> %p\n", q, p));
	*(ns1__hjcsgyqSelfcheckResponse*)p = *(ns1__hjcsgyqSelfcheckResponse*)q;
}

void ns1__hjcsgyqSelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__hjcsgyqSelfcheck::registCode = NULL;
	soap_default_double(soap, &this->ns1__hjcsgyqSelfcheck::actualTemperature);
	soap_default_double(soap, &this->ns1__hjcsgyqSelfcheck::temperature);
	soap_default_double(soap, &this->ns1__hjcsgyqSelfcheck::actualHumidity);
	soap_default_double(soap, &this->ns1__hjcsgyqSelfcheck::humidity);
	soap_default_double(soap, &this->ns1__hjcsgyqSelfcheck::actualAirPressure);
	soap_default_double(soap, &this->ns1__hjcsgyqSelfcheck::airPressure);
	this->ns1__hjcsgyqSelfcheck::checkTimeStart = NULL;
	this->ns1__hjcsgyqSelfcheck::checkTimeEnd = NULL;
	this->ns1__hjcsgyqSelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__hjcsgyqSelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__hjcsgyqSelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__hjcsgyqSelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__hjcsgyqSelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__hjcsgyqSelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__hjcsgyqSelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__hjcsgyqSelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__hjcsgyqSelfcheck(struct soap *soap, const char *tag, int id, const ns1__hjcsgyqSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__hjcsgyqSelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__hjcsgyqSelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "actualTemperature", -1, &(a->ns1__hjcsgyqSelfcheck::actualTemperature), ""))
		return soap->error;
	if (soap_out_double(soap, "temperature", -1, &(a->ns1__hjcsgyqSelfcheck::temperature), ""))
		return soap->error;
	if (soap_out_double(soap, "actualHumidity", -1, &(a->ns1__hjcsgyqSelfcheck::actualHumidity), ""))
		return soap->error;
	if (soap_out_double(soap, "humidity", -1, &(a->ns1__hjcsgyqSelfcheck::humidity), ""))
		return soap->error;
	if (soap_out_double(soap, "actualAirPressure", -1, &(a->ns1__hjcsgyqSelfcheck::actualAirPressure), ""))
		return soap->error;
	if (soap_out_double(soap, "airPressure", -1, &(a->ns1__hjcsgyqSelfcheck::airPressure), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__hjcsgyqSelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__hjcsgyqSelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__hjcsgyqSelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__hjcsgyqSelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__hjcsgyqSelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__hjcsgyqSelfcheck * SOAP_FMAC4 soap_in_ns1__hjcsgyqSelfcheck(struct soap *soap, const char *tag, ns1__hjcsgyqSelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__hjcsgyqSelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__hjcsgyqSelfcheck, sizeof(ns1__hjcsgyqSelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__hjcsgyqSelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__hjcsgyqSelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_actualTemperature1 = 1;
	size_t soap_flag_temperature1 = 1;
	size_t soap_flag_actualHumidity1 = 1;
	size_t soap_flag_humidity1 = 1;
	size_t soap_flag_actualAirPressure1 = 1;
	size_t soap_flag_airPressure1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__hjcsgyqSelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_actualTemperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "actualTemperature", &(a->ns1__hjcsgyqSelfcheck::actualTemperature), "xsd:double"))
				{	soap_flag_actualTemperature1--;
					continue;
				}
			if (soap_flag_temperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "temperature", &(a->ns1__hjcsgyqSelfcheck::temperature), "xsd:double"))
				{	soap_flag_temperature1--;
					continue;
				}
			if (soap_flag_actualHumidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "actualHumidity", &(a->ns1__hjcsgyqSelfcheck::actualHumidity), "xsd:double"))
				{	soap_flag_actualHumidity1--;
					continue;
				}
			if (soap_flag_humidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "humidity", &(a->ns1__hjcsgyqSelfcheck::humidity), "xsd:double"))
				{	soap_flag_humidity1--;
					continue;
				}
			if (soap_flag_actualAirPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "actualAirPressure", &(a->ns1__hjcsgyqSelfcheck::actualAirPressure), "xsd:double"))
				{	soap_flag_actualAirPressure1--;
					continue;
				}
			if (soap_flag_airPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "airPressure", &(a->ns1__hjcsgyqSelfcheck::airPressure), "xsd:double"))
				{	soap_flag_airPressure1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__hjcsgyqSelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__hjcsgyqSelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__hjcsgyqSelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__hjcsgyqSelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__hjcsgyqSelfcheck, 0, sizeof(ns1__hjcsgyqSelfcheck), 0, soap_copy_ns1__hjcsgyqSelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_actualTemperature1 > 0 || soap_flag_temperature1 > 0 || soap_flag_actualHumidity1 > 0 || soap_flag_humidity1 > 0 || soap_flag_actualAirPressure1 > 0 || soap_flag_airPressure1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__hjcsgyqSelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__hjcsgyqSelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:hjcsgyqSelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__hjcsgyqSelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__hjcsgyqSelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__hjcsgyqSelfcheck * SOAP_FMAC4 soap_get_ns1__hjcsgyqSelfcheck(struct soap *soap, ns1__hjcsgyqSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__hjcsgyqSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__hjcsgyqSelfcheck * SOAP_FMAC2 soap_instantiate_ns1__hjcsgyqSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__hjcsgyqSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__hjcsgyqSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__hjcsgyqSelfcheck);
		if (size)
			*size = sizeof(ns1__hjcsgyqSelfcheck);
		((ns1__hjcsgyqSelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__hjcsgyqSelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__hjcsgyqSelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__hjcsgyqSelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__hjcsgyqSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__hjcsgyqSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__hjcsgyqSelfcheck %p -> %p\n", q, p));
	*(ns1__hjcsgyqSelfcheck*)p = *(ns1__hjcsgyqSelfcheck*)q;
}

void ns1__cycdyhwAdjustResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__cycdyhwAdjustResponse::return_);
	/* transient soap skipped */
}

void ns1__cycdyhwAdjustResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__cycdyhwAdjustResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cycdyhwAdjustResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cycdyhwAdjustResponse(struct soap *soap, const char *tag, int id, const ns1__cycdyhwAdjustResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cycdyhwAdjustResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__cycdyhwAdjustResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cycdyhwAdjustResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cycdyhwAdjustResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cycdyhwAdjustResponse * SOAP_FMAC4 soap_in_ns1__cycdyhwAdjustResponse(struct soap *soap, const char *tag, ns1__cycdyhwAdjustResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cycdyhwAdjustResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cycdyhwAdjustResponse, sizeof(ns1__cycdyhwAdjustResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cycdyhwAdjustResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cycdyhwAdjustResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__cycdyhwAdjustResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cycdyhwAdjustResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cycdyhwAdjustResponse, 0, sizeof(ns1__cycdyhwAdjustResponse), 0, soap_copy_ns1__cycdyhwAdjustResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cycdyhwAdjustResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cycdyhwAdjustResponse);
	if (this->soap_out(soap, tag?tag:"ns1:cycdyhwAdjustResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cycdyhwAdjustResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cycdyhwAdjustResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cycdyhwAdjustResponse * SOAP_FMAC4 soap_get_ns1__cycdyhwAdjustResponse(struct soap *soap, ns1__cycdyhwAdjustResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cycdyhwAdjustResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cycdyhwAdjustResponse * SOAP_FMAC2 soap_instantiate_ns1__cycdyhwAdjustResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cycdyhwAdjustResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cycdyhwAdjustResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cycdyhwAdjustResponse);
		if (size)
			*size = sizeof(ns1__cycdyhwAdjustResponse);
		((ns1__cycdyhwAdjustResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cycdyhwAdjustResponse, n);
		if (size)
			*size = n * sizeof(ns1__cycdyhwAdjustResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cycdyhwAdjustResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cycdyhwAdjustResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cycdyhwAdjustResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cycdyhwAdjustResponse %p -> %p\n", q, p));
	*(ns1__cycdyhwAdjustResponse*)p = *(ns1__cycdyhwAdjustResponse*)q;
}

void ns1__cycdyhwAdjust::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__cycdyhwAdjust::registCode = NULL;
	this->ns1__cycdyhwAdjust::gasType = NULL;
	soap_default_double(soap, &this->ns1__cycdyhwAdjust::labelValueNO);
	soap_default_double(soap, &this->ns1__cycdyhwAdjust::detectValueNO);
	soap_default_double(soap, &this->ns1__cycdyhwAdjust::labelValueNO2);
	soap_default_double(soap, &this->ns1__cycdyhwAdjust::detectValueNO2);
	soap_default_double(soap, &this->ns1__cycdyhwAdjust::labelValueCO2);
	soap_default_double(soap, &this->ns1__cycdyhwAdjust::detectValueCO2);
	this->ns1__cycdyhwAdjust::adjustResult = NULL;
	this->ns1__cycdyhwAdjust::adjustTimeStart = NULL;
	this->ns1__cycdyhwAdjust::adjustTimeEnd = NULL;
	this->ns1__cycdyhwAdjust::remark = NULL;
	/* transient soap skipped */
}

void ns1__cycdyhwAdjust::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cycdyhwAdjust::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cycdyhwAdjust::gasType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cycdyhwAdjust::adjustResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cycdyhwAdjust::adjustTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cycdyhwAdjust::adjustTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cycdyhwAdjust::remark);
	/* transient soap skipped */
#endif
}

int ns1__cycdyhwAdjust::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cycdyhwAdjust(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cycdyhwAdjust(struct soap *soap, const char *tag, int id, const ns1__cycdyhwAdjust *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cycdyhwAdjust), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__cycdyhwAdjust::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gasType", -1, &(a->ns1__cycdyhwAdjust::gasType), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueNO", -1, &(a->ns1__cycdyhwAdjust::labelValueNO), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueNO", -1, &(a->ns1__cycdyhwAdjust::detectValueNO), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueNO2", -1, &(a->ns1__cycdyhwAdjust::labelValueNO2), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueNO2", -1, &(a->ns1__cycdyhwAdjust::detectValueNO2), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueCO2", -1, &(a->ns1__cycdyhwAdjust::labelValueCO2), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueCO2", -1, &(a->ns1__cycdyhwAdjust::detectValueCO2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "adjustResult", -1, &(a->ns1__cycdyhwAdjust::adjustResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "adjustTimeStart", -1, &(a->ns1__cycdyhwAdjust::adjustTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "adjustTimeEnd", -1, &(a->ns1__cycdyhwAdjust::adjustTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__cycdyhwAdjust::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cycdyhwAdjust::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cycdyhwAdjust(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cycdyhwAdjust * SOAP_FMAC4 soap_in_ns1__cycdyhwAdjust(struct soap *soap, const char *tag, ns1__cycdyhwAdjust *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cycdyhwAdjust *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cycdyhwAdjust, sizeof(ns1__cycdyhwAdjust), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cycdyhwAdjust)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cycdyhwAdjust *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_gasType1 = 1;
	size_t soap_flag_labelValueNO1 = 1;
	size_t soap_flag_detectValueNO1 = 1;
	size_t soap_flag_labelValueNO21 = 1;
	size_t soap_flag_detectValueNO21 = 1;
	size_t soap_flag_labelValueCO21 = 1;
	size_t soap_flag_detectValueCO21 = 1;
	size_t soap_flag_adjustResult1 = 1;
	size_t soap_flag_adjustTimeStart1 = 1;
	size_t soap_flag_adjustTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__cycdyhwAdjust::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_gasType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gasType", &(a->ns1__cycdyhwAdjust::gasType), "xsd:string"))
				{	soap_flag_gasType1--;
					continue;
				}
			if (soap_flag_labelValueNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueNO", &(a->ns1__cycdyhwAdjust::labelValueNO), "xsd:double"))
				{	soap_flag_labelValueNO1--;
					continue;
				}
			if (soap_flag_detectValueNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueNO", &(a->ns1__cycdyhwAdjust::detectValueNO), "xsd:double"))
				{	soap_flag_detectValueNO1--;
					continue;
				}
			if (soap_flag_labelValueNO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueNO2", &(a->ns1__cycdyhwAdjust::labelValueNO2), "xsd:double"))
				{	soap_flag_labelValueNO21--;
					continue;
				}
			if (soap_flag_detectValueNO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueNO2", &(a->ns1__cycdyhwAdjust::detectValueNO2), "xsd:double"))
				{	soap_flag_detectValueNO21--;
					continue;
				}
			if (soap_flag_labelValueCO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueCO2", &(a->ns1__cycdyhwAdjust::labelValueCO2), "xsd:double"))
				{	soap_flag_labelValueCO21--;
					continue;
				}
			if (soap_flag_detectValueCO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueCO2", &(a->ns1__cycdyhwAdjust::detectValueCO2), "xsd:double"))
				{	soap_flag_detectValueCO21--;
					continue;
				}
			if (soap_flag_adjustResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "adjustResult", &(a->ns1__cycdyhwAdjust::adjustResult), "xsd:string"))
				{	soap_flag_adjustResult1--;
					continue;
				}
			if (soap_flag_adjustTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "adjustTimeStart", &(a->ns1__cycdyhwAdjust::adjustTimeStart), "xsd:string"))
				{	soap_flag_adjustTimeStart1--;
					continue;
				}
			if (soap_flag_adjustTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "adjustTimeEnd", &(a->ns1__cycdyhwAdjust::adjustTimeEnd), "xsd:string"))
				{	soap_flag_adjustTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__cycdyhwAdjust::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cycdyhwAdjust *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cycdyhwAdjust, 0, sizeof(ns1__cycdyhwAdjust), 0, soap_copy_ns1__cycdyhwAdjust);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_labelValueNO1 > 0 || soap_flag_detectValueNO1 > 0 || soap_flag_labelValueNO21 > 0 || soap_flag_detectValueNO21 > 0 || soap_flag_labelValueCO21 > 0 || soap_flag_detectValueCO21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cycdyhwAdjust::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cycdyhwAdjust);
	if (this->soap_out(soap, tag?tag:"ns1:cycdyhwAdjust", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cycdyhwAdjust::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cycdyhwAdjust(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cycdyhwAdjust * SOAP_FMAC4 soap_get_ns1__cycdyhwAdjust(struct soap *soap, ns1__cycdyhwAdjust *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cycdyhwAdjust(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cycdyhwAdjust * SOAP_FMAC2 soap_instantiate_ns1__cycdyhwAdjust(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cycdyhwAdjust(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cycdyhwAdjust, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cycdyhwAdjust);
		if (size)
			*size = sizeof(ns1__cycdyhwAdjust);
		((ns1__cycdyhwAdjust*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cycdyhwAdjust, n);
		if (size)
			*size = n * sizeof(ns1__cycdyhwAdjust);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cycdyhwAdjust*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cycdyhwAdjust*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cycdyhwAdjust(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cycdyhwAdjust %p -> %p\n", q, p));
	*(ns1__cycdyhwAdjust*)p = *(ns1__cycdyhwAdjust*)q;
}

void ns1__software2centerNew_USCOREFCResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__software2centerNew_USCOREFCResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__software2centerNew_USCOREFCResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__software2centerNew_USCOREFCResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__software2centerNew_USCOREFCResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__software2centerNew_USCOREFCResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__software2centerNew_USCOREFCResponse(struct soap *soap, const char *tag, int id, const ns1__software2centerNew_USCOREFCResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__software2centerNew_USCOREFCResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__software2centerNew_USCOREFCResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__software2centerNew_USCOREFCResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__software2centerNew_USCOREFCResponse * SOAP_FMAC4 soap_in_ns1__software2centerNew_USCOREFCResponse(struct soap *soap, const char *tag, ns1__software2centerNew_USCOREFCResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__software2centerNew_USCOREFCResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse, sizeof(ns1__software2centerNew_USCOREFCResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__software2centerNew_USCOREFCResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__software2centerNew_USCOREFCResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__software2centerNew_USCOREFCResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse, 0, sizeof(ns1__software2centerNew_USCOREFCResponse), 0, soap_copy_ns1__software2centerNew_USCOREFCResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__software2centerNew_USCOREFCResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse);
	if (this->soap_out(soap, tag?tag:"ns1:software2centerNew_FCResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__software2centerNew_USCOREFCResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__software2centerNew_USCOREFCResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__software2centerNew_USCOREFCResponse * SOAP_FMAC4 soap_get_ns1__software2centerNew_USCOREFCResponse(struct soap *soap, ns1__software2centerNew_USCOREFCResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__software2centerNew_USCOREFCResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__software2centerNew_USCOREFCResponse * SOAP_FMAC2 soap_instantiate_ns1__software2centerNew_USCOREFCResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__software2centerNew_USCOREFCResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__software2centerNew_USCOREFCResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__software2centerNew_USCOREFCResponse);
		if (size)
			*size = sizeof(ns1__software2centerNew_USCOREFCResponse);
		((ns1__software2centerNew_USCOREFCResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__software2centerNew_USCOREFCResponse, n);
		if (size)
			*size = n * sizeof(ns1__software2centerNew_USCOREFCResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__software2centerNew_USCOREFCResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__software2centerNew_USCOREFCResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__software2centerNew_USCOREFCResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__software2centerNew_USCOREFCResponse %p -> %p\n", q, p));
	*(ns1__software2centerNew_USCOREFCResponse*)p = *(ns1__software2centerNew_USCOREFCResponse*)q;
}

void ns1__software2centerNew_USCOREFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__software2centerNew_USCOREFC::optionType = NULL;
	this->ns1__software2centerNew_USCOREFC::tableName = NULL;
	this->ns1__software2centerNew_USCOREFC::dataJson = NULL;
	this->ns1__software2centerNew_USCOREFC::carid = NULL;
	/* transient soap skipped */
}

void ns1__software2centerNew_USCOREFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__software2centerNew_USCOREFC::optionType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__software2centerNew_USCOREFC::tableName);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__software2centerNew_USCOREFC::dataJson);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__software2centerNew_USCOREFC::carid);
	/* transient soap skipped */
#endif
}

int ns1__software2centerNew_USCOREFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__software2centerNew_USCOREFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__software2centerNew_USCOREFC(struct soap *soap, const char *tag, int id, const ns1__software2centerNew_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__software2centerNew_USCOREFC), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "optionType", -1, &(a->ns1__software2centerNew_USCOREFC::optionType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "tableName", -1, &(a->ns1__software2centerNew_USCOREFC::tableName), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "dataJson", -1, &(a->ns1__software2centerNew_USCOREFC::dataJson), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "carid", -1, &(a->ns1__software2centerNew_USCOREFC::carid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__software2centerNew_USCOREFC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__software2centerNew_USCOREFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__software2centerNew_USCOREFC * SOAP_FMAC4 soap_in_ns1__software2centerNew_USCOREFC(struct soap *soap, const char *tag, ns1__software2centerNew_USCOREFC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__software2centerNew_USCOREFC *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__software2centerNew_USCOREFC, sizeof(ns1__software2centerNew_USCOREFC), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__software2centerNew_USCOREFC)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__software2centerNew_USCOREFC *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_optionType1 = 1;
	size_t soap_flag_tableName1 = 1;
	size_t soap_flag_dataJson1 = 1;
	size_t soap_flag_carid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_optionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "optionType", &(a->ns1__software2centerNew_USCOREFC::optionType), "xsd:string"))
				{	soap_flag_optionType1--;
					continue;
				}
			if (soap_flag_tableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "tableName", &(a->ns1__software2centerNew_USCOREFC::tableName), "xsd:string"))
				{	soap_flag_tableName1--;
					continue;
				}
			if (soap_flag_dataJson1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "dataJson", &(a->ns1__software2centerNew_USCOREFC::dataJson), "xsd:string"))
				{	soap_flag_dataJson1--;
					continue;
				}
			if (soap_flag_carid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "carid", &(a->ns1__software2centerNew_USCOREFC::carid), "xsd:string"))
				{	soap_flag_carid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__software2centerNew_USCOREFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__software2centerNew_USCOREFC, 0, sizeof(ns1__software2centerNew_USCOREFC), 0, soap_copy_ns1__software2centerNew_USCOREFC);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__software2centerNew_USCOREFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__software2centerNew_USCOREFC);
	if (this->soap_out(soap, tag?tag:"ns1:software2centerNew_FC", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__software2centerNew_USCOREFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__software2centerNew_USCOREFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__software2centerNew_USCOREFC * SOAP_FMAC4 soap_get_ns1__software2centerNew_USCOREFC(struct soap *soap, ns1__software2centerNew_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__software2centerNew_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__software2centerNew_USCOREFC * SOAP_FMAC2 soap_instantiate_ns1__software2centerNew_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__software2centerNew_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__software2centerNew_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__software2centerNew_USCOREFC);
		if (size)
			*size = sizeof(ns1__software2centerNew_USCOREFC);
		((ns1__software2centerNew_USCOREFC*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__software2centerNew_USCOREFC, n);
		if (size)
			*size = n * sizeof(ns1__software2centerNew_USCOREFC);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__software2centerNew_USCOREFC*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__software2centerNew_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__software2centerNew_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__software2centerNew_USCOREFC %p -> %p\n", q, p));
	*(ns1__software2centerNew_USCOREFC*)p = *(ns1__software2centerNew_USCOREFC*)q;
}

void ns1__getCarInfo_USCOREFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getCarInfo_USCOREFC::businessId = NULL;
	this->ns1__getCarInfo_USCOREFC::registCode = NULL;
	/* transient soap skipped */
}

void ns1__getCarInfo_USCOREFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getCarInfo_USCOREFC::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getCarInfo_USCOREFC::registCode);
	/* transient soap skipped */
#endif
}

int ns1__getCarInfo_USCOREFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getCarInfo_USCOREFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCarInfo_USCOREFC(struct soap *soap, const char *tag, int id, const ns1__getCarInfo_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCarInfo_USCOREFC), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__getCarInfo_USCOREFC::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__getCarInfo_USCOREFC::registCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getCarInfo_USCOREFC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getCarInfo_USCOREFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getCarInfo_USCOREFC * SOAP_FMAC4 soap_in_ns1__getCarInfo_USCOREFC(struct soap *soap, const char *tag, ns1__getCarInfo_USCOREFC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getCarInfo_USCOREFC *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCarInfo_USCOREFC, sizeof(ns1__getCarInfo_USCOREFC), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getCarInfo_USCOREFC)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getCarInfo_USCOREFC *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__getCarInfo_USCOREFC::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__getCarInfo_USCOREFC::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getCarInfo_USCOREFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCarInfo_USCOREFC, 0, sizeof(ns1__getCarInfo_USCOREFC), 0, soap_copy_ns1__getCarInfo_USCOREFC);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getCarInfo_USCOREFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getCarInfo_USCOREFC);
	if (this->soap_out(soap, tag?tag:"ns1:getCarInfo_FC", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getCarInfo_USCOREFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getCarInfo_USCOREFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getCarInfo_USCOREFC * SOAP_FMAC4 soap_get_ns1__getCarInfo_USCOREFC(struct soap *soap, ns1__getCarInfo_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCarInfo_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getCarInfo_USCOREFC * SOAP_FMAC2 soap_instantiate_ns1__getCarInfo_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCarInfo_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCarInfo_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getCarInfo_USCOREFC);
		if (size)
			*size = sizeof(ns1__getCarInfo_USCOREFC);
		((ns1__getCarInfo_USCOREFC*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getCarInfo_USCOREFC, n);
		if (size)
			*size = n * sizeof(ns1__getCarInfo_USCOREFC);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getCarInfo_USCOREFC*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getCarInfo_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCarInfo_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getCarInfo_USCOREFC %p -> %p\n", q, p));
	*(ns1__getCarInfo_USCOREFC*)p = *(ns1__getCarInfo_USCOREFC*)q;
}

void ns1__obdResultLogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__obdResultLogResponse::return_);
	/* transient soap skipped */
}

void ns1__obdResultLogResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__obdResultLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__obdResultLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__obdResultLogResponse(struct soap *soap, const char *tag, int id, const ns1__obdResultLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__obdResultLogResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__obdResultLogResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__obdResultLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__obdResultLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__obdResultLogResponse * SOAP_FMAC4 soap_in_ns1__obdResultLogResponse(struct soap *soap, const char *tag, ns1__obdResultLogResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__obdResultLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__obdResultLogResponse, sizeof(ns1__obdResultLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__obdResultLogResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__obdResultLogResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__obdResultLogResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__obdResultLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__obdResultLogResponse, 0, sizeof(ns1__obdResultLogResponse), 0, soap_copy_ns1__obdResultLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__obdResultLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__obdResultLogResponse);
	if (this->soap_out(soap, tag?tag:"ns1:obdResultLogResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__obdResultLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__obdResultLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__obdResultLogResponse * SOAP_FMAC4 soap_get_ns1__obdResultLogResponse(struct soap *soap, ns1__obdResultLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__obdResultLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__obdResultLogResponse * SOAP_FMAC2 soap_instantiate_ns1__obdResultLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__obdResultLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__obdResultLogResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__obdResultLogResponse);
		if (size)
			*size = sizeof(ns1__obdResultLogResponse);
		((ns1__obdResultLogResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__obdResultLogResponse, n);
		if (size)
			*size = n * sizeof(ns1__obdResultLogResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__obdResultLogResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__obdResultLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__obdResultLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__obdResultLogResponse %p -> %p\n", q, p));
	*(ns1__obdResultLogResponse*)p = *(ns1__obdResultLogResponse*)q;
}

void ns1__obdResultLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__obdResultLog::registCode = NULL;
	this->ns1__obdResultLog::businessId = NULL;
	this->ns1__obdResultLog::calidfdjkzdy = NULL;
	this->ns1__obdResultLog::calidhclkddy = NULL;
	this->ns1__obdResultLog::calidqtkzdy = NULL;
	this->ns1__obdResultLog::cvnfdjkzdy = NULL;
	this->ns1__obdResultLog::cvnhclkddy = NULL;
	this->ns1__obdResultLog::cvnqtkzdy = NULL;
	soap_default_double(soap, &this->ns1__obdResultLog::jqmjdkd);
	soap_default_double(soap, &this->ns1__obdResultLog::fhz);
	soap_default_double(soap, &this->ns1__obdResultLog::lambdaValue);
	soap_default_double(soap, &this->ns1__obdResultLog::ymkd);
	soap_default_double(soap, &this->ns1__obdResultLog::fdjscgl);
	soap_default_double(soap, &this->ns1__obdResultLog::zyyl);
	soap_default_double(soap, &this->ns1__obdResultLog::hyl);
	soap_default_double(soap, &this->ns1__obdResultLog::noxcgqnd);
	soap_default_double(soap, &this->ns1__obdResultLog::Nspsl);
	soap_default_double(soap, &this->ns1__obdResultLog::pqwd);
	soap_default_double(soap, &this->ns1__obdResultLog::Klpjqyc);
	soap_default_double(soap, &this->ns1__obdResultLog::Egrkd);
	soap_default_double(soap, &this->ns1__obdResultLog::rypsyl);
	soap_default_double(soap, &this->ns1__obdResultLog::cs);
	soap_default_double(soap, &this->ns1__obdResultLog::zs);
	soap_default_double(soap, &this->ns1__obdResultLog::jqyl);
	this->ns1__obdResultLog::fuelType = NULL;
	this->ns1__obdResultLog::checkTime = NULL;
	this->ns1__obdResultLog::remark = NULL;
	/* transient soap skipped */
}

void ns1__obdResultLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::calidfdjkzdy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::calidhclkddy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::calidqtkzdy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::cvnfdjkzdy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::cvnhclkddy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::cvnqtkzdy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::fuelType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::checkTime);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResultLog::remark);
	/* transient soap skipped */
#endif
}

int ns1__obdResultLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__obdResultLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__obdResultLog(struct soap *soap, const char *tag, int id, const ns1__obdResultLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__obdResultLog), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__obdResultLog::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__obdResultLog::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "calidfdjkzdy", -1, &(a->ns1__obdResultLog::calidfdjkzdy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "calidhclkddy", -1, &(a->ns1__obdResultLog::calidhclkddy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "calidqtkzdy", -1, &(a->ns1__obdResultLog::calidqtkzdy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "cvnfdjkzdy", -1, &(a->ns1__obdResultLog::cvnfdjkzdy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "cvnhclkddy", -1, &(a->ns1__obdResultLog::cvnhclkddy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "cvnqtkzdy", -1, &(a->ns1__obdResultLog::cvnqtkzdy), ""))
		return soap->error;
	if (soap_out_double(soap, "jqmjdkd", -1, &(a->ns1__obdResultLog::jqmjdkd), ""))
		return soap->error;
	if (soap_out_double(soap, "fhz", -1, &(a->ns1__obdResultLog::fhz), ""))
		return soap->error;
	if (soap_out_double(soap, "lambdaValue", -1, &(a->ns1__obdResultLog::lambdaValue), ""))
		return soap->error;
	if (soap_out_double(soap, "ymkd", -1, &(a->ns1__obdResultLog::ymkd), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjscgl", -1, &(a->ns1__obdResultLog::fdjscgl), ""))
		return soap->error;
	if (soap_out_double(soap, "zyyl", -1, &(a->ns1__obdResultLog::zyyl), ""))
		return soap->error;
	if (soap_out_double(soap, "hyl", -1, &(a->ns1__obdResultLog::hyl), ""))
		return soap->error;
	if (soap_out_double(soap, "noxcgqnd", -1, &(a->ns1__obdResultLog::noxcgqnd), ""))
		return soap->error;
	if (soap_out_double(soap, "Nspsl", -1, &(a->ns1__obdResultLog::Nspsl), ""))
		return soap->error;
	if (soap_out_double(soap, "pqwd", -1, &(a->ns1__obdResultLog::pqwd), ""))
		return soap->error;
	if (soap_out_double(soap, "Klpjqyc", -1, &(a->ns1__obdResultLog::Klpjqyc), ""))
		return soap->error;
	if (soap_out_double(soap, "Egrkd", -1, &(a->ns1__obdResultLog::Egrkd), ""))
		return soap->error;
	if (soap_out_double(soap, "rypsyl", -1, &(a->ns1__obdResultLog::rypsyl), ""))
		return soap->error;
	if (soap_out_double(soap, "cs", -1, &(a->ns1__obdResultLog::cs), ""))
		return soap->error;
	if (soap_out_double(soap, "zs", -1, &(a->ns1__obdResultLog::zs), ""))
		return soap->error;
	if (soap_out_double(soap, "jqyl", -1, &(a->ns1__obdResultLog::jqyl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fuelType", -1, &(a->ns1__obdResultLog::fuelType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTime", -1, &(a->ns1__obdResultLog::checkTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__obdResultLog::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__obdResultLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__obdResultLog(soap, tag, this, type);
}

SOAP_FMAC3 ns1__obdResultLog * SOAP_FMAC4 soap_in_ns1__obdResultLog(struct soap *soap, const char *tag, ns1__obdResultLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__obdResultLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__obdResultLog, sizeof(ns1__obdResultLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__obdResultLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__obdResultLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_calidfdjkzdy1 = 1;
	size_t soap_flag_calidhclkddy1 = 1;
	size_t soap_flag_calidqtkzdy1 = 1;
	size_t soap_flag_cvnfdjkzdy1 = 1;
	size_t soap_flag_cvnhclkddy1 = 1;
	size_t soap_flag_cvnqtkzdy1 = 1;
	size_t soap_flag_jqmjdkd1 = 1;
	size_t soap_flag_fhz1 = 1;
	size_t soap_flag_lambdaValue1 = 1;
	size_t soap_flag_ymkd1 = 1;
	size_t soap_flag_fdjscgl1 = 1;
	size_t soap_flag_zyyl1 = 1;
	size_t soap_flag_hyl1 = 1;
	size_t soap_flag_noxcgqnd1 = 1;
	size_t soap_flag_Nspsl1 = 1;
	size_t soap_flag_pqwd1 = 1;
	size_t soap_flag_Klpjqyc1 = 1;
	size_t soap_flag_Egrkd1 = 1;
	size_t soap_flag_rypsyl1 = 1;
	size_t soap_flag_cs1 = 1;
	size_t soap_flag_zs1 = 1;
	size_t soap_flag_jqyl1 = 1;
	size_t soap_flag_fuelType1 = 1;
	size_t soap_flag_checkTime1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__obdResultLog::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__obdResultLog::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_calidfdjkzdy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "calidfdjkzdy", &(a->ns1__obdResultLog::calidfdjkzdy), "xsd:string"))
				{	soap_flag_calidfdjkzdy1--;
					continue;
				}
			if (soap_flag_calidhclkddy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "calidhclkddy", &(a->ns1__obdResultLog::calidhclkddy), "xsd:string"))
				{	soap_flag_calidhclkddy1--;
					continue;
				}
			if (soap_flag_calidqtkzdy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "calidqtkzdy", &(a->ns1__obdResultLog::calidqtkzdy), "xsd:string"))
				{	soap_flag_calidqtkzdy1--;
					continue;
				}
			if (soap_flag_cvnfdjkzdy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "cvnfdjkzdy", &(a->ns1__obdResultLog::cvnfdjkzdy), "xsd:string"))
				{	soap_flag_cvnfdjkzdy1--;
					continue;
				}
			if (soap_flag_cvnhclkddy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "cvnhclkddy", &(a->ns1__obdResultLog::cvnhclkddy), "xsd:string"))
				{	soap_flag_cvnhclkddy1--;
					continue;
				}
			if (soap_flag_cvnqtkzdy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "cvnqtkzdy", &(a->ns1__obdResultLog::cvnqtkzdy), "xsd:string"))
				{	soap_flag_cvnqtkzdy1--;
					continue;
				}
			if (soap_flag_jqmjdkd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jqmjdkd", &(a->ns1__obdResultLog::jqmjdkd), "xsd:double"))
				{	soap_flag_jqmjdkd1--;
					continue;
				}
			if (soap_flag_fhz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fhz", &(a->ns1__obdResultLog::fhz), "xsd:double"))
				{	soap_flag_fhz1--;
					continue;
				}
			if (soap_flag_lambdaValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lambdaValue", &(a->ns1__obdResultLog::lambdaValue), "xsd:double"))
				{	soap_flag_lambdaValue1--;
					continue;
				}
			if (soap_flag_ymkd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ymkd", &(a->ns1__obdResultLog::ymkd), "xsd:double"))
				{	soap_flag_ymkd1--;
					continue;
				}
			if (soap_flag_fdjscgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjscgl", &(a->ns1__obdResultLog::fdjscgl), "xsd:double"))
				{	soap_flag_fdjscgl1--;
					continue;
				}
			if (soap_flag_zyyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zyyl", &(a->ns1__obdResultLog::zyyl), "xsd:double"))
				{	soap_flag_zyyl1--;
					continue;
				}
			if (soap_flag_hyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hyl", &(a->ns1__obdResultLog::hyl), "xsd:double"))
				{	soap_flag_hyl1--;
					continue;
				}
			if (soap_flag_noxcgqnd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "noxcgqnd", &(a->ns1__obdResultLog::noxcgqnd), "xsd:double"))
				{	soap_flag_noxcgqnd1--;
					continue;
				}
			if (soap_flag_Nspsl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Nspsl", &(a->ns1__obdResultLog::Nspsl), "xsd:double"))
				{	soap_flag_Nspsl1--;
					continue;
				}
			if (soap_flag_pqwd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "pqwd", &(a->ns1__obdResultLog::pqwd), "xsd:double"))
				{	soap_flag_pqwd1--;
					continue;
				}
			if (soap_flag_Klpjqyc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Klpjqyc", &(a->ns1__obdResultLog::Klpjqyc), "xsd:double"))
				{	soap_flag_Klpjqyc1--;
					continue;
				}
			if (soap_flag_Egrkd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Egrkd", &(a->ns1__obdResultLog::Egrkd), "xsd:double"))
				{	soap_flag_Egrkd1--;
					continue;
				}
			if (soap_flag_rypsyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "rypsyl", &(a->ns1__obdResultLog::rypsyl), "xsd:double"))
				{	soap_flag_rypsyl1--;
					continue;
				}
			if (soap_flag_cs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "cs", &(a->ns1__obdResultLog::cs), "xsd:double"))
				{	soap_flag_cs1--;
					continue;
				}
			if (soap_flag_zs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zs", &(a->ns1__obdResultLog::zs), "xsd:double"))
				{	soap_flag_zs1--;
					continue;
				}
			if (soap_flag_jqyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jqyl", &(a->ns1__obdResultLog::jqyl), "xsd:double"))
				{	soap_flag_jqyl1--;
					continue;
				}
			if (soap_flag_fuelType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fuelType", &(a->ns1__obdResultLog::fuelType), "xsd:string"))
				{	soap_flag_fuelType1--;
					continue;
				}
			if (soap_flag_checkTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTime", &(a->ns1__obdResultLog::checkTime), "xsd:string"))
				{	soap_flag_checkTime1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__obdResultLog::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__obdResultLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__obdResultLog, 0, sizeof(ns1__obdResultLog), 0, soap_copy_ns1__obdResultLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jqmjdkd1 > 0 || soap_flag_fhz1 > 0 || soap_flag_lambdaValue1 > 0 || soap_flag_ymkd1 > 0 || soap_flag_fdjscgl1 > 0 || soap_flag_zyyl1 > 0 || soap_flag_hyl1 > 0 || soap_flag_noxcgqnd1 > 0 || soap_flag_Nspsl1 > 0 || soap_flag_pqwd1 > 0 || soap_flag_Klpjqyc1 > 0 || soap_flag_Egrkd1 > 0 || soap_flag_rypsyl1 > 0 || soap_flag_cs1 > 0 || soap_flag_zs1 > 0 || soap_flag_jqyl1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__obdResultLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__obdResultLog);
	if (this->soap_out(soap, tag?tag:"ns1:obdResultLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__obdResultLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__obdResultLog(soap, this, tag, type);
}

SOAP_FMAC3 ns1__obdResultLog * SOAP_FMAC4 soap_get_ns1__obdResultLog(struct soap *soap, ns1__obdResultLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__obdResultLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__obdResultLog * SOAP_FMAC2 soap_instantiate_ns1__obdResultLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__obdResultLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__obdResultLog, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__obdResultLog);
		if (size)
			*size = sizeof(ns1__obdResultLog);
		((ns1__obdResultLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__obdResultLog, n);
		if (size)
			*size = n * sizeof(ns1__obdResultLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__obdResultLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__obdResultLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__obdResultLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__obdResultLog %p -> %p\n", q, p));
	*(ns1__obdResultLog*)p = *(ns1__obdResultLog*)q;
}

void ns1__dyhwAdjustResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__dyhwAdjustResponse::return_);
	/* transient soap skipped */
}

void ns1__dyhwAdjustResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__dyhwAdjustResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__dyhwAdjustResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dyhwAdjustResponse(struct soap *soap, const char *tag, int id, const ns1__dyhwAdjustResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__dyhwAdjustResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__dyhwAdjustResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__dyhwAdjustResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__dyhwAdjustResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dyhwAdjustResponse * SOAP_FMAC4 soap_in_ns1__dyhwAdjustResponse(struct soap *soap, const char *tag, ns1__dyhwAdjustResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__dyhwAdjustResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__dyhwAdjustResponse, sizeof(ns1__dyhwAdjustResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__dyhwAdjustResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__dyhwAdjustResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__dyhwAdjustResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__dyhwAdjustResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__dyhwAdjustResponse, 0, sizeof(ns1__dyhwAdjustResponse), 0, soap_copy_ns1__dyhwAdjustResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__dyhwAdjustResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__dyhwAdjustResponse);
	if (this->soap_out(soap, tag?tag:"ns1:dyhwAdjustResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__dyhwAdjustResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__dyhwAdjustResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dyhwAdjustResponse * SOAP_FMAC4 soap_get_ns1__dyhwAdjustResponse(struct soap *soap, ns1__dyhwAdjustResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__dyhwAdjustResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__dyhwAdjustResponse * SOAP_FMAC2 soap_instantiate_ns1__dyhwAdjustResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dyhwAdjustResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__dyhwAdjustResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__dyhwAdjustResponse);
		if (size)
			*size = sizeof(ns1__dyhwAdjustResponse);
		((ns1__dyhwAdjustResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__dyhwAdjustResponse, n);
		if (size)
			*size = n * sizeof(ns1__dyhwAdjustResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__dyhwAdjustResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__dyhwAdjustResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dyhwAdjustResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dyhwAdjustResponse %p -> %p\n", q, p));
	*(ns1__dyhwAdjustResponse*)p = *(ns1__dyhwAdjustResponse*)q;
}

void ns1__dyhwAdjust::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__dyhwAdjust::registCode = NULL;
	this->ns1__dyhwAdjust::gasType = NULL;
	soap_default_double(soap, &this->ns1__dyhwAdjust::labelValueNO);
	soap_default_double(soap, &this->ns1__dyhwAdjust::detectValueNO);
	soap_default_double(soap, &this->ns1__dyhwAdjust::labelValueNO2);
	soap_default_double(soap, &this->ns1__dyhwAdjust::detectValueNO2);
	this->ns1__dyhwAdjust::adjustResult = NULL;
	this->ns1__dyhwAdjust::adjustTimeStart = NULL;
	this->ns1__dyhwAdjust::adjustTimeEnd = NULL;
	this->ns1__dyhwAdjust::remark = NULL;
	/* transient soap skipped */
}

void ns1__dyhwAdjust::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwAdjust::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwAdjust::gasType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwAdjust::adjustResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwAdjust::adjustTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwAdjust::adjustTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwAdjust::remark);
	/* transient soap skipped */
#endif
}

int ns1__dyhwAdjust::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__dyhwAdjust(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dyhwAdjust(struct soap *soap, const char *tag, int id, const ns1__dyhwAdjust *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__dyhwAdjust), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__dyhwAdjust::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gasType", -1, &(a->ns1__dyhwAdjust::gasType), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueNO", -1, &(a->ns1__dyhwAdjust::labelValueNO), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueNO", -1, &(a->ns1__dyhwAdjust::detectValueNO), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueNO2", -1, &(a->ns1__dyhwAdjust::labelValueNO2), ""))
		return soap->error;
	if (soap_out_double(soap, "detectValueNO2", -1, &(a->ns1__dyhwAdjust::detectValueNO2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "adjustResult", -1, &(a->ns1__dyhwAdjust::adjustResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "adjustTimeStart", -1, &(a->ns1__dyhwAdjust::adjustTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "adjustTimeEnd", -1, &(a->ns1__dyhwAdjust::adjustTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__dyhwAdjust::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__dyhwAdjust::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__dyhwAdjust(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dyhwAdjust * SOAP_FMAC4 soap_in_ns1__dyhwAdjust(struct soap *soap, const char *tag, ns1__dyhwAdjust *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__dyhwAdjust *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__dyhwAdjust, sizeof(ns1__dyhwAdjust), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__dyhwAdjust)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__dyhwAdjust *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_gasType1 = 1;
	size_t soap_flag_labelValueNO1 = 1;
	size_t soap_flag_detectValueNO1 = 1;
	size_t soap_flag_labelValueNO21 = 1;
	size_t soap_flag_detectValueNO21 = 1;
	size_t soap_flag_adjustResult1 = 1;
	size_t soap_flag_adjustTimeStart1 = 1;
	size_t soap_flag_adjustTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__dyhwAdjust::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_gasType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gasType", &(a->ns1__dyhwAdjust::gasType), "xsd:string"))
				{	soap_flag_gasType1--;
					continue;
				}
			if (soap_flag_labelValueNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueNO", &(a->ns1__dyhwAdjust::labelValueNO), "xsd:double"))
				{	soap_flag_labelValueNO1--;
					continue;
				}
			if (soap_flag_detectValueNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueNO", &(a->ns1__dyhwAdjust::detectValueNO), "xsd:double"))
				{	soap_flag_detectValueNO1--;
					continue;
				}
			if (soap_flag_labelValueNO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueNO2", &(a->ns1__dyhwAdjust::labelValueNO2), "xsd:double"))
				{	soap_flag_labelValueNO21--;
					continue;
				}
			if (soap_flag_detectValueNO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "detectValueNO2", &(a->ns1__dyhwAdjust::detectValueNO2), "xsd:double"))
				{	soap_flag_detectValueNO21--;
					continue;
				}
			if (soap_flag_adjustResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "adjustResult", &(a->ns1__dyhwAdjust::adjustResult), "xsd:string"))
				{	soap_flag_adjustResult1--;
					continue;
				}
			if (soap_flag_adjustTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "adjustTimeStart", &(a->ns1__dyhwAdjust::adjustTimeStart), "xsd:string"))
				{	soap_flag_adjustTimeStart1--;
					continue;
				}
			if (soap_flag_adjustTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "adjustTimeEnd", &(a->ns1__dyhwAdjust::adjustTimeEnd), "xsd:string"))
				{	soap_flag_adjustTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__dyhwAdjust::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__dyhwAdjust *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__dyhwAdjust, 0, sizeof(ns1__dyhwAdjust), 0, soap_copy_ns1__dyhwAdjust);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_labelValueNO1 > 0 || soap_flag_detectValueNO1 > 0 || soap_flag_labelValueNO21 > 0 || soap_flag_detectValueNO21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__dyhwAdjust::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__dyhwAdjust);
	if (this->soap_out(soap, tag?tag:"ns1:dyhwAdjust", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__dyhwAdjust::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__dyhwAdjust(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dyhwAdjust * SOAP_FMAC4 soap_get_ns1__dyhwAdjust(struct soap *soap, ns1__dyhwAdjust *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__dyhwAdjust(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__dyhwAdjust * SOAP_FMAC2 soap_instantiate_ns1__dyhwAdjust(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dyhwAdjust(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__dyhwAdjust, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__dyhwAdjust);
		if (size)
			*size = sizeof(ns1__dyhwAdjust);
		((ns1__dyhwAdjust*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__dyhwAdjust, n);
		if (size)
			*size = n * sizeof(ns1__dyhwAdjust);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__dyhwAdjust*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__dyhwAdjust*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dyhwAdjust(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dyhwAdjust %p -> %p\n", q, p));
	*(ns1__dyhwAdjust*)p = *(ns1__dyhwAdjust*)q;
}

void ns1__loadDownLogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__loadDownLogResponse::return_);
	/* transient soap skipped */
}

void ns1__loadDownLogResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__loadDownLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__loadDownLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loadDownLogResponse(struct soap *soap, const char *tag, int id, const ns1__loadDownLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loadDownLogResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__loadDownLogResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__loadDownLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__loadDownLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__loadDownLogResponse * SOAP_FMAC4 soap_in_ns1__loadDownLogResponse(struct soap *soap, const char *tag, ns1__loadDownLogResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__loadDownLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loadDownLogResponse, sizeof(ns1__loadDownLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__loadDownLogResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__loadDownLogResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__loadDownLogResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__loadDownLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loadDownLogResponse, 0, sizeof(ns1__loadDownLogResponse), 0, soap_copy_ns1__loadDownLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__loadDownLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__loadDownLogResponse);
	if (this->soap_out(soap, tag?tag:"ns1:loadDownLogResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__loadDownLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__loadDownLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__loadDownLogResponse * SOAP_FMAC4 soap_get_ns1__loadDownLogResponse(struct soap *soap, ns1__loadDownLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loadDownLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__loadDownLogResponse * SOAP_FMAC2 soap_instantiate_ns1__loadDownLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loadDownLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__loadDownLogResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__loadDownLogResponse);
		if (size)
			*size = sizeof(ns1__loadDownLogResponse);
		((ns1__loadDownLogResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__loadDownLogResponse, n);
		if (size)
			*size = n * sizeof(ns1__loadDownLogResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__loadDownLogResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__loadDownLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__loadDownLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__loadDownLogResponse %p -> %p\n", q, p));
	*(ns1__loadDownLogResponse*)p = *(ns1__loadDownLogResponse*)q;
}

void ns1__loadDownLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__loadDownLog::businessId = NULL;
	this->ns1__loadDownLog::registCode = NULL;
	soap_default_int(soap, &this->ns1__loadDownLog::inspectNum);
	soap_default_double(soap, &this->ns1__loadDownLog::calVelMaxHp);
	soap_default_double(soap, &this->ns1__loadDownLog::actVelMaxHp);
	soap_default_double(soap, &this->ns1__loadDownLog::powerPerSec);
	soap_default_double(soap, &this->ns1__loadDownLog::speedPerSec);
	soap_default_double(soap, &this->ns1__loadDownLog::actMaxPower);
	soap_default_double(soap, &this->ns1__loadDownLog::rotateSpeed);
	soap_default_double(soap, &this->ns1__loadDownLog::envirTemperature);
	soap_default_double(soap, &this->ns1__loadDownLog::envirAirPressure);
	soap_default_double(soap, &this->ns1__loadDownLog::envirHumidity);
	soap_default_double(soap, &this->ns1__loadDownLog::powerCorrect);
	soap_default_double(soap, &this->ns1__loadDownLog::corMaxPower);
	soap_default_double(soap, &this->ns1__loadDownLog::smokeK100);
	soap_default_double(soap, &this->ns1__loadDownLog::smokeK90);
	soap_default_double(soap, &this->ns1__loadDownLog::smokeK80);
	soap_default_double(soap, &this->ns1__loadDownLog::speedK100);
	soap_default_double(soap, &this->ns1__loadDownLog::speedK90);
	soap_default_double(soap, &this->ns1__loadDownLog::speedK80);
	soap_default_double(soap, &this->ns1__loadDownLog::NO80);
	soap_default_double(soap, &this->ns1__loadDownLog::NO280);
	soap_default_double(soap, &this->ns1__loadDownLog::CO280);
	soap_default_double(soap, &this->ns1__loadDownLog::NOX80);
	soap_default_double(soap, &this->ns1__loadDownLog::ydjjcswd);
	soap_default_double(soap, &this->ns1__loadDownLog::qtfxyjcswd);
	soap_default_double(soap, &this->ns1__loadDownLog::zhlwd);
	soap_default_double(soap, &this->ns1__loadDownLog::ydjjcsqy);
	/* transient soap skipped */
}

void ns1__loadDownLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__loadDownLog::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__loadDownLog::registCode);
	/* transient soap skipped */
#endif
}

int ns1__loadDownLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__loadDownLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loadDownLog(struct soap *soap, const char *tag, int id, const ns1__loadDownLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loadDownLog), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__loadDownLog::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__loadDownLog::registCode), ""))
		return soap->error;
	if (soap_out_int(soap, "inspectNum", -1, &(a->ns1__loadDownLog::inspectNum), ""))
		return soap->error;
	if (soap_out_double(soap, "calVelMaxHp", -1, &(a->ns1__loadDownLog::calVelMaxHp), ""))
		return soap->error;
	if (soap_out_double(soap, "actVelMaxHp", -1, &(a->ns1__loadDownLog::actVelMaxHp), ""))
		return soap->error;
	if (soap_out_double(soap, "powerPerSec", -1, &(a->ns1__loadDownLog::powerPerSec), ""))
		return soap->error;
	if (soap_out_double(soap, "speedPerSec", -1, &(a->ns1__loadDownLog::speedPerSec), ""))
		return soap->error;
	if (soap_out_double(soap, "actMaxPower", -1, &(a->ns1__loadDownLog::actMaxPower), ""))
		return soap->error;
	if (soap_out_double(soap, "rotateSpeed", -1, &(a->ns1__loadDownLog::rotateSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "envirTemperature", -1, &(a->ns1__loadDownLog::envirTemperature), ""))
		return soap->error;
	if (soap_out_double(soap, "envirAirPressure", -1, &(a->ns1__loadDownLog::envirAirPressure), ""))
		return soap->error;
	if (soap_out_double(soap, "envirHumidity", -1, &(a->ns1__loadDownLog::envirHumidity), ""))
		return soap->error;
	if (soap_out_double(soap, "powerCorrect", -1, &(a->ns1__loadDownLog::powerCorrect), ""))
		return soap->error;
	if (soap_out_double(soap, "corMaxPower", -1, &(a->ns1__loadDownLog::corMaxPower), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeK100", -1, &(a->ns1__loadDownLog::smokeK100), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeK90", -1, &(a->ns1__loadDownLog::smokeK90), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeK80", -1, &(a->ns1__loadDownLog::smokeK80), ""))
		return soap->error;
	if (soap_out_double(soap, "speedK100", -1, &(a->ns1__loadDownLog::speedK100), ""))
		return soap->error;
	if (soap_out_double(soap, "speedK90", -1, &(a->ns1__loadDownLog::speedK90), ""))
		return soap->error;
	if (soap_out_double(soap, "speedK80", -1, &(a->ns1__loadDownLog::speedK80), ""))
		return soap->error;
	if (soap_out_double(soap, "NO80", -1, &(a->ns1__loadDownLog::NO80), ""))
		return soap->error;
	if (soap_out_double(soap, "NO280", -1, &(a->ns1__loadDownLog::NO280), ""))
		return soap->error;
	if (soap_out_double(soap, "CO280", -1, &(a->ns1__loadDownLog::CO280), ""))
		return soap->error;
	if (soap_out_double(soap, "NOX80", -1, &(a->ns1__loadDownLog::NOX80), ""))
		return soap->error;
	if (soap_out_double(soap, "ydjjcswd", -1, &(a->ns1__loadDownLog::ydjjcswd), ""))
		return soap->error;
	if (soap_out_double(soap, "qtfxyjcswd", -1, &(a->ns1__loadDownLog::qtfxyjcswd), ""))
		return soap->error;
	if (soap_out_double(soap, "zhlwd", -1, &(a->ns1__loadDownLog::zhlwd), ""))
		return soap->error;
	if (soap_out_double(soap, "ydjjcsqy", -1, &(a->ns1__loadDownLog::ydjjcsqy), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__loadDownLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__loadDownLog(soap, tag, this, type);
}

SOAP_FMAC3 ns1__loadDownLog * SOAP_FMAC4 soap_in_ns1__loadDownLog(struct soap *soap, const char *tag, ns1__loadDownLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__loadDownLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loadDownLog, sizeof(ns1__loadDownLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__loadDownLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__loadDownLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_inspectNum1 = 1;
	size_t soap_flag_calVelMaxHp1 = 1;
	size_t soap_flag_actVelMaxHp1 = 1;
	size_t soap_flag_powerPerSec1 = 1;
	size_t soap_flag_speedPerSec1 = 1;
	size_t soap_flag_actMaxPower1 = 1;
	size_t soap_flag_rotateSpeed1 = 1;
	size_t soap_flag_envirTemperature1 = 1;
	size_t soap_flag_envirAirPressure1 = 1;
	size_t soap_flag_envirHumidity1 = 1;
	size_t soap_flag_powerCorrect1 = 1;
	size_t soap_flag_corMaxPower1 = 1;
	size_t soap_flag_smokeK1001 = 1;
	size_t soap_flag_smokeK901 = 1;
	size_t soap_flag_smokeK801 = 1;
	size_t soap_flag_speedK1001 = 1;
	size_t soap_flag_speedK901 = 1;
	size_t soap_flag_speedK801 = 1;
	size_t soap_flag_NO801 = 1;
	size_t soap_flag_NO2801 = 1;
	size_t soap_flag_CO2801 = 1;
	size_t soap_flag_NOX801 = 1;
	size_t soap_flag_ydjjcswd1 = 1;
	size_t soap_flag_qtfxyjcswd1 = 1;
	size_t soap_flag_zhlwd1 = 1;
	size_t soap_flag_ydjjcsqy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__loadDownLog::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__loadDownLog::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_inspectNum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inspectNum", &(a->ns1__loadDownLog::inspectNum), "xsd:int"))
				{	soap_flag_inspectNum1--;
					continue;
				}
			if (soap_flag_calVelMaxHp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "calVelMaxHp", &(a->ns1__loadDownLog::calVelMaxHp), "xsd:double"))
				{	soap_flag_calVelMaxHp1--;
					continue;
				}
			if (soap_flag_actVelMaxHp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "actVelMaxHp", &(a->ns1__loadDownLog::actVelMaxHp), "xsd:double"))
				{	soap_flag_actVelMaxHp1--;
					continue;
				}
			if (soap_flag_powerPerSec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "powerPerSec", &(a->ns1__loadDownLog::powerPerSec), "xsd:double"))
				{	soap_flag_powerPerSec1--;
					continue;
				}
			if (soap_flag_speedPerSec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "speedPerSec", &(a->ns1__loadDownLog::speedPerSec), "xsd:double"))
				{	soap_flag_speedPerSec1--;
					continue;
				}
			if (soap_flag_actMaxPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "actMaxPower", &(a->ns1__loadDownLog::actMaxPower), "xsd:double"))
				{	soap_flag_actMaxPower1--;
					continue;
				}
			if (soap_flag_rotateSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "rotateSpeed", &(a->ns1__loadDownLog::rotateSpeed), "xsd:double"))
				{	soap_flag_rotateSpeed1--;
					continue;
				}
			if (soap_flag_envirTemperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "envirTemperature", &(a->ns1__loadDownLog::envirTemperature), "xsd:double"))
				{	soap_flag_envirTemperature1--;
					continue;
				}
			if (soap_flag_envirAirPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "envirAirPressure", &(a->ns1__loadDownLog::envirAirPressure), "xsd:double"))
				{	soap_flag_envirAirPressure1--;
					continue;
				}
			if (soap_flag_envirHumidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "envirHumidity", &(a->ns1__loadDownLog::envirHumidity), "xsd:double"))
				{	soap_flag_envirHumidity1--;
					continue;
				}
			if (soap_flag_powerCorrect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "powerCorrect", &(a->ns1__loadDownLog::powerCorrect), "xsd:double"))
				{	soap_flag_powerCorrect1--;
					continue;
				}
			if (soap_flag_corMaxPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "corMaxPower", &(a->ns1__loadDownLog::corMaxPower), "xsd:double"))
				{	soap_flag_corMaxPower1--;
					continue;
				}
			if (soap_flag_smokeK1001 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeK100", &(a->ns1__loadDownLog::smokeK100), "xsd:double"))
				{	soap_flag_smokeK1001--;
					continue;
				}
			if (soap_flag_smokeK901 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeK90", &(a->ns1__loadDownLog::smokeK90), "xsd:double"))
				{	soap_flag_smokeK901--;
					continue;
				}
			if (soap_flag_smokeK801 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeK80", &(a->ns1__loadDownLog::smokeK80), "xsd:double"))
				{	soap_flag_smokeK801--;
					continue;
				}
			if (soap_flag_speedK1001 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "speedK100", &(a->ns1__loadDownLog::speedK100), "xsd:double"))
				{	soap_flag_speedK1001--;
					continue;
				}
			if (soap_flag_speedK901 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "speedK90", &(a->ns1__loadDownLog::speedK90), "xsd:double"))
				{	soap_flag_speedK901--;
					continue;
				}
			if (soap_flag_speedK801 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "speedK80", &(a->ns1__loadDownLog::speedK80), "xsd:double"))
				{	soap_flag_speedK801--;
					continue;
				}
			if (soap_flag_NO801 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "NO80", &(a->ns1__loadDownLog::NO80), "xsd:double"))
				{	soap_flag_NO801--;
					continue;
				}
			if (soap_flag_NO2801 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "NO280", &(a->ns1__loadDownLog::NO280), "xsd:double"))
				{	soap_flag_NO2801--;
					continue;
				}
			if (soap_flag_CO2801 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CO280", &(a->ns1__loadDownLog::CO280), "xsd:double"))
				{	soap_flag_CO2801--;
					continue;
				}
			if (soap_flag_NOX801 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "NOX80", &(a->ns1__loadDownLog::NOX80), "xsd:double"))
				{	soap_flag_NOX801--;
					continue;
				}
			if (soap_flag_ydjjcswd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ydjjcswd", &(a->ns1__loadDownLog::ydjjcswd), "xsd:double"))
				{	soap_flag_ydjjcswd1--;
					continue;
				}
			if (soap_flag_qtfxyjcswd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "qtfxyjcswd", &(a->ns1__loadDownLog::qtfxyjcswd), "xsd:double"))
				{	soap_flag_qtfxyjcswd1--;
					continue;
				}
			if (soap_flag_zhlwd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zhlwd", &(a->ns1__loadDownLog::zhlwd), "xsd:double"))
				{	soap_flag_zhlwd1--;
					continue;
				}
			if (soap_flag_ydjjcsqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ydjjcsqy", &(a->ns1__loadDownLog::ydjjcsqy), "xsd:double"))
				{	soap_flag_ydjjcsqy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__loadDownLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loadDownLog, 0, sizeof(ns1__loadDownLog), 0, soap_copy_ns1__loadDownLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_inspectNum1 > 0 || soap_flag_calVelMaxHp1 > 0 || soap_flag_actVelMaxHp1 > 0 || soap_flag_powerPerSec1 > 0 || soap_flag_speedPerSec1 > 0 || soap_flag_actMaxPower1 > 0 || soap_flag_rotateSpeed1 > 0 || soap_flag_envirTemperature1 > 0 || soap_flag_envirAirPressure1 > 0 || soap_flag_envirHumidity1 > 0 || soap_flag_powerCorrect1 > 0 || soap_flag_corMaxPower1 > 0 || soap_flag_smokeK1001 > 0 || soap_flag_smokeK901 > 0 || soap_flag_smokeK801 > 0 || soap_flag_speedK1001 > 0 || soap_flag_speedK901 > 0 || soap_flag_speedK801 > 0 || soap_flag_NO801 > 0 || soap_flag_NO2801 > 0 || soap_flag_CO2801 > 0 || soap_flag_NOX801 > 0 || soap_flag_ydjjcswd1 > 0 || soap_flag_qtfxyjcswd1 > 0 || soap_flag_zhlwd1 > 0 || soap_flag_ydjjcsqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__loadDownLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__loadDownLog);
	if (this->soap_out(soap, tag?tag:"ns1:loadDownLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__loadDownLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__loadDownLog(soap, this, tag, type);
}

SOAP_FMAC3 ns1__loadDownLog * SOAP_FMAC4 soap_get_ns1__loadDownLog(struct soap *soap, ns1__loadDownLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loadDownLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__loadDownLog * SOAP_FMAC2 soap_instantiate_ns1__loadDownLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loadDownLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__loadDownLog, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__loadDownLog);
		if (size)
			*size = sizeof(ns1__loadDownLog);
		((ns1__loadDownLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__loadDownLog, n);
		if (size)
			*size = n * sizeof(ns1__loadDownLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__loadDownLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__loadDownLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__loadDownLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__loadDownLog %p -> %p\n", q, p));
	*(ns1__loadDownLog*)p = *(ns1__loadDownLog*)q;
}

void ns1__dyhwSelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__dyhwSelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__dyhwSelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__dyhwSelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__dyhwSelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dyhwSelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__dyhwSelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__dyhwSelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__dyhwSelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__dyhwSelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__dyhwSelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dyhwSelfcheckResponse * SOAP_FMAC4 soap_in_ns1__dyhwSelfcheckResponse(struct soap *soap, const char *tag, ns1__dyhwSelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__dyhwSelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__dyhwSelfcheckResponse, sizeof(ns1__dyhwSelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__dyhwSelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__dyhwSelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__dyhwSelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__dyhwSelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__dyhwSelfcheckResponse, 0, sizeof(ns1__dyhwSelfcheckResponse), 0, soap_copy_ns1__dyhwSelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__dyhwSelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__dyhwSelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:dyhwSelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__dyhwSelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__dyhwSelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dyhwSelfcheckResponse * SOAP_FMAC4 soap_get_ns1__dyhwSelfcheckResponse(struct soap *soap, ns1__dyhwSelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__dyhwSelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__dyhwSelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__dyhwSelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dyhwSelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__dyhwSelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__dyhwSelfcheckResponse);
		if (size)
			*size = sizeof(ns1__dyhwSelfcheckResponse);
		((ns1__dyhwSelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__dyhwSelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__dyhwSelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__dyhwSelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__dyhwSelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dyhwSelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dyhwSelfcheckResponse %p -> %p\n", q, p));
	*(ns1__dyhwSelfcheckResponse*)p = *(ns1__dyhwSelfcheckResponse*)q;
}

void ns1__dyhwSelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__dyhwSelfcheck::registCode = NULL;
	this->ns1__dyhwSelfcheck::checkResult = NULL;
	this->ns1__dyhwSelfcheck::checkTimeStart = NULL;
	this->ns1__dyhwSelfcheck::checkTimeEnd = NULL;
	this->ns1__dyhwSelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__dyhwSelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwSelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwSelfcheck::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwSelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwSelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__dyhwSelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__dyhwSelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__dyhwSelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dyhwSelfcheck(struct soap *soap, const char *tag, int id, const ns1__dyhwSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__dyhwSelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__dyhwSelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__dyhwSelfcheck::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__dyhwSelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__dyhwSelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__dyhwSelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__dyhwSelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__dyhwSelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dyhwSelfcheck * SOAP_FMAC4 soap_in_ns1__dyhwSelfcheck(struct soap *soap, const char *tag, ns1__dyhwSelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__dyhwSelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__dyhwSelfcheck, sizeof(ns1__dyhwSelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__dyhwSelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__dyhwSelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__dyhwSelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__dyhwSelfcheck::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__dyhwSelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__dyhwSelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__dyhwSelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__dyhwSelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__dyhwSelfcheck, 0, sizeof(ns1__dyhwSelfcheck), 0, soap_copy_ns1__dyhwSelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__dyhwSelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__dyhwSelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:dyhwSelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__dyhwSelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__dyhwSelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dyhwSelfcheck * SOAP_FMAC4 soap_get_ns1__dyhwSelfcheck(struct soap *soap, ns1__dyhwSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__dyhwSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__dyhwSelfcheck * SOAP_FMAC2 soap_instantiate_ns1__dyhwSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dyhwSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__dyhwSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__dyhwSelfcheck);
		if (size)
			*size = sizeof(ns1__dyhwSelfcheck);
		((ns1__dyhwSelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__dyhwSelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__dyhwSelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__dyhwSelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__dyhwSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dyhwSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dyhwSelfcheck %p -> %p\n", q, p));
	*(ns1__dyhwSelfcheck*)p = *(ns1__dyhwSelfcheck*)q;
}

void ns1__ydjSelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__ydjSelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__ydjSelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__ydjSelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ydjSelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ydjSelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__ydjSelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ydjSelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__ydjSelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ydjSelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ydjSelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ydjSelfcheckResponse * SOAP_FMAC4 soap_in_ns1__ydjSelfcheckResponse(struct soap *soap, const char *tag, ns1__ydjSelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ydjSelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ydjSelfcheckResponse, sizeof(ns1__ydjSelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ydjSelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ydjSelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__ydjSelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ydjSelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ydjSelfcheckResponse, 0, sizeof(ns1__ydjSelfcheckResponse), 0, soap_copy_ns1__ydjSelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ydjSelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__ydjSelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ydjSelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ydjSelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ydjSelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ydjSelfcheckResponse * SOAP_FMAC4 soap_get_ns1__ydjSelfcheckResponse(struct soap *soap, ns1__ydjSelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ydjSelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ydjSelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__ydjSelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ydjSelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ydjSelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ydjSelfcheckResponse);
		if (size)
			*size = sizeof(ns1__ydjSelfcheckResponse);
		((ns1__ydjSelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__ydjSelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__ydjSelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__ydjSelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__ydjSelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ydjSelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ydjSelfcheckResponse %p -> %p\n", q, p));
	*(ns1__ydjSelfcheckResponse*)p = *(ns1__ydjSelfcheckResponse*)q;
}

void ns1__ydjSelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ydjSelfcheck::registCode = NULL;
	this->ns1__ydjSelfcheck::zeroResult = NULL;
	soap_default_double(soap, &this->ns1__ydjSelfcheck::labelValueN30);
	soap_default_double(soap, &this->ns1__ydjSelfcheck::labelValueN50);
	soap_default_double(soap, &this->ns1__ydjSelfcheck::N30);
	soap_default_double(soap, &this->ns1__ydjSelfcheck::N50);
	soap_default_double(soap, &this->ns1__ydjSelfcheck::error30);
	soap_default_double(soap, &this->ns1__ydjSelfcheck::error50);
	this->ns1__ydjSelfcheck::checkResult = NULL;
	this->ns1__ydjSelfcheck::checkTimeStart = NULL;
	this->ns1__ydjSelfcheck::checkTimeEnd = NULL;
	this->ns1__ydjSelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__ydjSelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjSelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjSelfcheck::zeroResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjSelfcheck::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjSelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjSelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjSelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__ydjSelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ydjSelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ydjSelfcheck(struct soap *soap, const char *tag, int id, const ns1__ydjSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ydjSelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__ydjSelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "zeroResult", -1, &(a->ns1__ydjSelfcheck::zeroResult), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueN30", -1, &(a->ns1__ydjSelfcheck::labelValueN30), ""))
		return soap->error;
	if (soap_out_double(soap, "labelValueN50", -1, &(a->ns1__ydjSelfcheck::labelValueN50), ""))
		return soap->error;
	if (soap_out_double(soap, "N30", -1, &(a->ns1__ydjSelfcheck::N30), ""))
		return soap->error;
	if (soap_out_double(soap, "N50", -1, &(a->ns1__ydjSelfcheck::N50), ""))
		return soap->error;
	if (soap_out_double(soap, "error30", -1, &(a->ns1__ydjSelfcheck::error30), ""))
		return soap->error;
	if (soap_out_double(soap, "error50", -1, &(a->ns1__ydjSelfcheck::error50), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__ydjSelfcheck::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__ydjSelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__ydjSelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__ydjSelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ydjSelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ydjSelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ydjSelfcheck * SOAP_FMAC4 soap_in_ns1__ydjSelfcheck(struct soap *soap, const char *tag, ns1__ydjSelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ydjSelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ydjSelfcheck, sizeof(ns1__ydjSelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ydjSelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ydjSelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_zeroResult1 = 1;
	size_t soap_flag_labelValueN301 = 1;
	size_t soap_flag_labelValueN501 = 1;
	size_t soap_flag_N301 = 1;
	size_t soap_flag_N501 = 1;
	size_t soap_flag_error301 = 1;
	size_t soap_flag_error501 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__ydjSelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_zeroResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "zeroResult", &(a->ns1__ydjSelfcheck::zeroResult), "xsd:string"))
				{	soap_flag_zeroResult1--;
					continue;
				}
			if (soap_flag_labelValueN301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueN30", &(a->ns1__ydjSelfcheck::labelValueN30), "xsd:double"))
				{	soap_flag_labelValueN301--;
					continue;
				}
			if (soap_flag_labelValueN501 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "labelValueN50", &(a->ns1__ydjSelfcheck::labelValueN50), "xsd:double"))
				{	soap_flag_labelValueN501--;
					continue;
				}
			if (soap_flag_N301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "N30", &(a->ns1__ydjSelfcheck::N30), "xsd:double"))
				{	soap_flag_N301--;
					continue;
				}
			if (soap_flag_N501 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "N50", &(a->ns1__ydjSelfcheck::N50), "xsd:double"))
				{	soap_flag_N501--;
					continue;
				}
			if (soap_flag_error301 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "error30", &(a->ns1__ydjSelfcheck::error30), "xsd:double"))
				{	soap_flag_error301--;
					continue;
				}
			if (soap_flag_error501 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "error50", &(a->ns1__ydjSelfcheck::error50), "xsd:double"))
				{	soap_flag_error501--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__ydjSelfcheck::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__ydjSelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__ydjSelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__ydjSelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ydjSelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ydjSelfcheck, 0, sizeof(ns1__ydjSelfcheck), 0, soap_copy_ns1__ydjSelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_labelValueN301 > 0 || soap_flag_labelValueN501 > 0 || soap_flag_N301 > 0 || soap_flag_N501 > 0 || soap_flag_error301 > 0 || soap_flag_error501 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ydjSelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__ydjSelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:ydjSelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ydjSelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ydjSelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ydjSelfcheck * SOAP_FMAC4 soap_get_ns1__ydjSelfcheck(struct soap *soap, ns1__ydjSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ydjSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ydjSelfcheck * SOAP_FMAC2 soap_instantiate_ns1__ydjSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ydjSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ydjSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ydjSelfcheck);
		if (size)
			*size = sizeof(ns1__ydjSelfcheck);
		((ns1__ydjSelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__ydjSelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__ydjSelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__ydjSelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__ydjSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ydjSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ydjSelfcheck %p -> %p\n", q, p));
	*(ns1__ydjSelfcheck*)p = *(ns1__ydjSelfcheck*)q;
}

void ns1__vmasLogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__vmasLogResponse::return_);
	/* transient soap skipped */
}

void ns1__vmasLogResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__vmasLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__vmasLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__vmasLogResponse(struct soap *soap, const char *tag, int id, const ns1__vmasLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__vmasLogResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__vmasLogResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__vmasLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__vmasLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__vmasLogResponse * SOAP_FMAC4 soap_in_ns1__vmasLogResponse(struct soap *soap, const char *tag, ns1__vmasLogResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__vmasLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__vmasLogResponse, sizeof(ns1__vmasLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__vmasLogResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__vmasLogResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__vmasLogResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__vmasLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__vmasLogResponse, 0, sizeof(ns1__vmasLogResponse), 0, soap_copy_ns1__vmasLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__vmasLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__vmasLogResponse);
	if (this->soap_out(soap, tag?tag:"ns1:vmasLogResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__vmasLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__vmasLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__vmasLogResponse * SOAP_FMAC4 soap_get_ns1__vmasLogResponse(struct soap *soap, ns1__vmasLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__vmasLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__vmasLogResponse * SOAP_FMAC2 soap_instantiate_ns1__vmasLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__vmasLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__vmasLogResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__vmasLogResponse);
		if (size)
			*size = sizeof(ns1__vmasLogResponse);
		((ns1__vmasLogResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__vmasLogResponse, n);
		if (size)
			*size = n * sizeof(ns1__vmasLogResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__vmasLogResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__vmasLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__vmasLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__vmasLogResponse %p -> %p\n", q, p));
	*(ns1__vmasLogResponse*)p = *(ns1__vmasLogResponse*)q;
}

void ns1__vmasLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__vmasLog::businessId = NULL;
	this->ns1__vmasLog::registCode = NULL;
	soap_default_int(soap, &this->ns1__vmasLog::inspectNum);
	soap_default_double(soap, &this->ns1__vmasLog::flowHC);
	soap_default_double(soap, &this->ns1__vmasLog::flowCO);
	soap_default_double(soap, &this->ns1__vmasLog::flowCO2);
	soap_default_double(soap, &this->ns1__vmasLog::flowNO);
	soap_default_double(soap, &this->ns1__vmasLog::analyserO2);
	soap_default_double(soap, &this->ns1__vmasLog::flowmeterO2);
	soap_default_double(soap, &this->ns1__vmasLog::envO2);
	soap_default_double(soap, &this->ns1__vmasLog::actFlow);
	soap_default_double(soap, &this->ns1__vmasLog::stdFlow);
	soap_default_double(soap, &this->ns1__vmasLog::tailFlow);
	soap_default_double(soap, &this->ns1__vmasLog::weightHC);
	soap_default_double(soap, &this->ns1__vmasLog::weightCO);
	soap_default_double(soap, &this->ns1__vmasLog::weightNO);
	soap_default_double(soap, &this->ns1__vmasLog::lineSpeed);
	soap_default_double(soap, &this->ns1__vmasLog::totalPower);
	soap_default_double(soap, &this->ns1__vmasLog::parasPower);
	soap_default_double(soap, &this->ns1__vmasLog::indicPower);
	soap_default_double(soap, &this->ns1__vmasLog::flowAirPressure);
	soap_default_double(soap, &this->ns1__vmasLog::flowTemperature);
	soap_default_double(soap, &this->ns1__vmasLog::envirTemperature);
	soap_default_double(soap, &this->ns1__vmasLog::envirAirPressure);
	soap_default_double(soap, &this->ns1__vmasLog::envirHumidity);
	soap_default_double(soap, &this->ns1__vmasLog::diluteCorrect);
	soap_default_double(soap, &this->ns1__vmasLog::humidityCorrect);
	soap_default_double(soap, &this->ns1__vmasLog::diluteRatio);
	soap_default_double(soap, &this->ns1__vmasLog::lambdaValue);
	soap_default_double(soap, &this->ns1__vmasLog::qtfxyjcswd);
	soap_default_double(soap, &this->ns1__vmasLog::zhlwd);
	soap_default_double(soap, &this->ns1__vmasLog::weightNO1);
	soap_default_double(soap, &this->ns1__vmasLog::weightNO2);
	/* transient soap skipped */
}

void ns1__vmasLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__vmasLog::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__vmasLog::registCode);
	/* transient soap skipped */
#endif
}

int ns1__vmasLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__vmasLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__vmasLog(struct soap *soap, const char *tag, int id, const ns1__vmasLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__vmasLog), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__vmasLog::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__vmasLog::registCode), ""))
		return soap->error;
	if (soap_out_int(soap, "inspectNum", -1, &(a->ns1__vmasLog::inspectNum), ""))
		return soap->error;
	if (soap_out_double(soap, "flowHC", -1, &(a->ns1__vmasLog::flowHC), ""))
		return soap->error;
	if (soap_out_double(soap, "flowCO", -1, &(a->ns1__vmasLog::flowCO), ""))
		return soap->error;
	if (soap_out_double(soap, "flowCO2", -1, &(a->ns1__vmasLog::flowCO2), ""))
		return soap->error;
	if (soap_out_double(soap, "flowNO", -1, &(a->ns1__vmasLog::flowNO), ""))
		return soap->error;
	if (soap_out_double(soap, "analyserO2", -1, &(a->ns1__vmasLog::analyserO2), ""))
		return soap->error;
	if (soap_out_double(soap, "flowmeterO2", -1, &(a->ns1__vmasLog::flowmeterO2), ""))
		return soap->error;
	if (soap_out_double(soap, "envO2", -1, &(a->ns1__vmasLog::envO2), ""))
		return soap->error;
	if (soap_out_double(soap, "actFlow", -1, &(a->ns1__vmasLog::actFlow), ""))
		return soap->error;
	if (soap_out_double(soap, "stdFlow", -1, &(a->ns1__vmasLog::stdFlow), ""))
		return soap->error;
	if (soap_out_double(soap, "tailFlow", -1, &(a->ns1__vmasLog::tailFlow), ""))
		return soap->error;
	if (soap_out_double(soap, "weightHC", -1, &(a->ns1__vmasLog::weightHC), ""))
		return soap->error;
	if (soap_out_double(soap, "weightCO", -1, &(a->ns1__vmasLog::weightCO), ""))
		return soap->error;
	if (soap_out_double(soap, "weightNO", -1, &(a->ns1__vmasLog::weightNO), ""))
		return soap->error;
	if (soap_out_double(soap, "lineSpeed", -1, &(a->ns1__vmasLog::lineSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "totalPower", -1, &(a->ns1__vmasLog::totalPower), ""))
		return soap->error;
	if (soap_out_double(soap, "parasPower", -1, &(a->ns1__vmasLog::parasPower), ""))
		return soap->error;
	if (soap_out_double(soap, "indicPower", -1, &(a->ns1__vmasLog::indicPower), ""))
		return soap->error;
	if (soap_out_double(soap, "flowAirPressure", -1, &(a->ns1__vmasLog::flowAirPressure), ""))
		return soap->error;
	if (soap_out_double(soap, "flowTemperature", -1, &(a->ns1__vmasLog::flowTemperature), ""))
		return soap->error;
	if (soap_out_double(soap, "envirTemperature", -1, &(a->ns1__vmasLog::envirTemperature), ""))
		return soap->error;
	if (soap_out_double(soap, "envirAirPressure", -1, &(a->ns1__vmasLog::envirAirPressure), ""))
		return soap->error;
	if (soap_out_double(soap, "envirHumidity", -1, &(a->ns1__vmasLog::envirHumidity), ""))
		return soap->error;
	if (soap_out_double(soap, "diluteCorrect", -1, &(a->ns1__vmasLog::diluteCorrect), ""))
		return soap->error;
	if (soap_out_double(soap, "humidityCorrect", -1, &(a->ns1__vmasLog::humidityCorrect), ""))
		return soap->error;
	if (soap_out_double(soap, "diluteRatio", -1, &(a->ns1__vmasLog::diluteRatio), ""))
		return soap->error;
	if (soap_out_double(soap, "lambdaValue", -1, &(a->ns1__vmasLog::lambdaValue), ""))
		return soap->error;
	if (soap_out_double(soap, "qtfxyjcswd", -1, &(a->ns1__vmasLog::qtfxyjcswd), ""))
		return soap->error;
	if (soap_out_double(soap, "zhlwd", -1, &(a->ns1__vmasLog::zhlwd), ""))
		return soap->error;
	if (soap_out_double(soap, "weightNO1", -1, &(a->ns1__vmasLog::weightNO1), ""))
		return soap->error;
	if (soap_out_double(soap, "weightNO2", -1, &(a->ns1__vmasLog::weightNO2), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__vmasLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__vmasLog(soap, tag, this, type);
}

SOAP_FMAC3 ns1__vmasLog * SOAP_FMAC4 soap_in_ns1__vmasLog(struct soap *soap, const char *tag, ns1__vmasLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__vmasLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__vmasLog, sizeof(ns1__vmasLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__vmasLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__vmasLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_inspectNum1 = 1;
	size_t soap_flag_flowHC1 = 1;
	size_t soap_flag_flowCO1 = 1;
	size_t soap_flag_flowCO21 = 1;
	size_t soap_flag_flowNO1 = 1;
	size_t soap_flag_analyserO21 = 1;
	size_t soap_flag_flowmeterO21 = 1;
	size_t soap_flag_envO21 = 1;
	size_t soap_flag_actFlow1 = 1;
	size_t soap_flag_stdFlow1 = 1;
	size_t soap_flag_tailFlow1 = 1;
	size_t soap_flag_weightHC1 = 1;
	size_t soap_flag_weightCO1 = 1;
	size_t soap_flag_weightNO1 = 1;
	size_t soap_flag_lineSpeed1 = 1;
	size_t soap_flag_totalPower1 = 1;
	size_t soap_flag_parasPower1 = 1;
	size_t soap_flag_indicPower1 = 1;
	size_t soap_flag_flowAirPressure1 = 1;
	size_t soap_flag_flowTemperature1 = 1;
	size_t soap_flag_envirTemperature1 = 1;
	size_t soap_flag_envirAirPressure1 = 1;
	size_t soap_flag_envirHumidity1 = 1;
	size_t soap_flag_diluteCorrect1 = 1;
	size_t soap_flag_humidityCorrect1 = 1;
	size_t soap_flag_diluteRatio1 = 1;
	size_t soap_flag_lambdaValue1 = 1;
	size_t soap_flag_qtfxyjcswd1 = 1;
	size_t soap_flag_zhlwd1 = 1;
	size_t soap_flag_weightNO11 = 1;
	size_t soap_flag_weightNO21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__vmasLog::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__vmasLog::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_inspectNum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inspectNum", &(a->ns1__vmasLog::inspectNum), "xsd:int"))
				{	soap_flag_inspectNum1--;
					continue;
				}
			if (soap_flag_flowHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowHC", &(a->ns1__vmasLog::flowHC), "xsd:double"))
				{	soap_flag_flowHC1--;
					continue;
				}
			if (soap_flag_flowCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowCO", &(a->ns1__vmasLog::flowCO), "xsd:double"))
				{	soap_flag_flowCO1--;
					continue;
				}
			if (soap_flag_flowCO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowCO2", &(a->ns1__vmasLog::flowCO2), "xsd:double"))
				{	soap_flag_flowCO21--;
					continue;
				}
			if (soap_flag_flowNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowNO", &(a->ns1__vmasLog::flowNO), "xsd:double"))
				{	soap_flag_flowNO1--;
					continue;
				}
			if (soap_flag_analyserO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "analyserO2", &(a->ns1__vmasLog::analyserO2), "xsd:double"))
				{	soap_flag_analyserO21--;
					continue;
				}
			if (soap_flag_flowmeterO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowmeterO2", &(a->ns1__vmasLog::flowmeterO2), "xsd:double"))
				{	soap_flag_flowmeterO21--;
					continue;
				}
			if (soap_flag_envO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "envO2", &(a->ns1__vmasLog::envO2), "xsd:double"))
				{	soap_flag_envO21--;
					continue;
				}
			if (soap_flag_actFlow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "actFlow", &(a->ns1__vmasLog::actFlow), "xsd:double"))
				{	soap_flag_actFlow1--;
					continue;
				}
			if (soap_flag_stdFlow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "stdFlow", &(a->ns1__vmasLog::stdFlow), "xsd:double"))
				{	soap_flag_stdFlow1--;
					continue;
				}
			if (soap_flag_tailFlow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "tailFlow", &(a->ns1__vmasLog::tailFlow), "xsd:double"))
				{	soap_flag_tailFlow1--;
					continue;
				}
			if (soap_flag_weightHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "weightHC", &(a->ns1__vmasLog::weightHC), "xsd:double"))
				{	soap_flag_weightHC1--;
					continue;
				}
			if (soap_flag_weightCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "weightCO", &(a->ns1__vmasLog::weightCO), "xsd:double"))
				{	soap_flag_weightCO1--;
					continue;
				}
			if (soap_flag_weightNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "weightNO", &(a->ns1__vmasLog::weightNO), "xsd:double"))
				{	soap_flag_weightNO1--;
					continue;
				}
			if (soap_flag_lineSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lineSpeed", &(a->ns1__vmasLog::lineSpeed), "xsd:double"))
				{	soap_flag_lineSpeed1--;
					continue;
				}
			if (soap_flag_totalPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "totalPower", &(a->ns1__vmasLog::totalPower), "xsd:double"))
				{	soap_flag_totalPower1--;
					continue;
				}
			if (soap_flag_parasPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "parasPower", &(a->ns1__vmasLog::parasPower), "xsd:double"))
				{	soap_flag_parasPower1--;
					continue;
				}
			if (soap_flag_indicPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "indicPower", &(a->ns1__vmasLog::indicPower), "xsd:double"))
				{	soap_flag_indicPower1--;
					continue;
				}
			if (soap_flag_flowAirPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowAirPressure", &(a->ns1__vmasLog::flowAirPressure), "xsd:double"))
				{	soap_flag_flowAirPressure1--;
					continue;
				}
			if (soap_flag_flowTemperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowTemperature", &(a->ns1__vmasLog::flowTemperature), "xsd:double"))
				{	soap_flag_flowTemperature1--;
					continue;
				}
			if (soap_flag_envirTemperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "envirTemperature", &(a->ns1__vmasLog::envirTemperature), "xsd:double"))
				{	soap_flag_envirTemperature1--;
					continue;
				}
			if (soap_flag_envirAirPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "envirAirPressure", &(a->ns1__vmasLog::envirAirPressure), "xsd:double"))
				{	soap_flag_envirAirPressure1--;
					continue;
				}
			if (soap_flag_envirHumidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "envirHumidity", &(a->ns1__vmasLog::envirHumidity), "xsd:double"))
				{	soap_flag_envirHumidity1--;
					continue;
				}
			if (soap_flag_diluteCorrect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "diluteCorrect", &(a->ns1__vmasLog::diluteCorrect), "xsd:double"))
				{	soap_flag_diluteCorrect1--;
					continue;
				}
			if (soap_flag_humidityCorrect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "humidityCorrect", &(a->ns1__vmasLog::humidityCorrect), "xsd:double"))
				{	soap_flag_humidityCorrect1--;
					continue;
				}
			if (soap_flag_diluteRatio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "diluteRatio", &(a->ns1__vmasLog::diluteRatio), "xsd:double"))
				{	soap_flag_diluteRatio1--;
					continue;
				}
			if (soap_flag_lambdaValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lambdaValue", &(a->ns1__vmasLog::lambdaValue), "xsd:double"))
				{	soap_flag_lambdaValue1--;
					continue;
				}
			if (soap_flag_qtfxyjcswd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "qtfxyjcswd", &(a->ns1__vmasLog::qtfxyjcswd), "xsd:double"))
				{	soap_flag_qtfxyjcswd1--;
					continue;
				}
			if (soap_flag_zhlwd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zhlwd", &(a->ns1__vmasLog::zhlwd), "xsd:double"))
				{	soap_flag_zhlwd1--;
					continue;
				}
			if (soap_flag_weightNO11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "weightNO1", &(a->ns1__vmasLog::weightNO1), "xsd:double"))
				{	soap_flag_weightNO11--;
					continue;
				}
			if (soap_flag_weightNO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "weightNO2", &(a->ns1__vmasLog::weightNO2), "xsd:double"))
				{	soap_flag_weightNO21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__vmasLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__vmasLog, 0, sizeof(ns1__vmasLog), 0, soap_copy_ns1__vmasLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_inspectNum1 > 0 || soap_flag_flowHC1 > 0 || soap_flag_flowCO1 > 0 || soap_flag_flowCO21 > 0 || soap_flag_flowNO1 > 0 || soap_flag_analyserO21 > 0 || soap_flag_flowmeterO21 > 0 || soap_flag_envO21 > 0 || soap_flag_actFlow1 > 0 || soap_flag_stdFlow1 > 0 || soap_flag_tailFlow1 > 0 || soap_flag_weightHC1 > 0 || soap_flag_weightCO1 > 0 || soap_flag_weightNO1 > 0 || soap_flag_lineSpeed1 > 0 || soap_flag_totalPower1 > 0 || soap_flag_parasPower1 > 0 || soap_flag_indicPower1 > 0 || soap_flag_flowAirPressure1 > 0 || soap_flag_flowTemperature1 > 0 || soap_flag_envirTemperature1 > 0 || soap_flag_envirAirPressure1 > 0 || soap_flag_envirHumidity1 > 0 || soap_flag_diluteCorrect1 > 0 || soap_flag_humidityCorrect1 > 0 || soap_flag_diluteRatio1 > 0 || soap_flag_lambdaValue1 > 0 || soap_flag_qtfxyjcswd1 > 0 || soap_flag_zhlwd1 > 0 || soap_flag_weightNO11 > 0 || soap_flag_weightNO21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__vmasLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__vmasLog);
	if (this->soap_out(soap, tag?tag:"ns1:vmasLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__vmasLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__vmasLog(soap, this, tag, type);
}

SOAP_FMAC3 ns1__vmasLog * SOAP_FMAC4 soap_get_ns1__vmasLog(struct soap *soap, ns1__vmasLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__vmasLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__vmasLog * SOAP_FMAC2 soap_instantiate_ns1__vmasLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__vmasLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__vmasLog, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__vmasLog);
		if (size)
			*size = sizeof(ns1__vmasLog);
		((ns1__vmasLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__vmasLog, n);
		if (size)
			*size = n * sizeof(ns1__vmasLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__vmasLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__vmasLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__vmasLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__vmasLog %p -> %p\n", q, p));
	*(ns1__vmasLog*)p = *(ns1__vmasLog*)q;
}

void ns1__doubleIdleLogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__doubleIdleLogResponse::return_);
	/* transient soap skipped */
}

void ns1__doubleIdleLogResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__doubleIdleLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__doubleIdleLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__doubleIdleLogResponse(struct soap *soap, const char *tag, int id, const ns1__doubleIdleLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__doubleIdleLogResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__doubleIdleLogResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__doubleIdleLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__doubleIdleLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__doubleIdleLogResponse * SOAP_FMAC4 soap_in_ns1__doubleIdleLogResponse(struct soap *soap, const char *tag, ns1__doubleIdleLogResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__doubleIdleLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__doubleIdleLogResponse, sizeof(ns1__doubleIdleLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__doubleIdleLogResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__doubleIdleLogResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__doubleIdleLogResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__doubleIdleLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__doubleIdleLogResponse, 0, sizeof(ns1__doubleIdleLogResponse), 0, soap_copy_ns1__doubleIdleLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__doubleIdleLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__doubleIdleLogResponse);
	if (this->soap_out(soap, tag?tag:"ns1:doubleIdleLogResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__doubleIdleLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__doubleIdleLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__doubleIdleLogResponse * SOAP_FMAC4 soap_get_ns1__doubleIdleLogResponse(struct soap *soap, ns1__doubleIdleLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__doubleIdleLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__doubleIdleLogResponse * SOAP_FMAC2 soap_instantiate_ns1__doubleIdleLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__doubleIdleLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__doubleIdleLogResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__doubleIdleLogResponse);
		if (size)
			*size = sizeof(ns1__doubleIdleLogResponse);
		((ns1__doubleIdleLogResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__doubleIdleLogResponse, n);
		if (size)
			*size = n * sizeof(ns1__doubleIdleLogResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__doubleIdleLogResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__doubleIdleLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__doubleIdleLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__doubleIdleLogResponse %p -> %p\n", q, p));
	*(ns1__doubleIdleLogResponse*)p = *(ns1__doubleIdleLogResponse*)q;
}

void ns1__doubleIdleLog_USCOREFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__doubleIdleLog_USCOREFC::businessId = NULL;
	this->ns1__doubleIdleLog_USCOREFC::registCode = NULL;
	soap_default_int(soap, &this->ns1__doubleIdleLog_USCOREFC::inspectNum);
	soap_default_double(soap, &this->ns1__doubleIdleLog_USCOREFC::flowHC);
	soap_default_double(soap, &this->ns1__doubleIdleLog_USCOREFC::flowCO);
	soap_default_double(soap, &this->ns1__doubleIdleLog_USCOREFC::flowCO2);
	soap_default_double(soap, &this->ns1__doubleIdleLog_USCOREFC::analyserO2);
	soap_default_double(soap, &this->ns1__doubleIdleLog_USCOREFC::oilTemperature);
	this->ns1__doubleIdleLog_USCOREFC::rotateSpeed = NULL;
	/* transient soap skipped */
}

void ns1__doubleIdleLog_USCOREFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleLog_USCOREFC::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleLog_USCOREFC::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleLog_USCOREFC::rotateSpeed);
	/* transient soap skipped */
#endif
}

int ns1__doubleIdleLog_USCOREFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__doubleIdleLog_USCOREFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__doubleIdleLog_USCOREFC(struct soap *soap, const char *tag, int id, const ns1__doubleIdleLog_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__doubleIdleLog_USCOREFC), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__doubleIdleLog_USCOREFC::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__doubleIdleLog_USCOREFC::registCode), ""))
		return soap->error;
	if (soap_out_int(soap, "inspectNum", -1, &(a->ns1__doubleIdleLog_USCOREFC::inspectNum), ""))
		return soap->error;
	if (soap_out_double(soap, "flowHC", -1, &(a->ns1__doubleIdleLog_USCOREFC::flowHC), ""))
		return soap->error;
	if (soap_out_double(soap, "flowCO", -1, &(a->ns1__doubleIdleLog_USCOREFC::flowCO), ""))
		return soap->error;
	if (soap_out_double(soap, "flowCO2", -1, &(a->ns1__doubleIdleLog_USCOREFC::flowCO2), ""))
		return soap->error;
	if (soap_out_double(soap, "analyserO2", -1, &(a->ns1__doubleIdleLog_USCOREFC::analyserO2), ""))
		return soap->error;
	if (soap_out_double(soap, "oilTemperature", -1, &(a->ns1__doubleIdleLog_USCOREFC::oilTemperature), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "rotateSpeed", -1, &(a->ns1__doubleIdleLog_USCOREFC::rotateSpeed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__doubleIdleLog_USCOREFC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__doubleIdleLog_USCOREFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__doubleIdleLog_USCOREFC * SOAP_FMAC4 soap_in_ns1__doubleIdleLog_USCOREFC(struct soap *soap, const char *tag, ns1__doubleIdleLog_USCOREFC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__doubleIdleLog_USCOREFC *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__doubleIdleLog_USCOREFC, sizeof(ns1__doubleIdleLog_USCOREFC), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__doubleIdleLog_USCOREFC)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__doubleIdleLog_USCOREFC *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_inspectNum1 = 1;
	size_t soap_flag_flowHC1 = 1;
	size_t soap_flag_flowCO1 = 1;
	size_t soap_flag_flowCO21 = 1;
	size_t soap_flag_analyserO21 = 1;
	size_t soap_flag_oilTemperature1 = 1;
	size_t soap_flag_rotateSpeed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__doubleIdleLog_USCOREFC::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__doubleIdleLog_USCOREFC::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_inspectNum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inspectNum", &(a->ns1__doubleIdleLog_USCOREFC::inspectNum), "xsd:int"))
				{	soap_flag_inspectNum1--;
					continue;
				}
			if (soap_flag_flowHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowHC", &(a->ns1__doubleIdleLog_USCOREFC::flowHC), "xsd:double"))
				{	soap_flag_flowHC1--;
					continue;
				}
			if (soap_flag_flowCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowCO", &(a->ns1__doubleIdleLog_USCOREFC::flowCO), "xsd:double"))
				{	soap_flag_flowCO1--;
					continue;
				}
			if (soap_flag_flowCO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "flowCO2", &(a->ns1__doubleIdleLog_USCOREFC::flowCO2), "xsd:double"))
				{	soap_flag_flowCO21--;
					continue;
				}
			if (soap_flag_analyserO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "analyserO2", &(a->ns1__doubleIdleLog_USCOREFC::analyserO2), "xsd:double"))
				{	soap_flag_analyserO21--;
					continue;
				}
			if (soap_flag_oilTemperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "oilTemperature", &(a->ns1__doubleIdleLog_USCOREFC::oilTemperature), "xsd:double"))
				{	soap_flag_oilTemperature1--;
					continue;
				}
			if (soap_flag_rotateSpeed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "rotateSpeed", &(a->ns1__doubleIdleLog_USCOREFC::rotateSpeed), "xsd:string"))
				{	soap_flag_rotateSpeed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__doubleIdleLog_USCOREFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__doubleIdleLog_USCOREFC, 0, sizeof(ns1__doubleIdleLog_USCOREFC), 0, soap_copy_ns1__doubleIdleLog_USCOREFC);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_inspectNum1 > 0 || soap_flag_flowHC1 > 0 || soap_flag_flowCO1 > 0 || soap_flag_flowCO21 > 0 || soap_flag_analyserO21 > 0 || soap_flag_oilTemperature1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__doubleIdleLog_USCOREFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__doubleIdleLog_USCOREFC);
	if (this->soap_out(soap, tag?tag:"ns1:doubleIdleLog_FC", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__doubleIdleLog_USCOREFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__doubleIdleLog_USCOREFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__doubleIdleLog_USCOREFC * SOAP_FMAC4 soap_get_ns1__doubleIdleLog_USCOREFC(struct soap *soap, ns1__doubleIdleLog_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__doubleIdleLog_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__doubleIdleLog_USCOREFC * SOAP_FMAC2 soap_instantiate_ns1__doubleIdleLog_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__doubleIdleLog_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__doubleIdleLog_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__doubleIdleLog_USCOREFC);
		if (size)
			*size = sizeof(ns1__doubleIdleLog_USCOREFC);
		((ns1__doubleIdleLog_USCOREFC*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__doubleIdleLog_USCOREFC, n);
		if (size)
			*size = n * sizeof(ns1__doubleIdleLog_USCOREFC);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__doubleIdleLog_USCOREFC*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__doubleIdleLog_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__doubleIdleLog_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__doubleIdleLog_USCOREFC %p -> %p\n", q, p));
	*(ns1__doubleIdleLog_USCOREFC*)p = *(ns1__doubleIdleLog_USCOREFC*)q;
}

void ns1__obdResultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__obdResultResponse::return_);
	/* transient soap skipped */
}

void ns1__obdResultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__obdResultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__obdResultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__obdResultResponse(struct soap *soap, const char *tag, int id, const ns1__obdResultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__obdResultResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__obdResultResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__obdResultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__obdResultResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__obdResultResponse * SOAP_FMAC4 soap_in_ns1__obdResultResponse(struct soap *soap, const char *tag, ns1__obdResultResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__obdResultResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__obdResultResponse, sizeof(ns1__obdResultResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__obdResultResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__obdResultResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__obdResultResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__obdResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__obdResultResponse, 0, sizeof(ns1__obdResultResponse), 0, soap_copy_ns1__obdResultResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__obdResultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__obdResultResponse);
	if (this->soap_out(soap, tag?tag:"ns1:obdResultResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__obdResultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__obdResultResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__obdResultResponse * SOAP_FMAC4 soap_get_ns1__obdResultResponse(struct soap *soap, ns1__obdResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__obdResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__obdResultResponse * SOAP_FMAC2 soap_instantiate_ns1__obdResultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__obdResultResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__obdResultResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__obdResultResponse);
		if (size)
			*size = sizeof(ns1__obdResultResponse);
		((ns1__obdResultResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__obdResultResponse, n);
		if (size)
			*size = n * sizeof(ns1__obdResultResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__obdResultResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__obdResultResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__obdResultResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__obdResultResponse %p -> %p\n", q, p));
	*(ns1__obdResultResponse*)p = *(ns1__obdResultResponse*)q;
}

void ns1__obdResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__obdResult::businessId = NULL;
	this->ns1__obdResult::registCode = NULL;
	this->ns1__obdResult::result = NULL;
	this->ns1__obdResult::checktime = NULL;
	this->ns1__obdResult::obdgzzsq = NULL;
	this->ns1__obdResult::objgztx = NULL;
	this->ns1__obdResult::objgztxyy = NULL;
	this->ns1__obdResult::objgzzsdsfbj = NULL;
	this->ns1__obdResult::gzdm = NULL;
	this->ns1__obdResult::gzxx = NULL;
	this->ns1__obdResult::jxztsfwc = NULL;
	this->ns1__obdResult::jxztwwcyy = NULL;
	this->ns1__obdResult::qtxsgl = NULL;
	this->ns1__obdResult::calidfdjkzdy = NULL;
	this->ns1__obdResult::calidhclkddy = NULL;
	this->ns1__obdResult::calidqtkzdy = NULL;
	this->ns1__obdResult::cvnfdjkzdy = NULL;
	this->ns1__obdResult::cvnhclkddy = NULL;
	this->ns1__obdResult::cvnqtkzdy = NULL;
	/* transient soap skipped */
}

void ns1__obdResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::result);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::checktime);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::obdgzzsq);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::objgztx);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::objgztxyy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::objgzzsdsfbj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::gzdm);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::gzxx);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::jxztsfwc);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::jxztwwcyy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::qtxsgl);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::calidfdjkzdy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::calidhclkddy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::calidqtkzdy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::cvnfdjkzdy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::cvnhclkddy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdResult::cvnqtkzdy);
	/* transient soap skipped */
#endif
}

int ns1__obdResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__obdResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__obdResult(struct soap *soap, const char *tag, int id, const ns1__obdResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__obdResult), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__obdResult::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__obdResult::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "result", -1, &(a->ns1__obdResult::result), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checktime", -1, &(a->ns1__obdResult::checktime), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "obdgzzsq", -1, &(a->ns1__obdResult::obdgzzsq), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "objgztx", -1, &(a->ns1__obdResult::objgztx), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "objgztxyy", -1, &(a->ns1__obdResult::objgztxyy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "objgzzsdsfbj", -1, &(a->ns1__obdResult::objgzzsdsfbj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gzdm", -1, &(a->ns1__obdResult::gzdm), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gzxx", -1, &(a->ns1__obdResult::gzxx), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jxztsfwc", -1, &(a->ns1__obdResult::jxztsfwc), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jxztwwcyy", -1, &(a->ns1__obdResult::jxztwwcyy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qtxsgl", -1, &(a->ns1__obdResult::qtxsgl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "calidfdjkzdy", -1, &(a->ns1__obdResult::calidfdjkzdy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "calidhclkddy", -1, &(a->ns1__obdResult::calidhclkddy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "calidqtkzdy", -1, &(a->ns1__obdResult::calidqtkzdy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "cvnfdjkzdy", -1, &(a->ns1__obdResult::cvnfdjkzdy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "cvnhclkddy", -1, &(a->ns1__obdResult::cvnhclkddy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "cvnqtkzdy", -1, &(a->ns1__obdResult::cvnqtkzdy), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__obdResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__obdResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__obdResult * SOAP_FMAC4 soap_in_ns1__obdResult(struct soap *soap, const char *tag, ns1__obdResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__obdResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__obdResult, sizeof(ns1__obdResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__obdResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__obdResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_result1 = 1;
	size_t soap_flag_checktime1 = 1;
	size_t soap_flag_obdgzzsq1 = 1;
	size_t soap_flag_objgztx1 = 1;
	size_t soap_flag_objgztxyy1 = 1;
	size_t soap_flag_objgzzsdsfbj1 = 1;
	size_t soap_flag_gzdm1 = 1;
	size_t soap_flag_gzxx1 = 1;
	size_t soap_flag_jxztsfwc1 = 1;
	size_t soap_flag_jxztwwcyy1 = 1;
	size_t soap_flag_qtxsgl1 = 1;
	size_t soap_flag_calidfdjkzdy1 = 1;
	size_t soap_flag_calidhclkddy1 = 1;
	size_t soap_flag_calidqtkzdy1 = 1;
	size_t soap_flag_cvnfdjkzdy1 = 1;
	size_t soap_flag_cvnhclkddy1 = 1;
	size_t soap_flag_cvnqtkzdy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__obdResult::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__obdResult::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "result", &(a->ns1__obdResult::result), "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag_checktime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checktime", &(a->ns1__obdResult::checktime), "xsd:string"))
				{	soap_flag_checktime1--;
					continue;
				}
			if (soap_flag_obdgzzsq1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "obdgzzsq", &(a->ns1__obdResult::obdgzzsq), "xsd:string"))
				{	soap_flag_obdgzzsq1--;
					continue;
				}
			if (soap_flag_objgztx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "objgztx", &(a->ns1__obdResult::objgztx), "xsd:string"))
				{	soap_flag_objgztx1--;
					continue;
				}
			if (soap_flag_objgztxyy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "objgztxyy", &(a->ns1__obdResult::objgztxyy), "xsd:string"))
				{	soap_flag_objgztxyy1--;
					continue;
				}
			if (soap_flag_objgzzsdsfbj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "objgzzsdsfbj", &(a->ns1__obdResult::objgzzsdsfbj), "xsd:string"))
				{	soap_flag_objgzzsdsfbj1--;
					continue;
				}
			if (soap_flag_gzdm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gzdm", &(a->ns1__obdResult::gzdm), "xsd:string"))
				{	soap_flag_gzdm1--;
					continue;
				}
			if (soap_flag_gzxx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gzxx", &(a->ns1__obdResult::gzxx), "xsd:string"))
				{	soap_flag_gzxx1--;
					continue;
				}
			if (soap_flag_jxztsfwc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jxztsfwc", &(a->ns1__obdResult::jxztsfwc), "xsd:string"))
				{	soap_flag_jxztsfwc1--;
					continue;
				}
			if (soap_flag_jxztwwcyy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jxztwwcyy", &(a->ns1__obdResult::jxztwwcyy), "xsd:string"))
				{	soap_flag_jxztwwcyy1--;
					continue;
				}
			if (soap_flag_qtxsgl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qtxsgl", &(a->ns1__obdResult::qtxsgl), "xsd:string"))
				{	soap_flag_qtxsgl1--;
					continue;
				}
			if (soap_flag_calidfdjkzdy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "calidfdjkzdy", &(a->ns1__obdResult::calidfdjkzdy), "xsd:string"))
				{	soap_flag_calidfdjkzdy1--;
					continue;
				}
			if (soap_flag_calidhclkddy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "calidhclkddy", &(a->ns1__obdResult::calidhclkddy), "xsd:string"))
				{	soap_flag_calidhclkddy1--;
					continue;
				}
			if (soap_flag_calidqtkzdy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "calidqtkzdy", &(a->ns1__obdResult::calidqtkzdy), "xsd:string"))
				{	soap_flag_calidqtkzdy1--;
					continue;
				}
			if (soap_flag_cvnfdjkzdy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "cvnfdjkzdy", &(a->ns1__obdResult::cvnfdjkzdy), "xsd:string"))
				{	soap_flag_cvnfdjkzdy1--;
					continue;
				}
			if (soap_flag_cvnhclkddy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "cvnhclkddy", &(a->ns1__obdResult::cvnhclkddy), "xsd:string"))
				{	soap_flag_cvnhclkddy1--;
					continue;
				}
			if (soap_flag_cvnqtkzdy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "cvnqtkzdy", &(a->ns1__obdResult::cvnqtkzdy), "xsd:string"))
				{	soap_flag_cvnqtkzdy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__obdResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__obdResult, 0, sizeof(ns1__obdResult), 0, soap_copy_ns1__obdResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__obdResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__obdResult);
	if (this->soap_out(soap, tag?tag:"ns1:obdResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__obdResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__obdResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__obdResult * SOAP_FMAC4 soap_get_ns1__obdResult(struct soap *soap, ns1__obdResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__obdResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__obdResult * SOAP_FMAC2 soap_instantiate_ns1__obdResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__obdResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__obdResult, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__obdResult);
		if (size)
			*size = sizeof(ns1__obdResult);
		((ns1__obdResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__obdResult, n);
		if (size)
			*size = n * sizeof(ns1__obdResult);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__obdResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__obdResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__obdResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__obdResult %p -> %p\n", q, p));
	*(ns1__obdResult*)p = *(ns1__obdResult*)q;
}

void ns1__cgjSelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__cgjSelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__cgjSelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__cgjSelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjSelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjSelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__cgjSelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjSelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__cgjSelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjSelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjSelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjSelfcheckResponse * SOAP_FMAC4 soap_in_ns1__cgjSelfcheckResponse(struct soap *soap, const char *tag, ns1__cgjSelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjSelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjSelfcheckResponse, sizeof(ns1__cgjSelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjSelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjSelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__cgjSelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjSelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjSelfcheckResponse, 0, sizeof(ns1__cgjSelfcheckResponse), 0, soap_copy_ns1__cgjSelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjSelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjSelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:cgjSelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjSelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjSelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjSelfcheckResponse * SOAP_FMAC4 soap_get_ns1__cgjSelfcheckResponse(struct soap *soap, ns1__cgjSelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjSelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjSelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__cgjSelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjSelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjSelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjSelfcheckResponse);
		if (size)
			*size = sizeof(ns1__cgjSelfcheckResponse);
		((ns1__cgjSelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjSelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__cgjSelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjSelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjSelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjSelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjSelfcheckResponse %p -> %p\n", q, p));
	*(ns1__cgjSelfcheckResponse*)p = *(ns1__cgjSelfcheckResponse*)q;
}

void ns1__cgjSelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__cgjSelfcheck::registCode = NULL;
	soap_default_double(soap, &this->ns1__cgjSelfcheck::HVitualTime);
	soap_default_double(soap, &this->ns1__cgjSelfcheck::HrealTime);
	soap_default_double(soap, &this->ns1__cgjSelfcheck::LvitualTime);
	soap_default_double(soap, &this->ns1__cgjSelfcheck::LrealTime);
	soap_default_double(soap, &this->ns1__cgjSelfcheck::Hpower);
	soap_default_double(soap, &this->ns1__cgjSelfcheck::Lpower);
	this->ns1__cgjSelfcheck::checkResult = NULL;
	this->ns1__cgjSelfcheck::checkTimeStart = NULL;
	this->ns1__cgjSelfcheck::checkTimeEnd = NULL;
	this->ns1__cgjSelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__cgjSelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjSelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjSelfcheck::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjSelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjSelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjSelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__cgjSelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjSelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjSelfcheck(struct soap *soap, const char *tag, int id, const ns1__cgjSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjSelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__cgjSelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "HVitualTime", -1, &(a->ns1__cgjSelfcheck::HVitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "HrealTime", -1, &(a->ns1__cgjSelfcheck::HrealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "LvitualTime", -1, &(a->ns1__cgjSelfcheck::LvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "LrealTime", -1, &(a->ns1__cgjSelfcheck::LrealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "Hpower", -1, &(a->ns1__cgjSelfcheck::Hpower), ""))
		return soap->error;
	if (soap_out_double(soap, "Lpower", -1, &(a->ns1__cgjSelfcheck::Lpower), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__cgjSelfcheck::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__cgjSelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__cgjSelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__cgjSelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjSelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjSelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjSelfcheck * SOAP_FMAC4 soap_in_ns1__cgjSelfcheck(struct soap *soap, const char *tag, ns1__cgjSelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjSelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjSelfcheck, sizeof(ns1__cgjSelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjSelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjSelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_HVitualTime1 = 1;
	size_t soap_flag_HrealTime1 = 1;
	size_t soap_flag_LvitualTime1 = 1;
	size_t soap_flag_LrealTime1 = 1;
	size_t soap_flag_Hpower1 = 1;
	size_t soap_flag_Lpower1 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__cgjSelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_HVitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "HVitualTime", &(a->ns1__cgjSelfcheck::HVitualTime), "xsd:double"))
				{	soap_flag_HVitualTime1--;
					continue;
				}
			if (soap_flag_HrealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "HrealTime", &(a->ns1__cgjSelfcheck::HrealTime), "xsd:double"))
				{	soap_flag_HrealTime1--;
					continue;
				}
			if (soap_flag_LvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "LvitualTime", &(a->ns1__cgjSelfcheck::LvitualTime), "xsd:double"))
				{	soap_flag_LvitualTime1--;
					continue;
				}
			if (soap_flag_LrealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "LrealTime", &(a->ns1__cgjSelfcheck::LrealTime), "xsd:double"))
				{	soap_flag_LrealTime1--;
					continue;
				}
			if (soap_flag_Hpower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Hpower", &(a->ns1__cgjSelfcheck::Hpower), "xsd:double"))
				{	soap_flag_Hpower1--;
					continue;
				}
			if (soap_flag_Lpower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Lpower", &(a->ns1__cgjSelfcheck::Lpower), "xsd:double"))
				{	soap_flag_Lpower1--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__cgjSelfcheck::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__cgjSelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__cgjSelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__cgjSelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjSelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjSelfcheck, 0, sizeof(ns1__cgjSelfcheck), 0, soap_copy_ns1__cgjSelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HVitualTime1 > 0 || soap_flag_HrealTime1 > 0 || soap_flag_LvitualTime1 > 0 || soap_flag_LrealTime1 > 0 || soap_flag_Hpower1 > 0 || soap_flag_Lpower1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjSelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjSelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:cgjSelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjSelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjSelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjSelfcheck * SOAP_FMAC4 soap_get_ns1__cgjSelfcheck(struct soap *soap, ns1__cgjSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjSelfcheck * SOAP_FMAC2 soap_instantiate_ns1__cgjSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjSelfcheck);
		if (size)
			*size = sizeof(ns1__cgjSelfcheck);
		((ns1__cgjSelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjSelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__cgjSelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjSelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjSelfcheck %p -> %p\n", q, p));
	*(ns1__cgjSelfcheck*)p = *(ns1__cgjSelfcheck*)q;
}

void ns1__cgjLASelfcheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__cgjLASelfcheckResponse::return_);
	/* transient soap skipped */
}

void ns1__cgjLASelfcheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__cgjLASelfcheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjLASelfcheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjLASelfcheckResponse(struct soap *soap, const char *tag, int id, const ns1__cgjLASelfcheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjLASelfcheckResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__cgjLASelfcheckResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjLASelfcheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjLASelfcheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjLASelfcheckResponse * SOAP_FMAC4 soap_in_ns1__cgjLASelfcheckResponse(struct soap *soap, const char *tag, ns1__cgjLASelfcheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjLASelfcheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjLASelfcheckResponse, sizeof(ns1__cgjLASelfcheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjLASelfcheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjLASelfcheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__cgjLASelfcheckResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjLASelfcheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjLASelfcheckResponse, 0, sizeof(ns1__cgjLASelfcheckResponse), 0, soap_copy_ns1__cgjLASelfcheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjLASelfcheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjLASelfcheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:cgjLASelfcheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjLASelfcheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjLASelfcheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjLASelfcheckResponse * SOAP_FMAC4 soap_get_ns1__cgjLASelfcheckResponse(struct soap *soap, ns1__cgjLASelfcheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjLASelfcheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjLASelfcheckResponse * SOAP_FMAC2 soap_instantiate_ns1__cgjLASelfcheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjLASelfcheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjLASelfcheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjLASelfcheckResponse);
		if (size)
			*size = sizeof(ns1__cgjLASelfcheckResponse);
		((ns1__cgjLASelfcheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjLASelfcheckResponse, n);
		if (size)
			*size = n * sizeof(ns1__cgjLASelfcheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjLASelfcheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjLASelfcheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjLASelfcheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjLASelfcheckResponse %p -> %p\n", q, p));
	*(ns1__cgjLASelfcheckResponse*)p = *(ns1__cgjLASelfcheckResponse*)q;
}

void ns1__cgjLASelfcheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__cgjLASelfcheck::registCode = NULL;
	soap_default_double(soap, &this->ns1__cgjLASelfcheck::AvitualTime);
	soap_default_double(soap, &this->ns1__cgjLASelfcheck::ArealTime);
	soap_default_double(soap, &this->ns1__cgjLASelfcheck::BvitualTime);
	soap_default_double(soap, &this->ns1__cgjLASelfcheck::BrealTime);
	soap_default_double(soap, &this->ns1__cgjLASelfcheck::CvitualTime);
	soap_default_double(soap, &this->ns1__cgjLASelfcheck::CrealTime);
	soap_default_double(soap, &this->ns1__cgjLASelfcheck::DvitualTime);
	soap_default_double(soap, &this->ns1__cgjLASelfcheck::DrealTime);
	this->ns1__cgjLASelfcheck::checkResult = NULL;
	this->ns1__cgjLASelfcheck::checkTimeStart = NULL;
	this->ns1__cgjLASelfcheck::checkTimeEnd = NULL;
	this->ns1__cgjLASelfcheck::remark = NULL;
	/* transient soap skipped */
}

void ns1__cgjLASelfcheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjLASelfcheck::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjLASelfcheck::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjLASelfcheck::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjLASelfcheck::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjLASelfcheck::remark);
	/* transient soap skipped */
#endif
}

int ns1__cgjLASelfcheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjLASelfcheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjLASelfcheck(struct soap *soap, const char *tag, int id, const ns1__cgjLASelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjLASelfcheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__cgjLASelfcheck::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "AvitualTime", -1, &(a->ns1__cgjLASelfcheck::AvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "ArealTime", -1, &(a->ns1__cgjLASelfcheck::ArealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "BvitualTime", -1, &(a->ns1__cgjLASelfcheck::BvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "BrealTime", -1, &(a->ns1__cgjLASelfcheck::BrealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "CvitualTime", -1, &(a->ns1__cgjLASelfcheck::CvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "CrealTime", -1, &(a->ns1__cgjLASelfcheck::CrealTime), ""))
		return soap->error;
	if (soap_out_double(soap, "DvitualTime", -1, &(a->ns1__cgjLASelfcheck::DvitualTime), ""))
		return soap->error;
	if (soap_out_double(soap, "DrealTime", -1, &(a->ns1__cgjLASelfcheck::DrealTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__cgjLASelfcheck::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__cgjLASelfcheck::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__cgjLASelfcheck::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__cgjLASelfcheck::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjLASelfcheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjLASelfcheck(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjLASelfcheck * SOAP_FMAC4 soap_in_ns1__cgjLASelfcheck(struct soap *soap, const char *tag, ns1__cgjLASelfcheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjLASelfcheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjLASelfcheck, sizeof(ns1__cgjLASelfcheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjLASelfcheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjLASelfcheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_AvitualTime1 = 1;
	size_t soap_flag_ArealTime1 = 1;
	size_t soap_flag_BvitualTime1 = 1;
	size_t soap_flag_BrealTime1 = 1;
	size_t soap_flag_CvitualTime1 = 1;
	size_t soap_flag_CrealTime1 = 1;
	size_t soap_flag_DvitualTime1 = 1;
	size_t soap_flag_DrealTime1 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__cgjLASelfcheck::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_AvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "AvitualTime", &(a->ns1__cgjLASelfcheck::AvitualTime), "xsd:double"))
				{	soap_flag_AvitualTime1--;
					continue;
				}
			if (soap_flag_ArealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ArealTime", &(a->ns1__cgjLASelfcheck::ArealTime), "xsd:double"))
				{	soap_flag_ArealTime1--;
					continue;
				}
			if (soap_flag_BvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BvitualTime", &(a->ns1__cgjLASelfcheck::BvitualTime), "xsd:double"))
				{	soap_flag_BvitualTime1--;
					continue;
				}
			if (soap_flag_BrealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "BrealTime", &(a->ns1__cgjLASelfcheck::BrealTime), "xsd:double"))
				{	soap_flag_BrealTime1--;
					continue;
				}
			if (soap_flag_CvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CvitualTime", &(a->ns1__cgjLASelfcheck::CvitualTime), "xsd:double"))
				{	soap_flag_CvitualTime1--;
					continue;
				}
			if (soap_flag_CrealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "CrealTime", &(a->ns1__cgjLASelfcheck::CrealTime), "xsd:double"))
				{	soap_flag_CrealTime1--;
					continue;
				}
			if (soap_flag_DvitualTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "DvitualTime", &(a->ns1__cgjLASelfcheck::DvitualTime), "xsd:double"))
				{	soap_flag_DvitualTime1--;
					continue;
				}
			if (soap_flag_DrealTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "DrealTime", &(a->ns1__cgjLASelfcheck::DrealTime), "xsd:double"))
				{	soap_flag_DrealTime1--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__cgjLASelfcheck::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__cgjLASelfcheck::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__cgjLASelfcheck::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__cgjLASelfcheck::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjLASelfcheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjLASelfcheck, 0, sizeof(ns1__cgjLASelfcheck), 0, soap_copy_ns1__cgjLASelfcheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AvitualTime1 > 0 || soap_flag_ArealTime1 > 0 || soap_flag_BvitualTime1 > 0 || soap_flag_BrealTime1 > 0 || soap_flag_CvitualTime1 > 0 || soap_flag_CrealTime1 > 0 || soap_flag_DvitualTime1 > 0 || soap_flag_DrealTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjLASelfcheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjLASelfcheck);
	if (this->soap_out(soap, tag?tag:"ns1:cgjLASelfcheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjLASelfcheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjLASelfcheck(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjLASelfcheck * SOAP_FMAC4 soap_get_ns1__cgjLASelfcheck(struct soap *soap, ns1__cgjLASelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjLASelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjLASelfcheck * SOAP_FMAC2 soap_instantiate_ns1__cgjLASelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjLASelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjLASelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjLASelfcheck);
		if (size)
			*size = sizeof(ns1__cgjLASelfcheck);
		((ns1__cgjLASelfcheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjLASelfcheck, n);
		if (size)
			*size = n * sizeof(ns1__cgjLASelfcheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjLASelfcheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjLASelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjLASelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjLASelfcheck %p -> %p\n", q, p));
	*(ns1__cgjLASelfcheck*)p = *(ns1__cgjLASelfcheck*)q;
}

void ns1__doubleIdleDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__doubleIdleDataResponse::return_);
	/* transient soap skipped */
}

void ns1__doubleIdleDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__doubleIdleDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__doubleIdleDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__doubleIdleDataResponse(struct soap *soap, const char *tag, int id, const ns1__doubleIdleDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__doubleIdleDataResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__doubleIdleDataResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__doubleIdleDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__doubleIdleDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__doubleIdleDataResponse * SOAP_FMAC4 soap_in_ns1__doubleIdleDataResponse(struct soap *soap, const char *tag, ns1__doubleIdleDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__doubleIdleDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__doubleIdleDataResponse, sizeof(ns1__doubleIdleDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__doubleIdleDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__doubleIdleDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__doubleIdleDataResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__doubleIdleDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__doubleIdleDataResponse, 0, sizeof(ns1__doubleIdleDataResponse), 0, soap_copy_ns1__doubleIdleDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__doubleIdleDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__doubleIdleDataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:doubleIdleDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__doubleIdleDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__doubleIdleDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__doubleIdleDataResponse * SOAP_FMAC4 soap_get_ns1__doubleIdleDataResponse(struct soap *soap, ns1__doubleIdleDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__doubleIdleDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__doubleIdleDataResponse * SOAP_FMAC2 soap_instantiate_ns1__doubleIdleDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__doubleIdleDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__doubleIdleDataResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__doubleIdleDataResponse);
		if (size)
			*size = sizeof(ns1__doubleIdleDataResponse);
		((ns1__doubleIdleDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__doubleIdleDataResponse, n);
		if (size)
			*size = n * sizeof(ns1__doubleIdleDataResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__doubleIdleDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__doubleIdleDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__doubleIdleDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__doubleIdleDataResponse %p -> %p\n", q, p));
	*(ns1__doubleIdleDataResponse*)p = *(ns1__doubleIdleDataResponse*)q;
}

void ns1__doubleIdleData_USCOREFC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__doubleIdleData_USCOREFC::businessId = NULL;
	this->ns1__doubleIdleData_USCOREFC::registCode = NULL;
	soap_default_double(soap, &this->ns1__doubleIdleData_USCOREFC::lrotateSpeed);
	soap_default_double(soap, &this->ns1__doubleIdleData_USCOREFC::hrotateSpeed);
	soap_default_double(soap, &this->ns1__doubleIdleData_USCOREFC::coLowValue);
	soap_default_double(soap, &this->ns1__doubleIdleData_USCOREFC::hcLowValue);
	soap_default_double(soap, &this->ns1__doubleIdleData_USCOREFC::coHighValue);
	soap_default_double(soap, &this->ns1__doubleIdleData_USCOREFC::hcHighValue);
	soap_default_double(soap, &this->ns1__doubleIdleData_USCOREFC::lambdaValue);
	soap_default_double(soap, &this->ns1__doubleIdleData_USCOREFC::tempreture);
	soap_default_double(soap, &this->ns1__doubleIdleData_USCOREFC::humidity);
	soap_default_double(soap, &this->ns1__doubleIdleData_USCOREFC::airPressure);
	this->ns1__doubleIdleData_USCOREFC::timeStart = NULL;
	this->ns1__doubleIdleData_USCOREFC::timeEnd = NULL;
	/* transient soap skipped */
}

void ns1__doubleIdleData_USCOREFC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleData_USCOREFC::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleData_USCOREFC::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleData_USCOREFC::timeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__doubleIdleData_USCOREFC::timeEnd);
	/* transient soap skipped */
#endif
}

int ns1__doubleIdleData_USCOREFC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__doubleIdleData_USCOREFC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__doubleIdleData_USCOREFC(struct soap *soap, const char *tag, int id, const ns1__doubleIdleData_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__doubleIdleData_USCOREFC), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__doubleIdleData_USCOREFC::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__doubleIdleData_USCOREFC::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "lrotateSpeed", -1, &(a->ns1__doubleIdleData_USCOREFC::lrotateSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "hrotateSpeed", -1, &(a->ns1__doubleIdleData_USCOREFC::hrotateSpeed), ""))
		return soap->error;
	if (soap_out_double(soap, "coLowValue", -1, &(a->ns1__doubleIdleData_USCOREFC::coLowValue), ""))
		return soap->error;
	if (soap_out_double(soap, "hcLowValue", -1, &(a->ns1__doubleIdleData_USCOREFC::hcLowValue), ""))
		return soap->error;
	if (soap_out_double(soap, "coHighValue", -1, &(a->ns1__doubleIdleData_USCOREFC::coHighValue), ""))
		return soap->error;
	if (soap_out_double(soap, "hcHighValue", -1, &(a->ns1__doubleIdleData_USCOREFC::hcHighValue), ""))
		return soap->error;
	if (soap_out_double(soap, "lambdaValue", -1, &(a->ns1__doubleIdleData_USCOREFC::lambdaValue), ""))
		return soap->error;
	if (soap_out_double(soap, "tempreture", -1, &(a->ns1__doubleIdleData_USCOREFC::tempreture), ""))
		return soap->error;
	if (soap_out_double(soap, "humidity", -1, &(a->ns1__doubleIdleData_USCOREFC::humidity), ""))
		return soap->error;
	if (soap_out_double(soap, "airPressure", -1, &(a->ns1__doubleIdleData_USCOREFC::airPressure), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeStart", -1, &(a->ns1__doubleIdleData_USCOREFC::timeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "timeEnd", -1, &(a->ns1__doubleIdleData_USCOREFC::timeEnd), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__doubleIdleData_USCOREFC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__doubleIdleData_USCOREFC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__doubleIdleData_USCOREFC * SOAP_FMAC4 soap_in_ns1__doubleIdleData_USCOREFC(struct soap *soap, const char *tag, ns1__doubleIdleData_USCOREFC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__doubleIdleData_USCOREFC *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__doubleIdleData_USCOREFC, sizeof(ns1__doubleIdleData_USCOREFC), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__doubleIdleData_USCOREFC)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__doubleIdleData_USCOREFC *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_lrotateSpeed1 = 1;
	size_t soap_flag_hrotateSpeed1 = 1;
	size_t soap_flag_coLowValue1 = 1;
	size_t soap_flag_hcLowValue1 = 1;
	size_t soap_flag_coHighValue1 = 1;
	size_t soap_flag_hcHighValue1 = 1;
	size_t soap_flag_lambdaValue1 = 1;
	size_t soap_flag_tempreture1 = 1;
	size_t soap_flag_humidity1 = 1;
	size_t soap_flag_airPressure1 = 1;
	size_t soap_flag_timeStart1 = 1;
	size_t soap_flag_timeEnd1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__doubleIdleData_USCOREFC::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__doubleIdleData_USCOREFC::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_lrotateSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lrotateSpeed", &(a->ns1__doubleIdleData_USCOREFC::lrotateSpeed), "xsd:double"))
				{	soap_flag_lrotateSpeed1--;
					continue;
				}
			if (soap_flag_hrotateSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hrotateSpeed", &(a->ns1__doubleIdleData_USCOREFC::hrotateSpeed), "xsd:double"))
				{	soap_flag_hrotateSpeed1--;
					continue;
				}
			if (soap_flag_coLowValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "coLowValue", &(a->ns1__doubleIdleData_USCOREFC::coLowValue), "xsd:double"))
				{	soap_flag_coLowValue1--;
					continue;
				}
			if (soap_flag_hcLowValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hcLowValue", &(a->ns1__doubleIdleData_USCOREFC::hcLowValue), "xsd:double"))
				{	soap_flag_hcLowValue1--;
					continue;
				}
			if (soap_flag_coHighValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "coHighValue", &(a->ns1__doubleIdleData_USCOREFC::coHighValue), "xsd:double"))
				{	soap_flag_coHighValue1--;
					continue;
				}
			if (soap_flag_hcHighValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hcHighValue", &(a->ns1__doubleIdleData_USCOREFC::hcHighValue), "xsd:double"))
				{	soap_flag_hcHighValue1--;
					continue;
				}
			if (soap_flag_lambdaValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lambdaValue", &(a->ns1__doubleIdleData_USCOREFC::lambdaValue), "xsd:double"))
				{	soap_flag_lambdaValue1--;
					continue;
				}
			if (soap_flag_tempreture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "tempreture", &(a->ns1__doubleIdleData_USCOREFC::tempreture), "xsd:double"))
				{	soap_flag_tempreture1--;
					continue;
				}
			if (soap_flag_humidity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "humidity", &(a->ns1__doubleIdleData_USCOREFC::humidity), "xsd:double"))
				{	soap_flag_humidity1--;
					continue;
				}
			if (soap_flag_airPressure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "airPressure", &(a->ns1__doubleIdleData_USCOREFC::airPressure), "xsd:double"))
				{	soap_flag_airPressure1--;
					continue;
				}
			if (soap_flag_timeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeStart", &(a->ns1__doubleIdleData_USCOREFC::timeStart), "xsd:string"))
				{	soap_flag_timeStart1--;
					continue;
				}
			if (soap_flag_timeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "timeEnd", &(a->ns1__doubleIdleData_USCOREFC::timeEnd), "xsd:string"))
				{	soap_flag_timeEnd1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__doubleIdleData_USCOREFC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__doubleIdleData_USCOREFC, 0, sizeof(ns1__doubleIdleData_USCOREFC), 0, soap_copy_ns1__doubleIdleData_USCOREFC);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lrotateSpeed1 > 0 || soap_flag_hrotateSpeed1 > 0 || soap_flag_coLowValue1 > 0 || soap_flag_hcLowValue1 > 0 || soap_flag_coHighValue1 > 0 || soap_flag_hcHighValue1 > 0 || soap_flag_lambdaValue1 > 0 || soap_flag_tempreture1 > 0 || soap_flag_humidity1 > 0 || soap_flag_airPressure1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__doubleIdleData_USCOREFC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__doubleIdleData_USCOREFC);
	if (this->soap_out(soap, tag?tag:"ns1:doubleIdleData_FC", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__doubleIdleData_USCOREFC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__doubleIdleData_USCOREFC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__doubleIdleData_USCOREFC * SOAP_FMAC4 soap_get_ns1__doubleIdleData_USCOREFC(struct soap *soap, ns1__doubleIdleData_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__doubleIdleData_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__doubleIdleData_USCOREFC * SOAP_FMAC2 soap_instantiate_ns1__doubleIdleData_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__doubleIdleData_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__doubleIdleData_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__doubleIdleData_USCOREFC);
		if (size)
			*size = sizeof(ns1__doubleIdleData_USCOREFC);
		((ns1__doubleIdleData_USCOREFC*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__doubleIdleData_USCOREFC, n);
		if (size)
			*size = n * sizeof(ns1__doubleIdleData_USCOREFC);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__doubleIdleData_USCOREFC*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__doubleIdleData_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__doubleIdleData_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__doubleIdleData_USCOREFC %p -> %p\n", q, p));
	*(ns1__doubleIdleData_USCOREFC*)p = *(ns1__doubleIdleData_USCOREFC*)q;
}

void ns1__bgAirHCResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__bgAirHCResponse::return_);
	/* transient soap skipped */
}

void ns1__bgAirHCResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__bgAirHCResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__bgAirHCResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bgAirHCResponse(struct soap *soap, const char *tag, int id, const ns1__bgAirHCResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bgAirHCResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__bgAirHCResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__bgAirHCResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__bgAirHCResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__bgAirHCResponse * SOAP_FMAC4 soap_in_ns1__bgAirHCResponse(struct soap *soap, const char *tag, ns1__bgAirHCResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__bgAirHCResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bgAirHCResponse, sizeof(ns1__bgAirHCResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__bgAirHCResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__bgAirHCResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__bgAirHCResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__bgAirHCResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__bgAirHCResponse, 0, sizeof(ns1__bgAirHCResponse), 0, soap_copy_ns1__bgAirHCResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__bgAirHCResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__bgAirHCResponse);
	if (this->soap_out(soap, tag?tag:"ns1:bgAirHCResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__bgAirHCResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__bgAirHCResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__bgAirHCResponse * SOAP_FMAC4 soap_get_ns1__bgAirHCResponse(struct soap *soap, ns1__bgAirHCResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bgAirHCResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__bgAirHCResponse * SOAP_FMAC2 soap_instantiate_ns1__bgAirHCResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bgAirHCResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bgAirHCResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__bgAirHCResponse);
		if (size)
			*size = sizeof(ns1__bgAirHCResponse);
		((ns1__bgAirHCResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__bgAirHCResponse, n);
		if (size)
			*size = n * sizeof(ns1__bgAirHCResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__bgAirHCResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__bgAirHCResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bgAirHCResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__bgAirHCResponse %p -> %p\n", q, p));
	*(ns1__bgAirHCResponse*)p = *(ns1__bgAirHCResponse*)q;
}

void ns1__bgAirHC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__bgAirHC::businessId = NULL;
	this->ns1__bgAirHC::registCode = NULL;
	soap_default_double(soap, &this->ns1__bgAirHC::bgCO);
	soap_default_double(soap, &this->ns1__bgAirHC::bgNO);
	soap_default_double(soap, &this->ns1__bgAirHC::bgHC);
	soap_default_double(soap, &this->ns1__bgAirHC::canliuHC);
	this->ns1__bgAirHC::lFlowResult = NULL;
	soap_default_double(soap, &this->ns1__bgAirHC::o2Avg);
	this->ns1__bgAirHC::checkResult = NULL;
	this->ns1__bgAirHC::checkTimeStart = NULL;
	this->ns1__bgAirHC::checkTimeEnd = NULL;
	this->ns1__bgAirHC::remark = NULL;
	/* transient soap skipped */
}

void ns1__bgAirHC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__bgAirHC::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__bgAirHC::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__bgAirHC::lFlowResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__bgAirHC::checkResult);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__bgAirHC::checkTimeStart);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__bgAirHC::checkTimeEnd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__bgAirHC::remark);
	/* transient soap skipped */
#endif
}

int ns1__bgAirHC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__bgAirHC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bgAirHC(struct soap *soap, const char *tag, int id, const ns1__bgAirHC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bgAirHC), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__bgAirHC::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__bgAirHC::registCode), ""))
		return soap->error;
	if (soap_out_double(soap, "bgCO", -1, &(a->ns1__bgAirHC::bgCO), ""))
		return soap->error;
	if (soap_out_double(soap, "bgNO", -1, &(a->ns1__bgAirHC::bgNO), ""))
		return soap->error;
	if (soap_out_double(soap, "bgHC", -1, &(a->ns1__bgAirHC::bgHC), ""))
		return soap->error;
	if (soap_out_double(soap, "canliuHC", -1, &(a->ns1__bgAirHC::canliuHC), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lFlowResult", -1, &(a->ns1__bgAirHC::lFlowResult), ""))
		return soap->error;
	if (soap_out_double(soap, "o2Avg", -1, &(a->ns1__bgAirHC::o2Avg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkResult", -1, &(a->ns1__bgAirHC::checkResult), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeStart", -1, &(a->ns1__bgAirHC::checkTimeStart), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "checkTimeEnd", -1, &(a->ns1__bgAirHC::checkTimeEnd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__bgAirHC::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__bgAirHC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__bgAirHC(soap, tag, this, type);
}

SOAP_FMAC3 ns1__bgAirHC * SOAP_FMAC4 soap_in_ns1__bgAirHC(struct soap *soap, const char *tag, ns1__bgAirHC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__bgAirHC *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bgAirHC, sizeof(ns1__bgAirHC), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__bgAirHC)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__bgAirHC *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_bgCO1 = 1;
	size_t soap_flag_bgNO1 = 1;
	size_t soap_flag_bgHC1 = 1;
	size_t soap_flag_canliuHC1 = 1;
	size_t soap_flag_lFlowResult1 = 1;
	size_t soap_flag_o2Avg1 = 1;
	size_t soap_flag_checkResult1 = 1;
	size_t soap_flag_checkTimeStart1 = 1;
	size_t soap_flag_checkTimeEnd1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__bgAirHC::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__bgAirHC::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_bgCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bgCO", &(a->ns1__bgAirHC::bgCO), "xsd:double"))
				{	soap_flag_bgCO1--;
					continue;
				}
			if (soap_flag_bgNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bgNO", &(a->ns1__bgAirHC::bgNO), "xsd:double"))
				{	soap_flag_bgNO1--;
					continue;
				}
			if (soap_flag_bgHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bgHC", &(a->ns1__bgAirHC::bgHC), "xsd:double"))
				{	soap_flag_bgHC1--;
					continue;
				}
			if (soap_flag_canliuHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "canliuHC", &(a->ns1__bgAirHC::canliuHC), "xsd:double"))
				{	soap_flag_canliuHC1--;
					continue;
				}
			if (soap_flag_lFlowResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lFlowResult", &(a->ns1__bgAirHC::lFlowResult), "xsd:string"))
				{	soap_flag_lFlowResult1--;
					continue;
				}
			if (soap_flag_o2Avg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "o2Avg", &(a->ns1__bgAirHC::o2Avg), "xsd:double"))
				{	soap_flag_o2Avg1--;
					continue;
				}
			if (soap_flag_checkResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkResult", &(a->ns1__bgAirHC::checkResult), "xsd:string"))
				{	soap_flag_checkResult1--;
					continue;
				}
			if (soap_flag_checkTimeStart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeStart", &(a->ns1__bgAirHC::checkTimeStart), "xsd:string"))
				{	soap_flag_checkTimeStart1--;
					continue;
				}
			if (soap_flag_checkTimeEnd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "checkTimeEnd", &(a->ns1__bgAirHC::checkTimeEnd), "xsd:string"))
				{	soap_flag_checkTimeEnd1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__bgAirHC::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__bgAirHC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__bgAirHC, 0, sizeof(ns1__bgAirHC), 0, soap_copy_ns1__bgAirHC);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bgCO1 > 0 || soap_flag_bgNO1 > 0 || soap_flag_bgHC1 > 0 || soap_flag_canliuHC1 > 0 || soap_flag_o2Avg1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__bgAirHC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__bgAirHC);
	if (this->soap_out(soap, tag?tag:"ns1:bgAirHC", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__bgAirHC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__bgAirHC(soap, this, tag, type);
}

SOAP_FMAC3 ns1__bgAirHC * SOAP_FMAC4 soap_get_ns1__bgAirHC(struct soap *soap, ns1__bgAirHC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bgAirHC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__bgAirHC * SOAP_FMAC2 soap_instantiate_ns1__bgAirHC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bgAirHC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bgAirHC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__bgAirHC);
		if (size)
			*size = sizeof(ns1__bgAirHC);
		((ns1__bgAirHC*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__bgAirHC, n);
		if (size)
			*size = n * sizeof(ns1__bgAirHC);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__bgAirHC*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__bgAirHC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bgAirHC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__bgAirHC %p -> %p\n", q, p));
	*(ns1__bgAirHC*)p = *(ns1__bgAirHC*)q;
}

void ns1__sendMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__sendMessageResponse::return_);
	/* transient soap skipped */
}

void ns1__sendMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__sendMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sendMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sendMessageResponse(struct soap *soap, const char *tag, int id, const ns1__sendMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sendMessageResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__sendMessageResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sendMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sendMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sendMessageResponse * SOAP_FMAC4 soap_in_ns1__sendMessageResponse(struct soap *soap, const char *tag, ns1__sendMessageResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sendMessageResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sendMessageResponse, sizeof(ns1__sendMessageResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sendMessageResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sendMessageResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__sendMessageResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sendMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sendMessageResponse, 0, sizeof(ns1__sendMessageResponse), 0, soap_copy_ns1__sendMessageResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__sendMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__sendMessageResponse);
	if (this->soap_out(soap, tag?tag:"ns1:sendMessageResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sendMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sendMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sendMessageResponse * SOAP_FMAC4 soap_get_ns1__sendMessageResponse(struct soap *soap, ns1__sendMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sendMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sendMessageResponse * SOAP_FMAC2 soap_instantiate_ns1__sendMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sendMessageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sendMessageResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sendMessageResponse);
		if (size)
			*size = sizeof(ns1__sendMessageResponse);
		((ns1__sendMessageResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sendMessageResponse, n);
		if (size)
			*size = n * sizeof(ns1__sendMessageResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sendMessageResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sendMessageResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sendMessageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sendMessageResponse %p -> %p\n", q, p));
	*(ns1__sendMessageResponse*)p = *(ns1__sendMessageResponse*)q;
}

void ns1__sendMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sendMessage::businessId = NULL;
	this->ns1__sendMessage::registCode = NULL;
	this->ns1__sendMessage::code = NULL;
	this->ns1__sendMessage::message = NULL;
	/* transient soap skipped */
}

void ns1__sendMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sendMessage::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sendMessage::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sendMessage::code);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sendMessage::message);
	/* transient soap skipped */
#endif
}

int ns1__sendMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sendMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sendMessage(struct soap *soap, const char *tag, int id, const ns1__sendMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sendMessage), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__sendMessage::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__sendMessage::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "code", -1, &(a->ns1__sendMessage::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__sendMessage::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sendMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sendMessage(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sendMessage * SOAP_FMAC4 soap_in_ns1__sendMessage(struct soap *soap, const char *tag, ns1__sendMessage *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sendMessage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sendMessage, sizeof(ns1__sendMessage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sendMessage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sendMessage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__sendMessage::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__sendMessage::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "code", &(a->ns1__sendMessage::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__sendMessage::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sendMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sendMessage, 0, sizeof(ns1__sendMessage), 0, soap_copy_ns1__sendMessage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__sendMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__sendMessage);
	if (this->soap_out(soap, tag?tag:"ns1:sendMessage", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sendMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sendMessage(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sendMessage * SOAP_FMAC4 soap_get_ns1__sendMessage(struct soap *soap, ns1__sendMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sendMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sendMessage * SOAP_FMAC2 soap_instantiate_ns1__sendMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sendMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sendMessage, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sendMessage);
		if (size)
			*size = sizeof(ns1__sendMessage);
		((ns1__sendMessage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sendMessage, n);
		if (size)
			*size = n * sizeof(ns1__sendMessage);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sendMessage*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sendMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sendMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sendMessage %p -> %p\n", q, p));
	*(ns1__sendMessage*)p = *(ns1__sendMessage*)q;
}

void ns1__carInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__carInfo::carCardNumber = NULL;
	this->ns1__carInfo::airInflow = NULL;
	this->ns1__carInfo::fuelType = NULL;
	this->ns1__carInfo::isSYJHQ = NULL;
	soap_default_double(soap, &this->ns1__carInfo::maxWeight);
	soap_default_double(soap, &this->ns1__carInfo::motorPower);
	soap_default_double(soap, &this->ns1__carInfo::motorRate);
	this->ns1__carInfo::oilSupply = NULL;
	this->ns1__carInfo::speedChanger = NULL;
	soap_default_double(soap, &this->ns1__carInfo::standardWeight);
	/* transient soap skipped */
}

void ns1__carInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__carInfo::carCardNumber);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__carInfo::airInflow);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__carInfo::fuelType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__carInfo::isSYJHQ);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__carInfo::oilSupply);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__carInfo::speedChanger);
	/* transient soap skipped */
#endif
}

int ns1__carInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__carInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__carInfo(struct soap *soap, const char *tag, int id, const ns1__carInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__carInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "carCardNumber", -1, &(a->ns1__carInfo::carCardNumber), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "airInflow", -1, &(a->ns1__carInfo::airInflow), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fuelType", -1, &(a->ns1__carInfo::fuelType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "isSYJHQ", -1, &(a->ns1__carInfo::isSYJHQ), ""))
		return soap->error;
	if (soap_out_double(soap, "maxWeight", -1, &(a->ns1__carInfo::maxWeight), ""))
		return soap->error;
	if (soap_out_double(soap, "motorPower", -1, &(a->ns1__carInfo::motorPower), ""))
		return soap->error;
	if (soap_out_double(soap, "motorRate", -1, &(a->ns1__carInfo::motorRate), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "oilSupply", -1, &(a->ns1__carInfo::oilSupply), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "speedChanger", -1, &(a->ns1__carInfo::speedChanger), ""))
		return soap->error;
	if (soap_out_double(soap, "standardWeight", -1, &(a->ns1__carInfo::standardWeight), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__carInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__carInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__carInfo * SOAP_FMAC4 soap_in_ns1__carInfo(struct soap *soap, const char *tag, ns1__carInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__carInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__carInfo, sizeof(ns1__carInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__carInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__carInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_carCardNumber1 = 1;
	size_t soap_flag_airInflow1 = 1;
	size_t soap_flag_fuelType1 = 1;
	size_t soap_flag_isSYJHQ1 = 1;
	size_t soap_flag_maxWeight1 = 1;
	size_t soap_flag_motorPower1 = 1;
	size_t soap_flag_motorRate1 = 1;
	size_t soap_flag_oilSupply1 = 1;
	size_t soap_flag_speedChanger1 = 1;
	size_t soap_flag_standardWeight1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_carCardNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "carCardNumber", &(a->ns1__carInfo::carCardNumber), "xsd:string"))
				{	soap_flag_carCardNumber1--;
					continue;
				}
			if (soap_flag_airInflow1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "airInflow", &(a->ns1__carInfo::airInflow), "xsd:string"))
				{	soap_flag_airInflow1--;
					continue;
				}
			if (soap_flag_fuelType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fuelType", &(a->ns1__carInfo::fuelType), "xsd:string"))
				{	soap_flag_fuelType1--;
					continue;
				}
			if (soap_flag_isSYJHQ1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "isSYJHQ", &(a->ns1__carInfo::isSYJHQ), "xsd:string"))
				{	soap_flag_isSYJHQ1--;
					continue;
				}
			if (soap_flag_maxWeight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "maxWeight", &(a->ns1__carInfo::maxWeight), "xsd:double"))
				{	soap_flag_maxWeight1--;
					continue;
				}
			if (soap_flag_motorPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "motorPower", &(a->ns1__carInfo::motorPower), "xsd:double"))
				{	soap_flag_motorPower1--;
					continue;
				}
			if (soap_flag_motorRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "motorRate", &(a->ns1__carInfo::motorRate), "xsd:double"))
				{	soap_flag_motorRate1--;
					continue;
				}
			if (soap_flag_oilSupply1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "oilSupply", &(a->ns1__carInfo::oilSupply), "xsd:string"))
				{	soap_flag_oilSupply1--;
					continue;
				}
			if (soap_flag_speedChanger1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "speedChanger", &(a->ns1__carInfo::speedChanger), "xsd:string"))
				{	soap_flag_speedChanger1--;
					continue;
				}
			if (soap_flag_standardWeight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "standardWeight", &(a->ns1__carInfo::standardWeight), "xsd:double"))
				{	soap_flag_standardWeight1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__carInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__carInfo, 0, sizeof(ns1__carInfo), 0, soap_copy_ns1__carInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_maxWeight1 > 0 || soap_flag_motorPower1 > 0 || soap_flag_motorRate1 > 0 || soap_flag_standardWeight1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__carInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__carInfo);
	if (this->soap_out(soap, tag?tag:"ns1:carInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__carInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__carInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__carInfo * SOAP_FMAC4 soap_get_ns1__carInfo(struct soap *soap, ns1__carInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__carInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__carInfo * SOAP_FMAC2 soap_instantiate_ns1__carInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__carInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__carInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__carInfo);
		if (size)
			*size = sizeof(ns1__carInfo);
		((ns1__carInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__carInfo, n);
		if (size)
			*size = n * sizeof(ns1__carInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__carInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__carInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__carInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__carInfo %p -> %p\n", q, p));
	*(ns1__carInfo*)p = *(ns1__carInfo*)q;
}

void ns1__getCarInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getCarInfoResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getCarInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__carInfo(soap, &this->ns1__getCarInfoResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__getCarInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getCarInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCarInfoResponse(struct soap *soap, const char *tag, int id, const ns1__getCarInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCarInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__carInfo(soap, "return", -1, &(a->ns1__getCarInfoResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getCarInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getCarInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getCarInfoResponse * SOAP_FMAC4 soap_in_ns1__getCarInfoResponse(struct soap *soap, const char *tag, ns1__getCarInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getCarInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCarInfoResponse, sizeof(ns1__getCarInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getCarInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getCarInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__carInfo(soap, "return", &(a->ns1__getCarInfoResponse::return_), "ns1:carInfo"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getCarInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCarInfoResponse, 0, sizeof(ns1__getCarInfoResponse), 0, soap_copy_ns1__getCarInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getCarInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getCarInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getCarInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getCarInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getCarInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getCarInfoResponse * SOAP_FMAC4 soap_get_ns1__getCarInfoResponse(struct soap *soap, ns1__getCarInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCarInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getCarInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__getCarInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCarInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCarInfoResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getCarInfoResponse);
		if (size)
			*size = sizeof(ns1__getCarInfoResponse);
		((ns1__getCarInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getCarInfoResponse, n);
		if (size)
			*size = n * sizeof(ns1__getCarInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getCarInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getCarInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCarInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getCarInfoResponse %p -> %p\n", q, p));
	*(ns1__getCarInfoResponse*)p = *(ns1__getCarInfoResponse*)q;
}

void ns1__getCarInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getCarInfo::businessId = NULL;
	this->ns1__getCarInfo::registCode = NULL;
	/* transient soap skipped */
}

void ns1__getCarInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getCarInfo::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getCarInfo::registCode);
	/* transient soap skipped */
#endif
}

int ns1__getCarInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getCarInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCarInfo(struct soap *soap, const char *tag, int id, const ns1__getCarInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCarInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__getCarInfo::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__getCarInfo::registCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getCarInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getCarInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getCarInfo * SOAP_FMAC4 soap_in_ns1__getCarInfo(struct soap *soap, const char *tag, ns1__getCarInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getCarInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCarInfo, sizeof(ns1__getCarInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getCarInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getCarInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__getCarInfo::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__getCarInfo::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getCarInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCarInfo, 0, sizeof(ns1__getCarInfo), 0, soap_copy_ns1__getCarInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getCarInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getCarInfo);
	if (this->soap_out(soap, tag?tag:"ns1:getCarInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getCarInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getCarInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getCarInfo * SOAP_FMAC4 soap_get_ns1__getCarInfo(struct soap *soap, ns1__getCarInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCarInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getCarInfo * SOAP_FMAC2 soap_instantiate_ns1__getCarInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCarInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCarInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getCarInfo);
		if (size)
			*size = sizeof(ns1__getCarInfo);
		((ns1__getCarInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getCarInfo, n);
		if (size)
			*size = n * sizeof(ns1__getCarInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getCarInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getCarInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCarInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getCarInfo %p -> %p\n", q, p));
	*(ns1__getCarInfo*)p = *(ns1__getCarInfo*)q;
}

void ns1__lightproofSmokeLogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__lightproofSmokeLogResponse::return_);
	/* transient soap skipped */
}

void ns1__lightproofSmokeLogResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__lightproofSmokeLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lightproofSmokeLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lightproofSmokeLogResponse(struct soap *soap, const char *tag, int id, const ns1__lightproofSmokeLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lightproofSmokeLogResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__lightproofSmokeLogResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lightproofSmokeLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lightproofSmokeLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lightproofSmokeLogResponse * SOAP_FMAC4 soap_in_ns1__lightproofSmokeLogResponse(struct soap *soap, const char *tag, ns1__lightproofSmokeLogResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lightproofSmokeLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lightproofSmokeLogResponse, sizeof(ns1__lightproofSmokeLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lightproofSmokeLogResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lightproofSmokeLogResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__lightproofSmokeLogResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lightproofSmokeLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lightproofSmokeLogResponse, 0, sizeof(ns1__lightproofSmokeLogResponse), 0, soap_copy_ns1__lightproofSmokeLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lightproofSmokeLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lightproofSmokeLogResponse);
	if (this->soap_out(soap, tag?tag:"ns1:lightproofSmokeLogResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lightproofSmokeLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lightproofSmokeLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lightproofSmokeLogResponse * SOAP_FMAC4 soap_get_ns1__lightproofSmokeLogResponse(struct soap *soap, ns1__lightproofSmokeLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lightproofSmokeLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lightproofSmokeLogResponse * SOAP_FMAC2 soap_instantiate_ns1__lightproofSmokeLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lightproofSmokeLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lightproofSmokeLogResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lightproofSmokeLogResponse);
		if (size)
			*size = sizeof(ns1__lightproofSmokeLogResponse);
		((ns1__lightproofSmokeLogResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lightproofSmokeLogResponse, n);
		if (size)
			*size = n * sizeof(ns1__lightproofSmokeLogResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lightproofSmokeLogResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lightproofSmokeLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lightproofSmokeLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lightproofSmokeLogResponse %p -> %p\n", q, p));
	*(ns1__lightproofSmokeLogResponse*)p = *(ns1__lightproofSmokeLogResponse*)q;
}

void ns1__lightproofSmokeLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lightproofSmokeLog::businessId = NULL;
	this->ns1__lightproofSmokeLog::registCode = NULL;
	this->ns1__lightproofSmokeLog::logTime = NULL;
	this->ns1__lightproofSmokeLog::type = NULL;
	soap_default_int(soap, &this->ns1__lightproofSmokeLog::inspectNum);
	soap_default_double(soap, &this->ns1__lightproofSmokeLog::smokeValue);
	soap_default_int(soap, &this->ns1__lightproofSmokeLog::zs);
	soap_default_double(soap, &this->ns1__lightproofSmokeLog::ydjjcswd);
	soap_default_double(soap, &this->ns1__lightproofSmokeLog::ydjjcsqy);
	/* transient soap skipped */
}

void ns1__lightproofSmokeLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeLog::businessId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeLog::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeLog::logTime);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lightproofSmokeLog::type);
	/* transient soap skipped */
#endif
}

int ns1__lightproofSmokeLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lightproofSmokeLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lightproofSmokeLog(struct soap *soap, const char *tag, int id, const ns1__lightproofSmokeLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lightproofSmokeLog), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "businessId", -1, &(a->ns1__lightproofSmokeLog::businessId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__lightproofSmokeLog::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "logTime", -1, &(a->ns1__lightproofSmokeLog::logTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "type", -1, &(a->ns1__lightproofSmokeLog::type), ""))
		return soap->error;
	if (soap_out_int(soap, "inspectNum", -1, &(a->ns1__lightproofSmokeLog::inspectNum), ""))
		return soap->error;
	if (soap_out_double(soap, "smokeValue", -1, &(a->ns1__lightproofSmokeLog::smokeValue), ""))
		return soap->error;
	if (soap_out_int(soap, "zs", -1, &(a->ns1__lightproofSmokeLog::zs), ""))
		return soap->error;
	if (soap_out_double(soap, "ydjjcswd", -1, &(a->ns1__lightproofSmokeLog::ydjjcswd), ""))
		return soap->error;
	if (soap_out_double(soap, "ydjjcsqy", -1, &(a->ns1__lightproofSmokeLog::ydjjcsqy), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lightproofSmokeLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lightproofSmokeLog(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lightproofSmokeLog * SOAP_FMAC4 soap_in_ns1__lightproofSmokeLog(struct soap *soap, const char *tag, ns1__lightproofSmokeLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lightproofSmokeLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lightproofSmokeLog, sizeof(ns1__lightproofSmokeLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lightproofSmokeLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lightproofSmokeLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_businessId1 = 1;
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_logTime1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_inspectNum1 = 1;
	size_t soap_flag_smokeValue1 = 1;
	size_t soap_flag_zs1 = 1;
	size_t soap_flag_ydjjcswd1 = 1;
	size_t soap_flag_ydjjcsqy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_businessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "businessId", &(a->ns1__lightproofSmokeLog::businessId), "xsd:string"))
				{	soap_flag_businessId1--;
					continue;
				}
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__lightproofSmokeLog::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_logTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "logTime", &(a->ns1__lightproofSmokeLog::logTime), "xsd:string"))
				{	soap_flag_logTime1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "type", &(a->ns1__lightproofSmokeLog::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_inspectNum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "inspectNum", &(a->ns1__lightproofSmokeLog::inspectNum), "xsd:int"))
				{	soap_flag_inspectNum1--;
					continue;
				}
			if (soap_flag_smokeValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "smokeValue", &(a->ns1__lightproofSmokeLog::smokeValue), "xsd:double"))
				{	soap_flag_smokeValue1--;
					continue;
				}
			if (soap_flag_zs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zs", &(a->ns1__lightproofSmokeLog::zs), "xsd:int"))
				{	soap_flag_zs1--;
					continue;
				}
			if (soap_flag_ydjjcswd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ydjjcswd", &(a->ns1__lightproofSmokeLog::ydjjcswd), "xsd:double"))
				{	soap_flag_ydjjcswd1--;
					continue;
				}
			if (soap_flag_ydjjcsqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ydjjcsqy", &(a->ns1__lightproofSmokeLog::ydjjcsqy), "xsd:double"))
				{	soap_flag_ydjjcsqy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lightproofSmokeLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lightproofSmokeLog, 0, sizeof(ns1__lightproofSmokeLog), 0, soap_copy_ns1__lightproofSmokeLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_inspectNum1 > 0 || soap_flag_smokeValue1 > 0 || soap_flag_zs1 > 0 || soap_flag_ydjjcswd1 > 0 || soap_flag_ydjjcsqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lightproofSmokeLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lightproofSmokeLog);
	if (this->soap_out(soap, tag?tag:"ns1:lightproofSmokeLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lightproofSmokeLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lightproofSmokeLog(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lightproofSmokeLog * SOAP_FMAC4 soap_get_ns1__lightproofSmokeLog(struct soap *soap, ns1__lightproofSmokeLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lightproofSmokeLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lightproofSmokeLog * SOAP_FMAC2 soap_instantiate_ns1__lightproofSmokeLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lightproofSmokeLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lightproofSmokeLog, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lightproofSmokeLog);
		if (size)
			*size = sizeof(ns1__lightproofSmokeLog);
		((ns1__lightproofSmokeLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lightproofSmokeLog, n);
		if (size)
			*size = n * sizeof(ns1__lightproofSmokeLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lightproofSmokeLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lightproofSmokeLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lightproofSmokeLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lightproofSmokeLog %p -> %p\n", q, p));
	*(ns1__lightproofSmokeLog*)p = *(ns1__lightproofSmokeLog*)q;
}

void ns1__argChangResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__argChangResponse::return_);
	/* transient soap skipped */
}

void ns1__argChangResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__argChangResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__argChangResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__argChangResponse(struct soap *soap, const char *tag, int id, const ns1__argChangResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__argChangResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__argChangResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__argChangResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__argChangResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__argChangResponse * SOAP_FMAC4 soap_in_ns1__argChangResponse(struct soap *soap, const char *tag, ns1__argChangResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__argChangResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__argChangResponse, sizeof(ns1__argChangResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__argChangResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__argChangResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__argChangResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__argChangResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__argChangResponse, 0, sizeof(ns1__argChangResponse), 0, soap_copy_ns1__argChangResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__argChangResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__argChangResponse);
	if (this->soap_out(soap, tag?tag:"ns1:argChangResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__argChangResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__argChangResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__argChangResponse * SOAP_FMAC4 soap_get_ns1__argChangResponse(struct soap *soap, ns1__argChangResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__argChangResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__argChangResponse * SOAP_FMAC2 soap_instantiate_ns1__argChangResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__argChangResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__argChangResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__argChangResponse);
		if (size)
			*size = sizeof(ns1__argChangResponse);
		((ns1__argChangResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__argChangResponse, n);
		if (size)
			*size = n * sizeof(ns1__argChangResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__argChangResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__argChangResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__argChangResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__argChangResponse %p -> %p\n", q, p));
	*(ns1__argChangResponse*)p = *(ns1__argChangResponse*)q;
}

void ns1__argChang::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__argChang::registCode = NULL;
	this->ns1__argChang::argName = NULL;
	this->ns1__argChang::oldValue = NULL;
	this->ns1__argChang::newValue = NULL;
	this->ns1__argChang::changeTime = NULL;
	this->ns1__argChang::remark = NULL;
	/* transient soap skipped */
}

void ns1__argChang::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__argChang::registCode);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__argChang::argName);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__argChang::oldValue);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__argChang::newValue);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__argChang::changeTime);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__argChang::remark);
	/* transient soap skipped */
#endif
}

int ns1__argChang::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__argChang(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__argChang(struct soap *soap, const char *tag, int id, const ns1__argChang *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__argChang), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "registCode", -1, &(a->ns1__argChang::registCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "argName", -1, &(a->ns1__argChang::argName), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "oldValue", -1, &(a->ns1__argChang::oldValue), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "newValue", -1, &(a->ns1__argChang::newValue), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "changeTime", -1, &(a->ns1__argChang::changeTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "remark", -1, &(a->ns1__argChang::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__argChang::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__argChang(soap, tag, this, type);
}

SOAP_FMAC3 ns1__argChang * SOAP_FMAC4 soap_in_ns1__argChang(struct soap *soap, const char *tag, ns1__argChang *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__argChang *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__argChang, sizeof(ns1__argChang), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__argChang)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__argChang *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_registCode1 = 1;
	size_t soap_flag_argName1 = 1;
	size_t soap_flag_oldValue1 = 1;
	size_t soap_flag_newValue1 = 1;
	size_t soap_flag_changeTime1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_registCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "registCode", &(a->ns1__argChang::registCode), "xsd:string"))
				{	soap_flag_registCode1--;
					continue;
				}
			if (soap_flag_argName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "argName", &(a->ns1__argChang::argName), "xsd:string"))
				{	soap_flag_argName1--;
					continue;
				}
			if (soap_flag_oldValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "oldValue", &(a->ns1__argChang::oldValue), "xsd:string"))
				{	soap_flag_oldValue1--;
					continue;
				}
			if (soap_flag_newValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "newValue", &(a->ns1__argChang::newValue), "xsd:string"))
				{	soap_flag_newValue1--;
					continue;
				}
			if (soap_flag_changeTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "changeTime", &(a->ns1__argChang::changeTime), "xsd:string"))
				{	soap_flag_changeTime1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "remark", &(a->ns1__argChang::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__argChang *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__argChang, 0, sizeof(ns1__argChang), 0, soap_copy_ns1__argChang);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__argChang::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__argChang);
	if (this->soap_out(soap, tag?tag:"ns1:argChang", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__argChang::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__argChang(soap, this, tag, type);
}

SOAP_FMAC3 ns1__argChang * SOAP_FMAC4 soap_get_ns1__argChang(struct soap *soap, ns1__argChang *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__argChang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__argChang * SOAP_FMAC2 soap_instantiate_ns1__argChang(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__argChang(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__argChang, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__argChang);
		if (size)
			*size = sizeof(ns1__argChang);
		((ns1__argChang*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__argChang, n);
		if (size)
			*size = n * sizeof(ns1__argChang);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__argChang*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__argChang*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__argChang(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__argChang %p -> %p\n", q, p));
	*(ns1__argChang*)p = *(ns1__argChang*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjLSPSelfcheck_(struct soap *soap, struct __ns1__cgjLSPSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjLSPSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjLSPSelfcheck_(struct soap *soap, const struct __ns1__cgjLSPSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjLSPSelfcheck(soap, &a->ns1__cgjLSPSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjLSPSelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__cgjLSPSelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjLSPSelfcheck(soap, "ns1:cgjLSPSelfcheck", -1, &a->ns1__cgjLSPSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjLSPSelfcheck_ * SOAP_FMAC4 soap_in___ns1__cgjLSPSelfcheck_(struct soap *soap, const char *tag, struct __ns1__cgjLSPSelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__cgjLSPSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjLSPSelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjLSPSelfcheck_, sizeof(struct __ns1__cgjLSPSelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjLSPSelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjLSPSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjLSPSelfcheck(soap, "ns1:cgjLSPSelfcheck", &a->ns1__cgjLSPSelfcheck_, "ns1:cgjLSPSelfcheck"))
				{	soap_flag_ns1__cgjLSPSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjLSPSelfcheck_(struct soap *soap, const struct __ns1__cgjLSPSelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjLSPSelfcheck_(soap, tag?tag:"-ns1:cgjLSPSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjLSPSelfcheck_ * SOAP_FMAC4 soap_get___ns1__cgjLSPSelfcheck_(struct soap *soap, struct __ns1__cgjLSPSelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjLSPSelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjLSPSelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__cgjLSPSelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjLSPSelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjLSPSelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjLSPSelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__cgjLSPSelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjLSPSelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjLSPSelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjLSPSelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjLSPSelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjLSPSelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__cgjLSPSelfcheck_*)p = *(struct __ns1__cgjLSPSelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lljSelfcheck_(struct soap *soap, struct __ns1__lljSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lljSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lljSelfcheck_(struct soap *soap, const struct __ns1__lljSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lljSelfcheck(soap, &a->ns1__lljSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lljSelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__lljSelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lljSelfcheck(soap, "ns1:lljSelfcheck", -1, &a->ns1__lljSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lljSelfcheck_ * SOAP_FMAC4 soap_in___ns1__lljSelfcheck_(struct soap *soap, const char *tag, struct __ns1__lljSelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__lljSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lljSelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lljSelfcheck_, sizeof(struct __ns1__lljSelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lljSelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lljSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lljSelfcheck(soap, "ns1:lljSelfcheck", &a->ns1__lljSelfcheck_, "ns1:lljSelfcheck"))
				{	soap_flag_ns1__lljSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lljSelfcheck_(struct soap *soap, const struct __ns1__lljSelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lljSelfcheck_(soap, tag?tag:"-ns1:lljSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lljSelfcheck_ * SOAP_FMAC4 soap_get___ns1__lljSelfcheck_(struct soap *soap, struct __ns1__lljSelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lljSelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lljSelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__lljSelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lljSelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lljSelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lljSelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__lljSelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lljSelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__lljSelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lljSelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lljSelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lljSelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__lljSelfcheck_*)p = *(struct __ns1__lljSelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjALPSelfcheck_(struct soap *soap, struct __ns1__cgjALPSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjALPSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjALPSelfcheck_(struct soap *soap, const struct __ns1__cgjALPSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjALPSelfcheck(soap, &a->ns1__cgjALPSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjALPSelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__cgjALPSelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjALPSelfcheck(soap, "ns1:cgjALPSelfcheck", -1, &a->ns1__cgjALPSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjALPSelfcheck_ * SOAP_FMAC4 soap_in___ns1__cgjALPSelfcheck_(struct soap *soap, const char *tag, struct __ns1__cgjALPSelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__cgjALPSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjALPSelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjALPSelfcheck_, sizeof(struct __ns1__cgjALPSelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjALPSelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjALPSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjALPSelfcheck(soap, "ns1:cgjALPSelfcheck", &a->ns1__cgjALPSelfcheck_, "ns1:cgjALPSelfcheck"))
				{	soap_flag_ns1__cgjALPSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjALPSelfcheck_(struct soap *soap, const struct __ns1__cgjALPSelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjALPSelfcheck_(soap, tag?tag:"-ns1:cgjALPSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjALPSelfcheck_ * SOAP_FMAC4 soap_get___ns1__cgjALPSelfcheck_(struct soap *soap, struct __ns1__cgjALPSelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjALPSelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjALPSelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__cgjALPSelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjALPSelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjALPSelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjALPSelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__cgjALPSelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjALPSelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjALPSelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjALPSelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjALPSelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjALPSelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__cgjALPSelfcheck_*)p = *(struct __ns1__cgjALPSelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wqfxySelfcheck_(struct soap *soap, struct __ns1__wqfxySelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wqfxySelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wqfxySelfcheck_(struct soap *soap, const struct __ns1__wqfxySelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__wqfxySelfcheck(soap, &a->ns1__wqfxySelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wqfxySelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__wqfxySelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__wqfxySelfcheck(soap, "ns1:wqfxySelfcheck", -1, &a->ns1__wqfxySelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxySelfcheck_ * SOAP_FMAC4 soap_in___ns1__wqfxySelfcheck_(struct soap *soap, const char *tag, struct __ns1__wqfxySelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__wqfxySelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__wqfxySelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wqfxySelfcheck_, sizeof(struct __ns1__wqfxySelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wqfxySelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wqfxySelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wqfxySelfcheck(soap, "ns1:wqfxySelfcheck", &a->ns1__wqfxySelfcheck_, "ns1:wqfxySelfcheck"))
				{	soap_flag_ns1__wqfxySelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wqfxySelfcheck_(struct soap *soap, const struct __ns1__wqfxySelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wqfxySelfcheck_(soap, tag?tag:"-ns1:wqfxySelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxySelfcheck_ * SOAP_FMAC4 soap_get___ns1__wqfxySelfcheck_(struct soap *soap, struct __ns1__wqfxySelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wqfxySelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__wqfxySelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__wqfxySelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__wqfxySelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__wqfxySelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__wqfxySelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__wqfxySelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__wqfxySelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__wqfxySelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__wqfxySelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__wqfxySelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__wqfxySelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__wqfxySelfcheck_*)p = *(struct __ns1__wqfxySelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendMessage_USCOREFC_(struct soap *soap, struct __ns1__sendMessage_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendMessage_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendMessage_USCOREFC_(struct soap *soap, const struct __ns1__sendMessage_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__sendMessage_USCOREFC(soap, &a->ns1__sendMessage_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendMessage_USCOREFC_(struct soap *soap, const char *tag, int id, const struct __ns1__sendMessage_USCOREFC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__sendMessage_USCOREFC(soap, "ns1:sendMessage_FC", -1, &a->ns1__sendMessage_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendMessage_USCOREFC_ * SOAP_FMAC4 soap_in___ns1__sendMessage_USCOREFC_(struct soap *soap, const char *tag, struct __ns1__sendMessage_USCOREFC_ *a, const char *type)
{
	size_t soap_flag_ns1__sendMessage_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendMessage_USCOREFC_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendMessage_USCOREFC_, sizeof(struct __ns1__sendMessage_USCOREFC_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendMessage_USCOREFC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendMessage_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sendMessage_USCOREFC(soap, "ns1:sendMessage_FC", &a->ns1__sendMessage_USCOREFC_, "ns1:sendMessage_FC"))
				{	soap_flag_ns1__sendMessage_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendMessage_USCOREFC_(struct soap *soap, const struct __ns1__sendMessage_USCOREFC_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sendMessage_USCOREFC_(soap, tag?tag:"-ns1:sendMessage_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendMessage_USCOREFC_ * SOAP_FMAC4 soap_get___ns1__sendMessage_USCOREFC_(struct soap *soap, struct __ns1__sendMessage_USCOREFC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendMessage_USCOREFC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sendMessage_USCOREFC_ * SOAP_FMAC2 soap_instantiate___ns1__sendMessage_USCOREFC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendMessage_USCOREFC_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sendMessage_USCOREFC_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sendMessage_USCOREFC_);
		if (size)
			*size = sizeof(struct __ns1__sendMessage_USCOREFC_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__sendMessage_USCOREFC_, n);
		if (size)
			*size = n * sizeof(struct __ns1__sendMessage_USCOREFC_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__sendMessage_USCOREFC_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sendMessage_USCOREFC_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sendMessage_USCOREFC_ %p -> %p\n", q, p));
	*(struct __ns1__sendMessage_USCOREFC_*)p = *(struct __ns1__sendMessage_USCOREFC_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sdsqtfxySelfcheck_(struct soap *soap, struct __ns1__sdsqtfxySelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sdsqtfxySelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sdsqtfxySelfcheck_(struct soap *soap, const struct __ns1__sdsqtfxySelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__sdsqtfxySelfcheck(soap, &a->ns1__sdsqtfxySelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sdsqtfxySelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__sdsqtfxySelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__sdsqtfxySelfcheck(soap, "ns1:sdsqtfxySelfcheck", -1, &a->ns1__sdsqtfxySelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sdsqtfxySelfcheck_ * SOAP_FMAC4 soap_in___ns1__sdsqtfxySelfcheck_(struct soap *soap, const char *tag, struct __ns1__sdsqtfxySelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__sdsqtfxySelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sdsqtfxySelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sdsqtfxySelfcheck_, sizeof(struct __ns1__sdsqtfxySelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sdsqtfxySelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sdsqtfxySelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sdsqtfxySelfcheck(soap, "ns1:sdsqtfxySelfcheck", &a->ns1__sdsqtfxySelfcheck_, "ns1:sdsqtfxySelfcheck"))
				{	soap_flag_ns1__sdsqtfxySelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sdsqtfxySelfcheck_(struct soap *soap, const struct __ns1__sdsqtfxySelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sdsqtfxySelfcheck_(soap, tag?tag:"-ns1:sdsqtfxySelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sdsqtfxySelfcheck_ * SOAP_FMAC4 soap_get___ns1__sdsqtfxySelfcheck_(struct soap *soap, struct __ns1__sdsqtfxySelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sdsqtfxySelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sdsqtfxySelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__sdsqtfxySelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sdsqtfxySelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sdsqtfxySelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sdsqtfxySelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__sdsqtfxySelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__sdsqtfxySelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__sdsqtfxySelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__sdsqtfxySelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sdsqtfxySelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sdsqtfxySelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__sdsqtfxySelfcheck_*)p = *(struct __ns1__sdsqtfxySelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__qyfxSelfcheck_(struct soap *soap, struct __ns1__qyfxSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__qyfxSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__qyfxSelfcheck_(struct soap *soap, const struct __ns1__qyfxSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__qyfxSelfcheck(soap, &a->ns1__qyfxSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__qyfxSelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__qyfxSelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__qyfxSelfcheck(soap, "ns1:qyfxSelfcheck", -1, &a->ns1__qyfxSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__qyfxSelfcheck_ * SOAP_FMAC4 soap_in___ns1__qyfxSelfcheck_(struct soap *soap, const char *tag, struct __ns1__qyfxSelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__qyfxSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__qyfxSelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__qyfxSelfcheck_, sizeof(struct __ns1__qyfxSelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__qyfxSelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__qyfxSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__qyfxSelfcheck(soap, "ns1:qyfxSelfcheck", &a->ns1__qyfxSelfcheck_, "ns1:qyfxSelfcheck"))
				{	soap_flag_ns1__qyfxSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__qyfxSelfcheck_(struct soap *soap, const struct __ns1__qyfxSelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__qyfxSelfcheck_(soap, tag?tag:"-ns1:qyfxSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__qyfxSelfcheck_ * SOAP_FMAC4 soap_get___ns1__qyfxSelfcheck_(struct soap *soap, struct __ns1__qyfxSelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__qyfxSelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__qyfxSelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__qyfxSelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__qyfxSelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__qyfxSelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__qyfxSelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__qyfxSelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__qyfxSelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__qyfxSelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__qyfxSelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__qyfxSelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__qyfxSelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__qyfxSelfcheck_*)p = *(struct __ns1__qyfxSelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lightproofSmokeData_(struct soap *soap, struct __ns1__lightproofSmokeData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lightproofSmokeData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lightproofSmokeData_(struct soap *soap, const struct __ns1__lightproofSmokeData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lightproofSmokeData(soap, &a->ns1__lightproofSmokeData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lightproofSmokeData_(struct soap *soap, const char *tag, int id, const struct __ns1__lightproofSmokeData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lightproofSmokeData(soap, "ns1:lightproofSmokeData", -1, &a->ns1__lightproofSmokeData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeData_ * SOAP_FMAC4 soap_in___ns1__lightproofSmokeData_(struct soap *soap, const char *tag, struct __ns1__lightproofSmokeData_ *a, const char *type)
{
	size_t soap_flag_ns1__lightproofSmokeData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lightproofSmokeData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lightproofSmokeData_, sizeof(struct __ns1__lightproofSmokeData_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lightproofSmokeData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lightproofSmokeData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lightproofSmokeData(soap, "ns1:lightproofSmokeData", &a->ns1__lightproofSmokeData_, "ns1:lightproofSmokeData"))
				{	soap_flag_ns1__lightproofSmokeData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lightproofSmokeData_(struct soap *soap, const struct __ns1__lightproofSmokeData_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lightproofSmokeData_(soap, tag?tag:"-ns1:lightproofSmokeData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeData_ * SOAP_FMAC4 soap_get___ns1__lightproofSmokeData_(struct soap *soap, struct __ns1__lightproofSmokeData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lightproofSmokeData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lightproofSmokeData_ * SOAP_FMAC2 soap_instantiate___ns1__lightproofSmokeData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lightproofSmokeData_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lightproofSmokeData_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lightproofSmokeData_);
		if (size)
			*size = sizeof(struct __ns1__lightproofSmokeData_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lightproofSmokeData_, n);
		if (size)
			*size = n * sizeof(struct __ns1__lightproofSmokeData_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lightproofSmokeData_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lightproofSmokeData_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lightproofSmokeData_ %p -> %p\n", q, p));
	*(struct __ns1__lightproofSmokeData_*)p = *(struct __ns1__lightproofSmokeData_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lightproofSmokeData_USCOREFC_(struct soap *soap, struct __ns1__lightproofSmokeData_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lightproofSmokeData_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lightproofSmokeData_USCOREFC_(struct soap *soap, const struct __ns1__lightproofSmokeData_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lightproofSmokeData_USCOREFC(soap, &a->ns1__lightproofSmokeData_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lightproofSmokeData_USCOREFC_(struct soap *soap, const char *tag, int id, const struct __ns1__lightproofSmokeData_USCOREFC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lightproofSmokeData_USCOREFC(soap, "ns1:lightproofSmokeData_FC", -1, &a->ns1__lightproofSmokeData_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeData_USCOREFC_ * SOAP_FMAC4 soap_in___ns1__lightproofSmokeData_USCOREFC_(struct soap *soap, const char *tag, struct __ns1__lightproofSmokeData_USCOREFC_ *a, const char *type)
{
	size_t soap_flag_ns1__lightproofSmokeData_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lightproofSmokeData_USCOREFC_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC_, sizeof(struct __ns1__lightproofSmokeData_USCOREFC_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lightproofSmokeData_USCOREFC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lightproofSmokeData_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lightproofSmokeData_USCOREFC(soap, "ns1:lightproofSmokeData_FC", &a->ns1__lightproofSmokeData_USCOREFC_, "ns1:lightproofSmokeData_FC"))
				{	soap_flag_ns1__lightproofSmokeData_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lightproofSmokeData_USCOREFC_(struct soap *soap, const struct __ns1__lightproofSmokeData_USCOREFC_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lightproofSmokeData_USCOREFC_(soap, tag?tag:"-ns1:lightproofSmokeData_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeData_USCOREFC_ * SOAP_FMAC4 soap_get___ns1__lightproofSmokeData_USCOREFC_(struct soap *soap, struct __ns1__lightproofSmokeData_USCOREFC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lightproofSmokeData_USCOREFC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lightproofSmokeData_USCOREFC_ * SOAP_FMAC2 soap_instantiate___ns1__lightproofSmokeData_USCOREFC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lightproofSmokeData_USCOREFC_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lightproofSmokeData_USCOREFC_);
		if (size)
			*size = sizeof(struct __ns1__lightproofSmokeData_USCOREFC_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lightproofSmokeData_USCOREFC_, n);
		if (size)
			*size = n * sizeof(struct __ns1__lightproofSmokeData_USCOREFC_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lightproofSmokeData_USCOREFC_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lightproofSmokeData_USCOREFC_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lightproofSmokeData_USCOREFC_ %p -> %p\n", q, p));
	*(struct __ns1__lightproofSmokeData_USCOREFC_*)p = *(struct __ns1__lightproofSmokeData_USCOREFC_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wqfxyAdjust_(struct soap *soap, struct __ns1__wqfxyAdjust_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wqfxyAdjust_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wqfxyAdjust_(struct soap *soap, const struct __ns1__wqfxyAdjust_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__wqfxyAdjust(soap, &a->ns1__wqfxyAdjust_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wqfxyAdjust_(struct soap *soap, const char *tag, int id, const struct __ns1__wqfxyAdjust_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__wqfxyAdjust(soap, "ns1:wqfxyAdjust", -1, &a->ns1__wqfxyAdjust_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxyAdjust_ * SOAP_FMAC4 soap_in___ns1__wqfxyAdjust_(struct soap *soap, const char *tag, struct __ns1__wqfxyAdjust_ *a, const char *type)
{
	size_t soap_flag_ns1__wqfxyAdjust_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__wqfxyAdjust_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wqfxyAdjust_, sizeof(struct __ns1__wqfxyAdjust_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wqfxyAdjust_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wqfxyAdjust_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wqfxyAdjust(soap, "ns1:wqfxyAdjust", &a->ns1__wqfxyAdjust_, "ns1:wqfxyAdjust"))
				{	soap_flag_ns1__wqfxyAdjust_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wqfxyAdjust_(struct soap *soap, const struct __ns1__wqfxyAdjust_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wqfxyAdjust_(soap, tag?tag:"-ns1:wqfxyAdjust", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxyAdjust_ * SOAP_FMAC4 soap_get___ns1__wqfxyAdjust_(struct soap *soap, struct __ns1__wqfxyAdjust_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wqfxyAdjust_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__wqfxyAdjust_ * SOAP_FMAC2 soap_instantiate___ns1__wqfxyAdjust_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__wqfxyAdjust_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__wqfxyAdjust_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__wqfxyAdjust_);
		if (size)
			*size = sizeof(struct __ns1__wqfxyAdjust_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__wqfxyAdjust_, n);
		if (size)
			*size = n * sizeof(struct __ns1__wqfxyAdjust_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__wqfxyAdjust_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__wqfxyAdjust_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__wqfxyAdjust_ %p -> %p\n", q, p));
	*(struct __ns1__wqfxyAdjust_*)p = *(struct __ns1__wqfxyAdjust_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjPLHPSelfcheck_(struct soap *soap, struct __ns1__cgjPLHPSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjPLHPSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjPLHPSelfcheck_(struct soap *soap, const struct __ns1__cgjPLHPSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjPLHPSelfcheck(soap, &a->ns1__cgjPLHPSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjPLHPSelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__cgjPLHPSelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjPLHPSelfcheck(soap, "ns1:cgjPLHPSelfcheck", -1, &a->ns1__cgjPLHPSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjPLHPSelfcheck_ * SOAP_FMAC4 soap_in___ns1__cgjPLHPSelfcheck_(struct soap *soap, const char *tag, struct __ns1__cgjPLHPSelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__cgjPLHPSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjPLHPSelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjPLHPSelfcheck_, sizeof(struct __ns1__cgjPLHPSelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjPLHPSelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjPLHPSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjPLHPSelfcheck(soap, "ns1:cgjPLHPSelfcheck", &a->ns1__cgjPLHPSelfcheck_, "ns1:cgjPLHPSelfcheck"))
				{	soap_flag_ns1__cgjPLHPSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjPLHPSelfcheck_(struct soap *soap, const struct __ns1__cgjPLHPSelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjPLHPSelfcheck_(soap, tag?tag:"-ns1:cgjPLHPSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjPLHPSelfcheck_ * SOAP_FMAC4 soap_get___ns1__cgjPLHPSelfcheck_(struct soap *soap, struct __ns1__cgjPLHPSelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjPLHPSelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjPLHPSelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__cgjPLHPSelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjPLHPSelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjPLHPSelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjPLHPSelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__cgjPLHPSelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjPLHPSelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjPLHPSelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjPLHPSelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjPLHPSelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjPLHPSelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__cgjPLHPSelfcheck_*)p = *(struct __ns1__cgjPLHPSelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doubleIdleLog_(struct soap *soap, struct __ns1__doubleIdleLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doubleIdleLog_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doubleIdleLog_(struct soap *soap, const struct __ns1__doubleIdleLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__doubleIdleLog(soap, &a->ns1__doubleIdleLog_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doubleIdleLog_(struct soap *soap, const char *tag, int id, const struct __ns1__doubleIdleLog_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__doubleIdleLog(soap, "ns1:doubleIdleLog", -1, &a->ns1__doubleIdleLog_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleLog_ * SOAP_FMAC4 soap_in___ns1__doubleIdleLog_(struct soap *soap, const char *tag, struct __ns1__doubleIdleLog_ *a, const char *type)
{
	size_t soap_flag_ns1__doubleIdleLog_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doubleIdleLog_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doubleIdleLog_, sizeof(struct __ns1__doubleIdleLog_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doubleIdleLog_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doubleIdleLog_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__doubleIdleLog(soap, "ns1:doubleIdleLog", &a->ns1__doubleIdleLog_, "ns1:doubleIdleLog"))
				{	soap_flag_ns1__doubleIdleLog_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doubleIdleLog_(struct soap *soap, const struct __ns1__doubleIdleLog_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__doubleIdleLog_(soap, tag?tag:"-ns1:doubleIdleLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleLog_ * SOAP_FMAC4 soap_get___ns1__doubleIdleLog_(struct soap *soap, struct __ns1__doubleIdleLog_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doubleIdleLog_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__doubleIdleLog_ * SOAP_FMAC2 soap_instantiate___ns1__doubleIdleLog_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doubleIdleLog_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__doubleIdleLog_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__doubleIdleLog_);
		if (size)
			*size = sizeof(struct __ns1__doubleIdleLog_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__doubleIdleLog_, n);
		if (size)
			*size = n * sizeof(struct __ns1__doubleIdleLog_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__doubleIdleLog_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__doubleIdleLog_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__doubleIdleLog_ %p -> %p\n", q, p));
	*(struct __ns1__doubleIdleLog_*)p = *(struct __ns1__doubleIdleLog_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doubleIdleData_(struct soap *soap, struct __ns1__doubleIdleData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doubleIdleData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doubleIdleData_(struct soap *soap, const struct __ns1__doubleIdleData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__doubleIdleData(soap, &a->ns1__doubleIdleData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doubleIdleData_(struct soap *soap, const char *tag, int id, const struct __ns1__doubleIdleData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__doubleIdleData(soap, "ns1:doubleIdleData", -1, &a->ns1__doubleIdleData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleData_ * SOAP_FMAC4 soap_in___ns1__doubleIdleData_(struct soap *soap, const char *tag, struct __ns1__doubleIdleData_ *a, const char *type)
{
	size_t soap_flag_ns1__doubleIdleData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doubleIdleData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doubleIdleData_, sizeof(struct __ns1__doubleIdleData_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doubleIdleData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doubleIdleData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__doubleIdleData(soap, "ns1:doubleIdleData", &a->ns1__doubleIdleData_, "ns1:doubleIdleData"))
				{	soap_flag_ns1__doubleIdleData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doubleIdleData_(struct soap *soap, const struct __ns1__doubleIdleData_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__doubleIdleData_(soap, tag?tag:"-ns1:doubleIdleData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleData_ * SOAP_FMAC4 soap_get___ns1__doubleIdleData_(struct soap *soap, struct __ns1__doubleIdleData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doubleIdleData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__doubleIdleData_ * SOAP_FMAC2 soap_instantiate___ns1__doubleIdleData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doubleIdleData_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__doubleIdleData_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__doubleIdleData_);
		if (size)
			*size = sizeof(struct __ns1__doubleIdleData_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__doubleIdleData_, n);
		if (size)
			*size = n * sizeof(struct __ns1__doubleIdleData_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__doubleIdleData_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__doubleIdleData_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__doubleIdleData_ %p -> %p\n", q, p));
	*(struct __ns1__doubleIdleData_*)p = *(struct __ns1__doubleIdleData_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSatate_(struct soap *soap, struct __ns1__getSatate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSatate_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSatate_(struct soap *soap, const struct __ns1__getSatate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__getSatate(soap, &a->ns1__getSatate_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSatate_(struct soap *soap, const char *tag, int id, const struct __ns1__getSatate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__getSatate(soap, "ns1:getSatate", -1, &a->ns1__getSatate_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSatate_ * SOAP_FMAC4 soap_in___ns1__getSatate_(struct soap *soap, const char *tag, struct __ns1__getSatate_ *a, const char *type)
{
	size_t soap_flag_ns1__getSatate_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getSatate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSatate_, sizeof(struct __ns1__getSatate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSatate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSatate_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getSatate(soap, "ns1:getSatate", &a->ns1__getSatate_, "ns1:getSatate"))
				{	soap_flag_ns1__getSatate_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSatate_(struct soap *soap, const struct __ns1__getSatate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSatate_(soap, tag?tag:"-ns1:getSatate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSatate_ * SOAP_FMAC4 soap_get___ns1__getSatate_(struct soap *soap, struct __ns1__getSatate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSatate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSatate_ * SOAP_FMAC2 soap_instantiate___ns1__getSatate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSatate_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSatate_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSatate_);
		if (size)
			*size = sizeof(struct __ns1__getSatate_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getSatate_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getSatate_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getSatate_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSatate_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSatate_ %p -> %p\n", q, p));
	*(struct __ns1__getSatate_*)p = *(struct __ns1__getSatate_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__motoDbIdleData_(struct soap *soap, struct __ns1__motoDbIdleData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__motoDbIdleData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__motoDbIdleData_(struct soap *soap, const struct __ns1__motoDbIdleData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__motoDbIdleData(soap, &a->ns1__motoDbIdleData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__motoDbIdleData_(struct soap *soap, const char *tag, int id, const struct __ns1__motoDbIdleData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__motoDbIdleData(soap, "ns1:motoDbIdleData", -1, &a->ns1__motoDbIdleData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__motoDbIdleData_ * SOAP_FMAC4 soap_in___ns1__motoDbIdleData_(struct soap *soap, const char *tag, struct __ns1__motoDbIdleData_ *a, const char *type)
{
	size_t soap_flag_ns1__motoDbIdleData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__motoDbIdleData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__motoDbIdleData_, sizeof(struct __ns1__motoDbIdleData_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__motoDbIdleData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__motoDbIdleData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__motoDbIdleData(soap, "ns1:motoDbIdleData", &a->ns1__motoDbIdleData_, "ns1:motoDbIdleData"))
				{	soap_flag_ns1__motoDbIdleData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__motoDbIdleData_(struct soap *soap, const struct __ns1__motoDbIdleData_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__motoDbIdleData_(soap, tag?tag:"-ns1:motoDbIdleData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__motoDbIdleData_ * SOAP_FMAC4 soap_get___ns1__motoDbIdleData_(struct soap *soap, struct __ns1__motoDbIdleData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__motoDbIdleData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__motoDbIdleData_ * SOAP_FMAC2 soap_instantiate___ns1__motoDbIdleData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__motoDbIdleData_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__motoDbIdleData_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__motoDbIdleData_);
		if (size)
			*size = sizeof(struct __ns1__motoDbIdleData_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__motoDbIdleData_, n);
		if (size)
			*size = n * sizeof(struct __ns1__motoDbIdleData_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__motoDbIdleData_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__motoDbIdleData_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__motoDbIdleData_ %p -> %p\n", q, p));
	*(struct __ns1__motoDbIdleData_*)p = *(struct __ns1__motoDbIdleData_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__vmasData_(struct soap *soap, struct __ns1__vmasData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__vmasData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__vmasData_(struct soap *soap, const struct __ns1__vmasData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__vmasData(soap, &a->ns1__vmasData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__vmasData_(struct soap *soap, const char *tag, int id, const struct __ns1__vmasData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__vmasData(soap, "ns1:vmasData", -1, &a->ns1__vmasData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vmasData_ * SOAP_FMAC4 soap_in___ns1__vmasData_(struct soap *soap, const char *tag, struct __ns1__vmasData_ *a, const char *type)
{
	size_t soap_flag_ns1__vmasData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__vmasData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__vmasData_, sizeof(struct __ns1__vmasData_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__vmasData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__vmasData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__vmasData(soap, "ns1:vmasData", &a->ns1__vmasData_, "ns1:vmasData"))
				{	soap_flag_ns1__vmasData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__vmasData_(struct soap *soap, const struct __ns1__vmasData_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__vmasData_(soap, tag?tag:"-ns1:vmasData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vmasData_ * SOAP_FMAC4 soap_get___ns1__vmasData_(struct soap *soap, struct __ns1__vmasData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__vmasData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__vmasData_ * SOAP_FMAC2 soap_instantiate___ns1__vmasData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__vmasData_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__vmasData_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__vmasData_);
		if (size)
			*size = sizeof(struct __ns1__vmasData_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__vmasData_, n);
		if (size)
			*size = n * sizeof(struct __ns1__vmasData_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__vmasData_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__vmasData_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__vmasData_ %p -> %p\n", q, p));
	*(struct __ns1__vmasData_*)p = *(struct __ns1__vmasData_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__loadDownData_(struct soap *soap, struct __ns1__loadDownData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__loadDownData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__loadDownData_(struct soap *soap, const struct __ns1__loadDownData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__loadDownData(soap, &a->ns1__loadDownData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__loadDownData_(struct soap *soap, const char *tag, int id, const struct __ns1__loadDownData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__loadDownData(soap, "ns1:loadDownData", -1, &a->ns1__loadDownData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadDownData_ * SOAP_FMAC4 soap_in___ns1__loadDownData_(struct soap *soap, const char *tag, struct __ns1__loadDownData_ *a, const char *type)
{
	size_t soap_flag_ns1__loadDownData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__loadDownData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__loadDownData_, sizeof(struct __ns1__loadDownData_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__loadDownData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loadDownData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__loadDownData(soap, "ns1:loadDownData", &a->ns1__loadDownData_, "ns1:loadDownData"))
				{	soap_flag_ns1__loadDownData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__loadDownData_(struct soap *soap, const struct __ns1__loadDownData_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__loadDownData_(soap, tag?tag:"-ns1:loadDownData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadDownData_ * SOAP_FMAC4 soap_get___ns1__loadDownData_(struct soap *soap, struct __ns1__loadDownData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__loadDownData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__loadDownData_ * SOAP_FMAC2 soap_instantiate___ns1__loadDownData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__loadDownData_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__loadDownData_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__loadDownData_);
		if (size)
			*size = sizeof(struct __ns1__loadDownData_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__loadDownData_, n);
		if (size)
			*size = n * sizeof(struct __ns1__loadDownData_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__loadDownData_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__loadDownData_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__loadDownData_ %p -> %p\n", q, p));
	*(struct __ns1__loadDownData_*)p = *(struct __ns1__loadDownData_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lightproofSmokeDataLog_USCOREFC_(struct soap *soap, struct __ns1__lightproofSmokeDataLog_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lightproofSmokeDataLog_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lightproofSmokeDataLog_USCOREFC_(struct soap *soap, const struct __ns1__lightproofSmokeDataLog_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, &a->ns1__lightproofSmokeDataLog_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lightproofSmokeDataLog_USCOREFC_(struct soap *soap, const char *tag, int id, const struct __ns1__lightproofSmokeDataLog_USCOREFC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, "ns1:lightproofSmokeDataLog_FC", -1, &a->ns1__lightproofSmokeDataLog_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeDataLog_USCOREFC_ * SOAP_FMAC4 soap_in___ns1__lightproofSmokeDataLog_USCOREFC_(struct soap *soap, const char *tag, struct __ns1__lightproofSmokeDataLog_USCOREFC_ *a, const char *type)
{
	size_t soap_flag_ns1__lightproofSmokeDataLog_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lightproofSmokeDataLog_USCOREFC_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC_, sizeof(struct __ns1__lightproofSmokeDataLog_USCOREFC_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lightproofSmokeDataLog_USCOREFC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lightproofSmokeDataLog_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, "ns1:lightproofSmokeDataLog_FC", &a->ns1__lightproofSmokeDataLog_USCOREFC_, "ns1:lightproofSmokeDataLog_FC"))
				{	soap_flag_ns1__lightproofSmokeDataLog_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lightproofSmokeDataLog_USCOREFC_(struct soap *soap, const struct __ns1__lightproofSmokeDataLog_USCOREFC_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lightproofSmokeDataLog_USCOREFC_(soap, tag?tag:"-ns1:lightproofSmokeDataLog_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeDataLog_USCOREFC_ * SOAP_FMAC4 soap_get___ns1__lightproofSmokeDataLog_USCOREFC_(struct soap *soap, struct __ns1__lightproofSmokeDataLog_USCOREFC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lightproofSmokeDataLog_USCOREFC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lightproofSmokeDataLog_USCOREFC_ * SOAP_FMAC2 soap_instantiate___ns1__lightproofSmokeDataLog_USCOREFC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lightproofSmokeDataLog_USCOREFC_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lightproofSmokeDataLog_USCOREFC_);
		if (size)
			*size = sizeof(struct __ns1__lightproofSmokeDataLog_USCOREFC_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lightproofSmokeDataLog_USCOREFC_, n);
		if (size)
			*size = n * sizeof(struct __ns1__lightproofSmokeDataLog_USCOREFC_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lightproofSmokeDataLog_USCOREFC_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lightproofSmokeDataLog_USCOREFC_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lightproofSmokeDataLog_USCOREFC_ %p -> %p\n", q, p));
	*(struct __ns1__lightproofSmokeDataLog_USCOREFC_*)p = *(struct __ns1__lightproofSmokeDataLog_USCOREFC_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__pqfxySelfcheck_(struct soap *soap, struct __ns1__pqfxySelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__pqfxySelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__pqfxySelfcheck_(struct soap *soap, const struct __ns1__pqfxySelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__pqfxySelfcheck(soap, &a->ns1__pqfxySelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__pqfxySelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__pqfxySelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__pqfxySelfcheck(soap, "ns1:pqfxySelfcheck", -1, &a->ns1__pqfxySelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__pqfxySelfcheck_ * SOAP_FMAC4 soap_in___ns1__pqfxySelfcheck_(struct soap *soap, const char *tag, struct __ns1__pqfxySelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__pqfxySelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__pqfxySelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__pqfxySelfcheck_, sizeof(struct __ns1__pqfxySelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__pqfxySelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__pqfxySelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__pqfxySelfcheck(soap, "ns1:pqfxySelfcheck", &a->ns1__pqfxySelfcheck_, "ns1:pqfxySelfcheck"))
				{	soap_flag_ns1__pqfxySelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__pqfxySelfcheck_(struct soap *soap, const struct __ns1__pqfxySelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__pqfxySelfcheck_(soap, tag?tag:"-ns1:pqfxySelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__pqfxySelfcheck_ * SOAP_FMAC4 soap_get___ns1__pqfxySelfcheck_(struct soap *soap, struct __ns1__pqfxySelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__pqfxySelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__pqfxySelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__pqfxySelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__pqfxySelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__pqfxySelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__pqfxySelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__pqfxySelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__pqfxySelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__pqfxySelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__pqfxySelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__pqfxySelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__pqfxySelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__pqfxySelfcheck_*)p = *(struct __ns1__pqfxySelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hjcsgyqSelfcheck_(struct soap *soap, struct __ns1__hjcsgyqSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hjcsgyqSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hjcsgyqSelfcheck_(struct soap *soap, const struct __ns1__hjcsgyqSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__hjcsgyqSelfcheck(soap, &a->ns1__hjcsgyqSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hjcsgyqSelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__hjcsgyqSelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__hjcsgyqSelfcheck(soap, "ns1:hjcsgyqSelfcheck", -1, &a->ns1__hjcsgyqSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hjcsgyqSelfcheck_ * SOAP_FMAC4 soap_in___ns1__hjcsgyqSelfcheck_(struct soap *soap, const char *tag, struct __ns1__hjcsgyqSelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__hjcsgyqSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__hjcsgyqSelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hjcsgyqSelfcheck_, sizeof(struct __ns1__hjcsgyqSelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hjcsgyqSelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hjcsgyqSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__hjcsgyqSelfcheck(soap, "ns1:hjcsgyqSelfcheck", &a->ns1__hjcsgyqSelfcheck_, "ns1:hjcsgyqSelfcheck"))
				{	soap_flag_ns1__hjcsgyqSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hjcsgyqSelfcheck_(struct soap *soap, const struct __ns1__hjcsgyqSelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hjcsgyqSelfcheck_(soap, tag?tag:"-ns1:hjcsgyqSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hjcsgyqSelfcheck_ * SOAP_FMAC4 soap_get___ns1__hjcsgyqSelfcheck_(struct soap *soap, struct __ns1__hjcsgyqSelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hjcsgyqSelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__hjcsgyqSelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__hjcsgyqSelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__hjcsgyqSelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__hjcsgyqSelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__hjcsgyqSelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__hjcsgyqSelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__hjcsgyqSelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__hjcsgyqSelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__hjcsgyqSelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__hjcsgyqSelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__hjcsgyqSelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__hjcsgyqSelfcheck_*)p = *(struct __ns1__hjcsgyqSelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cycdyhwAdjust_(struct soap *soap, struct __ns1__cycdyhwAdjust_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cycdyhwAdjust_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cycdyhwAdjust_(struct soap *soap, const struct __ns1__cycdyhwAdjust_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cycdyhwAdjust(soap, &a->ns1__cycdyhwAdjust_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cycdyhwAdjust_(struct soap *soap, const char *tag, int id, const struct __ns1__cycdyhwAdjust_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cycdyhwAdjust(soap, "ns1:cycdyhwAdjust", -1, &a->ns1__cycdyhwAdjust_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cycdyhwAdjust_ * SOAP_FMAC4 soap_in___ns1__cycdyhwAdjust_(struct soap *soap, const char *tag, struct __ns1__cycdyhwAdjust_ *a, const char *type)
{
	size_t soap_flag_ns1__cycdyhwAdjust_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cycdyhwAdjust_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cycdyhwAdjust_, sizeof(struct __ns1__cycdyhwAdjust_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cycdyhwAdjust_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cycdyhwAdjust_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cycdyhwAdjust(soap, "ns1:cycdyhwAdjust", &a->ns1__cycdyhwAdjust_, "ns1:cycdyhwAdjust"))
				{	soap_flag_ns1__cycdyhwAdjust_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cycdyhwAdjust_(struct soap *soap, const struct __ns1__cycdyhwAdjust_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cycdyhwAdjust_(soap, tag?tag:"-ns1:cycdyhwAdjust", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cycdyhwAdjust_ * SOAP_FMAC4 soap_get___ns1__cycdyhwAdjust_(struct soap *soap, struct __ns1__cycdyhwAdjust_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cycdyhwAdjust_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cycdyhwAdjust_ * SOAP_FMAC2 soap_instantiate___ns1__cycdyhwAdjust_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cycdyhwAdjust_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cycdyhwAdjust_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cycdyhwAdjust_);
		if (size)
			*size = sizeof(struct __ns1__cycdyhwAdjust_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cycdyhwAdjust_, n);
		if (size)
			*size = n * sizeof(struct __ns1__cycdyhwAdjust_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cycdyhwAdjust_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cycdyhwAdjust_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cycdyhwAdjust_ %p -> %p\n", q, p));
	*(struct __ns1__cycdyhwAdjust_*)p = *(struct __ns1__cycdyhwAdjust_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__software2centerNew_USCOREFC_(struct soap *soap, struct __ns1__software2centerNew_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__software2centerNew_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__software2centerNew_USCOREFC_(struct soap *soap, const struct __ns1__software2centerNew_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__software2centerNew_USCOREFC(soap, &a->ns1__software2centerNew_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__software2centerNew_USCOREFC_(struct soap *soap, const char *tag, int id, const struct __ns1__software2centerNew_USCOREFC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__software2centerNew_USCOREFC(soap, "ns1:software2centerNew_FC", -1, &a->ns1__software2centerNew_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__software2centerNew_USCOREFC_ * SOAP_FMAC4 soap_in___ns1__software2centerNew_USCOREFC_(struct soap *soap, const char *tag, struct __ns1__software2centerNew_USCOREFC_ *a, const char *type)
{
	size_t soap_flag_ns1__software2centerNew_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__software2centerNew_USCOREFC_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__software2centerNew_USCOREFC_, sizeof(struct __ns1__software2centerNew_USCOREFC_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__software2centerNew_USCOREFC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__software2centerNew_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__software2centerNew_USCOREFC(soap, "ns1:software2centerNew_FC", &a->ns1__software2centerNew_USCOREFC_, "ns1:software2centerNew_FC"))
				{	soap_flag_ns1__software2centerNew_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__software2centerNew_USCOREFC_(struct soap *soap, const struct __ns1__software2centerNew_USCOREFC_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__software2centerNew_USCOREFC_(soap, tag?tag:"-ns1:software2centerNew_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__software2centerNew_USCOREFC_ * SOAP_FMAC4 soap_get___ns1__software2centerNew_USCOREFC_(struct soap *soap, struct __ns1__software2centerNew_USCOREFC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__software2centerNew_USCOREFC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__software2centerNew_USCOREFC_ * SOAP_FMAC2 soap_instantiate___ns1__software2centerNew_USCOREFC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__software2centerNew_USCOREFC_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__software2centerNew_USCOREFC_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__software2centerNew_USCOREFC_);
		if (size)
			*size = sizeof(struct __ns1__software2centerNew_USCOREFC_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__software2centerNew_USCOREFC_, n);
		if (size)
			*size = n * sizeof(struct __ns1__software2centerNew_USCOREFC_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__software2centerNew_USCOREFC_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__software2centerNew_USCOREFC_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__software2centerNew_USCOREFC_ %p -> %p\n", q, p));
	*(struct __ns1__software2centerNew_USCOREFC_*)p = *(struct __ns1__software2centerNew_USCOREFC_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCarInfo_USCOREFC_(struct soap *soap, struct __ns1__getCarInfo_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCarInfo_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCarInfo_USCOREFC_(struct soap *soap, const struct __ns1__getCarInfo_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__getCarInfo_USCOREFC(soap, &a->ns1__getCarInfo_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCarInfo_USCOREFC_(struct soap *soap, const char *tag, int id, const struct __ns1__getCarInfo_USCOREFC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__getCarInfo_USCOREFC(soap, "ns1:getCarInfo_FC", -1, &a->ns1__getCarInfo_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCarInfo_USCOREFC_ * SOAP_FMAC4 soap_in___ns1__getCarInfo_USCOREFC_(struct soap *soap, const char *tag, struct __ns1__getCarInfo_USCOREFC_ *a, const char *type)
{
	size_t soap_flag_ns1__getCarInfo_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getCarInfo_USCOREFC_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCarInfo_USCOREFC_, sizeof(struct __ns1__getCarInfo_USCOREFC_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCarInfo_USCOREFC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCarInfo_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getCarInfo_USCOREFC(soap, "ns1:getCarInfo_FC", &a->ns1__getCarInfo_USCOREFC_, "ns1:getCarInfo_FC"))
				{	soap_flag_ns1__getCarInfo_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCarInfo_USCOREFC_(struct soap *soap, const struct __ns1__getCarInfo_USCOREFC_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCarInfo_USCOREFC_(soap, tag?tag:"-ns1:getCarInfo_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCarInfo_USCOREFC_ * SOAP_FMAC4 soap_get___ns1__getCarInfo_USCOREFC_(struct soap *soap, struct __ns1__getCarInfo_USCOREFC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCarInfo_USCOREFC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getCarInfo_USCOREFC_ * SOAP_FMAC2 soap_instantiate___ns1__getCarInfo_USCOREFC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCarInfo_USCOREFC_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCarInfo_USCOREFC_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCarInfo_USCOREFC_);
		if (size)
			*size = sizeof(struct __ns1__getCarInfo_USCOREFC_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getCarInfo_USCOREFC_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getCarInfo_USCOREFC_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getCarInfo_USCOREFC_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCarInfo_USCOREFC_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCarInfo_USCOREFC_ %p -> %p\n", q, p));
	*(struct __ns1__getCarInfo_USCOREFC_*)p = *(struct __ns1__getCarInfo_USCOREFC_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__obdResultLog_(struct soap *soap, struct __ns1__obdResultLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__obdResultLog_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__obdResultLog_(struct soap *soap, const struct __ns1__obdResultLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__obdResultLog(soap, &a->ns1__obdResultLog_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__obdResultLog_(struct soap *soap, const char *tag, int id, const struct __ns1__obdResultLog_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__obdResultLog(soap, "ns1:obdResultLog", -1, &a->ns1__obdResultLog_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdResultLog_ * SOAP_FMAC4 soap_in___ns1__obdResultLog_(struct soap *soap, const char *tag, struct __ns1__obdResultLog_ *a, const char *type)
{
	size_t soap_flag_ns1__obdResultLog_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__obdResultLog_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__obdResultLog_, sizeof(struct __ns1__obdResultLog_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__obdResultLog_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__obdResultLog_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__obdResultLog(soap, "ns1:obdResultLog", &a->ns1__obdResultLog_, "ns1:obdResultLog"))
				{	soap_flag_ns1__obdResultLog_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__obdResultLog_(struct soap *soap, const struct __ns1__obdResultLog_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__obdResultLog_(soap, tag?tag:"-ns1:obdResultLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdResultLog_ * SOAP_FMAC4 soap_get___ns1__obdResultLog_(struct soap *soap, struct __ns1__obdResultLog_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__obdResultLog_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__obdResultLog_ * SOAP_FMAC2 soap_instantiate___ns1__obdResultLog_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__obdResultLog_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__obdResultLog_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__obdResultLog_);
		if (size)
			*size = sizeof(struct __ns1__obdResultLog_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__obdResultLog_, n);
		if (size)
			*size = n * sizeof(struct __ns1__obdResultLog_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__obdResultLog_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__obdResultLog_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__obdResultLog_ %p -> %p\n", q, p));
	*(struct __ns1__obdResultLog_*)p = *(struct __ns1__obdResultLog_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__dyhwAdjust_(struct soap *soap, struct __ns1__dyhwAdjust_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__dyhwAdjust_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__dyhwAdjust_(struct soap *soap, const struct __ns1__dyhwAdjust_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__dyhwAdjust(soap, &a->ns1__dyhwAdjust_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__dyhwAdjust_(struct soap *soap, const char *tag, int id, const struct __ns1__dyhwAdjust_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__dyhwAdjust(soap, "ns1:dyhwAdjust", -1, &a->ns1__dyhwAdjust_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dyhwAdjust_ * SOAP_FMAC4 soap_in___ns1__dyhwAdjust_(struct soap *soap, const char *tag, struct __ns1__dyhwAdjust_ *a, const char *type)
{
	size_t soap_flag_ns1__dyhwAdjust_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__dyhwAdjust_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__dyhwAdjust_, sizeof(struct __ns1__dyhwAdjust_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__dyhwAdjust_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__dyhwAdjust_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__dyhwAdjust(soap, "ns1:dyhwAdjust", &a->ns1__dyhwAdjust_, "ns1:dyhwAdjust"))
				{	soap_flag_ns1__dyhwAdjust_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__dyhwAdjust_(struct soap *soap, const struct __ns1__dyhwAdjust_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__dyhwAdjust_(soap, tag?tag:"-ns1:dyhwAdjust", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dyhwAdjust_ * SOAP_FMAC4 soap_get___ns1__dyhwAdjust_(struct soap *soap, struct __ns1__dyhwAdjust_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__dyhwAdjust_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__dyhwAdjust_ * SOAP_FMAC2 soap_instantiate___ns1__dyhwAdjust_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__dyhwAdjust_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__dyhwAdjust_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__dyhwAdjust_);
		if (size)
			*size = sizeof(struct __ns1__dyhwAdjust_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__dyhwAdjust_, n);
		if (size)
			*size = n * sizeof(struct __ns1__dyhwAdjust_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__dyhwAdjust_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__dyhwAdjust_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__dyhwAdjust_ %p -> %p\n", q, p));
	*(struct __ns1__dyhwAdjust_*)p = *(struct __ns1__dyhwAdjust_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__loadDownLog_(struct soap *soap, struct __ns1__loadDownLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__loadDownLog_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__loadDownLog_(struct soap *soap, const struct __ns1__loadDownLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__loadDownLog(soap, &a->ns1__loadDownLog_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__loadDownLog_(struct soap *soap, const char *tag, int id, const struct __ns1__loadDownLog_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__loadDownLog(soap, "ns1:loadDownLog", -1, &a->ns1__loadDownLog_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadDownLog_ * SOAP_FMAC4 soap_in___ns1__loadDownLog_(struct soap *soap, const char *tag, struct __ns1__loadDownLog_ *a, const char *type)
{
	size_t soap_flag_ns1__loadDownLog_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__loadDownLog_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__loadDownLog_, sizeof(struct __ns1__loadDownLog_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__loadDownLog_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loadDownLog_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__loadDownLog(soap, "ns1:loadDownLog", &a->ns1__loadDownLog_, "ns1:loadDownLog"))
				{	soap_flag_ns1__loadDownLog_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__loadDownLog_(struct soap *soap, const struct __ns1__loadDownLog_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__loadDownLog_(soap, tag?tag:"-ns1:loadDownLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadDownLog_ * SOAP_FMAC4 soap_get___ns1__loadDownLog_(struct soap *soap, struct __ns1__loadDownLog_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__loadDownLog_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__loadDownLog_ * SOAP_FMAC2 soap_instantiate___ns1__loadDownLog_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__loadDownLog_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__loadDownLog_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__loadDownLog_);
		if (size)
			*size = sizeof(struct __ns1__loadDownLog_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__loadDownLog_, n);
		if (size)
			*size = n * sizeof(struct __ns1__loadDownLog_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__loadDownLog_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__loadDownLog_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__loadDownLog_ %p -> %p\n", q, p));
	*(struct __ns1__loadDownLog_*)p = *(struct __ns1__loadDownLog_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__dyhwSelfcheck_(struct soap *soap, struct __ns1__dyhwSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__dyhwSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__dyhwSelfcheck_(struct soap *soap, const struct __ns1__dyhwSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__dyhwSelfcheck(soap, &a->ns1__dyhwSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__dyhwSelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__dyhwSelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__dyhwSelfcheck(soap, "ns1:dyhwSelfcheck", -1, &a->ns1__dyhwSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dyhwSelfcheck_ * SOAP_FMAC4 soap_in___ns1__dyhwSelfcheck_(struct soap *soap, const char *tag, struct __ns1__dyhwSelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__dyhwSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__dyhwSelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__dyhwSelfcheck_, sizeof(struct __ns1__dyhwSelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__dyhwSelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__dyhwSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__dyhwSelfcheck(soap, "ns1:dyhwSelfcheck", &a->ns1__dyhwSelfcheck_, "ns1:dyhwSelfcheck"))
				{	soap_flag_ns1__dyhwSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__dyhwSelfcheck_(struct soap *soap, const struct __ns1__dyhwSelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__dyhwSelfcheck_(soap, tag?tag:"-ns1:dyhwSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dyhwSelfcheck_ * SOAP_FMAC4 soap_get___ns1__dyhwSelfcheck_(struct soap *soap, struct __ns1__dyhwSelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__dyhwSelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__dyhwSelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__dyhwSelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__dyhwSelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__dyhwSelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__dyhwSelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__dyhwSelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__dyhwSelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__dyhwSelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__dyhwSelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__dyhwSelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__dyhwSelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__dyhwSelfcheck_*)p = *(struct __ns1__dyhwSelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ydjSelfcheck_(struct soap *soap, struct __ns1__ydjSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ydjSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ydjSelfcheck_(struct soap *soap, const struct __ns1__ydjSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ydjSelfcheck(soap, &a->ns1__ydjSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ydjSelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__ydjSelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ydjSelfcheck(soap, "ns1:ydjSelfcheck", -1, &a->ns1__ydjSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ydjSelfcheck_ * SOAP_FMAC4 soap_in___ns1__ydjSelfcheck_(struct soap *soap, const char *tag, struct __ns1__ydjSelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__ydjSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ydjSelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ydjSelfcheck_, sizeof(struct __ns1__ydjSelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ydjSelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ydjSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ydjSelfcheck(soap, "ns1:ydjSelfcheck", &a->ns1__ydjSelfcheck_, "ns1:ydjSelfcheck"))
				{	soap_flag_ns1__ydjSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ydjSelfcheck_(struct soap *soap, const struct __ns1__ydjSelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ydjSelfcheck_(soap, tag?tag:"-ns1:ydjSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ydjSelfcheck_ * SOAP_FMAC4 soap_get___ns1__ydjSelfcheck_(struct soap *soap, struct __ns1__ydjSelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ydjSelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__ydjSelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__ydjSelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ydjSelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__ydjSelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ydjSelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__ydjSelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__ydjSelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__ydjSelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__ydjSelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ydjSelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ydjSelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__ydjSelfcheck_*)p = *(struct __ns1__ydjSelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__vmasLog_(struct soap *soap, struct __ns1__vmasLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__vmasLog_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__vmasLog_(struct soap *soap, const struct __ns1__vmasLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__vmasLog(soap, &a->ns1__vmasLog_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__vmasLog_(struct soap *soap, const char *tag, int id, const struct __ns1__vmasLog_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__vmasLog(soap, "ns1:vmasLog", -1, &a->ns1__vmasLog_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vmasLog_ * SOAP_FMAC4 soap_in___ns1__vmasLog_(struct soap *soap, const char *tag, struct __ns1__vmasLog_ *a, const char *type)
{
	size_t soap_flag_ns1__vmasLog_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__vmasLog_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__vmasLog_, sizeof(struct __ns1__vmasLog_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__vmasLog_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__vmasLog_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__vmasLog(soap, "ns1:vmasLog", &a->ns1__vmasLog_, "ns1:vmasLog"))
				{	soap_flag_ns1__vmasLog_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__vmasLog_(struct soap *soap, const struct __ns1__vmasLog_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__vmasLog_(soap, tag?tag:"-ns1:vmasLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vmasLog_ * SOAP_FMAC4 soap_get___ns1__vmasLog_(struct soap *soap, struct __ns1__vmasLog_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__vmasLog_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__vmasLog_ * SOAP_FMAC2 soap_instantiate___ns1__vmasLog_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__vmasLog_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__vmasLog_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__vmasLog_);
		if (size)
			*size = sizeof(struct __ns1__vmasLog_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__vmasLog_, n);
		if (size)
			*size = n * sizeof(struct __ns1__vmasLog_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__vmasLog_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__vmasLog_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__vmasLog_ %p -> %p\n", q, p));
	*(struct __ns1__vmasLog_*)p = *(struct __ns1__vmasLog_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doubleIdleLog_USCOREFC_(struct soap *soap, struct __ns1__doubleIdleLog_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doubleIdleLog_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doubleIdleLog_USCOREFC_(struct soap *soap, const struct __ns1__doubleIdleLog_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__doubleIdleLog_USCOREFC(soap, &a->ns1__doubleIdleLog_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doubleIdleLog_USCOREFC_(struct soap *soap, const char *tag, int id, const struct __ns1__doubleIdleLog_USCOREFC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__doubleIdleLog_USCOREFC(soap, "ns1:doubleIdleLog_FC", -1, &a->ns1__doubleIdleLog_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleLog_USCOREFC_ * SOAP_FMAC4 soap_in___ns1__doubleIdleLog_USCOREFC_(struct soap *soap, const char *tag, struct __ns1__doubleIdleLog_USCOREFC_ *a, const char *type)
{
	size_t soap_flag_ns1__doubleIdleLog_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doubleIdleLog_USCOREFC_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doubleIdleLog_USCOREFC_, sizeof(struct __ns1__doubleIdleLog_USCOREFC_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doubleIdleLog_USCOREFC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doubleIdleLog_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__doubleIdleLog_USCOREFC(soap, "ns1:doubleIdleLog_FC", &a->ns1__doubleIdleLog_USCOREFC_, "ns1:doubleIdleLog_FC"))
				{	soap_flag_ns1__doubleIdleLog_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doubleIdleLog_USCOREFC_(struct soap *soap, const struct __ns1__doubleIdleLog_USCOREFC_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__doubleIdleLog_USCOREFC_(soap, tag?tag:"-ns1:doubleIdleLog_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleLog_USCOREFC_ * SOAP_FMAC4 soap_get___ns1__doubleIdleLog_USCOREFC_(struct soap *soap, struct __ns1__doubleIdleLog_USCOREFC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doubleIdleLog_USCOREFC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__doubleIdleLog_USCOREFC_ * SOAP_FMAC2 soap_instantiate___ns1__doubleIdleLog_USCOREFC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doubleIdleLog_USCOREFC_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__doubleIdleLog_USCOREFC_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__doubleIdleLog_USCOREFC_);
		if (size)
			*size = sizeof(struct __ns1__doubleIdleLog_USCOREFC_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__doubleIdleLog_USCOREFC_, n);
		if (size)
			*size = n * sizeof(struct __ns1__doubleIdleLog_USCOREFC_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__doubleIdleLog_USCOREFC_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__doubleIdleLog_USCOREFC_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__doubleIdleLog_USCOREFC_ %p -> %p\n", q, p));
	*(struct __ns1__doubleIdleLog_USCOREFC_*)p = *(struct __ns1__doubleIdleLog_USCOREFC_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__obdResult_(struct soap *soap, struct __ns1__obdResult_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__obdResult_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__obdResult_(struct soap *soap, const struct __ns1__obdResult_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__obdResult(soap, &a->ns1__obdResult_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__obdResult_(struct soap *soap, const char *tag, int id, const struct __ns1__obdResult_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__obdResult(soap, "ns1:obdResult", -1, &a->ns1__obdResult_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdResult_ * SOAP_FMAC4 soap_in___ns1__obdResult_(struct soap *soap, const char *tag, struct __ns1__obdResult_ *a, const char *type)
{
	size_t soap_flag_ns1__obdResult_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__obdResult_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__obdResult_, sizeof(struct __ns1__obdResult_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__obdResult_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__obdResult_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__obdResult(soap, "ns1:obdResult", &a->ns1__obdResult_, "ns1:obdResult"))
				{	soap_flag_ns1__obdResult_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__obdResult_(struct soap *soap, const struct __ns1__obdResult_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__obdResult_(soap, tag?tag:"-ns1:obdResult", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdResult_ * SOAP_FMAC4 soap_get___ns1__obdResult_(struct soap *soap, struct __ns1__obdResult_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__obdResult_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__obdResult_ * SOAP_FMAC2 soap_instantiate___ns1__obdResult_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__obdResult_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__obdResult_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__obdResult_);
		if (size)
			*size = sizeof(struct __ns1__obdResult_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__obdResult_, n);
		if (size)
			*size = n * sizeof(struct __ns1__obdResult_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__obdResult_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__obdResult_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__obdResult_ %p -> %p\n", q, p));
	*(struct __ns1__obdResult_*)p = *(struct __ns1__obdResult_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjSelfcheck_(struct soap *soap, struct __ns1__cgjSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjSelfcheck_(struct soap *soap, const struct __ns1__cgjSelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjSelfcheck(soap, &a->ns1__cgjSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjSelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__cgjSelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjSelfcheck(soap, "ns1:cgjSelfcheck", -1, &a->ns1__cgjSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjSelfcheck_ * SOAP_FMAC4 soap_in___ns1__cgjSelfcheck_(struct soap *soap, const char *tag, struct __ns1__cgjSelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__cgjSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjSelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjSelfcheck_, sizeof(struct __ns1__cgjSelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjSelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjSelfcheck(soap, "ns1:cgjSelfcheck", &a->ns1__cgjSelfcheck_, "ns1:cgjSelfcheck"))
				{	soap_flag_ns1__cgjSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjSelfcheck_(struct soap *soap, const struct __ns1__cgjSelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjSelfcheck_(soap, tag?tag:"-ns1:cgjSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjSelfcheck_ * SOAP_FMAC4 soap_get___ns1__cgjSelfcheck_(struct soap *soap, struct __ns1__cgjSelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjSelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjSelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__cgjSelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjSelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjSelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjSelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__cgjSelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjSelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjSelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjSelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjSelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjSelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__cgjSelfcheck_*)p = *(struct __ns1__cgjSelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjLASelfcheck_(struct soap *soap, struct __ns1__cgjLASelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjLASelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjLASelfcheck_(struct soap *soap, const struct __ns1__cgjLASelfcheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjLASelfcheck(soap, &a->ns1__cgjLASelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjLASelfcheck_(struct soap *soap, const char *tag, int id, const struct __ns1__cgjLASelfcheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjLASelfcheck(soap, "ns1:cgjLASelfcheck", -1, &a->ns1__cgjLASelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjLASelfcheck_ * SOAP_FMAC4 soap_in___ns1__cgjLASelfcheck_(struct soap *soap, const char *tag, struct __ns1__cgjLASelfcheck_ *a, const char *type)
{
	size_t soap_flag_ns1__cgjLASelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjLASelfcheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjLASelfcheck_, sizeof(struct __ns1__cgjLASelfcheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjLASelfcheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjLASelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjLASelfcheck(soap, "ns1:cgjLASelfcheck", &a->ns1__cgjLASelfcheck_, "ns1:cgjLASelfcheck"))
				{	soap_flag_ns1__cgjLASelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjLASelfcheck_(struct soap *soap, const struct __ns1__cgjLASelfcheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjLASelfcheck_(soap, tag?tag:"-ns1:cgjLASelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjLASelfcheck_ * SOAP_FMAC4 soap_get___ns1__cgjLASelfcheck_(struct soap *soap, struct __ns1__cgjLASelfcheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjLASelfcheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjLASelfcheck_ * SOAP_FMAC2 soap_instantiate___ns1__cgjLASelfcheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjLASelfcheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjLASelfcheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjLASelfcheck_);
		if (size)
			*size = sizeof(struct __ns1__cgjLASelfcheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjLASelfcheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjLASelfcheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjLASelfcheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjLASelfcheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjLASelfcheck_ %p -> %p\n", q, p));
	*(struct __ns1__cgjLASelfcheck_*)p = *(struct __ns1__cgjLASelfcheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doubleIdleData_USCOREFC_(struct soap *soap, struct __ns1__doubleIdleData_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doubleIdleData_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doubleIdleData_USCOREFC_(struct soap *soap, const struct __ns1__doubleIdleData_USCOREFC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__doubleIdleData_USCOREFC(soap, &a->ns1__doubleIdleData_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doubleIdleData_USCOREFC_(struct soap *soap, const char *tag, int id, const struct __ns1__doubleIdleData_USCOREFC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__doubleIdleData_USCOREFC(soap, "ns1:doubleIdleData_FC", -1, &a->ns1__doubleIdleData_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleData_USCOREFC_ * SOAP_FMAC4 soap_in___ns1__doubleIdleData_USCOREFC_(struct soap *soap, const char *tag, struct __ns1__doubleIdleData_USCOREFC_ *a, const char *type)
{
	size_t soap_flag_ns1__doubleIdleData_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doubleIdleData_USCOREFC_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doubleIdleData_USCOREFC_, sizeof(struct __ns1__doubleIdleData_USCOREFC_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doubleIdleData_USCOREFC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doubleIdleData_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__doubleIdleData_USCOREFC(soap, "ns1:doubleIdleData_FC", &a->ns1__doubleIdleData_USCOREFC_, "ns1:doubleIdleData_FC"))
				{	soap_flag_ns1__doubleIdleData_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doubleIdleData_USCOREFC_(struct soap *soap, const struct __ns1__doubleIdleData_USCOREFC_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__doubleIdleData_USCOREFC_(soap, tag?tag:"-ns1:doubleIdleData_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleData_USCOREFC_ * SOAP_FMAC4 soap_get___ns1__doubleIdleData_USCOREFC_(struct soap *soap, struct __ns1__doubleIdleData_USCOREFC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doubleIdleData_USCOREFC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__doubleIdleData_USCOREFC_ * SOAP_FMAC2 soap_instantiate___ns1__doubleIdleData_USCOREFC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doubleIdleData_USCOREFC_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__doubleIdleData_USCOREFC_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__doubleIdleData_USCOREFC_);
		if (size)
			*size = sizeof(struct __ns1__doubleIdleData_USCOREFC_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__doubleIdleData_USCOREFC_, n);
		if (size)
			*size = n * sizeof(struct __ns1__doubleIdleData_USCOREFC_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__doubleIdleData_USCOREFC_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__doubleIdleData_USCOREFC_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__doubleIdleData_USCOREFC_ %p -> %p\n", q, p));
	*(struct __ns1__doubleIdleData_USCOREFC_*)p = *(struct __ns1__doubleIdleData_USCOREFC_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__bgAirHC_(struct soap *soap, struct __ns1__bgAirHC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__bgAirHC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__bgAirHC_(struct soap *soap, const struct __ns1__bgAirHC_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__bgAirHC(soap, &a->ns1__bgAirHC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__bgAirHC_(struct soap *soap, const char *tag, int id, const struct __ns1__bgAirHC_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__bgAirHC(soap, "ns1:bgAirHC", -1, &a->ns1__bgAirHC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bgAirHC_ * SOAP_FMAC4 soap_in___ns1__bgAirHC_(struct soap *soap, const char *tag, struct __ns1__bgAirHC_ *a, const char *type)
{
	size_t soap_flag_ns1__bgAirHC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__bgAirHC_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__bgAirHC_, sizeof(struct __ns1__bgAirHC_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__bgAirHC_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__bgAirHC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__bgAirHC(soap, "ns1:bgAirHC", &a->ns1__bgAirHC_, "ns1:bgAirHC"))
				{	soap_flag_ns1__bgAirHC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__bgAirHC_(struct soap *soap, const struct __ns1__bgAirHC_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__bgAirHC_(soap, tag?tag:"-ns1:bgAirHC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bgAirHC_ * SOAP_FMAC4 soap_get___ns1__bgAirHC_(struct soap *soap, struct __ns1__bgAirHC_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__bgAirHC_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__bgAirHC_ * SOAP_FMAC2 soap_instantiate___ns1__bgAirHC_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__bgAirHC_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__bgAirHC_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__bgAirHC_);
		if (size)
			*size = sizeof(struct __ns1__bgAirHC_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__bgAirHC_, n);
		if (size)
			*size = n * sizeof(struct __ns1__bgAirHC_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__bgAirHC_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__bgAirHC_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__bgAirHC_ %p -> %p\n", q, p));
	*(struct __ns1__bgAirHC_*)p = *(struct __ns1__bgAirHC_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendMessage_(struct soap *soap, struct __ns1__sendMessage_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendMessage_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendMessage_(struct soap *soap, const struct __ns1__sendMessage_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__sendMessage(soap, &a->ns1__sendMessage_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendMessage_(struct soap *soap, const char *tag, int id, const struct __ns1__sendMessage_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__sendMessage(soap, "ns1:sendMessage", -1, &a->ns1__sendMessage_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendMessage_ * SOAP_FMAC4 soap_in___ns1__sendMessage_(struct soap *soap, const char *tag, struct __ns1__sendMessage_ *a, const char *type)
{
	size_t soap_flag_ns1__sendMessage_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendMessage_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendMessage_, sizeof(struct __ns1__sendMessage_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendMessage_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendMessage_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sendMessage(soap, "ns1:sendMessage", &a->ns1__sendMessage_, "ns1:sendMessage"))
				{	soap_flag_ns1__sendMessage_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendMessage_(struct soap *soap, const struct __ns1__sendMessage_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sendMessage_(soap, tag?tag:"-ns1:sendMessage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendMessage_ * SOAP_FMAC4 soap_get___ns1__sendMessage_(struct soap *soap, struct __ns1__sendMessage_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendMessage_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sendMessage_ * SOAP_FMAC2 soap_instantiate___ns1__sendMessage_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendMessage_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sendMessage_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sendMessage_);
		if (size)
			*size = sizeof(struct __ns1__sendMessage_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__sendMessage_, n);
		if (size)
			*size = n * sizeof(struct __ns1__sendMessage_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__sendMessage_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sendMessage_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sendMessage_ %p -> %p\n", q, p));
	*(struct __ns1__sendMessage_*)p = *(struct __ns1__sendMessage_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCarInfo_(struct soap *soap, struct __ns1__getCarInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCarInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCarInfo_(struct soap *soap, const struct __ns1__getCarInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__getCarInfo(soap, &a->ns1__getCarInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCarInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__getCarInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__getCarInfo(soap, "ns1:getCarInfo", -1, &a->ns1__getCarInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCarInfo_ * SOAP_FMAC4 soap_in___ns1__getCarInfo_(struct soap *soap, const char *tag, struct __ns1__getCarInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__getCarInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getCarInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCarInfo_, sizeof(struct __ns1__getCarInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCarInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCarInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getCarInfo(soap, "ns1:getCarInfo", &a->ns1__getCarInfo_, "ns1:getCarInfo"))
				{	soap_flag_ns1__getCarInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCarInfo_(struct soap *soap, const struct __ns1__getCarInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCarInfo_(soap, tag?tag:"-ns1:getCarInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCarInfo_ * SOAP_FMAC4 soap_get___ns1__getCarInfo_(struct soap *soap, struct __ns1__getCarInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCarInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getCarInfo_ * SOAP_FMAC2 soap_instantiate___ns1__getCarInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCarInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCarInfo_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCarInfo_);
		if (size)
			*size = sizeof(struct __ns1__getCarInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getCarInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__getCarInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getCarInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCarInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCarInfo_ %p -> %p\n", q, p));
	*(struct __ns1__getCarInfo_*)p = *(struct __ns1__getCarInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lightproofSmokeLog_(struct soap *soap, struct __ns1__lightproofSmokeLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lightproofSmokeLog_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lightproofSmokeLog_(struct soap *soap, const struct __ns1__lightproofSmokeLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lightproofSmokeLog(soap, &a->ns1__lightproofSmokeLog_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lightproofSmokeLog_(struct soap *soap, const char *tag, int id, const struct __ns1__lightproofSmokeLog_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lightproofSmokeLog(soap, "ns1:lightproofSmokeLog", -1, &a->ns1__lightproofSmokeLog_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeLog_ * SOAP_FMAC4 soap_in___ns1__lightproofSmokeLog_(struct soap *soap, const char *tag, struct __ns1__lightproofSmokeLog_ *a, const char *type)
{
	size_t soap_flag_ns1__lightproofSmokeLog_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lightproofSmokeLog_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lightproofSmokeLog_, sizeof(struct __ns1__lightproofSmokeLog_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lightproofSmokeLog_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lightproofSmokeLog_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lightproofSmokeLog(soap, "ns1:lightproofSmokeLog", &a->ns1__lightproofSmokeLog_, "ns1:lightproofSmokeLog"))
				{	soap_flag_ns1__lightproofSmokeLog_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lightproofSmokeLog_(struct soap *soap, const struct __ns1__lightproofSmokeLog_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lightproofSmokeLog_(soap, tag?tag:"-ns1:lightproofSmokeLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeLog_ * SOAP_FMAC4 soap_get___ns1__lightproofSmokeLog_(struct soap *soap, struct __ns1__lightproofSmokeLog_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lightproofSmokeLog_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lightproofSmokeLog_ * SOAP_FMAC2 soap_instantiate___ns1__lightproofSmokeLog_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lightproofSmokeLog_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lightproofSmokeLog_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lightproofSmokeLog_);
		if (size)
			*size = sizeof(struct __ns1__lightproofSmokeLog_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lightproofSmokeLog_, n);
		if (size)
			*size = n * sizeof(struct __ns1__lightproofSmokeLog_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lightproofSmokeLog_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lightproofSmokeLog_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lightproofSmokeLog_ %p -> %p\n", q, p));
	*(struct __ns1__lightproofSmokeLog_*)p = *(struct __ns1__lightproofSmokeLog_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__argChang_(struct soap *soap, struct __ns1__argChang_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__argChang_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__argChang_(struct soap *soap, const struct __ns1__argChang_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__argChang(soap, &a->ns1__argChang_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__argChang_(struct soap *soap, const char *tag, int id, const struct __ns1__argChang_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__argChang(soap, "ns1:argChang", -1, &a->ns1__argChang_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__argChang_ * SOAP_FMAC4 soap_in___ns1__argChang_(struct soap *soap, const char *tag, struct __ns1__argChang_ *a, const char *type)
{
	size_t soap_flag_ns1__argChang_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__argChang_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__argChang_, sizeof(struct __ns1__argChang_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__argChang_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__argChang_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__argChang(soap, "ns1:argChang", &a->ns1__argChang_, "ns1:argChang"))
				{	soap_flag_ns1__argChang_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__argChang_(struct soap *soap, const struct __ns1__argChang_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__argChang_(soap, tag?tag:"-ns1:argChang", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__argChang_ * SOAP_FMAC4 soap_get___ns1__argChang_(struct soap *soap, struct __ns1__argChang_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__argChang_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__argChang_ * SOAP_FMAC2 soap_instantiate___ns1__argChang_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__argChang_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__argChang_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__argChang_);
		if (size)
			*size = sizeof(struct __ns1__argChang_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__argChang_, n);
		if (size)
			*size = n * sizeof(struct __ns1__argChang_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__argChang_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__argChang_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__argChang_ %p -> %p\n", q, p));
	*(struct __ns1__argChang_*)p = *(struct __ns1__argChang_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjLSPSelfcheck(struct soap *soap, struct __ns1__cgjLSPSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjLSPSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjLSPSelfcheck(struct soap *soap, const struct __ns1__cgjLSPSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjLSPSelfcheck(soap, &a->ns1__cgjLSPSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjLSPSelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__cgjLSPSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjLSPSelfcheck(soap, "ns1:cgjLSPSelfcheck", -1, &a->ns1__cgjLSPSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjLSPSelfcheck * SOAP_FMAC4 soap_in___ns1__cgjLSPSelfcheck(struct soap *soap, const char *tag, struct __ns1__cgjLSPSelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__cgjLSPSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjLSPSelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjLSPSelfcheck, sizeof(struct __ns1__cgjLSPSelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjLSPSelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjLSPSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjLSPSelfcheck(soap, "ns1:cgjLSPSelfcheck", &a->ns1__cgjLSPSelfcheck_, "ns1:cgjLSPSelfcheck"))
				{	soap_flag_ns1__cgjLSPSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjLSPSelfcheck(struct soap *soap, const struct __ns1__cgjLSPSelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjLSPSelfcheck(soap, tag?tag:"-ns1:cgjLSPSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjLSPSelfcheck * SOAP_FMAC4 soap_get___ns1__cgjLSPSelfcheck(struct soap *soap, struct __ns1__cgjLSPSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjLSPSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjLSPSelfcheck * SOAP_FMAC2 soap_instantiate___ns1__cgjLSPSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjLSPSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjLSPSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjLSPSelfcheck);
		if (size)
			*size = sizeof(struct __ns1__cgjLSPSelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjLSPSelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjLSPSelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjLSPSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjLSPSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjLSPSelfcheck %p -> %p\n", q, p));
	*(struct __ns1__cgjLSPSelfcheck*)p = *(struct __ns1__cgjLSPSelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lljSelfcheck(struct soap *soap, struct __ns1__lljSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lljSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lljSelfcheck(struct soap *soap, const struct __ns1__lljSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lljSelfcheck(soap, &a->ns1__lljSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lljSelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__lljSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lljSelfcheck(soap, "ns1:lljSelfcheck", -1, &a->ns1__lljSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lljSelfcheck * SOAP_FMAC4 soap_in___ns1__lljSelfcheck(struct soap *soap, const char *tag, struct __ns1__lljSelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__lljSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lljSelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lljSelfcheck, sizeof(struct __ns1__lljSelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lljSelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lljSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lljSelfcheck(soap, "ns1:lljSelfcheck", &a->ns1__lljSelfcheck_, "ns1:lljSelfcheck"))
				{	soap_flag_ns1__lljSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lljSelfcheck(struct soap *soap, const struct __ns1__lljSelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lljSelfcheck(soap, tag?tag:"-ns1:lljSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lljSelfcheck * SOAP_FMAC4 soap_get___ns1__lljSelfcheck(struct soap *soap, struct __ns1__lljSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lljSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lljSelfcheck * SOAP_FMAC2 soap_instantiate___ns1__lljSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lljSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lljSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lljSelfcheck);
		if (size)
			*size = sizeof(struct __ns1__lljSelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lljSelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__lljSelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lljSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lljSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lljSelfcheck %p -> %p\n", q, p));
	*(struct __ns1__lljSelfcheck*)p = *(struct __ns1__lljSelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjALPSelfcheck(struct soap *soap, struct __ns1__cgjALPSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjALPSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjALPSelfcheck(struct soap *soap, const struct __ns1__cgjALPSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjALPSelfcheck(soap, &a->ns1__cgjALPSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjALPSelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__cgjALPSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjALPSelfcheck(soap, "ns1:cgjALPSelfcheck", -1, &a->ns1__cgjALPSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjALPSelfcheck * SOAP_FMAC4 soap_in___ns1__cgjALPSelfcheck(struct soap *soap, const char *tag, struct __ns1__cgjALPSelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__cgjALPSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjALPSelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjALPSelfcheck, sizeof(struct __ns1__cgjALPSelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjALPSelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjALPSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjALPSelfcheck(soap, "ns1:cgjALPSelfcheck", &a->ns1__cgjALPSelfcheck_, "ns1:cgjALPSelfcheck"))
				{	soap_flag_ns1__cgjALPSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjALPSelfcheck(struct soap *soap, const struct __ns1__cgjALPSelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjALPSelfcheck(soap, tag?tag:"-ns1:cgjALPSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjALPSelfcheck * SOAP_FMAC4 soap_get___ns1__cgjALPSelfcheck(struct soap *soap, struct __ns1__cgjALPSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjALPSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjALPSelfcheck * SOAP_FMAC2 soap_instantiate___ns1__cgjALPSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjALPSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjALPSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjALPSelfcheck);
		if (size)
			*size = sizeof(struct __ns1__cgjALPSelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjALPSelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjALPSelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjALPSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjALPSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjALPSelfcheck %p -> %p\n", q, p));
	*(struct __ns1__cgjALPSelfcheck*)p = *(struct __ns1__cgjALPSelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wqfxySelfcheck(struct soap *soap, struct __ns1__wqfxySelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wqfxySelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wqfxySelfcheck(struct soap *soap, const struct __ns1__wqfxySelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__wqfxySelfcheck(soap, &a->ns1__wqfxySelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wqfxySelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__wqfxySelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__wqfxySelfcheck(soap, "ns1:wqfxySelfcheck", -1, &a->ns1__wqfxySelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxySelfcheck * SOAP_FMAC4 soap_in___ns1__wqfxySelfcheck(struct soap *soap, const char *tag, struct __ns1__wqfxySelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__wqfxySelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__wqfxySelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wqfxySelfcheck, sizeof(struct __ns1__wqfxySelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wqfxySelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wqfxySelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wqfxySelfcheck(soap, "ns1:wqfxySelfcheck", &a->ns1__wqfxySelfcheck_, "ns1:wqfxySelfcheck"))
				{	soap_flag_ns1__wqfxySelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wqfxySelfcheck(struct soap *soap, const struct __ns1__wqfxySelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wqfxySelfcheck(soap, tag?tag:"-ns1:wqfxySelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxySelfcheck * SOAP_FMAC4 soap_get___ns1__wqfxySelfcheck(struct soap *soap, struct __ns1__wqfxySelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wqfxySelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__wqfxySelfcheck * SOAP_FMAC2 soap_instantiate___ns1__wqfxySelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__wqfxySelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__wqfxySelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__wqfxySelfcheck);
		if (size)
			*size = sizeof(struct __ns1__wqfxySelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__wqfxySelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__wqfxySelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__wqfxySelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__wqfxySelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__wqfxySelfcheck %p -> %p\n", q, p));
	*(struct __ns1__wqfxySelfcheck*)p = *(struct __ns1__wqfxySelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendMessage_USCOREFC(struct soap *soap, struct __ns1__sendMessage_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendMessage_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendMessage_USCOREFC(struct soap *soap, const struct __ns1__sendMessage_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__sendMessage_USCOREFC(soap, &a->ns1__sendMessage_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendMessage_USCOREFC(struct soap *soap, const char *tag, int id, const struct __ns1__sendMessage_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__sendMessage_USCOREFC(soap, "ns1:sendMessage_FC", -1, &a->ns1__sendMessage_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendMessage_USCOREFC * SOAP_FMAC4 soap_in___ns1__sendMessage_USCOREFC(struct soap *soap, const char *tag, struct __ns1__sendMessage_USCOREFC *a, const char *type)
{
	size_t soap_flag_ns1__sendMessage_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendMessage_USCOREFC *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendMessage_USCOREFC, sizeof(struct __ns1__sendMessage_USCOREFC), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendMessage_USCOREFC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendMessage_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sendMessage_USCOREFC(soap, "ns1:sendMessage_FC", &a->ns1__sendMessage_USCOREFC_, "ns1:sendMessage_FC"))
				{	soap_flag_ns1__sendMessage_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendMessage_USCOREFC(struct soap *soap, const struct __ns1__sendMessage_USCOREFC *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sendMessage_USCOREFC(soap, tag?tag:"-ns1:sendMessage_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendMessage_USCOREFC * SOAP_FMAC4 soap_get___ns1__sendMessage_USCOREFC(struct soap *soap, struct __ns1__sendMessage_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendMessage_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sendMessage_USCOREFC * SOAP_FMAC2 soap_instantiate___ns1__sendMessage_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendMessage_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sendMessage_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sendMessage_USCOREFC);
		if (size)
			*size = sizeof(struct __ns1__sendMessage_USCOREFC);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__sendMessage_USCOREFC, n);
		if (size)
			*size = n * sizeof(struct __ns1__sendMessage_USCOREFC);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__sendMessage_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sendMessage_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sendMessage_USCOREFC %p -> %p\n", q, p));
	*(struct __ns1__sendMessage_USCOREFC*)p = *(struct __ns1__sendMessage_USCOREFC*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sdsqtfxySelfcheck(struct soap *soap, struct __ns1__sdsqtfxySelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sdsqtfxySelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sdsqtfxySelfcheck(struct soap *soap, const struct __ns1__sdsqtfxySelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__sdsqtfxySelfcheck(soap, &a->ns1__sdsqtfxySelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sdsqtfxySelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__sdsqtfxySelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__sdsqtfxySelfcheck(soap, "ns1:sdsqtfxySelfcheck", -1, &a->ns1__sdsqtfxySelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sdsqtfxySelfcheck * SOAP_FMAC4 soap_in___ns1__sdsqtfxySelfcheck(struct soap *soap, const char *tag, struct __ns1__sdsqtfxySelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__sdsqtfxySelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sdsqtfxySelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sdsqtfxySelfcheck, sizeof(struct __ns1__sdsqtfxySelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sdsqtfxySelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sdsqtfxySelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sdsqtfxySelfcheck(soap, "ns1:sdsqtfxySelfcheck", &a->ns1__sdsqtfxySelfcheck_, "ns1:sdsqtfxySelfcheck"))
				{	soap_flag_ns1__sdsqtfxySelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sdsqtfxySelfcheck(struct soap *soap, const struct __ns1__sdsqtfxySelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sdsqtfxySelfcheck(soap, tag?tag:"-ns1:sdsqtfxySelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sdsqtfxySelfcheck * SOAP_FMAC4 soap_get___ns1__sdsqtfxySelfcheck(struct soap *soap, struct __ns1__sdsqtfxySelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sdsqtfxySelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sdsqtfxySelfcheck * SOAP_FMAC2 soap_instantiate___ns1__sdsqtfxySelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sdsqtfxySelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sdsqtfxySelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sdsqtfxySelfcheck);
		if (size)
			*size = sizeof(struct __ns1__sdsqtfxySelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__sdsqtfxySelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__sdsqtfxySelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__sdsqtfxySelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sdsqtfxySelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sdsqtfxySelfcheck %p -> %p\n", q, p));
	*(struct __ns1__sdsqtfxySelfcheck*)p = *(struct __ns1__sdsqtfxySelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__qyfxSelfcheck(struct soap *soap, struct __ns1__qyfxSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__qyfxSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__qyfxSelfcheck(struct soap *soap, const struct __ns1__qyfxSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__qyfxSelfcheck(soap, &a->ns1__qyfxSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__qyfxSelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__qyfxSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__qyfxSelfcheck(soap, "ns1:qyfxSelfcheck", -1, &a->ns1__qyfxSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__qyfxSelfcheck * SOAP_FMAC4 soap_in___ns1__qyfxSelfcheck(struct soap *soap, const char *tag, struct __ns1__qyfxSelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__qyfxSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__qyfxSelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__qyfxSelfcheck, sizeof(struct __ns1__qyfxSelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__qyfxSelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__qyfxSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__qyfxSelfcheck(soap, "ns1:qyfxSelfcheck", &a->ns1__qyfxSelfcheck_, "ns1:qyfxSelfcheck"))
				{	soap_flag_ns1__qyfxSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__qyfxSelfcheck(struct soap *soap, const struct __ns1__qyfxSelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__qyfxSelfcheck(soap, tag?tag:"-ns1:qyfxSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__qyfxSelfcheck * SOAP_FMAC4 soap_get___ns1__qyfxSelfcheck(struct soap *soap, struct __ns1__qyfxSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__qyfxSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__qyfxSelfcheck * SOAP_FMAC2 soap_instantiate___ns1__qyfxSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__qyfxSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__qyfxSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__qyfxSelfcheck);
		if (size)
			*size = sizeof(struct __ns1__qyfxSelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__qyfxSelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__qyfxSelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__qyfxSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__qyfxSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__qyfxSelfcheck %p -> %p\n", q, p));
	*(struct __ns1__qyfxSelfcheck*)p = *(struct __ns1__qyfxSelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lightproofSmokeData(struct soap *soap, struct __ns1__lightproofSmokeData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lightproofSmokeData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lightproofSmokeData(struct soap *soap, const struct __ns1__lightproofSmokeData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lightproofSmokeData(soap, &a->ns1__lightproofSmokeData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lightproofSmokeData(struct soap *soap, const char *tag, int id, const struct __ns1__lightproofSmokeData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lightproofSmokeData(soap, "ns1:lightproofSmokeData", -1, &a->ns1__lightproofSmokeData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeData * SOAP_FMAC4 soap_in___ns1__lightproofSmokeData(struct soap *soap, const char *tag, struct __ns1__lightproofSmokeData *a, const char *type)
{
	size_t soap_flag_ns1__lightproofSmokeData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lightproofSmokeData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lightproofSmokeData, sizeof(struct __ns1__lightproofSmokeData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lightproofSmokeData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lightproofSmokeData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lightproofSmokeData(soap, "ns1:lightproofSmokeData", &a->ns1__lightproofSmokeData_, "ns1:lightproofSmokeData"))
				{	soap_flag_ns1__lightproofSmokeData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lightproofSmokeData(struct soap *soap, const struct __ns1__lightproofSmokeData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lightproofSmokeData(soap, tag?tag:"-ns1:lightproofSmokeData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeData * SOAP_FMAC4 soap_get___ns1__lightproofSmokeData(struct soap *soap, struct __ns1__lightproofSmokeData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lightproofSmokeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lightproofSmokeData * SOAP_FMAC2 soap_instantiate___ns1__lightproofSmokeData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lightproofSmokeData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lightproofSmokeData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lightproofSmokeData);
		if (size)
			*size = sizeof(struct __ns1__lightproofSmokeData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lightproofSmokeData, n);
		if (size)
			*size = n * sizeof(struct __ns1__lightproofSmokeData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lightproofSmokeData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lightproofSmokeData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lightproofSmokeData %p -> %p\n", q, p));
	*(struct __ns1__lightproofSmokeData*)p = *(struct __ns1__lightproofSmokeData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lightproofSmokeData_USCOREFC(struct soap *soap, struct __ns1__lightproofSmokeData_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lightproofSmokeData_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lightproofSmokeData_USCOREFC(struct soap *soap, const struct __ns1__lightproofSmokeData_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lightproofSmokeData_USCOREFC(soap, &a->ns1__lightproofSmokeData_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lightproofSmokeData_USCOREFC(struct soap *soap, const char *tag, int id, const struct __ns1__lightproofSmokeData_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lightproofSmokeData_USCOREFC(soap, "ns1:lightproofSmokeData_FC", -1, &a->ns1__lightproofSmokeData_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeData_USCOREFC * SOAP_FMAC4 soap_in___ns1__lightproofSmokeData_USCOREFC(struct soap *soap, const char *tag, struct __ns1__lightproofSmokeData_USCOREFC *a, const char *type)
{
	size_t soap_flag_ns1__lightproofSmokeData_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lightproofSmokeData_USCOREFC *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC, sizeof(struct __ns1__lightproofSmokeData_USCOREFC), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lightproofSmokeData_USCOREFC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lightproofSmokeData_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lightproofSmokeData_USCOREFC(soap, "ns1:lightproofSmokeData_FC", &a->ns1__lightproofSmokeData_USCOREFC_, "ns1:lightproofSmokeData_FC"))
				{	soap_flag_ns1__lightproofSmokeData_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lightproofSmokeData_USCOREFC(struct soap *soap, const struct __ns1__lightproofSmokeData_USCOREFC *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lightproofSmokeData_USCOREFC(soap, tag?tag:"-ns1:lightproofSmokeData_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeData_USCOREFC * SOAP_FMAC4 soap_get___ns1__lightproofSmokeData_USCOREFC(struct soap *soap, struct __ns1__lightproofSmokeData_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lightproofSmokeData_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lightproofSmokeData_USCOREFC * SOAP_FMAC2 soap_instantiate___ns1__lightproofSmokeData_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lightproofSmokeData_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lightproofSmokeData_USCOREFC);
		if (size)
			*size = sizeof(struct __ns1__lightproofSmokeData_USCOREFC);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lightproofSmokeData_USCOREFC, n);
		if (size)
			*size = n * sizeof(struct __ns1__lightproofSmokeData_USCOREFC);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lightproofSmokeData_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lightproofSmokeData_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lightproofSmokeData_USCOREFC %p -> %p\n", q, p));
	*(struct __ns1__lightproofSmokeData_USCOREFC*)p = *(struct __ns1__lightproofSmokeData_USCOREFC*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wqfxyAdjust(struct soap *soap, struct __ns1__wqfxyAdjust *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wqfxyAdjust_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wqfxyAdjust(struct soap *soap, const struct __ns1__wqfxyAdjust *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__wqfxyAdjust(soap, &a->ns1__wqfxyAdjust_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wqfxyAdjust(struct soap *soap, const char *tag, int id, const struct __ns1__wqfxyAdjust *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__wqfxyAdjust(soap, "ns1:wqfxyAdjust", -1, &a->ns1__wqfxyAdjust_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxyAdjust * SOAP_FMAC4 soap_in___ns1__wqfxyAdjust(struct soap *soap, const char *tag, struct __ns1__wqfxyAdjust *a, const char *type)
{
	size_t soap_flag_ns1__wqfxyAdjust_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__wqfxyAdjust *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wqfxyAdjust, sizeof(struct __ns1__wqfxyAdjust), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wqfxyAdjust(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wqfxyAdjust_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wqfxyAdjust(soap, "ns1:wqfxyAdjust", &a->ns1__wqfxyAdjust_, "ns1:wqfxyAdjust"))
				{	soap_flag_ns1__wqfxyAdjust_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wqfxyAdjust(struct soap *soap, const struct __ns1__wqfxyAdjust *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wqfxyAdjust(soap, tag?tag:"-ns1:wqfxyAdjust", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxyAdjust * SOAP_FMAC4 soap_get___ns1__wqfxyAdjust(struct soap *soap, struct __ns1__wqfxyAdjust *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wqfxyAdjust(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__wqfxyAdjust * SOAP_FMAC2 soap_instantiate___ns1__wqfxyAdjust(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__wqfxyAdjust(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__wqfxyAdjust, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__wqfxyAdjust);
		if (size)
			*size = sizeof(struct __ns1__wqfxyAdjust);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__wqfxyAdjust, n);
		if (size)
			*size = n * sizeof(struct __ns1__wqfxyAdjust);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__wqfxyAdjust*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__wqfxyAdjust(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__wqfxyAdjust %p -> %p\n", q, p));
	*(struct __ns1__wqfxyAdjust*)p = *(struct __ns1__wqfxyAdjust*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjPLHPSelfcheck(struct soap *soap, struct __ns1__cgjPLHPSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjPLHPSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjPLHPSelfcheck(struct soap *soap, const struct __ns1__cgjPLHPSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjPLHPSelfcheck(soap, &a->ns1__cgjPLHPSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjPLHPSelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__cgjPLHPSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjPLHPSelfcheck(soap, "ns1:cgjPLHPSelfcheck", -1, &a->ns1__cgjPLHPSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjPLHPSelfcheck * SOAP_FMAC4 soap_in___ns1__cgjPLHPSelfcheck(struct soap *soap, const char *tag, struct __ns1__cgjPLHPSelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__cgjPLHPSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjPLHPSelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjPLHPSelfcheck, sizeof(struct __ns1__cgjPLHPSelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjPLHPSelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjPLHPSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjPLHPSelfcheck(soap, "ns1:cgjPLHPSelfcheck", &a->ns1__cgjPLHPSelfcheck_, "ns1:cgjPLHPSelfcheck"))
				{	soap_flag_ns1__cgjPLHPSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjPLHPSelfcheck(struct soap *soap, const struct __ns1__cgjPLHPSelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjPLHPSelfcheck(soap, tag?tag:"-ns1:cgjPLHPSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjPLHPSelfcheck * SOAP_FMAC4 soap_get___ns1__cgjPLHPSelfcheck(struct soap *soap, struct __ns1__cgjPLHPSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjPLHPSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjPLHPSelfcheck * SOAP_FMAC2 soap_instantiate___ns1__cgjPLHPSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjPLHPSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjPLHPSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjPLHPSelfcheck);
		if (size)
			*size = sizeof(struct __ns1__cgjPLHPSelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjPLHPSelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjPLHPSelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjPLHPSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjPLHPSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjPLHPSelfcheck %p -> %p\n", q, p));
	*(struct __ns1__cgjPLHPSelfcheck*)p = *(struct __ns1__cgjPLHPSelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doubleIdleLog(struct soap *soap, struct __ns1__doubleIdleLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doubleIdleLog_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doubleIdleLog(struct soap *soap, const struct __ns1__doubleIdleLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__doubleIdleLog(soap, &a->ns1__doubleIdleLog_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doubleIdleLog(struct soap *soap, const char *tag, int id, const struct __ns1__doubleIdleLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__doubleIdleLog(soap, "ns1:doubleIdleLog", -1, &a->ns1__doubleIdleLog_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleLog * SOAP_FMAC4 soap_in___ns1__doubleIdleLog(struct soap *soap, const char *tag, struct __ns1__doubleIdleLog *a, const char *type)
{
	size_t soap_flag_ns1__doubleIdleLog_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doubleIdleLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doubleIdleLog, sizeof(struct __ns1__doubleIdleLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doubleIdleLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doubleIdleLog_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__doubleIdleLog(soap, "ns1:doubleIdleLog", &a->ns1__doubleIdleLog_, "ns1:doubleIdleLog"))
				{	soap_flag_ns1__doubleIdleLog_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doubleIdleLog(struct soap *soap, const struct __ns1__doubleIdleLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__doubleIdleLog(soap, tag?tag:"-ns1:doubleIdleLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleLog * SOAP_FMAC4 soap_get___ns1__doubleIdleLog(struct soap *soap, struct __ns1__doubleIdleLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doubleIdleLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__doubleIdleLog * SOAP_FMAC2 soap_instantiate___ns1__doubleIdleLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doubleIdleLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__doubleIdleLog, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__doubleIdleLog);
		if (size)
			*size = sizeof(struct __ns1__doubleIdleLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__doubleIdleLog, n);
		if (size)
			*size = n * sizeof(struct __ns1__doubleIdleLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__doubleIdleLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__doubleIdleLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__doubleIdleLog %p -> %p\n", q, p));
	*(struct __ns1__doubleIdleLog*)p = *(struct __ns1__doubleIdleLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doubleIdleData(struct soap *soap, struct __ns1__doubleIdleData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doubleIdleData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doubleIdleData(struct soap *soap, const struct __ns1__doubleIdleData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__doubleIdleData(soap, &a->ns1__doubleIdleData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doubleIdleData(struct soap *soap, const char *tag, int id, const struct __ns1__doubleIdleData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__doubleIdleData(soap, "ns1:doubleIdleData", -1, &a->ns1__doubleIdleData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleData * SOAP_FMAC4 soap_in___ns1__doubleIdleData(struct soap *soap, const char *tag, struct __ns1__doubleIdleData *a, const char *type)
{
	size_t soap_flag_ns1__doubleIdleData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doubleIdleData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doubleIdleData, sizeof(struct __ns1__doubleIdleData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doubleIdleData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doubleIdleData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__doubleIdleData(soap, "ns1:doubleIdleData", &a->ns1__doubleIdleData_, "ns1:doubleIdleData"))
				{	soap_flag_ns1__doubleIdleData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doubleIdleData(struct soap *soap, const struct __ns1__doubleIdleData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__doubleIdleData(soap, tag?tag:"-ns1:doubleIdleData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleData * SOAP_FMAC4 soap_get___ns1__doubleIdleData(struct soap *soap, struct __ns1__doubleIdleData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doubleIdleData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__doubleIdleData * SOAP_FMAC2 soap_instantiate___ns1__doubleIdleData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doubleIdleData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__doubleIdleData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__doubleIdleData);
		if (size)
			*size = sizeof(struct __ns1__doubleIdleData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__doubleIdleData, n);
		if (size)
			*size = n * sizeof(struct __ns1__doubleIdleData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__doubleIdleData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__doubleIdleData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__doubleIdleData %p -> %p\n", q, p));
	*(struct __ns1__doubleIdleData*)p = *(struct __ns1__doubleIdleData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSatate(struct soap *soap, struct __ns1__getSatate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSatate_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSatate(struct soap *soap, const struct __ns1__getSatate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__getSatate(soap, &a->ns1__getSatate_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSatate(struct soap *soap, const char *tag, int id, const struct __ns1__getSatate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__getSatate(soap, "ns1:getSatate", -1, &a->ns1__getSatate_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSatate * SOAP_FMAC4 soap_in___ns1__getSatate(struct soap *soap, const char *tag, struct __ns1__getSatate *a, const char *type)
{
	size_t soap_flag_ns1__getSatate_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getSatate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSatate, sizeof(struct __ns1__getSatate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSatate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSatate_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getSatate(soap, "ns1:getSatate", &a->ns1__getSatate_, "ns1:getSatate"))
				{	soap_flag_ns1__getSatate_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSatate(struct soap *soap, const struct __ns1__getSatate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSatate(soap, tag?tag:"-ns1:getSatate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSatate * SOAP_FMAC4 soap_get___ns1__getSatate(struct soap *soap, struct __ns1__getSatate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSatate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSatate * SOAP_FMAC2 soap_instantiate___ns1__getSatate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSatate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSatate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSatate);
		if (size)
			*size = sizeof(struct __ns1__getSatate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getSatate, n);
		if (size)
			*size = n * sizeof(struct __ns1__getSatate);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getSatate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSatate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSatate %p -> %p\n", q, p));
	*(struct __ns1__getSatate*)p = *(struct __ns1__getSatate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__motoDbIdleData(struct soap *soap, struct __ns1__motoDbIdleData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__motoDbIdleData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__motoDbIdleData(struct soap *soap, const struct __ns1__motoDbIdleData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__motoDbIdleData(soap, &a->ns1__motoDbIdleData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__motoDbIdleData(struct soap *soap, const char *tag, int id, const struct __ns1__motoDbIdleData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__motoDbIdleData(soap, "ns1:motoDbIdleData", -1, &a->ns1__motoDbIdleData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__motoDbIdleData * SOAP_FMAC4 soap_in___ns1__motoDbIdleData(struct soap *soap, const char *tag, struct __ns1__motoDbIdleData *a, const char *type)
{
	size_t soap_flag_ns1__motoDbIdleData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__motoDbIdleData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__motoDbIdleData, sizeof(struct __ns1__motoDbIdleData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__motoDbIdleData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__motoDbIdleData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__motoDbIdleData(soap, "ns1:motoDbIdleData", &a->ns1__motoDbIdleData_, "ns1:motoDbIdleData"))
				{	soap_flag_ns1__motoDbIdleData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__motoDbIdleData(struct soap *soap, const struct __ns1__motoDbIdleData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__motoDbIdleData(soap, tag?tag:"-ns1:motoDbIdleData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__motoDbIdleData * SOAP_FMAC4 soap_get___ns1__motoDbIdleData(struct soap *soap, struct __ns1__motoDbIdleData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__motoDbIdleData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__motoDbIdleData * SOAP_FMAC2 soap_instantiate___ns1__motoDbIdleData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__motoDbIdleData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__motoDbIdleData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__motoDbIdleData);
		if (size)
			*size = sizeof(struct __ns1__motoDbIdleData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__motoDbIdleData, n);
		if (size)
			*size = n * sizeof(struct __ns1__motoDbIdleData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__motoDbIdleData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__motoDbIdleData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__motoDbIdleData %p -> %p\n", q, p));
	*(struct __ns1__motoDbIdleData*)p = *(struct __ns1__motoDbIdleData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__vmasData(struct soap *soap, struct __ns1__vmasData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__vmasData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__vmasData(struct soap *soap, const struct __ns1__vmasData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__vmasData(soap, &a->ns1__vmasData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__vmasData(struct soap *soap, const char *tag, int id, const struct __ns1__vmasData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__vmasData(soap, "ns1:vmasData", -1, &a->ns1__vmasData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vmasData * SOAP_FMAC4 soap_in___ns1__vmasData(struct soap *soap, const char *tag, struct __ns1__vmasData *a, const char *type)
{
	size_t soap_flag_ns1__vmasData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__vmasData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__vmasData, sizeof(struct __ns1__vmasData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__vmasData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__vmasData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__vmasData(soap, "ns1:vmasData", &a->ns1__vmasData_, "ns1:vmasData"))
				{	soap_flag_ns1__vmasData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__vmasData(struct soap *soap, const struct __ns1__vmasData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__vmasData(soap, tag?tag:"-ns1:vmasData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vmasData * SOAP_FMAC4 soap_get___ns1__vmasData(struct soap *soap, struct __ns1__vmasData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__vmasData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__vmasData * SOAP_FMAC2 soap_instantiate___ns1__vmasData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__vmasData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__vmasData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__vmasData);
		if (size)
			*size = sizeof(struct __ns1__vmasData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__vmasData, n);
		if (size)
			*size = n * sizeof(struct __ns1__vmasData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__vmasData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__vmasData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__vmasData %p -> %p\n", q, p));
	*(struct __ns1__vmasData*)p = *(struct __ns1__vmasData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__loadDownData(struct soap *soap, struct __ns1__loadDownData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__loadDownData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__loadDownData(struct soap *soap, const struct __ns1__loadDownData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__loadDownData(soap, &a->ns1__loadDownData_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__loadDownData(struct soap *soap, const char *tag, int id, const struct __ns1__loadDownData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__loadDownData(soap, "ns1:loadDownData", -1, &a->ns1__loadDownData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadDownData * SOAP_FMAC4 soap_in___ns1__loadDownData(struct soap *soap, const char *tag, struct __ns1__loadDownData *a, const char *type)
{
	size_t soap_flag_ns1__loadDownData_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__loadDownData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__loadDownData, sizeof(struct __ns1__loadDownData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__loadDownData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loadDownData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__loadDownData(soap, "ns1:loadDownData", &a->ns1__loadDownData_, "ns1:loadDownData"))
				{	soap_flag_ns1__loadDownData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__loadDownData(struct soap *soap, const struct __ns1__loadDownData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__loadDownData(soap, tag?tag:"-ns1:loadDownData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadDownData * SOAP_FMAC4 soap_get___ns1__loadDownData(struct soap *soap, struct __ns1__loadDownData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__loadDownData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__loadDownData * SOAP_FMAC2 soap_instantiate___ns1__loadDownData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__loadDownData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__loadDownData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__loadDownData);
		if (size)
			*size = sizeof(struct __ns1__loadDownData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__loadDownData, n);
		if (size)
			*size = n * sizeof(struct __ns1__loadDownData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__loadDownData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__loadDownData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__loadDownData %p -> %p\n", q, p));
	*(struct __ns1__loadDownData*)p = *(struct __ns1__loadDownData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, struct __ns1__lightproofSmokeDataLog_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lightproofSmokeDataLog_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, const struct __ns1__lightproofSmokeDataLog_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, &a->ns1__lightproofSmokeDataLog_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, const char *tag, int id, const struct __ns1__lightproofSmokeDataLog_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, "ns1:lightproofSmokeDataLog_FC", -1, &a->ns1__lightproofSmokeDataLog_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeDataLog_USCOREFC * SOAP_FMAC4 soap_in___ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, const char *tag, struct __ns1__lightproofSmokeDataLog_USCOREFC *a, const char *type)
{
	size_t soap_flag_ns1__lightproofSmokeDataLog_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lightproofSmokeDataLog_USCOREFC *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC, sizeof(struct __ns1__lightproofSmokeDataLog_USCOREFC), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lightproofSmokeDataLog_USCOREFC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lightproofSmokeDataLog_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, "ns1:lightproofSmokeDataLog_FC", &a->ns1__lightproofSmokeDataLog_USCOREFC_, "ns1:lightproofSmokeDataLog_FC"))
				{	soap_flag_ns1__lightproofSmokeDataLog_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, const struct __ns1__lightproofSmokeDataLog_USCOREFC *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lightproofSmokeDataLog_USCOREFC(soap, tag?tag:"-ns1:lightproofSmokeDataLog_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeDataLog_USCOREFC * SOAP_FMAC4 soap_get___ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, struct __ns1__lightproofSmokeDataLog_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lightproofSmokeDataLog_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lightproofSmokeDataLog_USCOREFC * SOAP_FMAC2 soap_instantiate___ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lightproofSmokeDataLog_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lightproofSmokeDataLog_USCOREFC);
		if (size)
			*size = sizeof(struct __ns1__lightproofSmokeDataLog_USCOREFC);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lightproofSmokeDataLog_USCOREFC, n);
		if (size)
			*size = n * sizeof(struct __ns1__lightproofSmokeDataLog_USCOREFC);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lightproofSmokeDataLog_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lightproofSmokeDataLog_USCOREFC %p -> %p\n", q, p));
	*(struct __ns1__lightproofSmokeDataLog_USCOREFC*)p = *(struct __ns1__lightproofSmokeDataLog_USCOREFC*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__pqfxySelfcheck(struct soap *soap, struct __ns1__pqfxySelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__pqfxySelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__pqfxySelfcheck(struct soap *soap, const struct __ns1__pqfxySelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__pqfxySelfcheck(soap, &a->ns1__pqfxySelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__pqfxySelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__pqfxySelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__pqfxySelfcheck(soap, "ns1:pqfxySelfcheck", -1, &a->ns1__pqfxySelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__pqfxySelfcheck * SOAP_FMAC4 soap_in___ns1__pqfxySelfcheck(struct soap *soap, const char *tag, struct __ns1__pqfxySelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__pqfxySelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__pqfxySelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__pqfxySelfcheck, sizeof(struct __ns1__pqfxySelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__pqfxySelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__pqfxySelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__pqfxySelfcheck(soap, "ns1:pqfxySelfcheck", &a->ns1__pqfxySelfcheck_, "ns1:pqfxySelfcheck"))
				{	soap_flag_ns1__pqfxySelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__pqfxySelfcheck(struct soap *soap, const struct __ns1__pqfxySelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__pqfxySelfcheck(soap, tag?tag:"-ns1:pqfxySelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__pqfxySelfcheck * SOAP_FMAC4 soap_get___ns1__pqfxySelfcheck(struct soap *soap, struct __ns1__pqfxySelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__pqfxySelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__pqfxySelfcheck * SOAP_FMAC2 soap_instantiate___ns1__pqfxySelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__pqfxySelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__pqfxySelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__pqfxySelfcheck);
		if (size)
			*size = sizeof(struct __ns1__pqfxySelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__pqfxySelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__pqfxySelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__pqfxySelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__pqfxySelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__pqfxySelfcheck %p -> %p\n", q, p));
	*(struct __ns1__pqfxySelfcheck*)p = *(struct __ns1__pqfxySelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hjcsgyqSelfcheck(struct soap *soap, struct __ns1__hjcsgyqSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hjcsgyqSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hjcsgyqSelfcheck(struct soap *soap, const struct __ns1__hjcsgyqSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__hjcsgyqSelfcheck(soap, &a->ns1__hjcsgyqSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hjcsgyqSelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__hjcsgyqSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__hjcsgyqSelfcheck(soap, "ns1:hjcsgyqSelfcheck", -1, &a->ns1__hjcsgyqSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hjcsgyqSelfcheck * SOAP_FMAC4 soap_in___ns1__hjcsgyqSelfcheck(struct soap *soap, const char *tag, struct __ns1__hjcsgyqSelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__hjcsgyqSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__hjcsgyqSelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hjcsgyqSelfcheck, sizeof(struct __ns1__hjcsgyqSelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hjcsgyqSelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hjcsgyqSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__hjcsgyqSelfcheck(soap, "ns1:hjcsgyqSelfcheck", &a->ns1__hjcsgyqSelfcheck_, "ns1:hjcsgyqSelfcheck"))
				{	soap_flag_ns1__hjcsgyqSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hjcsgyqSelfcheck(struct soap *soap, const struct __ns1__hjcsgyqSelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hjcsgyqSelfcheck(soap, tag?tag:"-ns1:hjcsgyqSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hjcsgyqSelfcheck * SOAP_FMAC4 soap_get___ns1__hjcsgyqSelfcheck(struct soap *soap, struct __ns1__hjcsgyqSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hjcsgyqSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__hjcsgyqSelfcheck * SOAP_FMAC2 soap_instantiate___ns1__hjcsgyqSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__hjcsgyqSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__hjcsgyqSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__hjcsgyqSelfcheck);
		if (size)
			*size = sizeof(struct __ns1__hjcsgyqSelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__hjcsgyqSelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__hjcsgyqSelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__hjcsgyqSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__hjcsgyqSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__hjcsgyqSelfcheck %p -> %p\n", q, p));
	*(struct __ns1__hjcsgyqSelfcheck*)p = *(struct __ns1__hjcsgyqSelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cycdyhwAdjust(struct soap *soap, struct __ns1__cycdyhwAdjust *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cycdyhwAdjust_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cycdyhwAdjust(struct soap *soap, const struct __ns1__cycdyhwAdjust *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cycdyhwAdjust(soap, &a->ns1__cycdyhwAdjust_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cycdyhwAdjust(struct soap *soap, const char *tag, int id, const struct __ns1__cycdyhwAdjust *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cycdyhwAdjust(soap, "ns1:cycdyhwAdjust", -1, &a->ns1__cycdyhwAdjust_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cycdyhwAdjust * SOAP_FMAC4 soap_in___ns1__cycdyhwAdjust(struct soap *soap, const char *tag, struct __ns1__cycdyhwAdjust *a, const char *type)
{
	size_t soap_flag_ns1__cycdyhwAdjust_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cycdyhwAdjust *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cycdyhwAdjust, sizeof(struct __ns1__cycdyhwAdjust), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cycdyhwAdjust(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cycdyhwAdjust_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cycdyhwAdjust(soap, "ns1:cycdyhwAdjust", &a->ns1__cycdyhwAdjust_, "ns1:cycdyhwAdjust"))
				{	soap_flag_ns1__cycdyhwAdjust_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cycdyhwAdjust(struct soap *soap, const struct __ns1__cycdyhwAdjust *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cycdyhwAdjust(soap, tag?tag:"-ns1:cycdyhwAdjust", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cycdyhwAdjust * SOAP_FMAC4 soap_get___ns1__cycdyhwAdjust(struct soap *soap, struct __ns1__cycdyhwAdjust *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cycdyhwAdjust(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cycdyhwAdjust * SOAP_FMAC2 soap_instantiate___ns1__cycdyhwAdjust(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cycdyhwAdjust(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cycdyhwAdjust, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cycdyhwAdjust);
		if (size)
			*size = sizeof(struct __ns1__cycdyhwAdjust);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cycdyhwAdjust, n);
		if (size)
			*size = n * sizeof(struct __ns1__cycdyhwAdjust);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cycdyhwAdjust*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cycdyhwAdjust(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cycdyhwAdjust %p -> %p\n", q, p));
	*(struct __ns1__cycdyhwAdjust*)p = *(struct __ns1__cycdyhwAdjust*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__software2centerNew_USCOREFC(struct soap *soap, struct __ns1__software2centerNew_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__software2centerNew_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__software2centerNew_USCOREFC(struct soap *soap, const struct __ns1__software2centerNew_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__software2centerNew_USCOREFC(soap, &a->ns1__software2centerNew_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__software2centerNew_USCOREFC(struct soap *soap, const char *tag, int id, const struct __ns1__software2centerNew_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__software2centerNew_USCOREFC(soap, "ns1:software2centerNew_FC", -1, &a->ns1__software2centerNew_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__software2centerNew_USCOREFC * SOAP_FMAC4 soap_in___ns1__software2centerNew_USCOREFC(struct soap *soap, const char *tag, struct __ns1__software2centerNew_USCOREFC *a, const char *type)
{
	size_t soap_flag_ns1__software2centerNew_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__software2centerNew_USCOREFC *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__software2centerNew_USCOREFC, sizeof(struct __ns1__software2centerNew_USCOREFC), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__software2centerNew_USCOREFC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__software2centerNew_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__software2centerNew_USCOREFC(soap, "ns1:software2centerNew_FC", &a->ns1__software2centerNew_USCOREFC_, "ns1:software2centerNew_FC"))
				{	soap_flag_ns1__software2centerNew_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__software2centerNew_USCOREFC(struct soap *soap, const struct __ns1__software2centerNew_USCOREFC *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__software2centerNew_USCOREFC(soap, tag?tag:"-ns1:software2centerNew_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__software2centerNew_USCOREFC * SOAP_FMAC4 soap_get___ns1__software2centerNew_USCOREFC(struct soap *soap, struct __ns1__software2centerNew_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__software2centerNew_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__software2centerNew_USCOREFC * SOAP_FMAC2 soap_instantiate___ns1__software2centerNew_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__software2centerNew_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__software2centerNew_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__software2centerNew_USCOREFC);
		if (size)
			*size = sizeof(struct __ns1__software2centerNew_USCOREFC);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__software2centerNew_USCOREFC, n);
		if (size)
			*size = n * sizeof(struct __ns1__software2centerNew_USCOREFC);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__software2centerNew_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__software2centerNew_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__software2centerNew_USCOREFC %p -> %p\n", q, p));
	*(struct __ns1__software2centerNew_USCOREFC*)p = *(struct __ns1__software2centerNew_USCOREFC*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCarInfo_USCOREFC(struct soap *soap, struct __ns1__getCarInfo_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCarInfo_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCarInfo_USCOREFC(struct soap *soap, const struct __ns1__getCarInfo_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__getCarInfo_USCOREFC(soap, &a->ns1__getCarInfo_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCarInfo_USCOREFC(struct soap *soap, const char *tag, int id, const struct __ns1__getCarInfo_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__getCarInfo_USCOREFC(soap, "ns1:getCarInfo_FC", -1, &a->ns1__getCarInfo_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCarInfo_USCOREFC * SOAP_FMAC4 soap_in___ns1__getCarInfo_USCOREFC(struct soap *soap, const char *tag, struct __ns1__getCarInfo_USCOREFC *a, const char *type)
{
	size_t soap_flag_ns1__getCarInfo_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getCarInfo_USCOREFC *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCarInfo_USCOREFC, sizeof(struct __ns1__getCarInfo_USCOREFC), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCarInfo_USCOREFC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCarInfo_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getCarInfo_USCOREFC(soap, "ns1:getCarInfo_FC", &a->ns1__getCarInfo_USCOREFC_, "ns1:getCarInfo_FC"))
				{	soap_flag_ns1__getCarInfo_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCarInfo_USCOREFC(struct soap *soap, const struct __ns1__getCarInfo_USCOREFC *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCarInfo_USCOREFC(soap, tag?tag:"-ns1:getCarInfo_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCarInfo_USCOREFC * SOAP_FMAC4 soap_get___ns1__getCarInfo_USCOREFC(struct soap *soap, struct __ns1__getCarInfo_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCarInfo_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getCarInfo_USCOREFC * SOAP_FMAC2 soap_instantiate___ns1__getCarInfo_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCarInfo_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCarInfo_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCarInfo_USCOREFC);
		if (size)
			*size = sizeof(struct __ns1__getCarInfo_USCOREFC);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getCarInfo_USCOREFC, n);
		if (size)
			*size = n * sizeof(struct __ns1__getCarInfo_USCOREFC);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getCarInfo_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCarInfo_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCarInfo_USCOREFC %p -> %p\n", q, p));
	*(struct __ns1__getCarInfo_USCOREFC*)p = *(struct __ns1__getCarInfo_USCOREFC*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__obdResultLog(struct soap *soap, struct __ns1__obdResultLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__obdResultLog_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__obdResultLog(struct soap *soap, const struct __ns1__obdResultLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__obdResultLog(soap, &a->ns1__obdResultLog_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__obdResultLog(struct soap *soap, const char *tag, int id, const struct __ns1__obdResultLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__obdResultLog(soap, "ns1:obdResultLog", -1, &a->ns1__obdResultLog_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdResultLog * SOAP_FMAC4 soap_in___ns1__obdResultLog(struct soap *soap, const char *tag, struct __ns1__obdResultLog *a, const char *type)
{
	size_t soap_flag_ns1__obdResultLog_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__obdResultLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__obdResultLog, sizeof(struct __ns1__obdResultLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__obdResultLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__obdResultLog_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__obdResultLog(soap, "ns1:obdResultLog", &a->ns1__obdResultLog_, "ns1:obdResultLog"))
				{	soap_flag_ns1__obdResultLog_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__obdResultLog(struct soap *soap, const struct __ns1__obdResultLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__obdResultLog(soap, tag?tag:"-ns1:obdResultLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdResultLog * SOAP_FMAC4 soap_get___ns1__obdResultLog(struct soap *soap, struct __ns1__obdResultLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__obdResultLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__obdResultLog * SOAP_FMAC2 soap_instantiate___ns1__obdResultLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__obdResultLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__obdResultLog, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__obdResultLog);
		if (size)
			*size = sizeof(struct __ns1__obdResultLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__obdResultLog, n);
		if (size)
			*size = n * sizeof(struct __ns1__obdResultLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__obdResultLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__obdResultLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__obdResultLog %p -> %p\n", q, p));
	*(struct __ns1__obdResultLog*)p = *(struct __ns1__obdResultLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__dyhwAdjust(struct soap *soap, struct __ns1__dyhwAdjust *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__dyhwAdjust_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__dyhwAdjust(struct soap *soap, const struct __ns1__dyhwAdjust *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__dyhwAdjust(soap, &a->ns1__dyhwAdjust_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__dyhwAdjust(struct soap *soap, const char *tag, int id, const struct __ns1__dyhwAdjust *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__dyhwAdjust(soap, "ns1:dyhwAdjust", -1, &a->ns1__dyhwAdjust_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dyhwAdjust * SOAP_FMAC4 soap_in___ns1__dyhwAdjust(struct soap *soap, const char *tag, struct __ns1__dyhwAdjust *a, const char *type)
{
	size_t soap_flag_ns1__dyhwAdjust_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__dyhwAdjust *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__dyhwAdjust, sizeof(struct __ns1__dyhwAdjust), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__dyhwAdjust(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__dyhwAdjust_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__dyhwAdjust(soap, "ns1:dyhwAdjust", &a->ns1__dyhwAdjust_, "ns1:dyhwAdjust"))
				{	soap_flag_ns1__dyhwAdjust_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__dyhwAdjust(struct soap *soap, const struct __ns1__dyhwAdjust *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__dyhwAdjust(soap, tag?tag:"-ns1:dyhwAdjust", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dyhwAdjust * SOAP_FMAC4 soap_get___ns1__dyhwAdjust(struct soap *soap, struct __ns1__dyhwAdjust *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__dyhwAdjust(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__dyhwAdjust * SOAP_FMAC2 soap_instantiate___ns1__dyhwAdjust(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__dyhwAdjust(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__dyhwAdjust, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__dyhwAdjust);
		if (size)
			*size = sizeof(struct __ns1__dyhwAdjust);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__dyhwAdjust, n);
		if (size)
			*size = n * sizeof(struct __ns1__dyhwAdjust);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__dyhwAdjust*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__dyhwAdjust(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__dyhwAdjust %p -> %p\n", q, p));
	*(struct __ns1__dyhwAdjust*)p = *(struct __ns1__dyhwAdjust*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__loadDownLog(struct soap *soap, struct __ns1__loadDownLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__loadDownLog_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__loadDownLog(struct soap *soap, const struct __ns1__loadDownLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__loadDownLog(soap, &a->ns1__loadDownLog_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__loadDownLog(struct soap *soap, const char *tag, int id, const struct __ns1__loadDownLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__loadDownLog(soap, "ns1:loadDownLog", -1, &a->ns1__loadDownLog_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadDownLog * SOAP_FMAC4 soap_in___ns1__loadDownLog(struct soap *soap, const char *tag, struct __ns1__loadDownLog *a, const char *type)
{
	size_t soap_flag_ns1__loadDownLog_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__loadDownLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__loadDownLog, sizeof(struct __ns1__loadDownLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__loadDownLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loadDownLog_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__loadDownLog(soap, "ns1:loadDownLog", &a->ns1__loadDownLog_, "ns1:loadDownLog"))
				{	soap_flag_ns1__loadDownLog_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__loadDownLog(struct soap *soap, const struct __ns1__loadDownLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__loadDownLog(soap, tag?tag:"-ns1:loadDownLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadDownLog * SOAP_FMAC4 soap_get___ns1__loadDownLog(struct soap *soap, struct __ns1__loadDownLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__loadDownLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__loadDownLog * SOAP_FMAC2 soap_instantiate___ns1__loadDownLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__loadDownLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__loadDownLog, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__loadDownLog);
		if (size)
			*size = sizeof(struct __ns1__loadDownLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__loadDownLog, n);
		if (size)
			*size = n * sizeof(struct __ns1__loadDownLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__loadDownLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__loadDownLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__loadDownLog %p -> %p\n", q, p));
	*(struct __ns1__loadDownLog*)p = *(struct __ns1__loadDownLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__dyhwSelfcheck(struct soap *soap, struct __ns1__dyhwSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__dyhwSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__dyhwSelfcheck(struct soap *soap, const struct __ns1__dyhwSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__dyhwSelfcheck(soap, &a->ns1__dyhwSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__dyhwSelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__dyhwSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__dyhwSelfcheck(soap, "ns1:dyhwSelfcheck", -1, &a->ns1__dyhwSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dyhwSelfcheck * SOAP_FMAC4 soap_in___ns1__dyhwSelfcheck(struct soap *soap, const char *tag, struct __ns1__dyhwSelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__dyhwSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__dyhwSelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__dyhwSelfcheck, sizeof(struct __ns1__dyhwSelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__dyhwSelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__dyhwSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__dyhwSelfcheck(soap, "ns1:dyhwSelfcheck", &a->ns1__dyhwSelfcheck_, "ns1:dyhwSelfcheck"))
				{	soap_flag_ns1__dyhwSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__dyhwSelfcheck(struct soap *soap, const struct __ns1__dyhwSelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__dyhwSelfcheck(soap, tag?tag:"-ns1:dyhwSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dyhwSelfcheck * SOAP_FMAC4 soap_get___ns1__dyhwSelfcheck(struct soap *soap, struct __ns1__dyhwSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__dyhwSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__dyhwSelfcheck * SOAP_FMAC2 soap_instantiate___ns1__dyhwSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__dyhwSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__dyhwSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__dyhwSelfcheck);
		if (size)
			*size = sizeof(struct __ns1__dyhwSelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__dyhwSelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__dyhwSelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__dyhwSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__dyhwSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__dyhwSelfcheck %p -> %p\n", q, p));
	*(struct __ns1__dyhwSelfcheck*)p = *(struct __ns1__dyhwSelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ydjSelfcheck(struct soap *soap, struct __ns1__ydjSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ydjSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ydjSelfcheck(struct soap *soap, const struct __ns1__ydjSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ydjSelfcheck(soap, &a->ns1__ydjSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ydjSelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__ydjSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ydjSelfcheck(soap, "ns1:ydjSelfcheck", -1, &a->ns1__ydjSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ydjSelfcheck * SOAP_FMAC4 soap_in___ns1__ydjSelfcheck(struct soap *soap, const char *tag, struct __ns1__ydjSelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__ydjSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ydjSelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ydjSelfcheck, sizeof(struct __ns1__ydjSelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ydjSelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ydjSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ydjSelfcheck(soap, "ns1:ydjSelfcheck", &a->ns1__ydjSelfcheck_, "ns1:ydjSelfcheck"))
				{	soap_flag_ns1__ydjSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ydjSelfcheck(struct soap *soap, const struct __ns1__ydjSelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ydjSelfcheck(soap, tag?tag:"-ns1:ydjSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ydjSelfcheck * SOAP_FMAC4 soap_get___ns1__ydjSelfcheck(struct soap *soap, struct __ns1__ydjSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ydjSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__ydjSelfcheck * SOAP_FMAC2 soap_instantiate___ns1__ydjSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ydjSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__ydjSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ydjSelfcheck);
		if (size)
			*size = sizeof(struct __ns1__ydjSelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__ydjSelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__ydjSelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__ydjSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ydjSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ydjSelfcheck %p -> %p\n", q, p));
	*(struct __ns1__ydjSelfcheck*)p = *(struct __ns1__ydjSelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__vmasLog(struct soap *soap, struct __ns1__vmasLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__vmasLog_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__vmasLog(struct soap *soap, const struct __ns1__vmasLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__vmasLog(soap, &a->ns1__vmasLog_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__vmasLog(struct soap *soap, const char *tag, int id, const struct __ns1__vmasLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__vmasLog(soap, "ns1:vmasLog", -1, &a->ns1__vmasLog_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vmasLog * SOAP_FMAC4 soap_in___ns1__vmasLog(struct soap *soap, const char *tag, struct __ns1__vmasLog *a, const char *type)
{
	size_t soap_flag_ns1__vmasLog_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__vmasLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__vmasLog, sizeof(struct __ns1__vmasLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__vmasLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__vmasLog_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__vmasLog(soap, "ns1:vmasLog", &a->ns1__vmasLog_, "ns1:vmasLog"))
				{	soap_flag_ns1__vmasLog_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__vmasLog(struct soap *soap, const struct __ns1__vmasLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__vmasLog(soap, tag?tag:"-ns1:vmasLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vmasLog * SOAP_FMAC4 soap_get___ns1__vmasLog(struct soap *soap, struct __ns1__vmasLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__vmasLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__vmasLog * SOAP_FMAC2 soap_instantiate___ns1__vmasLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__vmasLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__vmasLog, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__vmasLog);
		if (size)
			*size = sizeof(struct __ns1__vmasLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__vmasLog, n);
		if (size)
			*size = n * sizeof(struct __ns1__vmasLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__vmasLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__vmasLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__vmasLog %p -> %p\n", q, p));
	*(struct __ns1__vmasLog*)p = *(struct __ns1__vmasLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doubleIdleLog_USCOREFC(struct soap *soap, struct __ns1__doubleIdleLog_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doubleIdleLog_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doubleIdleLog_USCOREFC(struct soap *soap, const struct __ns1__doubleIdleLog_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__doubleIdleLog_USCOREFC(soap, &a->ns1__doubleIdleLog_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doubleIdleLog_USCOREFC(struct soap *soap, const char *tag, int id, const struct __ns1__doubleIdleLog_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__doubleIdleLog_USCOREFC(soap, "ns1:doubleIdleLog_FC", -1, &a->ns1__doubleIdleLog_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleLog_USCOREFC * SOAP_FMAC4 soap_in___ns1__doubleIdleLog_USCOREFC(struct soap *soap, const char *tag, struct __ns1__doubleIdleLog_USCOREFC *a, const char *type)
{
	size_t soap_flag_ns1__doubleIdleLog_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doubleIdleLog_USCOREFC *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doubleIdleLog_USCOREFC, sizeof(struct __ns1__doubleIdleLog_USCOREFC), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doubleIdleLog_USCOREFC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doubleIdleLog_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__doubleIdleLog_USCOREFC(soap, "ns1:doubleIdleLog_FC", &a->ns1__doubleIdleLog_USCOREFC_, "ns1:doubleIdleLog_FC"))
				{	soap_flag_ns1__doubleIdleLog_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doubleIdleLog_USCOREFC(struct soap *soap, const struct __ns1__doubleIdleLog_USCOREFC *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__doubleIdleLog_USCOREFC(soap, tag?tag:"-ns1:doubleIdleLog_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleLog_USCOREFC * SOAP_FMAC4 soap_get___ns1__doubleIdleLog_USCOREFC(struct soap *soap, struct __ns1__doubleIdleLog_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doubleIdleLog_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__doubleIdleLog_USCOREFC * SOAP_FMAC2 soap_instantiate___ns1__doubleIdleLog_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doubleIdleLog_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__doubleIdleLog_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__doubleIdleLog_USCOREFC);
		if (size)
			*size = sizeof(struct __ns1__doubleIdleLog_USCOREFC);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__doubleIdleLog_USCOREFC, n);
		if (size)
			*size = n * sizeof(struct __ns1__doubleIdleLog_USCOREFC);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__doubleIdleLog_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__doubleIdleLog_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__doubleIdleLog_USCOREFC %p -> %p\n", q, p));
	*(struct __ns1__doubleIdleLog_USCOREFC*)p = *(struct __ns1__doubleIdleLog_USCOREFC*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__obdResult(struct soap *soap, struct __ns1__obdResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__obdResult_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__obdResult(struct soap *soap, const struct __ns1__obdResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__obdResult(soap, &a->ns1__obdResult_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__obdResult(struct soap *soap, const char *tag, int id, const struct __ns1__obdResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__obdResult(soap, "ns1:obdResult", -1, &a->ns1__obdResult_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdResult * SOAP_FMAC4 soap_in___ns1__obdResult(struct soap *soap, const char *tag, struct __ns1__obdResult *a, const char *type)
{
	size_t soap_flag_ns1__obdResult_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__obdResult *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__obdResult, sizeof(struct __ns1__obdResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__obdResult(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__obdResult_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__obdResult(soap, "ns1:obdResult", &a->ns1__obdResult_, "ns1:obdResult"))
				{	soap_flag_ns1__obdResult_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__obdResult(struct soap *soap, const struct __ns1__obdResult *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__obdResult(soap, tag?tag:"-ns1:obdResult", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdResult * SOAP_FMAC4 soap_get___ns1__obdResult(struct soap *soap, struct __ns1__obdResult *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__obdResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__obdResult * SOAP_FMAC2 soap_instantiate___ns1__obdResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__obdResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__obdResult, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__obdResult);
		if (size)
			*size = sizeof(struct __ns1__obdResult);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__obdResult, n);
		if (size)
			*size = n * sizeof(struct __ns1__obdResult);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__obdResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__obdResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__obdResult %p -> %p\n", q, p));
	*(struct __ns1__obdResult*)p = *(struct __ns1__obdResult*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjSelfcheck(struct soap *soap, struct __ns1__cgjSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjSelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjSelfcheck(struct soap *soap, const struct __ns1__cgjSelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjSelfcheck(soap, &a->ns1__cgjSelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjSelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__cgjSelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjSelfcheck(soap, "ns1:cgjSelfcheck", -1, &a->ns1__cgjSelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjSelfcheck * SOAP_FMAC4 soap_in___ns1__cgjSelfcheck(struct soap *soap, const char *tag, struct __ns1__cgjSelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__cgjSelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjSelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjSelfcheck, sizeof(struct __ns1__cgjSelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjSelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjSelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjSelfcheck(soap, "ns1:cgjSelfcheck", &a->ns1__cgjSelfcheck_, "ns1:cgjSelfcheck"))
				{	soap_flag_ns1__cgjSelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjSelfcheck(struct soap *soap, const struct __ns1__cgjSelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjSelfcheck(soap, tag?tag:"-ns1:cgjSelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjSelfcheck * SOAP_FMAC4 soap_get___ns1__cgjSelfcheck(struct soap *soap, struct __ns1__cgjSelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjSelfcheck * SOAP_FMAC2 soap_instantiate___ns1__cgjSelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjSelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjSelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjSelfcheck);
		if (size)
			*size = sizeof(struct __ns1__cgjSelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjSelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjSelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjSelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjSelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjSelfcheck %p -> %p\n", q, p));
	*(struct __ns1__cgjSelfcheck*)p = *(struct __ns1__cgjSelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjLASelfcheck(struct soap *soap, struct __ns1__cgjLASelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjLASelfcheck_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjLASelfcheck(struct soap *soap, const struct __ns1__cgjLASelfcheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjLASelfcheck(soap, &a->ns1__cgjLASelfcheck_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjLASelfcheck(struct soap *soap, const char *tag, int id, const struct __ns1__cgjLASelfcheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjLASelfcheck(soap, "ns1:cgjLASelfcheck", -1, &a->ns1__cgjLASelfcheck_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjLASelfcheck * SOAP_FMAC4 soap_in___ns1__cgjLASelfcheck(struct soap *soap, const char *tag, struct __ns1__cgjLASelfcheck *a, const char *type)
{
	size_t soap_flag_ns1__cgjLASelfcheck_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjLASelfcheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjLASelfcheck, sizeof(struct __ns1__cgjLASelfcheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjLASelfcheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjLASelfcheck_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjLASelfcheck(soap, "ns1:cgjLASelfcheck", &a->ns1__cgjLASelfcheck_, "ns1:cgjLASelfcheck"))
				{	soap_flag_ns1__cgjLASelfcheck_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjLASelfcheck(struct soap *soap, const struct __ns1__cgjLASelfcheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjLASelfcheck(soap, tag?tag:"-ns1:cgjLASelfcheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjLASelfcheck * SOAP_FMAC4 soap_get___ns1__cgjLASelfcheck(struct soap *soap, struct __ns1__cgjLASelfcheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjLASelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjLASelfcheck * SOAP_FMAC2 soap_instantiate___ns1__cgjLASelfcheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjLASelfcheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjLASelfcheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjLASelfcheck);
		if (size)
			*size = sizeof(struct __ns1__cgjLASelfcheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjLASelfcheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjLASelfcheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjLASelfcheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjLASelfcheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjLASelfcheck %p -> %p\n", q, p));
	*(struct __ns1__cgjLASelfcheck*)p = *(struct __ns1__cgjLASelfcheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__doubleIdleData_USCOREFC(struct soap *soap, struct __ns1__doubleIdleData_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__doubleIdleData_USCOREFC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__doubleIdleData_USCOREFC(struct soap *soap, const struct __ns1__doubleIdleData_USCOREFC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__doubleIdleData_USCOREFC(soap, &a->ns1__doubleIdleData_USCOREFC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__doubleIdleData_USCOREFC(struct soap *soap, const char *tag, int id, const struct __ns1__doubleIdleData_USCOREFC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__doubleIdleData_USCOREFC(soap, "ns1:doubleIdleData_FC", -1, &a->ns1__doubleIdleData_USCOREFC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleData_USCOREFC * SOAP_FMAC4 soap_in___ns1__doubleIdleData_USCOREFC(struct soap *soap, const char *tag, struct __ns1__doubleIdleData_USCOREFC *a, const char *type)
{
	size_t soap_flag_ns1__doubleIdleData_USCOREFC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__doubleIdleData_USCOREFC *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__doubleIdleData_USCOREFC, sizeof(struct __ns1__doubleIdleData_USCOREFC), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__doubleIdleData_USCOREFC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__doubleIdleData_USCOREFC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__doubleIdleData_USCOREFC(soap, "ns1:doubleIdleData_FC", &a->ns1__doubleIdleData_USCOREFC_, "ns1:doubleIdleData_FC"))
				{	soap_flag_ns1__doubleIdleData_USCOREFC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__doubleIdleData_USCOREFC(struct soap *soap, const struct __ns1__doubleIdleData_USCOREFC *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__doubleIdleData_USCOREFC(soap, tag?tag:"-ns1:doubleIdleData_FC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__doubleIdleData_USCOREFC * SOAP_FMAC4 soap_get___ns1__doubleIdleData_USCOREFC(struct soap *soap, struct __ns1__doubleIdleData_USCOREFC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__doubleIdleData_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__doubleIdleData_USCOREFC * SOAP_FMAC2 soap_instantiate___ns1__doubleIdleData_USCOREFC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__doubleIdleData_USCOREFC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__doubleIdleData_USCOREFC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__doubleIdleData_USCOREFC);
		if (size)
			*size = sizeof(struct __ns1__doubleIdleData_USCOREFC);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__doubleIdleData_USCOREFC, n);
		if (size)
			*size = n * sizeof(struct __ns1__doubleIdleData_USCOREFC);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__doubleIdleData_USCOREFC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__doubleIdleData_USCOREFC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__doubleIdleData_USCOREFC %p -> %p\n", q, p));
	*(struct __ns1__doubleIdleData_USCOREFC*)p = *(struct __ns1__doubleIdleData_USCOREFC*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__bgAirHC(struct soap *soap, struct __ns1__bgAirHC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__bgAirHC_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__bgAirHC(struct soap *soap, const struct __ns1__bgAirHC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__bgAirHC(soap, &a->ns1__bgAirHC_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__bgAirHC(struct soap *soap, const char *tag, int id, const struct __ns1__bgAirHC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__bgAirHC(soap, "ns1:bgAirHC", -1, &a->ns1__bgAirHC_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bgAirHC * SOAP_FMAC4 soap_in___ns1__bgAirHC(struct soap *soap, const char *tag, struct __ns1__bgAirHC *a, const char *type)
{
	size_t soap_flag_ns1__bgAirHC_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__bgAirHC *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__bgAirHC, sizeof(struct __ns1__bgAirHC), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__bgAirHC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__bgAirHC_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__bgAirHC(soap, "ns1:bgAirHC", &a->ns1__bgAirHC_, "ns1:bgAirHC"))
				{	soap_flag_ns1__bgAirHC_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__bgAirHC(struct soap *soap, const struct __ns1__bgAirHC *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__bgAirHC(soap, tag?tag:"-ns1:bgAirHC", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bgAirHC * SOAP_FMAC4 soap_get___ns1__bgAirHC(struct soap *soap, struct __ns1__bgAirHC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__bgAirHC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__bgAirHC * SOAP_FMAC2 soap_instantiate___ns1__bgAirHC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__bgAirHC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__bgAirHC, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__bgAirHC);
		if (size)
			*size = sizeof(struct __ns1__bgAirHC);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__bgAirHC, n);
		if (size)
			*size = n * sizeof(struct __ns1__bgAirHC);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__bgAirHC*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__bgAirHC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__bgAirHC %p -> %p\n", q, p));
	*(struct __ns1__bgAirHC*)p = *(struct __ns1__bgAirHC*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendMessage(struct soap *soap, struct __ns1__sendMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendMessage_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendMessage(struct soap *soap, const struct __ns1__sendMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__sendMessage(soap, &a->ns1__sendMessage_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendMessage(struct soap *soap, const char *tag, int id, const struct __ns1__sendMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__sendMessage(soap, "ns1:sendMessage", -1, &a->ns1__sendMessage_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendMessage * SOAP_FMAC4 soap_in___ns1__sendMessage(struct soap *soap, const char *tag, struct __ns1__sendMessage *a, const char *type)
{
	size_t soap_flag_ns1__sendMessage_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sendMessage *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendMessage, sizeof(struct __ns1__sendMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendMessage_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sendMessage(soap, "ns1:sendMessage", &a->ns1__sendMessage_, "ns1:sendMessage"))
				{	soap_flag_ns1__sendMessage_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendMessage(struct soap *soap, const struct __ns1__sendMessage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sendMessage(soap, tag?tag:"-ns1:sendMessage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendMessage * SOAP_FMAC4 soap_get___ns1__sendMessage(struct soap *soap, struct __ns1__sendMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sendMessage * SOAP_FMAC2 soap_instantiate___ns1__sendMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sendMessage, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sendMessage);
		if (size)
			*size = sizeof(struct __ns1__sendMessage);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__sendMessage, n);
		if (size)
			*size = n * sizeof(struct __ns1__sendMessage);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__sendMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sendMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sendMessage %p -> %p\n", q, p));
	*(struct __ns1__sendMessage*)p = *(struct __ns1__sendMessage*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCarInfo(struct soap *soap, struct __ns1__getCarInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCarInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCarInfo(struct soap *soap, const struct __ns1__getCarInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__getCarInfo(soap, &a->ns1__getCarInfo_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCarInfo(struct soap *soap, const char *tag, int id, const struct __ns1__getCarInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__getCarInfo(soap, "ns1:getCarInfo", -1, &a->ns1__getCarInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCarInfo * SOAP_FMAC4 soap_in___ns1__getCarInfo(struct soap *soap, const char *tag, struct __ns1__getCarInfo *a, const char *type)
{
	size_t soap_flag_ns1__getCarInfo_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getCarInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCarInfo, sizeof(struct __ns1__getCarInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCarInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCarInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getCarInfo(soap, "ns1:getCarInfo", &a->ns1__getCarInfo_, "ns1:getCarInfo"))
				{	soap_flag_ns1__getCarInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCarInfo(struct soap *soap, const struct __ns1__getCarInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCarInfo(soap, tag?tag:"-ns1:getCarInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCarInfo * SOAP_FMAC4 soap_get___ns1__getCarInfo(struct soap *soap, struct __ns1__getCarInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCarInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getCarInfo * SOAP_FMAC2 soap_instantiate___ns1__getCarInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCarInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCarInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCarInfo);
		if (size)
			*size = sizeof(struct __ns1__getCarInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getCarInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__getCarInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getCarInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCarInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCarInfo %p -> %p\n", q, p));
	*(struct __ns1__getCarInfo*)p = *(struct __ns1__getCarInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lightproofSmokeLog(struct soap *soap, struct __ns1__lightproofSmokeLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lightproofSmokeLog_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lightproofSmokeLog(struct soap *soap, const struct __ns1__lightproofSmokeLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lightproofSmokeLog(soap, &a->ns1__lightproofSmokeLog_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lightproofSmokeLog(struct soap *soap, const char *tag, int id, const struct __ns1__lightproofSmokeLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lightproofSmokeLog(soap, "ns1:lightproofSmokeLog", -1, &a->ns1__lightproofSmokeLog_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeLog * SOAP_FMAC4 soap_in___ns1__lightproofSmokeLog(struct soap *soap, const char *tag, struct __ns1__lightproofSmokeLog *a, const char *type)
{
	size_t soap_flag_ns1__lightproofSmokeLog_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lightproofSmokeLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lightproofSmokeLog, sizeof(struct __ns1__lightproofSmokeLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lightproofSmokeLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lightproofSmokeLog_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lightproofSmokeLog(soap, "ns1:lightproofSmokeLog", &a->ns1__lightproofSmokeLog_, "ns1:lightproofSmokeLog"))
				{	soap_flag_ns1__lightproofSmokeLog_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lightproofSmokeLog(struct soap *soap, const struct __ns1__lightproofSmokeLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lightproofSmokeLog(soap, tag?tag:"-ns1:lightproofSmokeLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lightproofSmokeLog * SOAP_FMAC4 soap_get___ns1__lightproofSmokeLog(struct soap *soap, struct __ns1__lightproofSmokeLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lightproofSmokeLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lightproofSmokeLog * SOAP_FMAC2 soap_instantiate___ns1__lightproofSmokeLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lightproofSmokeLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lightproofSmokeLog, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lightproofSmokeLog);
		if (size)
			*size = sizeof(struct __ns1__lightproofSmokeLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lightproofSmokeLog, n);
		if (size)
			*size = n * sizeof(struct __ns1__lightproofSmokeLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lightproofSmokeLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lightproofSmokeLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lightproofSmokeLog %p -> %p\n", q, p));
	*(struct __ns1__lightproofSmokeLog*)p = *(struct __ns1__lightproofSmokeLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__argChang(struct soap *soap, struct __ns1__argChang *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__argChang_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__argChang(struct soap *soap, const struct __ns1__argChang *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__argChang(soap, &a->ns1__argChang_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__argChang(struct soap *soap, const char *tag, int id, const struct __ns1__argChang *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__argChang(soap, "ns1:argChang", -1, &a->ns1__argChang_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__argChang * SOAP_FMAC4 soap_in___ns1__argChang(struct soap *soap, const char *tag, struct __ns1__argChang *a, const char *type)
{
	size_t soap_flag_ns1__argChang_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__argChang *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__argChang, sizeof(struct __ns1__argChang), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__argChang(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__argChang_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__argChang(soap, "ns1:argChang", &a->ns1__argChang_, "ns1:argChang"))
				{	soap_flag_ns1__argChang_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__argChang(struct soap *soap, const struct __ns1__argChang *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__argChang(soap, tag?tag:"-ns1:argChang", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__argChang * SOAP_FMAC4 soap_get___ns1__argChang(struct soap *soap, struct __ns1__argChang *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__argChang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__argChang * SOAP_FMAC2 soap_instantiate___ns1__argChang(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__argChang(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__argChang, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__argChang);
		if (size)
			*size = sizeof(struct __ns1__argChang);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__argChang, n);
		if (size)
			*size = n * sizeof(struct __ns1__argChang);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__argChang*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__argChang(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__argChang %p -> %p\n", q, p));
	*(struct __ns1__argChang*)p = *(struct __ns1__argChang*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cgjLSPSelfcheck(struct soap *soap, ns1__cgjLSPSelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cgjLSPSelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cgjLSPSelfcheck(struct soap *soap, const char *tag, int id, ns1__cgjLSPSelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cgjLSPSelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cgjLSPSelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__cgjLSPSelfcheck(struct soap *soap, const char *tag, ns1__cgjLSPSelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cgjLSPSelfcheck **)soap_malloc(soap, sizeof(ns1__cgjLSPSelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cgjLSPSelfcheck *)soap_instantiate_ns1__cgjLSPSelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cgjLSPSelfcheck ** p = (ns1__cgjLSPSelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cgjLSPSelfcheck, sizeof(ns1__cgjLSPSelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cgjLSPSelfcheck(struct soap *soap, ns1__cgjLSPSelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__cgjLSPSelfcheck);
	if (soap_out_PointerTons1__cgjLSPSelfcheck(soap, tag?tag:"ns1:cgjLSPSelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cgjLSPSelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__cgjLSPSelfcheck(struct soap *soap, ns1__cgjLSPSelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cgjLSPSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lljSelfcheck(struct soap *soap, ns1__lljSelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__lljSelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lljSelfcheck(struct soap *soap, const char *tag, int id, ns1__lljSelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__lljSelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lljSelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__lljSelfcheck(struct soap *soap, const char *tag, ns1__lljSelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__lljSelfcheck **)soap_malloc(soap, sizeof(ns1__lljSelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__lljSelfcheck *)soap_instantiate_ns1__lljSelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__lljSelfcheck ** p = (ns1__lljSelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__lljSelfcheck, sizeof(ns1__lljSelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lljSelfcheck(struct soap *soap, ns1__lljSelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__lljSelfcheck);
	if (soap_out_PointerTons1__lljSelfcheck(soap, tag?tag:"ns1:lljSelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lljSelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__lljSelfcheck(struct soap *soap, ns1__lljSelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__lljSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cgjALPSelfcheck(struct soap *soap, ns1__cgjALPSelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cgjALPSelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cgjALPSelfcheck(struct soap *soap, const char *tag, int id, ns1__cgjALPSelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cgjALPSelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cgjALPSelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__cgjALPSelfcheck(struct soap *soap, const char *tag, ns1__cgjALPSelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cgjALPSelfcheck **)soap_malloc(soap, sizeof(ns1__cgjALPSelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cgjALPSelfcheck *)soap_instantiate_ns1__cgjALPSelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cgjALPSelfcheck ** p = (ns1__cgjALPSelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cgjALPSelfcheck, sizeof(ns1__cgjALPSelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cgjALPSelfcheck(struct soap *soap, ns1__cgjALPSelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__cgjALPSelfcheck);
	if (soap_out_PointerTons1__cgjALPSelfcheck(soap, tag?tag:"ns1:cgjALPSelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cgjALPSelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__cgjALPSelfcheck(struct soap *soap, ns1__cgjALPSelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cgjALPSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wqfxySelfcheck(struct soap *soap, ns1__wqfxySelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wqfxySelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wqfxySelfcheck(struct soap *soap, const char *tag, int id, ns1__wqfxySelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wqfxySelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wqfxySelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__wqfxySelfcheck(struct soap *soap, const char *tag, ns1__wqfxySelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wqfxySelfcheck **)soap_malloc(soap, sizeof(ns1__wqfxySelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wqfxySelfcheck *)soap_instantiate_ns1__wqfxySelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wqfxySelfcheck ** p = (ns1__wqfxySelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wqfxySelfcheck, sizeof(ns1__wqfxySelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wqfxySelfcheck(struct soap *soap, ns1__wqfxySelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__wqfxySelfcheck);
	if (soap_out_PointerTons1__wqfxySelfcheck(soap, tag?tag:"ns1:wqfxySelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wqfxySelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__wqfxySelfcheck(struct soap *soap, ns1__wqfxySelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wqfxySelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sendMessage_USCOREFC(struct soap *soap, ns1__sendMessage_USCOREFC *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sendMessage_USCOREFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sendMessage_USCOREFC(struct soap *soap, const char *tag, int id, ns1__sendMessage_USCOREFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sendMessage_USCOREFC);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sendMessage_USCOREFC ** SOAP_FMAC4 soap_in_PointerTons1__sendMessage_USCOREFC(struct soap *soap, const char *tag, ns1__sendMessage_USCOREFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sendMessage_USCOREFC **)soap_malloc(soap, sizeof(ns1__sendMessage_USCOREFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sendMessage_USCOREFC *)soap_instantiate_ns1__sendMessage_USCOREFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sendMessage_USCOREFC ** p = (ns1__sendMessage_USCOREFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sendMessage_USCOREFC, sizeof(ns1__sendMessage_USCOREFC), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sendMessage_USCOREFC(struct soap *soap, ns1__sendMessage_USCOREFC *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__sendMessage_USCOREFC);
	if (soap_out_PointerTons1__sendMessage_USCOREFC(soap, tag?tag:"ns1:sendMessage_FC", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sendMessage_USCOREFC ** SOAP_FMAC4 soap_get_PointerTons1__sendMessage_USCOREFC(struct soap *soap, ns1__sendMessage_USCOREFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sendMessage_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sdsqtfxySelfcheck(struct soap *soap, ns1__sdsqtfxySelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sdsqtfxySelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sdsqtfxySelfcheck(struct soap *soap, const char *tag, int id, ns1__sdsqtfxySelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sdsqtfxySelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sdsqtfxySelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__sdsqtfxySelfcheck(struct soap *soap, const char *tag, ns1__sdsqtfxySelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sdsqtfxySelfcheck **)soap_malloc(soap, sizeof(ns1__sdsqtfxySelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sdsqtfxySelfcheck *)soap_instantiate_ns1__sdsqtfxySelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sdsqtfxySelfcheck ** p = (ns1__sdsqtfxySelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sdsqtfxySelfcheck, sizeof(ns1__sdsqtfxySelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sdsqtfxySelfcheck(struct soap *soap, ns1__sdsqtfxySelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__sdsqtfxySelfcheck);
	if (soap_out_PointerTons1__sdsqtfxySelfcheck(soap, tag?tag:"ns1:sdsqtfxySelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sdsqtfxySelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__sdsqtfxySelfcheck(struct soap *soap, ns1__sdsqtfxySelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sdsqtfxySelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__qyfxSelfcheck(struct soap *soap, ns1__qyfxSelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__qyfxSelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__qyfxSelfcheck(struct soap *soap, const char *tag, int id, ns1__qyfxSelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__qyfxSelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__qyfxSelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__qyfxSelfcheck(struct soap *soap, const char *tag, ns1__qyfxSelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__qyfxSelfcheck **)soap_malloc(soap, sizeof(ns1__qyfxSelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__qyfxSelfcheck *)soap_instantiate_ns1__qyfxSelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__qyfxSelfcheck ** p = (ns1__qyfxSelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__qyfxSelfcheck, sizeof(ns1__qyfxSelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__qyfxSelfcheck(struct soap *soap, ns1__qyfxSelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__qyfxSelfcheck);
	if (soap_out_PointerTons1__qyfxSelfcheck(soap, tag?tag:"ns1:qyfxSelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__qyfxSelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__qyfxSelfcheck(struct soap *soap, ns1__qyfxSelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__qyfxSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lightproofSmokeData(struct soap *soap, ns1__lightproofSmokeData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__lightproofSmokeData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lightproofSmokeData(struct soap *soap, const char *tag, int id, ns1__lightproofSmokeData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__lightproofSmokeData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lightproofSmokeData ** SOAP_FMAC4 soap_in_PointerTons1__lightproofSmokeData(struct soap *soap, const char *tag, ns1__lightproofSmokeData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__lightproofSmokeData **)soap_malloc(soap, sizeof(ns1__lightproofSmokeData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__lightproofSmokeData *)soap_instantiate_ns1__lightproofSmokeData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__lightproofSmokeData ** p = (ns1__lightproofSmokeData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__lightproofSmokeData, sizeof(ns1__lightproofSmokeData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lightproofSmokeData(struct soap *soap, ns1__lightproofSmokeData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__lightproofSmokeData);
	if (soap_out_PointerTons1__lightproofSmokeData(soap, tag?tag:"ns1:lightproofSmokeData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lightproofSmokeData ** SOAP_FMAC4 soap_get_PointerTons1__lightproofSmokeData(struct soap *soap, ns1__lightproofSmokeData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__lightproofSmokeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lightproofSmokeData_USCOREFC(struct soap *soap, ns1__lightproofSmokeData_USCOREFC *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lightproofSmokeData_USCOREFC(struct soap *soap, const char *tag, int id, ns1__lightproofSmokeData_USCOREFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lightproofSmokeData_USCOREFC ** SOAP_FMAC4 soap_in_PointerTons1__lightproofSmokeData_USCOREFC(struct soap *soap, const char *tag, ns1__lightproofSmokeData_USCOREFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__lightproofSmokeData_USCOREFC **)soap_malloc(soap, sizeof(ns1__lightproofSmokeData_USCOREFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__lightproofSmokeData_USCOREFC *)soap_instantiate_ns1__lightproofSmokeData_USCOREFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__lightproofSmokeData_USCOREFC ** p = (ns1__lightproofSmokeData_USCOREFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC, sizeof(ns1__lightproofSmokeData_USCOREFC), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lightproofSmokeData_USCOREFC(struct soap *soap, ns1__lightproofSmokeData_USCOREFC *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__lightproofSmokeData_USCOREFC);
	if (soap_out_PointerTons1__lightproofSmokeData_USCOREFC(soap, tag?tag:"ns1:lightproofSmokeData_FC", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lightproofSmokeData_USCOREFC ** SOAP_FMAC4 soap_get_PointerTons1__lightproofSmokeData_USCOREFC(struct soap *soap, ns1__lightproofSmokeData_USCOREFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__lightproofSmokeData_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wqfxyAdjust(struct soap *soap, ns1__wqfxyAdjust *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wqfxyAdjust))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wqfxyAdjust(struct soap *soap, const char *tag, int id, ns1__wqfxyAdjust *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wqfxyAdjust);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wqfxyAdjust ** SOAP_FMAC4 soap_in_PointerTons1__wqfxyAdjust(struct soap *soap, const char *tag, ns1__wqfxyAdjust **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wqfxyAdjust **)soap_malloc(soap, sizeof(ns1__wqfxyAdjust *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wqfxyAdjust *)soap_instantiate_ns1__wqfxyAdjust(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wqfxyAdjust ** p = (ns1__wqfxyAdjust **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wqfxyAdjust, sizeof(ns1__wqfxyAdjust), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wqfxyAdjust(struct soap *soap, ns1__wqfxyAdjust *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__wqfxyAdjust);
	if (soap_out_PointerTons1__wqfxyAdjust(soap, tag?tag:"ns1:wqfxyAdjust", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wqfxyAdjust ** SOAP_FMAC4 soap_get_PointerTons1__wqfxyAdjust(struct soap *soap, ns1__wqfxyAdjust **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wqfxyAdjust(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cgjPLHPSelfcheck(struct soap *soap, ns1__cgjPLHPSelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cgjPLHPSelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cgjPLHPSelfcheck(struct soap *soap, const char *tag, int id, ns1__cgjPLHPSelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cgjPLHPSelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cgjPLHPSelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__cgjPLHPSelfcheck(struct soap *soap, const char *tag, ns1__cgjPLHPSelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cgjPLHPSelfcheck **)soap_malloc(soap, sizeof(ns1__cgjPLHPSelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cgjPLHPSelfcheck *)soap_instantiate_ns1__cgjPLHPSelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cgjPLHPSelfcheck ** p = (ns1__cgjPLHPSelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cgjPLHPSelfcheck, sizeof(ns1__cgjPLHPSelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cgjPLHPSelfcheck(struct soap *soap, ns1__cgjPLHPSelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__cgjPLHPSelfcheck);
	if (soap_out_PointerTons1__cgjPLHPSelfcheck(soap, tag?tag:"ns1:cgjPLHPSelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cgjPLHPSelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__cgjPLHPSelfcheck(struct soap *soap, ns1__cgjPLHPSelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cgjPLHPSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__doubleIdleLog(struct soap *soap, ns1__doubleIdleLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__doubleIdleLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__doubleIdleLog(struct soap *soap, const char *tag, int id, ns1__doubleIdleLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__doubleIdleLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__doubleIdleLog ** SOAP_FMAC4 soap_in_PointerTons1__doubleIdleLog(struct soap *soap, const char *tag, ns1__doubleIdleLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__doubleIdleLog **)soap_malloc(soap, sizeof(ns1__doubleIdleLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__doubleIdleLog *)soap_instantiate_ns1__doubleIdleLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__doubleIdleLog ** p = (ns1__doubleIdleLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__doubleIdleLog, sizeof(ns1__doubleIdleLog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__doubleIdleLog(struct soap *soap, ns1__doubleIdleLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__doubleIdleLog);
	if (soap_out_PointerTons1__doubleIdleLog(soap, tag?tag:"ns1:doubleIdleLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__doubleIdleLog ** SOAP_FMAC4 soap_get_PointerTons1__doubleIdleLog(struct soap *soap, ns1__doubleIdleLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__doubleIdleLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__doubleIdleData(struct soap *soap, ns1__doubleIdleData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__doubleIdleData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__doubleIdleData(struct soap *soap, const char *tag, int id, ns1__doubleIdleData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__doubleIdleData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__doubleIdleData ** SOAP_FMAC4 soap_in_PointerTons1__doubleIdleData(struct soap *soap, const char *tag, ns1__doubleIdleData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__doubleIdleData **)soap_malloc(soap, sizeof(ns1__doubleIdleData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__doubleIdleData *)soap_instantiate_ns1__doubleIdleData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__doubleIdleData ** p = (ns1__doubleIdleData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__doubleIdleData, sizeof(ns1__doubleIdleData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__doubleIdleData(struct soap *soap, ns1__doubleIdleData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__doubleIdleData);
	if (soap_out_PointerTons1__doubleIdleData(soap, tag?tag:"ns1:doubleIdleData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__doubleIdleData ** SOAP_FMAC4 soap_get_PointerTons1__doubleIdleData(struct soap *soap, ns1__doubleIdleData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__doubleIdleData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getSatate(struct soap *soap, ns1__getSatate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getSatate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getSatate(struct soap *soap, const char *tag, int id, ns1__getSatate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getSatate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getSatate ** SOAP_FMAC4 soap_in_PointerTons1__getSatate(struct soap *soap, const char *tag, ns1__getSatate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getSatate **)soap_malloc(soap, sizeof(ns1__getSatate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getSatate *)soap_instantiate_ns1__getSatate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getSatate ** p = (ns1__getSatate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSatate, sizeof(ns1__getSatate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getSatate(struct soap *soap, ns1__getSatate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__getSatate);
	if (soap_out_PointerTons1__getSatate(soap, tag?tag:"ns1:getSatate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getSatate ** SOAP_FMAC4 soap_get_PointerTons1__getSatate(struct soap *soap, ns1__getSatate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getSatate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__motoDbIdleData(struct soap *soap, ns1__motoDbIdleData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__motoDbIdleData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__motoDbIdleData(struct soap *soap, const char *tag, int id, ns1__motoDbIdleData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__motoDbIdleData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__motoDbIdleData ** SOAP_FMAC4 soap_in_PointerTons1__motoDbIdleData(struct soap *soap, const char *tag, ns1__motoDbIdleData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__motoDbIdleData **)soap_malloc(soap, sizeof(ns1__motoDbIdleData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__motoDbIdleData *)soap_instantiate_ns1__motoDbIdleData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__motoDbIdleData ** p = (ns1__motoDbIdleData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__motoDbIdleData, sizeof(ns1__motoDbIdleData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__motoDbIdleData(struct soap *soap, ns1__motoDbIdleData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__motoDbIdleData);
	if (soap_out_PointerTons1__motoDbIdleData(soap, tag?tag:"ns1:motoDbIdleData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__motoDbIdleData ** SOAP_FMAC4 soap_get_PointerTons1__motoDbIdleData(struct soap *soap, ns1__motoDbIdleData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__motoDbIdleData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__vmasData(struct soap *soap, ns1__vmasData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__vmasData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__vmasData(struct soap *soap, const char *tag, int id, ns1__vmasData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__vmasData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__vmasData ** SOAP_FMAC4 soap_in_PointerTons1__vmasData(struct soap *soap, const char *tag, ns1__vmasData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__vmasData **)soap_malloc(soap, sizeof(ns1__vmasData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__vmasData *)soap_instantiate_ns1__vmasData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__vmasData ** p = (ns1__vmasData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__vmasData, sizeof(ns1__vmasData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__vmasData(struct soap *soap, ns1__vmasData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__vmasData);
	if (soap_out_PointerTons1__vmasData(soap, tag?tag:"ns1:vmasData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__vmasData ** SOAP_FMAC4 soap_get_PointerTons1__vmasData(struct soap *soap, ns1__vmasData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__vmasData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__loadDownData(struct soap *soap, ns1__loadDownData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__loadDownData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__loadDownData(struct soap *soap, const char *tag, int id, ns1__loadDownData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__loadDownData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__loadDownData ** SOAP_FMAC4 soap_in_PointerTons1__loadDownData(struct soap *soap, const char *tag, ns1__loadDownData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__loadDownData **)soap_malloc(soap, sizeof(ns1__loadDownData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__loadDownData *)soap_instantiate_ns1__loadDownData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__loadDownData ** p = (ns1__loadDownData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loadDownData, sizeof(ns1__loadDownData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__loadDownData(struct soap *soap, ns1__loadDownData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__loadDownData);
	if (soap_out_PointerTons1__loadDownData(soap, tag?tag:"ns1:loadDownData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__loadDownData ** SOAP_FMAC4 soap_get_PointerTons1__loadDownData(struct soap *soap, ns1__loadDownData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__loadDownData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, ns1__lightproofSmokeDataLog_USCOREFC *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, const char *tag, int id, ns1__lightproofSmokeDataLog_USCOREFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lightproofSmokeDataLog_USCOREFC ** SOAP_FMAC4 soap_in_PointerTons1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, const char *tag, ns1__lightproofSmokeDataLog_USCOREFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__lightproofSmokeDataLog_USCOREFC **)soap_malloc(soap, sizeof(ns1__lightproofSmokeDataLog_USCOREFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__lightproofSmokeDataLog_USCOREFC *)soap_instantiate_ns1__lightproofSmokeDataLog_USCOREFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__lightproofSmokeDataLog_USCOREFC ** p = (ns1__lightproofSmokeDataLog_USCOREFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC, sizeof(ns1__lightproofSmokeDataLog_USCOREFC), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, ns1__lightproofSmokeDataLog_USCOREFC *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__lightproofSmokeDataLog_USCOREFC);
	if (soap_out_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, tag?tag:"ns1:lightproofSmokeDataLog_FC", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lightproofSmokeDataLog_USCOREFC ** SOAP_FMAC4 soap_get_PointerTons1__lightproofSmokeDataLog_USCOREFC(struct soap *soap, ns1__lightproofSmokeDataLog_USCOREFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__lightproofSmokeDataLog_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__pqfxySelfcheck(struct soap *soap, ns1__pqfxySelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__pqfxySelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__pqfxySelfcheck(struct soap *soap, const char *tag, int id, ns1__pqfxySelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__pqfxySelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__pqfxySelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__pqfxySelfcheck(struct soap *soap, const char *tag, ns1__pqfxySelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__pqfxySelfcheck **)soap_malloc(soap, sizeof(ns1__pqfxySelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__pqfxySelfcheck *)soap_instantiate_ns1__pqfxySelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__pqfxySelfcheck ** p = (ns1__pqfxySelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__pqfxySelfcheck, sizeof(ns1__pqfxySelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__pqfxySelfcheck(struct soap *soap, ns1__pqfxySelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__pqfxySelfcheck);
	if (soap_out_PointerTons1__pqfxySelfcheck(soap, tag?tag:"ns1:pqfxySelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__pqfxySelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__pqfxySelfcheck(struct soap *soap, ns1__pqfxySelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__pqfxySelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__hjcsgyqSelfcheck(struct soap *soap, ns1__hjcsgyqSelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__hjcsgyqSelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__hjcsgyqSelfcheck(struct soap *soap, const char *tag, int id, ns1__hjcsgyqSelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__hjcsgyqSelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__hjcsgyqSelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__hjcsgyqSelfcheck(struct soap *soap, const char *tag, ns1__hjcsgyqSelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__hjcsgyqSelfcheck **)soap_malloc(soap, sizeof(ns1__hjcsgyqSelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__hjcsgyqSelfcheck *)soap_instantiate_ns1__hjcsgyqSelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__hjcsgyqSelfcheck ** p = (ns1__hjcsgyqSelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__hjcsgyqSelfcheck, sizeof(ns1__hjcsgyqSelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__hjcsgyqSelfcheck(struct soap *soap, ns1__hjcsgyqSelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__hjcsgyqSelfcheck);
	if (soap_out_PointerTons1__hjcsgyqSelfcheck(soap, tag?tag:"ns1:hjcsgyqSelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__hjcsgyqSelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__hjcsgyqSelfcheck(struct soap *soap, ns1__hjcsgyqSelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__hjcsgyqSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cycdyhwAdjust(struct soap *soap, ns1__cycdyhwAdjust *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cycdyhwAdjust))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cycdyhwAdjust(struct soap *soap, const char *tag, int id, ns1__cycdyhwAdjust *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cycdyhwAdjust);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cycdyhwAdjust ** SOAP_FMAC4 soap_in_PointerTons1__cycdyhwAdjust(struct soap *soap, const char *tag, ns1__cycdyhwAdjust **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cycdyhwAdjust **)soap_malloc(soap, sizeof(ns1__cycdyhwAdjust *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cycdyhwAdjust *)soap_instantiate_ns1__cycdyhwAdjust(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cycdyhwAdjust ** p = (ns1__cycdyhwAdjust **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cycdyhwAdjust, sizeof(ns1__cycdyhwAdjust), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cycdyhwAdjust(struct soap *soap, ns1__cycdyhwAdjust *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__cycdyhwAdjust);
	if (soap_out_PointerTons1__cycdyhwAdjust(soap, tag?tag:"ns1:cycdyhwAdjust", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cycdyhwAdjust ** SOAP_FMAC4 soap_get_PointerTons1__cycdyhwAdjust(struct soap *soap, ns1__cycdyhwAdjust **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cycdyhwAdjust(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__software2centerNew_USCOREFC(struct soap *soap, ns1__software2centerNew_USCOREFC *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__software2centerNew_USCOREFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__software2centerNew_USCOREFC(struct soap *soap, const char *tag, int id, ns1__software2centerNew_USCOREFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__software2centerNew_USCOREFC);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__software2centerNew_USCOREFC ** SOAP_FMAC4 soap_in_PointerTons1__software2centerNew_USCOREFC(struct soap *soap, const char *tag, ns1__software2centerNew_USCOREFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__software2centerNew_USCOREFC **)soap_malloc(soap, sizeof(ns1__software2centerNew_USCOREFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__software2centerNew_USCOREFC *)soap_instantiate_ns1__software2centerNew_USCOREFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__software2centerNew_USCOREFC ** p = (ns1__software2centerNew_USCOREFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__software2centerNew_USCOREFC, sizeof(ns1__software2centerNew_USCOREFC), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__software2centerNew_USCOREFC(struct soap *soap, ns1__software2centerNew_USCOREFC *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__software2centerNew_USCOREFC);
	if (soap_out_PointerTons1__software2centerNew_USCOREFC(soap, tag?tag:"ns1:software2centerNew_FC", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__software2centerNew_USCOREFC ** SOAP_FMAC4 soap_get_PointerTons1__software2centerNew_USCOREFC(struct soap *soap, ns1__software2centerNew_USCOREFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__software2centerNew_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getCarInfo_USCOREFC(struct soap *soap, ns1__getCarInfo_USCOREFC *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getCarInfo_USCOREFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getCarInfo_USCOREFC(struct soap *soap, const char *tag, int id, ns1__getCarInfo_USCOREFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getCarInfo_USCOREFC);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getCarInfo_USCOREFC ** SOAP_FMAC4 soap_in_PointerTons1__getCarInfo_USCOREFC(struct soap *soap, const char *tag, ns1__getCarInfo_USCOREFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getCarInfo_USCOREFC **)soap_malloc(soap, sizeof(ns1__getCarInfo_USCOREFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getCarInfo_USCOREFC *)soap_instantiate_ns1__getCarInfo_USCOREFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getCarInfo_USCOREFC ** p = (ns1__getCarInfo_USCOREFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getCarInfo_USCOREFC, sizeof(ns1__getCarInfo_USCOREFC), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getCarInfo_USCOREFC(struct soap *soap, ns1__getCarInfo_USCOREFC *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__getCarInfo_USCOREFC);
	if (soap_out_PointerTons1__getCarInfo_USCOREFC(soap, tag?tag:"ns1:getCarInfo_FC", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getCarInfo_USCOREFC ** SOAP_FMAC4 soap_get_PointerTons1__getCarInfo_USCOREFC(struct soap *soap, ns1__getCarInfo_USCOREFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getCarInfo_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__obdResultLog(struct soap *soap, ns1__obdResultLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__obdResultLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__obdResultLog(struct soap *soap, const char *tag, int id, ns1__obdResultLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__obdResultLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__obdResultLog ** SOAP_FMAC4 soap_in_PointerTons1__obdResultLog(struct soap *soap, const char *tag, ns1__obdResultLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__obdResultLog **)soap_malloc(soap, sizeof(ns1__obdResultLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__obdResultLog *)soap_instantiate_ns1__obdResultLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__obdResultLog ** p = (ns1__obdResultLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__obdResultLog, sizeof(ns1__obdResultLog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__obdResultLog(struct soap *soap, ns1__obdResultLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__obdResultLog);
	if (soap_out_PointerTons1__obdResultLog(soap, tag?tag:"ns1:obdResultLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__obdResultLog ** SOAP_FMAC4 soap_get_PointerTons1__obdResultLog(struct soap *soap, ns1__obdResultLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__obdResultLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dyhwAdjust(struct soap *soap, ns1__dyhwAdjust *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__dyhwAdjust))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dyhwAdjust(struct soap *soap, const char *tag, int id, ns1__dyhwAdjust *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__dyhwAdjust);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dyhwAdjust ** SOAP_FMAC4 soap_in_PointerTons1__dyhwAdjust(struct soap *soap, const char *tag, ns1__dyhwAdjust **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__dyhwAdjust **)soap_malloc(soap, sizeof(ns1__dyhwAdjust *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__dyhwAdjust *)soap_instantiate_ns1__dyhwAdjust(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__dyhwAdjust ** p = (ns1__dyhwAdjust **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__dyhwAdjust, sizeof(ns1__dyhwAdjust), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dyhwAdjust(struct soap *soap, ns1__dyhwAdjust *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__dyhwAdjust);
	if (soap_out_PointerTons1__dyhwAdjust(soap, tag?tag:"ns1:dyhwAdjust", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dyhwAdjust ** SOAP_FMAC4 soap_get_PointerTons1__dyhwAdjust(struct soap *soap, ns1__dyhwAdjust **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__dyhwAdjust(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__loadDownLog(struct soap *soap, ns1__loadDownLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__loadDownLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__loadDownLog(struct soap *soap, const char *tag, int id, ns1__loadDownLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__loadDownLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__loadDownLog ** SOAP_FMAC4 soap_in_PointerTons1__loadDownLog(struct soap *soap, const char *tag, ns1__loadDownLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__loadDownLog **)soap_malloc(soap, sizeof(ns1__loadDownLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__loadDownLog *)soap_instantiate_ns1__loadDownLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__loadDownLog ** p = (ns1__loadDownLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loadDownLog, sizeof(ns1__loadDownLog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__loadDownLog(struct soap *soap, ns1__loadDownLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__loadDownLog);
	if (soap_out_PointerTons1__loadDownLog(soap, tag?tag:"ns1:loadDownLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__loadDownLog ** SOAP_FMAC4 soap_get_PointerTons1__loadDownLog(struct soap *soap, ns1__loadDownLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__loadDownLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dyhwSelfcheck(struct soap *soap, ns1__dyhwSelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__dyhwSelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dyhwSelfcheck(struct soap *soap, const char *tag, int id, ns1__dyhwSelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__dyhwSelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dyhwSelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__dyhwSelfcheck(struct soap *soap, const char *tag, ns1__dyhwSelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__dyhwSelfcheck **)soap_malloc(soap, sizeof(ns1__dyhwSelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__dyhwSelfcheck *)soap_instantiate_ns1__dyhwSelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__dyhwSelfcheck ** p = (ns1__dyhwSelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__dyhwSelfcheck, sizeof(ns1__dyhwSelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dyhwSelfcheck(struct soap *soap, ns1__dyhwSelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__dyhwSelfcheck);
	if (soap_out_PointerTons1__dyhwSelfcheck(soap, tag?tag:"ns1:dyhwSelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dyhwSelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__dyhwSelfcheck(struct soap *soap, ns1__dyhwSelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__dyhwSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ydjSelfcheck(struct soap *soap, ns1__ydjSelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ydjSelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ydjSelfcheck(struct soap *soap, const char *tag, int id, ns1__ydjSelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ydjSelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ydjSelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__ydjSelfcheck(struct soap *soap, const char *tag, ns1__ydjSelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ydjSelfcheck **)soap_malloc(soap, sizeof(ns1__ydjSelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ydjSelfcheck *)soap_instantiate_ns1__ydjSelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ydjSelfcheck ** p = (ns1__ydjSelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ydjSelfcheck, sizeof(ns1__ydjSelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ydjSelfcheck(struct soap *soap, ns1__ydjSelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__ydjSelfcheck);
	if (soap_out_PointerTons1__ydjSelfcheck(soap, tag?tag:"ns1:ydjSelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ydjSelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__ydjSelfcheck(struct soap *soap, ns1__ydjSelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ydjSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__vmasLog(struct soap *soap, ns1__vmasLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__vmasLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__vmasLog(struct soap *soap, const char *tag, int id, ns1__vmasLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__vmasLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__vmasLog ** SOAP_FMAC4 soap_in_PointerTons1__vmasLog(struct soap *soap, const char *tag, ns1__vmasLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__vmasLog **)soap_malloc(soap, sizeof(ns1__vmasLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__vmasLog *)soap_instantiate_ns1__vmasLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__vmasLog ** p = (ns1__vmasLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__vmasLog, sizeof(ns1__vmasLog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__vmasLog(struct soap *soap, ns1__vmasLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__vmasLog);
	if (soap_out_PointerTons1__vmasLog(soap, tag?tag:"ns1:vmasLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__vmasLog ** SOAP_FMAC4 soap_get_PointerTons1__vmasLog(struct soap *soap, ns1__vmasLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__vmasLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__doubleIdleLog_USCOREFC(struct soap *soap, ns1__doubleIdleLog_USCOREFC *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__doubleIdleLog_USCOREFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__doubleIdleLog_USCOREFC(struct soap *soap, const char *tag, int id, ns1__doubleIdleLog_USCOREFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__doubleIdleLog_USCOREFC);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__doubleIdleLog_USCOREFC ** SOAP_FMAC4 soap_in_PointerTons1__doubleIdleLog_USCOREFC(struct soap *soap, const char *tag, ns1__doubleIdleLog_USCOREFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__doubleIdleLog_USCOREFC **)soap_malloc(soap, sizeof(ns1__doubleIdleLog_USCOREFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__doubleIdleLog_USCOREFC *)soap_instantiate_ns1__doubleIdleLog_USCOREFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__doubleIdleLog_USCOREFC ** p = (ns1__doubleIdleLog_USCOREFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__doubleIdleLog_USCOREFC, sizeof(ns1__doubleIdleLog_USCOREFC), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__doubleIdleLog_USCOREFC(struct soap *soap, ns1__doubleIdleLog_USCOREFC *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__doubleIdleLog_USCOREFC);
	if (soap_out_PointerTons1__doubleIdleLog_USCOREFC(soap, tag?tag:"ns1:doubleIdleLog_FC", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__doubleIdleLog_USCOREFC ** SOAP_FMAC4 soap_get_PointerTons1__doubleIdleLog_USCOREFC(struct soap *soap, ns1__doubleIdleLog_USCOREFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__doubleIdleLog_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__obdResult(struct soap *soap, ns1__obdResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__obdResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__obdResult(struct soap *soap, const char *tag, int id, ns1__obdResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__obdResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__obdResult ** SOAP_FMAC4 soap_in_PointerTons1__obdResult(struct soap *soap, const char *tag, ns1__obdResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__obdResult **)soap_malloc(soap, sizeof(ns1__obdResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__obdResult *)soap_instantiate_ns1__obdResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__obdResult ** p = (ns1__obdResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__obdResult, sizeof(ns1__obdResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__obdResult(struct soap *soap, ns1__obdResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__obdResult);
	if (soap_out_PointerTons1__obdResult(soap, tag?tag:"ns1:obdResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__obdResult ** SOAP_FMAC4 soap_get_PointerTons1__obdResult(struct soap *soap, ns1__obdResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__obdResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cgjSelfcheck(struct soap *soap, ns1__cgjSelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cgjSelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cgjSelfcheck(struct soap *soap, const char *tag, int id, ns1__cgjSelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cgjSelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cgjSelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__cgjSelfcheck(struct soap *soap, const char *tag, ns1__cgjSelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cgjSelfcheck **)soap_malloc(soap, sizeof(ns1__cgjSelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cgjSelfcheck *)soap_instantiate_ns1__cgjSelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cgjSelfcheck ** p = (ns1__cgjSelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cgjSelfcheck, sizeof(ns1__cgjSelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cgjSelfcheck(struct soap *soap, ns1__cgjSelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__cgjSelfcheck);
	if (soap_out_PointerTons1__cgjSelfcheck(soap, tag?tag:"ns1:cgjSelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cgjSelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__cgjSelfcheck(struct soap *soap, ns1__cgjSelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cgjSelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cgjLASelfcheck(struct soap *soap, ns1__cgjLASelfcheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cgjLASelfcheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cgjLASelfcheck(struct soap *soap, const char *tag, int id, ns1__cgjLASelfcheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cgjLASelfcheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cgjLASelfcheck ** SOAP_FMAC4 soap_in_PointerTons1__cgjLASelfcheck(struct soap *soap, const char *tag, ns1__cgjLASelfcheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cgjLASelfcheck **)soap_malloc(soap, sizeof(ns1__cgjLASelfcheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cgjLASelfcheck *)soap_instantiate_ns1__cgjLASelfcheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cgjLASelfcheck ** p = (ns1__cgjLASelfcheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cgjLASelfcheck, sizeof(ns1__cgjLASelfcheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cgjLASelfcheck(struct soap *soap, ns1__cgjLASelfcheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__cgjLASelfcheck);
	if (soap_out_PointerTons1__cgjLASelfcheck(soap, tag?tag:"ns1:cgjLASelfcheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cgjLASelfcheck ** SOAP_FMAC4 soap_get_PointerTons1__cgjLASelfcheck(struct soap *soap, ns1__cgjLASelfcheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cgjLASelfcheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__doubleIdleData_USCOREFC(struct soap *soap, ns1__doubleIdleData_USCOREFC *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__doubleIdleData_USCOREFC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__doubleIdleData_USCOREFC(struct soap *soap, const char *tag, int id, ns1__doubleIdleData_USCOREFC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__doubleIdleData_USCOREFC);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__doubleIdleData_USCOREFC ** SOAP_FMAC4 soap_in_PointerTons1__doubleIdleData_USCOREFC(struct soap *soap, const char *tag, ns1__doubleIdleData_USCOREFC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__doubleIdleData_USCOREFC **)soap_malloc(soap, sizeof(ns1__doubleIdleData_USCOREFC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__doubleIdleData_USCOREFC *)soap_instantiate_ns1__doubleIdleData_USCOREFC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__doubleIdleData_USCOREFC ** p = (ns1__doubleIdleData_USCOREFC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__doubleIdleData_USCOREFC, sizeof(ns1__doubleIdleData_USCOREFC), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__doubleIdleData_USCOREFC(struct soap *soap, ns1__doubleIdleData_USCOREFC *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__doubleIdleData_USCOREFC);
	if (soap_out_PointerTons1__doubleIdleData_USCOREFC(soap, tag?tag:"ns1:doubleIdleData_FC", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__doubleIdleData_USCOREFC ** SOAP_FMAC4 soap_get_PointerTons1__doubleIdleData_USCOREFC(struct soap *soap, ns1__doubleIdleData_USCOREFC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__doubleIdleData_USCOREFC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__bgAirHC(struct soap *soap, ns1__bgAirHC *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__bgAirHC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__bgAirHC(struct soap *soap, const char *tag, int id, ns1__bgAirHC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__bgAirHC);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__bgAirHC ** SOAP_FMAC4 soap_in_PointerTons1__bgAirHC(struct soap *soap, const char *tag, ns1__bgAirHC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__bgAirHC **)soap_malloc(soap, sizeof(ns1__bgAirHC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__bgAirHC *)soap_instantiate_ns1__bgAirHC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__bgAirHC ** p = (ns1__bgAirHC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__bgAirHC, sizeof(ns1__bgAirHC), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__bgAirHC(struct soap *soap, ns1__bgAirHC *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__bgAirHC);
	if (soap_out_PointerTons1__bgAirHC(soap, tag?tag:"ns1:bgAirHC", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__bgAirHC ** SOAP_FMAC4 soap_get_PointerTons1__bgAirHC(struct soap *soap, ns1__bgAirHC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__bgAirHC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sendMessage(struct soap *soap, ns1__sendMessage *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sendMessage))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sendMessage(struct soap *soap, const char *tag, int id, ns1__sendMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sendMessage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sendMessage ** SOAP_FMAC4 soap_in_PointerTons1__sendMessage(struct soap *soap, const char *tag, ns1__sendMessage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sendMessage **)soap_malloc(soap, sizeof(ns1__sendMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sendMessage *)soap_instantiate_ns1__sendMessage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sendMessage ** p = (ns1__sendMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sendMessage, sizeof(ns1__sendMessage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sendMessage(struct soap *soap, ns1__sendMessage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__sendMessage);
	if (soap_out_PointerTons1__sendMessage(soap, tag?tag:"ns1:sendMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sendMessage ** SOAP_FMAC4 soap_get_PointerTons1__sendMessage(struct soap *soap, ns1__sendMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sendMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getCarInfo(struct soap *soap, ns1__getCarInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getCarInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getCarInfo(struct soap *soap, const char *tag, int id, ns1__getCarInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getCarInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getCarInfo ** SOAP_FMAC4 soap_in_PointerTons1__getCarInfo(struct soap *soap, const char *tag, ns1__getCarInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getCarInfo **)soap_malloc(soap, sizeof(ns1__getCarInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getCarInfo *)soap_instantiate_ns1__getCarInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getCarInfo ** p = (ns1__getCarInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getCarInfo, sizeof(ns1__getCarInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getCarInfo(struct soap *soap, ns1__getCarInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__getCarInfo);
	if (soap_out_PointerTons1__getCarInfo(soap, tag?tag:"ns1:getCarInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getCarInfo ** SOAP_FMAC4 soap_get_PointerTons1__getCarInfo(struct soap *soap, ns1__getCarInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getCarInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lightproofSmokeLog(struct soap *soap, ns1__lightproofSmokeLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__lightproofSmokeLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lightproofSmokeLog(struct soap *soap, const char *tag, int id, ns1__lightproofSmokeLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__lightproofSmokeLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lightproofSmokeLog ** SOAP_FMAC4 soap_in_PointerTons1__lightproofSmokeLog(struct soap *soap, const char *tag, ns1__lightproofSmokeLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__lightproofSmokeLog **)soap_malloc(soap, sizeof(ns1__lightproofSmokeLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__lightproofSmokeLog *)soap_instantiate_ns1__lightproofSmokeLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__lightproofSmokeLog ** p = (ns1__lightproofSmokeLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__lightproofSmokeLog, sizeof(ns1__lightproofSmokeLog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lightproofSmokeLog(struct soap *soap, ns1__lightproofSmokeLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__lightproofSmokeLog);
	if (soap_out_PointerTons1__lightproofSmokeLog(soap, tag?tag:"ns1:lightproofSmokeLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lightproofSmokeLog ** SOAP_FMAC4 soap_get_PointerTons1__lightproofSmokeLog(struct soap *soap, ns1__lightproofSmokeLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__lightproofSmokeLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__argChang(struct soap *soap, ns1__argChang *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__argChang))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__argChang(struct soap *soap, const char *tag, int id, ns1__argChang *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__argChang);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__argChang ** SOAP_FMAC4 soap_in_PointerTons1__argChang(struct soap *soap, const char *tag, ns1__argChang **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__argChang **)soap_malloc(soap, sizeof(ns1__argChang *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__argChang *)soap_instantiate_ns1__argChang(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__argChang ** p = (ns1__argChang **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__argChang, sizeof(ns1__argChang), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__argChang(struct soap *soap, ns1__argChang *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__argChang);
	if (soap_out_PointerTons1__argChang(soap, tag?tag:"ns1:argChang", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__argChang ** SOAP_FMAC4 soap_get_PointerTons1__argChang(struct soap *soap, ns1__argChang **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__argChang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__stateInfo(struct soap *soap, ns1__stateInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__stateInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__stateInfo(struct soap *soap, const char *tag, int id, ns1__stateInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__stateInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__stateInfo ** SOAP_FMAC4 soap_in_PointerTons1__stateInfo(struct soap *soap, const char *tag, ns1__stateInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__stateInfo **)soap_malloc(soap, sizeof(ns1__stateInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__stateInfo *)soap_instantiate_ns1__stateInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__stateInfo ** p = (ns1__stateInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__stateInfo, sizeof(ns1__stateInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__stateInfo(struct soap *soap, ns1__stateInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__stateInfo);
	if (soap_out_PointerTons1__stateInfo(soap, tag?tag:"ns1:stateInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__stateInfo ** SOAP_FMAC4 soap_get_PointerTons1__stateInfo(struct soap *soap, ns1__stateInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__stateInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__carInfo(struct soap *soap, ns1__carInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__carInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__carInfo(struct soap *soap, const char *tag, int id, ns1__carInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__carInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__carInfo ** SOAP_FMAC4 soap_in_PointerTons1__carInfo(struct soap *soap, const char *tag, ns1__carInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__carInfo **)soap_malloc(soap, sizeof(ns1__carInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__carInfo *)soap_instantiate_ns1__carInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__carInfo ** p = (ns1__carInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__carInfo, sizeof(ns1__carInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__carInfo(struct soap *soap, ns1__carInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__carInfo);
	if (soap_out_PointerTons1__carInfo(soap, tag?tag:"ns1:carInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__carInfo ** SOAP_FMAC4 soap_get_PointerTons1__carInfo(struct soap *soap, ns1__carInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__carInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__wstring(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__wstring))
		soap_serialize_std__wstring(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__wstring(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__wstring);
	if (id < 0)
		return soap->error;
	return soap_out_std__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTostd__wstring(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__wstring(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTostd__wstring);
	if (soap_out_PointerTostd__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTostd__wstring(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
