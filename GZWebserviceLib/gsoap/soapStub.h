/* soapStub.h
   Generated by gSOAP 2.8.21 from deviceSwap.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://iface.server.webservice.zkyt.com/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20821
# error "GSOAP VERSION 20821 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__argChang
#define SOAP_TYPE_ns1__argChang (8)
/* ns1:argChang */
class SOAP_CMAC ns1__argChang
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *argName;	/* optional element of type xsd:string */
	std::wstring *oldValue;	/* optional element of type xsd:string */
	std::wstring *newValue;	/* optional element of type xsd:string */
	std::wstring *changeTime;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique type id SOAP_TYPE_ns1__argChang */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__argChang() { ns1__argChang::soap_default(NULL); }
	virtual ~ns1__argChang() { }
};
#endif

#ifndef SOAP_TYPE_ns1__argChangResponse
#define SOAP_TYPE_ns1__argChangResponse (9)
/* ns1:argChangResponse */
class SOAP_CMAC ns1__argChangResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique type id SOAP_TYPE_ns1__argChangResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__argChangResponse() { ns1__argChangResponse::soap_default(NULL); }
	virtual ~ns1__argChangResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lightproofSmokeLog
#define SOAP_TYPE_ns1__lightproofSmokeLog (10)
/* ns1:lightproofSmokeLog */
class SOAP_CMAC ns1__lightproofSmokeLog
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *logTime;	/* optional element of type xsd:string */
	std::wstring *type;	/* optional element of type xsd:string */
	int inspectNum;	/* required element of type xsd:int */
	double smokeValue;	/* required element of type xsd:double */
	int zs;	/* required element of type xsd:int */
	double ydjjcswd;	/* required element of type xsd:double */
	double ydjjcsqy;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique type id SOAP_TYPE_ns1__lightproofSmokeLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lightproofSmokeLog() { ns1__lightproofSmokeLog::soap_default(NULL); }
	virtual ~ns1__lightproofSmokeLog() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lightproofSmokeLogResponse
#define SOAP_TYPE_ns1__lightproofSmokeLogResponse (11)
/* ns1:lightproofSmokeLogResponse */
class SOAP_CMAC ns1__lightproofSmokeLogResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique type id SOAP_TYPE_ns1__lightproofSmokeLogResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lightproofSmokeLogResponse() { ns1__lightproofSmokeLogResponse::soap_default(NULL); }
	virtual ~ns1__lightproofSmokeLogResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getCarInfo
#define SOAP_TYPE_ns1__getCarInfo (12)
/* ns1:getCarInfo */
class SOAP_CMAC ns1__getCarInfo
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique type id SOAP_TYPE_ns1__getCarInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getCarInfo() { ns1__getCarInfo::soap_default(NULL); }
	virtual ~ns1__getCarInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getCarInfoResponse
#define SOAP_TYPE_ns1__getCarInfoResponse (13)
/* ns1:getCarInfoResponse */
class SOAP_CMAC ns1__getCarInfoResponse
{
public:
	class ns1__carInfo *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:carInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique type id SOAP_TYPE_ns1__getCarInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getCarInfoResponse() { ns1__getCarInfoResponse::soap_default(NULL); }
	virtual ~ns1__getCarInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__carInfo
#define SOAP_TYPE_ns1__carInfo (14)
/* ns1:carInfo */
class SOAP_CMAC ns1__carInfo
{
public:
	std::wstring *carCardNumber;	/* optional element of type xsd:string */
	std::wstring *airInflow;	/* optional element of type xsd:string */
	std::wstring *fuelType;	/* optional element of type xsd:string */
	std::wstring *isSYJHQ;	/* optional element of type xsd:string */
	double maxWeight;	/* required element of type xsd:double */
	double motorPower;	/* required element of type xsd:double */
	double motorRate;	/* required element of type xsd:double */
	std::wstring *oilSupply;	/* optional element of type xsd:string */
	std::wstring *speedChanger;	/* optional element of type xsd:string */
	double standardWeight;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique type id SOAP_TYPE_ns1__carInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__carInfo() { ns1__carInfo::soap_default(NULL); }
	virtual ~ns1__carInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sendMessage
#define SOAP_TYPE_ns1__sendMessage (15)
/* ns1:sendMessage */
class SOAP_CMAC ns1__sendMessage
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *code;	/* optional element of type xsd:string */
	std::wstring *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique type id SOAP_TYPE_ns1__sendMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sendMessage() { ns1__sendMessage::soap_default(NULL); }
	virtual ~ns1__sendMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sendMessageResponse
#define SOAP_TYPE_ns1__sendMessageResponse (16)
/* ns1:sendMessageResponse */
class SOAP_CMAC ns1__sendMessageResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique type id SOAP_TYPE_ns1__sendMessageResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sendMessageResponse() { ns1__sendMessageResponse::soap_default(NULL); }
	virtual ~ns1__sendMessageResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__bgAirHC
#define SOAP_TYPE_ns1__bgAirHC (17)
/* ns1:bgAirHC */
class SOAP_CMAC ns1__bgAirHC
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	double bgCO;	/* required element of type xsd:double */
	double bgNO;	/* required element of type xsd:double */
	double bgHC;	/* required element of type xsd:double */
	double canliuHC;	/* required element of type xsd:double */
	std::wstring *lFlowResult;	/* optional element of type xsd:string */
	double o2Avg;	/* required element of type xsd:double */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique type id SOAP_TYPE_ns1__bgAirHC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__bgAirHC() { ns1__bgAirHC::soap_default(NULL); }
	virtual ~ns1__bgAirHC() { }
};
#endif

#ifndef SOAP_TYPE_ns1__bgAirHCResponse
#define SOAP_TYPE_ns1__bgAirHCResponse (18)
/* ns1:bgAirHCResponse */
class SOAP_CMAC ns1__bgAirHCResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique type id SOAP_TYPE_ns1__bgAirHCResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__bgAirHCResponse() { ns1__bgAirHCResponse::soap_default(NULL); }
	virtual ~ns1__bgAirHCResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__doubleIdleData_USCOREFC
#define SOAP_TYPE_ns1__doubleIdleData_USCOREFC (19)
/* ns1:doubleIdleData_FC */
class SOAP_CMAC ns1__doubleIdleData_USCOREFC
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	double lrotateSpeed;	/* required element of type xsd:double */
	double hrotateSpeed;	/* required element of type xsd:double */
	double coLowValue;	/* required element of type xsd:double */
	double hcLowValue;	/* required element of type xsd:double */
	double coHighValue;	/* required element of type xsd:double */
	double hcHighValue;	/* required element of type xsd:double */
	double lambdaValue;	/* required element of type xsd:double */
	double tempreture;	/* required element of type xsd:double */
	double humidity;	/* required element of type xsd:double */
	double airPressure;	/* required element of type xsd:double */
	std::wstring *timeStart;	/* optional element of type xsd:string */
	std::wstring *timeEnd;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique type id SOAP_TYPE_ns1__doubleIdleData_USCOREFC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__doubleIdleData_USCOREFC() { ns1__doubleIdleData_USCOREFC::soap_default(NULL); }
	virtual ~ns1__doubleIdleData_USCOREFC() { }
};
#endif

#ifndef SOAP_TYPE_ns1__doubleIdleDataResponse
#define SOAP_TYPE_ns1__doubleIdleDataResponse (20)
/* ns1:doubleIdleDataResponse */
class SOAP_CMAC ns1__doubleIdleDataResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique type id SOAP_TYPE_ns1__doubleIdleDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__doubleIdleDataResponse() { ns1__doubleIdleDataResponse::soap_default(NULL); }
	virtual ~ns1__doubleIdleDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjLASelfcheck
#define SOAP_TYPE_ns1__cgjLASelfcheck (21)
/* ns1:cgjLASelfcheck */
class SOAP_CMAC ns1__cgjLASelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	double AvitualTime;	/* required element of type xsd:double */
	double ArealTime;	/* required element of type xsd:double */
	double BvitualTime;	/* required element of type xsd:double */
	double BrealTime;	/* required element of type xsd:double */
	double CvitualTime;	/* required element of type xsd:double */
	double CrealTime;	/* required element of type xsd:double */
	double DvitualTime;	/* required element of type xsd:double */
	double DrealTime;	/* required element of type xsd:double */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique type id SOAP_TYPE_ns1__cgjLASelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjLASelfcheck() { ns1__cgjLASelfcheck::soap_default(NULL); }
	virtual ~ns1__cgjLASelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjLASelfcheckResponse
#define SOAP_TYPE_ns1__cgjLASelfcheckResponse (22)
/* ns1:cgjLASelfcheckResponse */
class SOAP_CMAC ns1__cgjLASelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique type id SOAP_TYPE_ns1__cgjLASelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjLASelfcheckResponse() { ns1__cgjLASelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__cgjLASelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjSelfcheck
#define SOAP_TYPE_ns1__cgjSelfcheck (23)
/* ns1:cgjSelfcheck */
class SOAP_CMAC ns1__cgjSelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	double HVitualTime;	/* required element of type xsd:double */
	double HrealTime;	/* required element of type xsd:double */
	double LvitualTime;	/* required element of type xsd:double */
	double LrealTime;	/* required element of type xsd:double */
	double Hpower;	/* required element of type xsd:double */
	double Lpower;	/* required element of type xsd:double */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique type id SOAP_TYPE_ns1__cgjSelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjSelfcheck() { ns1__cgjSelfcheck::soap_default(NULL); }
	virtual ~ns1__cgjSelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjSelfcheckResponse
#define SOAP_TYPE_ns1__cgjSelfcheckResponse (24)
/* ns1:cgjSelfcheckResponse */
class SOAP_CMAC ns1__cgjSelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique type id SOAP_TYPE_ns1__cgjSelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjSelfcheckResponse() { ns1__cgjSelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__cgjSelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__obdResult
#define SOAP_TYPE_ns1__obdResult (25)
/* ns1:obdResult */
class SOAP_CMAC ns1__obdResult
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *result;	/* optional element of type xsd:string */
	std::wstring *checktime;	/* optional element of type xsd:string */
	std::wstring *obdgzzsq;	/* optional element of type xsd:string */
	std::wstring *objgztx;	/* optional element of type xsd:string */
	std::wstring *objgztxyy;	/* optional element of type xsd:string */
	std::wstring *objgzzsdsfbj;	/* optional element of type xsd:string */
	std::wstring *gzdm;	/* optional element of type xsd:string */
	std::wstring *gzxx;	/* optional element of type xsd:string */
	std::wstring *jxztsfwc;	/* optional element of type xsd:string */
	std::wstring *jxztwwcyy;	/* optional element of type xsd:string */
	std::wstring *qtxsgl;	/* optional element of type xsd:string */
	std::wstring *calidfdjkzdy;	/* optional element of type xsd:string */
	std::wstring *calidhclkddy;	/* optional element of type xsd:string */
	std::wstring *calidqtkzdy;	/* optional element of type xsd:string */
	std::wstring *cvnfdjkzdy;	/* optional element of type xsd:string */
	std::wstring *cvnhclkddy;	/* optional element of type xsd:string */
	std::wstring *cvnqtkzdy;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique type id SOAP_TYPE_ns1__obdResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__obdResult() { ns1__obdResult::soap_default(NULL); }
	virtual ~ns1__obdResult() { }
};
#endif

#ifndef SOAP_TYPE_ns1__obdResultResponse
#define SOAP_TYPE_ns1__obdResultResponse (26)
/* ns1:obdResultResponse */
class SOAP_CMAC ns1__obdResultResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique type id SOAP_TYPE_ns1__obdResultResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__obdResultResponse() { ns1__obdResultResponse::soap_default(NULL); }
	virtual ~ns1__obdResultResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__doubleIdleLog_USCOREFC
#define SOAP_TYPE_ns1__doubleIdleLog_USCOREFC (27)
/* ns1:doubleIdleLog_FC */
class SOAP_CMAC ns1__doubleIdleLog_USCOREFC
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	int inspectNum;	/* required element of type xsd:int */
	double flowHC;	/* required element of type xsd:double */
	double flowCO;	/* required element of type xsd:double */
	double flowCO2;	/* required element of type xsd:double */
	double analyserO2;	/* required element of type xsd:double */
	double oilTemperature;	/* required element of type xsd:double */
	std::wstring *rotateSpeed;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique type id SOAP_TYPE_ns1__doubleIdleLog_USCOREFC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__doubleIdleLog_USCOREFC() { ns1__doubleIdleLog_USCOREFC::soap_default(NULL); }
	virtual ~ns1__doubleIdleLog_USCOREFC() { }
};
#endif

#ifndef SOAP_TYPE_ns1__doubleIdleLogResponse
#define SOAP_TYPE_ns1__doubleIdleLogResponse (28)
/* ns1:doubleIdleLogResponse */
class SOAP_CMAC ns1__doubleIdleLogResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique type id SOAP_TYPE_ns1__doubleIdleLogResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__doubleIdleLogResponse() { ns1__doubleIdleLogResponse::soap_default(NULL); }
	virtual ~ns1__doubleIdleLogResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__vmasLog
#define SOAP_TYPE_ns1__vmasLog (29)
/* ns1:vmasLog */
class SOAP_CMAC ns1__vmasLog
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	int inspectNum;	/* required element of type xsd:int */
	double flowHC;	/* required element of type xsd:double */
	double flowCO;	/* required element of type xsd:double */
	double flowCO2;	/* required element of type xsd:double */
	double flowNO;	/* required element of type xsd:double */
	double analyserO2;	/* required element of type xsd:double */
	double flowmeterO2;	/* required element of type xsd:double */
	double envO2;	/* required element of type xsd:double */
	double actFlow;	/* required element of type xsd:double */
	double stdFlow;	/* required element of type xsd:double */
	double tailFlow;	/* required element of type xsd:double */
	double weightHC;	/* required element of type xsd:double */
	double weightCO;	/* required element of type xsd:double */
	double weightNO;	/* required element of type xsd:double */
	double lineSpeed;	/* required element of type xsd:double */
	double totalPower;	/* required element of type xsd:double */
	double parasPower;	/* required element of type xsd:double */
	double indicPower;	/* required element of type xsd:double */
	double flowAirPressure;	/* required element of type xsd:double */
	double flowTemperature;	/* required element of type xsd:double */
	double envirTemperature;	/* required element of type xsd:double */
	double envirAirPressure;	/* required element of type xsd:double */
	double envirHumidity;	/* required element of type xsd:double */
	double diluteCorrect;	/* required element of type xsd:double */
	double humidityCorrect;	/* required element of type xsd:double */
	double diluteRatio;	/* required element of type xsd:double */
	double lambdaValue;	/* required element of type xsd:double */
	double qtfxyjcswd;	/* required element of type xsd:double */
	double zhlwd;	/* required element of type xsd:double */
	double weightNO1;	/* required element of type xsd:double */
	double weightNO2;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique type id SOAP_TYPE_ns1__vmasLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__vmasLog() { ns1__vmasLog::soap_default(NULL); }
	virtual ~ns1__vmasLog() { }
};
#endif

#ifndef SOAP_TYPE_ns1__vmasLogResponse
#define SOAP_TYPE_ns1__vmasLogResponse (30)
/* ns1:vmasLogResponse */
class SOAP_CMAC ns1__vmasLogResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE_ns1__vmasLogResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__vmasLogResponse() { ns1__vmasLogResponse::soap_default(NULL); }
	virtual ~ns1__vmasLogResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ydjSelfcheck
#define SOAP_TYPE_ns1__ydjSelfcheck (31)
/* ns1:ydjSelfcheck */
class SOAP_CMAC ns1__ydjSelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *zeroResult;	/* optional element of type xsd:string */
	double labelValueN30;	/* required element of type xsd:double */
	double labelValueN50;	/* required element of type xsd:double */
	double N30;	/* required element of type xsd:double */
	double N50;	/* required element of type xsd:double */
	double error30;	/* required element of type xsd:double */
	double error50;	/* required element of type xsd:double */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique type id SOAP_TYPE_ns1__ydjSelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ydjSelfcheck() { ns1__ydjSelfcheck::soap_default(NULL); }
	virtual ~ns1__ydjSelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ydjSelfcheckResponse
#define SOAP_TYPE_ns1__ydjSelfcheckResponse (32)
/* ns1:ydjSelfcheckResponse */
class SOAP_CMAC ns1__ydjSelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique type id SOAP_TYPE_ns1__ydjSelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ydjSelfcheckResponse() { ns1__ydjSelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__ydjSelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__dyhwSelfcheck
#define SOAP_TYPE_ns1__dyhwSelfcheck (33)
/* ns1:dyhwSelfcheck */
class SOAP_CMAC ns1__dyhwSelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique type id SOAP_TYPE_ns1__dyhwSelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__dyhwSelfcheck() { ns1__dyhwSelfcheck::soap_default(NULL); }
	virtual ~ns1__dyhwSelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__dyhwSelfcheckResponse
#define SOAP_TYPE_ns1__dyhwSelfcheckResponse (34)
/* ns1:dyhwSelfcheckResponse */
class SOAP_CMAC ns1__dyhwSelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique type id SOAP_TYPE_ns1__dyhwSelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__dyhwSelfcheckResponse() { ns1__dyhwSelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__dyhwSelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__loadDownLog
#define SOAP_TYPE_ns1__loadDownLog (35)
/* ns1:loadDownLog */
class SOAP_CMAC ns1__loadDownLog
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	int inspectNum;	/* required element of type xsd:int */
	double calVelMaxHp;	/* required element of type xsd:double */
	double actVelMaxHp;	/* required element of type xsd:double */
	double powerPerSec;	/* required element of type xsd:double */
	double speedPerSec;	/* required element of type xsd:double */
	double actMaxPower;	/* required element of type xsd:double */
	double rotateSpeed;	/* required element of type xsd:double */
	double envirTemperature;	/* required element of type xsd:double */
	double envirAirPressure;	/* required element of type xsd:double */
	double envirHumidity;	/* required element of type xsd:double */
	double powerCorrect;	/* required element of type xsd:double */
	double corMaxPower;	/* required element of type xsd:double */
	double smokeK100;	/* required element of type xsd:double */
	double smokeK90;	/* required element of type xsd:double */
	double smokeK80;	/* required element of type xsd:double */
	double speedK100;	/* required element of type xsd:double */
	double speedK90;	/* required element of type xsd:double */
	double speedK80;	/* required element of type xsd:double */
	double NO80;	/* required element of type xsd:double */
	double NO280;	/* required element of type xsd:double */
	double CO280;	/* required element of type xsd:double */
	double NOX80;	/* required element of type xsd:double */
	double ydjjcswd;	/* required element of type xsd:double */
	double qtfxyjcswd;	/* required element of type xsd:double */
	double zhlwd;	/* required element of type xsd:double */
	double ydjjcsqy;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique type id SOAP_TYPE_ns1__loadDownLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__loadDownLog() { ns1__loadDownLog::soap_default(NULL); }
	virtual ~ns1__loadDownLog() { }
};
#endif

#ifndef SOAP_TYPE_ns1__loadDownLogResponse
#define SOAP_TYPE_ns1__loadDownLogResponse (36)
/* ns1:loadDownLogResponse */
class SOAP_CMAC ns1__loadDownLogResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique type id SOAP_TYPE_ns1__loadDownLogResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__loadDownLogResponse() { ns1__loadDownLogResponse::soap_default(NULL); }
	virtual ~ns1__loadDownLogResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__dyhwAdjust
#define SOAP_TYPE_ns1__dyhwAdjust (37)
/* ns1:dyhwAdjust */
class SOAP_CMAC ns1__dyhwAdjust
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *gasType;	/* optional element of type xsd:string */
	double labelValueNO;	/* required element of type xsd:double */
	double detectValueNO;	/* required element of type xsd:double */
	double labelValueNO2;	/* required element of type xsd:double */
	double detectValueNO2;	/* required element of type xsd:double */
	std::wstring *adjustResult;	/* optional element of type xsd:string */
	std::wstring *adjustTimeStart;	/* optional element of type xsd:string */
	std::wstring *adjustTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique type id SOAP_TYPE_ns1__dyhwAdjust */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__dyhwAdjust() { ns1__dyhwAdjust::soap_default(NULL); }
	virtual ~ns1__dyhwAdjust() { }
};
#endif

#ifndef SOAP_TYPE_ns1__dyhwAdjustResponse
#define SOAP_TYPE_ns1__dyhwAdjustResponse (38)
/* ns1:dyhwAdjustResponse */
class SOAP_CMAC ns1__dyhwAdjustResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique type id SOAP_TYPE_ns1__dyhwAdjustResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__dyhwAdjustResponse() { ns1__dyhwAdjustResponse::soap_default(NULL); }
	virtual ~ns1__dyhwAdjustResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__obdResultLog
#define SOAP_TYPE_ns1__obdResultLog (39)
/* ns1:obdResultLog */
class SOAP_CMAC ns1__obdResultLog
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *calidfdjkzdy;	/* optional element of type xsd:string */
	std::wstring *calidhclkddy;	/* optional element of type xsd:string */
	std::wstring *calidqtkzdy;	/* optional element of type xsd:string */
	std::wstring *cvnfdjkzdy;	/* optional element of type xsd:string */
	std::wstring *cvnhclkddy;	/* optional element of type xsd:string */
	std::wstring *cvnqtkzdy;	/* optional element of type xsd:string */
	double jqmjdkd;	/* required element of type xsd:double */
	double fhz;	/* required element of type xsd:double */
	double lambdaValue;	/* required element of type xsd:double */
	double ymkd;	/* required element of type xsd:double */
	double fdjscgl;	/* required element of type xsd:double */
	double zyyl;	/* required element of type xsd:double */
	double hyl;	/* required element of type xsd:double */
	double noxcgqnd;	/* required element of type xsd:double */
	double Nspsl;	/* required element of type xsd:double */
	double pqwd;	/* required element of type xsd:double */
	double Klpjqyc;	/* required element of type xsd:double */
	double Egrkd;	/* required element of type xsd:double */
	double rypsyl;	/* required element of type xsd:double */
	double cs;	/* required element of type xsd:double */
	double zs;	/* required element of type xsd:double */
	double jqyl;	/* required element of type xsd:double */
	std::wstring *fuelType;	/* optional element of type xsd:string */
	std::wstring *checkTime;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique type id SOAP_TYPE_ns1__obdResultLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__obdResultLog() { ns1__obdResultLog::soap_default(NULL); }
	virtual ~ns1__obdResultLog() { }
};
#endif

#ifndef SOAP_TYPE_ns1__obdResultLogResponse
#define SOAP_TYPE_ns1__obdResultLogResponse (40)
/* ns1:obdResultLogResponse */
class SOAP_CMAC ns1__obdResultLogResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique type id SOAP_TYPE_ns1__obdResultLogResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__obdResultLogResponse() { ns1__obdResultLogResponse::soap_default(NULL); }
	virtual ~ns1__obdResultLogResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getCarInfo_USCOREFC
#define SOAP_TYPE_ns1__getCarInfo_USCOREFC (41)
/* ns1:getCarInfo_FC */
class SOAP_CMAC ns1__getCarInfo_USCOREFC
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique type id SOAP_TYPE_ns1__getCarInfo_USCOREFC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getCarInfo_USCOREFC() { ns1__getCarInfo_USCOREFC::soap_default(NULL); }
	virtual ~ns1__getCarInfo_USCOREFC() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cycdyhwAdjust
#define SOAP_TYPE_ns1__cycdyhwAdjust (42)
/* ns1:cycdyhwAdjust */
class SOAP_CMAC ns1__cycdyhwAdjust
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *gasType;	/* optional element of type xsd:string */
	double labelValueNO;	/* required element of type xsd:double */
	double detectValueNO;	/* required element of type xsd:double */
	double labelValueNO2;	/* required element of type xsd:double */
	double detectValueNO2;	/* required element of type xsd:double */
	double labelValueCO2;	/* required element of type xsd:double */
	double detectValueCO2;	/* required element of type xsd:double */
	std::wstring *adjustResult;	/* optional element of type xsd:string */
	std::wstring *adjustTimeStart;	/* optional element of type xsd:string */
	std::wstring *adjustTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique type id SOAP_TYPE_ns1__cycdyhwAdjust */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cycdyhwAdjust() { ns1__cycdyhwAdjust::soap_default(NULL); }
	virtual ~ns1__cycdyhwAdjust() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cycdyhwAdjustResponse
#define SOAP_TYPE_ns1__cycdyhwAdjustResponse (43)
/* ns1:cycdyhwAdjustResponse */
class SOAP_CMAC ns1__cycdyhwAdjustResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique type id SOAP_TYPE_ns1__cycdyhwAdjustResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cycdyhwAdjustResponse() { ns1__cycdyhwAdjustResponse::soap_default(NULL); }
	virtual ~ns1__cycdyhwAdjustResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__hjcsgyqSelfcheck
#define SOAP_TYPE_ns1__hjcsgyqSelfcheck (44)
/* ns1:hjcsgyqSelfcheck */
class SOAP_CMAC ns1__hjcsgyqSelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	double actualTemperature;	/* required element of type xsd:double */
	double temperature;	/* required element of type xsd:double */
	double actualHumidity;	/* required element of type xsd:double */
	double humidity;	/* required element of type xsd:double */
	double actualAirPressure;	/* required element of type xsd:double */
	double airPressure;	/* required element of type xsd:double */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique type id SOAP_TYPE_ns1__hjcsgyqSelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__hjcsgyqSelfcheck() { ns1__hjcsgyqSelfcheck::soap_default(NULL); }
	virtual ~ns1__hjcsgyqSelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse
#define SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse (45)
/* ns1:hjcsgyqSelfcheckResponse */
class SOAP_CMAC ns1__hjcsgyqSelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_ns1__hjcsgyqSelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__hjcsgyqSelfcheckResponse() { ns1__hjcsgyqSelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__hjcsgyqSelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__pqfxySelfcheck
#define SOAP_TYPE_ns1__pqfxySelfcheck (46)
/* ns1:pqfxySelfcheck */
class SOAP_CMAC ns1__pqfxySelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	double noxRTime1;	/* required element of type xsd:double */
	std::wstring *noxRTime1Start;	/* optional element of type xsd:string */
	std::wstring *noxRTime1End;	/* optional element of type xsd:string */
	double noxRTime2;	/* required element of type xsd:double */
	std::wstring *noxRTime2Start;	/* optional element of type xsd:string */
	std::wstring *noxRTime2End;	/* optional element of type xsd:string */
	double co2RTime1;	/* required element of type xsd:double */
	std::wstring *co2RTime1Start;	/* optional element of type xsd:string */
	std::wstring *co2RTime1End;	/* optional element of type xsd:string */
	double co2RTime2;	/* required element of type xsd:double */
	std::wstring *co2RTime2Start;	/* optional element of type xsd:string */
	std::wstring *co2RTime2End;	/* optional element of type xsd:string */
	double CEconverte;	/* required element of type xsd:double */
	std::wstring *CETimeStart;	/* optional element of type xsd:string */
	std::wstring *CETimeEnd;	/* optional element of type xsd:string */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique type id SOAP_TYPE_ns1__pqfxySelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__pqfxySelfcheck() { ns1__pqfxySelfcheck::soap_default(NULL); }
	virtual ~ns1__pqfxySelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__pqfxySelfcheckResponse
#define SOAP_TYPE_ns1__pqfxySelfcheckResponse (47)
/* ns1:pqfxySelfcheckResponse */
class SOAP_CMAC ns1__pqfxySelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique type id SOAP_TYPE_ns1__pqfxySelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__pqfxySelfcheckResponse() { ns1__pqfxySelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__pqfxySelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC
#define SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC (48)
/* ns1:lightproofSmokeDataLog_FC */
class SOAP_CMAC ns1__lightproofSmokeDataLog_USCOREFC
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *cytimestart;	/* optional element of type xsd:string */
	double labelvalue;	/* required element of type xsd:double */
	double zs;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique type id SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lightproofSmokeDataLog_USCOREFC() { ns1__lightproofSmokeDataLog_USCOREFC::soap_default(NULL); }
	virtual ~ns1__lightproofSmokeDataLog_USCOREFC() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse
#define SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse (49)
/* ns1:lightproofSmokeDataLog_FCResponse */
class SOAP_CMAC ns1__lightproofSmokeDataLog_USCOREFCResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique type id SOAP_TYPE_ns1__lightproofSmokeDataLog_USCOREFCResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lightproofSmokeDataLog_USCOREFCResponse() { ns1__lightproofSmokeDataLog_USCOREFCResponse::soap_default(NULL); }
	virtual ~ns1__lightproofSmokeDataLog_USCOREFCResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__loadDownData
#define SOAP_TYPE_ns1__loadDownData (50)
/* ns1:loadDownData */
class SOAP_CMAC ns1__loadDownData
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	double smokeK100;	/* required element of type xsd:double */
	double smokeK90;	/* required element of type xsd:double */
	double smokeK80;	/* required element of type xsd:double */
	double power;	/* required element of type xsd:double */
	double speed;	/* required element of type xsd:double */
	double mortorSpeed;	/* required element of type xsd:double */
	double idleRotateSpeed;	/* required element of type xsd:double */
	double valueNO;	/* required element of type xsd:double */
	double tempreture;	/* required element of type xsd:double */
	double humidity;	/* required element of type xsd:double */
	double airPressure;	/* required element of type xsd:double */
	std::wstring *timeStart;	/* optional element of type xsd:string */
	std::wstring *timeEnd;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique type id SOAP_TYPE_ns1__loadDownData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__loadDownData() { ns1__loadDownData::soap_default(NULL); }
	virtual ~ns1__loadDownData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__loadDownDataResponse
#define SOAP_TYPE_ns1__loadDownDataResponse (51)
/* ns1:loadDownDataResponse */
class SOAP_CMAC ns1__loadDownDataResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique type id SOAP_TYPE_ns1__loadDownDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__loadDownDataResponse() { ns1__loadDownDataResponse::soap_default(NULL); }
	virtual ~ns1__loadDownDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__vmasData
#define SOAP_TYPE_ns1__vmasData (52)
/* ns1:vmasData */
class SOAP_CMAC ns1__vmasData
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	double valueCO;	/* required element of type xsd:double */
	double valueHC;	/* required element of type xsd:double */
	double valueNO;	/* required element of type xsd:double */
	double testSetPower;	/* required element of type xsd:double */
	double totalDistance;	/* required element of type xsd:double */
	double tempreture;	/* required element of type xsd:double */
	double humidity;	/* required element of type xsd:double */
	double airPressure;	/* required element of type xsd:double */
	std::wstring *timeStart;	/* optional element of type xsd:string */
	std::wstring *timeEnd;	/* optional element of type xsd:string */
	double lambdaValue;	/* required element of type xsd:double */
	double valueNO1;	/* required element of type xsd:double */
	double valueNO2;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique type id SOAP_TYPE_ns1__vmasData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__vmasData() { ns1__vmasData::soap_default(NULL); }
	virtual ~ns1__vmasData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__vmasDataResponse
#define SOAP_TYPE_ns1__vmasDataResponse (53)
/* ns1:vmasDataResponse */
class SOAP_CMAC ns1__vmasDataResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique type id SOAP_TYPE_ns1__vmasDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__vmasDataResponse() { ns1__vmasDataResponse::soap_default(NULL); }
	virtual ~ns1__vmasDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__motoDbIdleData
#define SOAP_TYPE_ns1__motoDbIdleData (54)
/* ns1:motoDbIdleData */
class SOAP_CMAC ns1__motoDbIdleData
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	double hHC;	/* required element of type xsd:double */
	double hCO;	/* required element of type xsd:double */
	double hCO2;	/* required element of type xsd:double */
	double hIdleSpeed;	/* required element of type xsd:double */
	double HC;	/* required element of type xsd:double */
	double CO;	/* required element of type xsd:double */
	double CO2;	/* required element of type xsd:double */
	double idleSpeed;	/* required element of type xsd:double */
	double tempreture;	/* required element of type xsd:double */
	double humidity;	/* required element of type xsd:double */
	double airPressure;	/* required element of type xsd:double */
	std::wstring *timeStart;	/* optional element of type xsd:string */
	std::wstring *timeEnd;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique type id SOAP_TYPE_ns1__motoDbIdleData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__motoDbIdleData() { ns1__motoDbIdleData::soap_default(NULL); }
	virtual ~ns1__motoDbIdleData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__motoDbIdleDataResponse
#define SOAP_TYPE_ns1__motoDbIdleDataResponse (55)
/* ns1:motoDbIdleDataResponse */
class SOAP_CMAC ns1__motoDbIdleDataResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique type id SOAP_TYPE_ns1__motoDbIdleDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__motoDbIdleDataResponse() { ns1__motoDbIdleDataResponse::soap_default(NULL); }
	virtual ~ns1__motoDbIdleDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getSatate
#define SOAP_TYPE_ns1__getSatate (56)
/* ns1:getSatate */
class SOAP_CMAC ns1__getSatate
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique type id SOAP_TYPE_ns1__getSatate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getSatate() { ns1__getSatate::soap_default(NULL); }
	virtual ~ns1__getSatate() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getSatateResponse
#define SOAP_TYPE_ns1__getSatateResponse (57)
/* ns1:getSatateResponse */
class SOAP_CMAC ns1__getSatateResponse
{
public:
	class ns1__stateInfo *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:stateInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique type id SOAP_TYPE_ns1__getSatateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getSatateResponse() { ns1__getSatateResponse::soap_default(NULL); }
	virtual ~ns1__getSatateResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__stateInfo
#define SOAP_TYPE_ns1__stateInfo (58)
/* ns1:stateInfo */
class SOAP_CMAC ns1__stateInfo
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *methodId;	/* optional element of type xsd:string */
	std::wstring *state;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique type id SOAP_TYPE_ns1__stateInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__stateInfo() { ns1__stateInfo::soap_default(NULL); }
	virtual ~ns1__stateInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__doubleIdleData
#define SOAP_TYPE_ns1__doubleIdleData (59)
/* ns1:doubleIdleData */
class SOAP_CMAC ns1__doubleIdleData
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	double lrotateSpeed;	/* required element of type xsd:double */
	double hrotateSpeed;	/* required element of type xsd:double */
	double coLowValue;	/* required element of type xsd:double */
	double hcLowValue;	/* required element of type xsd:double */
	double coHighValue;	/* required element of type xsd:double */
	double hcHighValue;	/* required element of type xsd:double */
	double lambdaValue;	/* required element of type xsd:double */
	double tempreture;	/* required element of type xsd:double */
	double humidity;	/* required element of type xsd:double */
	double airPressure;	/* required element of type xsd:double */
	std::wstring *timeStart;	/* optional element of type xsd:string */
	std::wstring *timeEnd;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique type id SOAP_TYPE_ns1__doubleIdleData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__doubleIdleData() { ns1__doubleIdleData::soap_default(NULL); }
	virtual ~ns1__doubleIdleData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__doubleIdleLog
#define SOAP_TYPE_ns1__doubleIdleLog (60)
/* ns1:doubleIdleLog */
class SOAP_CMAC ns1__doubleIdleLog
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	int inspectNum;	/* required element of type xsd:int */
	double flowHC;	/* required element of type xsd:double */
	double flowCO;	/* required element of type xsd:double */
	double flowCO2;	/* required element of type xsd:double */
	double analyserO2;	/* required element of type xsd:double */
	double oilTemperature;	/* required element of type xsd:double */
	std::wstring *rotateSpeed;	/* optional element of type xsd:string */
	double lambdaValue;	/* required element of type xsd:double */
	double qtfxyjcswd;	/* required element of type xsd:double */
	double zhlwd;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique type id SOAP_TYPE_ns1__doubleIdleLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__doubleIdleLog() { ns1__doubleIdleLog::soap_default(NULL); }
	virtual ~ns1__doubleIdleLog() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjPLHPSelfcheck
#define SOAP_TYPE_ns1__cgjPLHPSelfcheck (61)
/* ns1:cgjPLHPSelfcheck */
class SOAP_CMAC ns1__cgjPLHPSelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *speedQJ1;	/* optional element of type xsd:string */
	double nameSpeed1;	/* required element of type xsd:double */
	double PLHP1;	/* required element of type xsd:double */
	std::wstring *speedQJ2;	/* optional element of type xsd:string */
	double nameSpeed2;	/* required element of type xsd:double */
	double PLHP2;	/* required element of type xsd:double */
	std::wstring *speedQJ3;	/* optional element of type xsd:string */
	double nameSpeed3;	/* required element of type xsd:double */
	double PLHP3;	/* required element of type xsd:double */
	std::wstring *speedQJ4;	/* optional element of type xsd:string */
	double nameSpeed4;	/* required element of type xsd:double */
	double PLHP4;	/* required element of type xsd:double */
	double maxSpeed;	/* required element of type xsd:double */
	double ALpower1;	/* required element of type xsd:double */
	double ALpower2;	/* required element of type xsd:double */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique type id SOAP_TYPE_ns1__cgjPLHPSelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjPLHPSelfcheck() { ns1__cgjPLHPSelfcheck::soap_default(NULL); }
	virtual ~ns1__cgjPLHPSelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse
#define SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse (62)
/* ns1:cgjPLHPSelfcheckResponse */
class SOAP_CMAC ns1__cgjPLHPSelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique type id SOAP_TYPE_ns1__cgjPLHPSelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjPLHPSelfcheckResponse() { ns1__cgjPLHPSelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__cgjPLHPSelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wqfxyAdjust
#define SOAP_TYPE_ns1__wqfxyAdjust (63)
/* ns1:wqfxyAdjust */
class SOAP_CMAC ns1__wqfxyAdjust
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *gasType;	/* optional element of type xsd:string */
	double labelValueCO2;	/* required element of type xsd:double */
	double detectValueCO2;	/* required element of type xsd:double */
	double labelValueCO;	/* required element of type xsd:double */
	double detectValueCO;	/* required element of type xsd:double */
	double labelValueNO;	/* required element of type xsd:double */
	double detectValueNO;	/* required element of type xsd:double */
	double labelValueNO2;	/* required element of type xsd:double */
	double detectValueNO2;	/* required element of type xsd:double */
	double labelValueHC;	/* required element of type xsd:double */
	double detectValueHC;	/* required element of type xsd:double */
	double labelValueO2;	/* required element of type xsd:double */
	double detectValueO2;	/* required element of type xsd:double */
	double labelValuePEF;	/* required element of type xsd:double */
	double labelValueC3H8;	/* required element of type xsd:double */
	std::wstring *adjustResult;	/* optional element of type xsd:string */
	std::wstring *adjustTimeStart;	/* optional element of type xsd:string */
	std::wstring *adjustTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique type id SOAP_TYPE_ns1__wqfxyAdjust */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wqfxyAdjust() { ns1__wqfxyAdjust::soap_default(NULL); }
	virtual ~ns1__wqfxyAdjust() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wqfxyAdjustResponse
#define SOAP_TYPE_ns1__wqfxyAdjustResponse (64)
/* ns1:wqfxyAdjustResponse */
class SOAP_CMAC ns1__wqfxyAdjustResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique type id SOAP_TYPE_ns1__wqfxyAdjustResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wqfxyAdjustResponse() { ns1__wqfxyAdjustResponse::soap_default(NULL); }
	virtual ~ns1__wqfxyAdjustResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC
#define SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC (65)
/* ns1:lightproofSmokeData_FC */
class SOAP_CMAC ns1__lightproofSmokeData_USCOREFC
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	double smokeValue1;	/* required element of type xsd:double */
	double smokeValue2;	/* required element of type xsd:double */
	double smokeValue3;	/* required element of type xsd:double */
	double tempreture;	/* required element of type xsd:double */
	double humidity;	/* required element of type xsd:double */
	double airPressure;	/* required element of type xsd:double */
	std::wstring *timeStart;	/* optional element of type xsd:string */
	std::wstring *timeEnd;	/* optional element of type xsd:string */
	int zs1;	/* required element of type xsd:int */
	int zs2;	/* required element of type xsd:int */
	int zs3;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique type id SOAP_TYPE_ns1__lightproofSmokeData_USCOREFC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lightproofSmokeData_USCOREFC() { ns1__lightproofSmokeData_USCOREFC::soap_default(NULL); }
	virtual ~ns1__lightproofSmokeData_USCOREFC() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lightproofSmokeDataResponse
#define SOAP_TYPE_ns1__lightproofSmokeDataResponse (66)
/* ns1:lightproofSmokeDataResponse */
class SOAP_CMAC ns1__lightproofSmokeDataResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique type id SOAP_TYPE_ns1__lightproofSmokeDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lightproofSmokeDataResponse() { ns1__lightproofSmokeDataResponse::soap_default(NULL); }
	virtual ~ns1__lightproofSmokeDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lightproofSmokeData
#define SOAP_TYPE_ns1__lightproofSmokeData (67)
/* ns1:lightproofSmokeData */
class SOAP_CMAC ns1__lightproofSmokeData
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	double smokeValue1;	/* required element of type xsd:double */
	double smokeValue2;	/* required element of type xsd:double */
	double smokeValue3;	/* required element of type xsd:double */
	double tempreture;	/* required element of type xsd:double */
	double humidity;	/* required element of type xsd:double */
	double airPressure;	/* required element of type xsd:double */
	std::wstring *timeStart;	/* optional element of type xsd:string */
	std::wstring *timeEnd;	/* optional element of type xsd:string */
	int zs1;	/* required element of type xsd:int */
	int zs2;	/* required element of type xsd:int */
	int zs3;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique type id SOAP_TYPE_ns1__lightproofSmokeData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lightproofSmokeData() { ns1__lightproofSmokeData::soap_default(NULL); }
	virtual ~ns1__lightproofSmokeData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__qyfxSelfcheck
#define SOAP_TYPE_ns1__qyfxSelfcheck (68)
/* ns1:qyfxSelfcheck */
class SOAP_CMAC ns1__qyfxSelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *carryTimeStart;	/* optional element of type xsd:string */
	std::wstring *carryTimeEnd;	/* optional element of type xsd:string */
	double carryTimenumber;	/* required element of type xsd:double */
	std::wstring *respondTimeStartHC_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndHC_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartCO_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndCO_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartCO2_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndCO2_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartNO_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndNO_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartNO2_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndNO2_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartO2_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndO2_USCORE1;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartHC_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndHC_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartCO_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndCO_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartCO2_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndCO2_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartNO_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndNO_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartNO2_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndNO2_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeStartO2_USCORE2;	/* optional element of type xsd:string */
	std::wstring *respondTimeEndO2_USCORE2;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique type id SOAP_TYPE_ns1__qyfxSelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__qyfxSelfcheck() { ns1__qyfxSelfcheck::soap_default(NULL); }
	virtual ~ns1__qyfxSelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__qyfxSelfcheckResponse
#define SOAP_TYPE_ns1__qyfxSelfcheckResponse (69)
/* ns1:qyfxSelfcheckResponse */
class SOAP_CMAC ns1__qyfxSelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique type id SOAP_TYPE_ns1__qyfxSelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__qyfxSelfcheckResponse() { ns1__qyfxSelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__qyfxSelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sdsqtfxySelfcheck
#define SOAP_TYPE_ns1__sdsqtfxySelfcheck (70)
/* ns1:sdsqtfxySelfcheck */
class SOAP_CMAC ns1__sdsqtfxySelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *tightnessResult;	/* optional element of type xsd:string */
	std::wstring *lFlowResult;	/* optional element of type xsd:string */
	double canliuHC;	/* required element of type xsd:double */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique type id SOAP_TYPE_ns1__sdsqtfxySelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sdsqtfxySelfcheck() { ns1__sdsqtfxySelfcheck::soap_default(NULL); }
	virtual ~ns1__sdsqtfxySelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse
#define SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse (71)
/* ns1:sdsqtfxySelfcheckResponse */
class SOAP_CMAC ns1__sdsqtfxySelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique type id SOAP_TYPE_ns1__sdsqtfxySelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sdsqtfxySelfcheckResponse() { ns1__sdsqtfxySelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__sdsqtfxySelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sendMessage_USCOREFC
#define SOAP_TYPE_ns1__sendMessage_USCOREFC (72)
/* ns1:sendMessage_FC */
class SOAP_CMAC ns1__sendMessage_USCOREFC
{
public:
	std::wstring *businessId;	/* optional element of type xsd:string */
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *code;	/* optional element of type xsd:string */
	std::wstring *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique type id SOAP_TYPE_ns1__sendMessage_USCOREFC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sendMessage_USCOREFC() { ns1__sendMessage_USCOREFC::soap_default(NULL); }
	virtual ~ns1__sendMessage_USCOREFC() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wqfxySelfcheck
#define SOAP_TYPE_ns1__wqfxySelfcheck (73)
/* ns1:wqfxySelfcheck */
class SOAP_CMAC ns1__wqfxySelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	std::wstring *tightnessResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique type id SOAP_TYPE_ns1__wqfxySelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wqfxySelfcheck() { ns1__wqfxySelfcheck::soap_default(NULL); }
	virtual ~ns1__wqfxySelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wqfxySelfcheckResponse
#define SOAP_TYPE_ns1__wqfxySelfcheckResponse (74)
/* ns1:wqfxySelfcheckResponse */
class SOAP_CMAC ns1__wqfxySelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique type id SOAP_TYPE_ns1__wqfxySelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wqfxySelfcheckResponse() { ns1__wqfxySelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__wqfxySelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjALPSelfcheck
#define SOAP_TYPE_ns1__cgjALPSelfcheck (75)
/* ns1:cgjALPSelfcheck */
class SOAP_CMAC ns1__cgjALPSelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	double AvitualTime;	/* required element of type xsd:double */
	double ArealTime;	/* required element of type xsd:double */
	double BvitualTime;	/* required element of type xsd:double */
	double BrealTime;	/* required element of type xsd:double */
	double CvitualTime;	/* required element of type xsd:double */
	double CrealTime;	/* required element of type xsd:double */
	double ALpower1;	/* required element of type xsd:double */
	double ALpower2;	/* required element of type xsd:double */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique type id SOAP_TYPE_ns1__cgjALPSelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjALPSelfcheck() { ns1__cgjALPSelfcheck::soap_default(NULL); }
	virtual ~ns1__cgjALPSelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjALPSelfcheckResponse
#define SOAP_TYPE_ns1__cgjALPSelfcheckResponse (76)
/* ns1:cgjALPSelfcheckResponse */
class SOAP_CMAC ns1__cgjALPSelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique type id SOAP_TYPE_ns1__cgjALPSelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjALPSelfcheckResponse() { ns1__cgjALPSelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__cgjALPSelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lljSelfcheck
#define SOAP_TYPE_ns1__lljSelfcheck (77)
/* ns1:lljSelfcheck */
class SOAP_CMAC ns1__lljSelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	double avgFlow;	/* required element of type xsd:double */
	double O2Avg;	/* required element of type xsd:double */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique type id SOAP_TYPE_ns1__lljSelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lljSelfcheck() { ns1__lljSelfcheck::soap_default(NULL); }
	virtual ~ns1__lljSelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lljSelfcheckResponse
#define SOAP_TYPE_ns1__lljSelfcheckResponse (78)
/* ns1:lljSelfcheckResponse */
class SOAP_CMAC ns1__lljSelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique type id SOAP_TYPE_ns1__lljSelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lljSelfcheckResponse() { ns1__lljSelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__lljSelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjLSPSelfcheck
#define SOAP_TYPE_ns1__cgjLSPSelfcheck (79)
/* ns1:cgjLSPSelfcheck */
class SOAP_CMAC ns1__cgjLSPSelfcheck
{
public:
	std::wstring *registCode;	/* optional element of type xsd:string */
	double AvitualTime;	/* required element of type xsd:double */
	double ArealTime;	/* required element of type xsd:double */
	double BvitualTime;	/* required element of type xsd:double */
	double BrealTime;	/* required element of type xsd:double */
	double CvitualTime;	/* required element of type xsd:double */
	double CrealTime;	/* required element of type xsd:double */
	double DvitualTime;	/* required element of type xsd:double */
	double DrealTime;	/* required element of type xsd:double */
	double ALSpower;	/* required element of type xsd:double */
	double BLSpower;	/* required element of type xsd:double */
	double CLSpower;	/* required element of type xsd:double */
	double DLSpower;	/* required element of type xsd:double */
	std::wstring *checkResult;	/* optional element of type xsd:string */
	std::wstring *checkTimeStart;	/* optional element of type xsd:string */
	std::wstring *checkTimeEnd;	/* optional element of type xsd:string */
	std::wstring *remark;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique type id SOAP_TYPE_ns1__cgjLSPSelfcheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjLSPSelfcheck() { ns1__cgjLSPSelfcheck::soap_default(NULL); }
	virtual ~ns1__cgjLSPSelfcheck() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjLSPSelfcheckResponse
#define SOAP_TYPE_ns1__cgjLSPSelfcheckResponse (80)
/* ns1:cgjLSPSelfcheckResponse */
class SOAP_CMAC ns1__cgjLSPSelfcheckResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique type id SOAP_TYPE_ns1__cgjLSPSelfcheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjLSPSelfcheckResponse() { ns1__cgjLSPSelfcheckResponse::soap_default(NULL); }
	virtual ~ns1__cgjLSPSelfcheckResponse() { }
};
#endif

#ifndef SOAP_TYPE___ns1__argChang
#define SOAP_TYPE___ns1__argChang (91)
/* Operation wrapper: */
struct __ns1__argChang
{
public:
	ns1__argChang *ns1__argChang_;	/* optional element of type ns1:argChang */
public:
	int soap_type() const { return 91; } /* = unique type id SOAP_TYPE___ns1__argChang */
};
#endif

#ifndef SOAP_TYPE___ns1__lightproofSmokeLog
#define SOAP_TYPE___ns1__lightproofSmokeLog (95)
/* Operation wrapper: */
struct __ns1__lightproofSmokeLog
{
public:
	ns1__lightproofSmokeLog *ns1__lightproofSmokeLog_;	/* optional element of type ns1:lightproofSmokeLog */
public:
	int soap_type() const { return 95; } /* = unique type id SOAP_TYPE___ns1__lightproofSmokeLog */
};
#endif

#ifndef SOAP_TYPE___ns1__getCarInfo
#define SOAP_TYPE___ns1__getCarInfo (99)
/* Operation wrapper: */
struct __ns1__getCarInfo
{
public:
	ns1__getCarInfo *ns1__getCarInfo_;	/* optional element of type ns1:getCarInfo */
public:
	int soap_type() const { return 99; } /* = unique type id SOAP_TYPE___ns1__getCarInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__sendMessage
#define SOAP_TYPE___ns1__sendMessage (103)
/* Operation wrapper: */
struct __ns1__sendMessage
{
public:
	ns1__sendMessage *ns1__sendMessage_;	/* optional element of type ns1:sendMessage */
public:
	int soap_type() const { return 103; } /* = unique type id SOAP_TYPE___ns1__sendMessage */
};
#endif

#ifndef SOAP_TYPE___ns1__bgAirHC
#define SOAP_TYPE___ns1__bgAirHC (107)
/* Operation wrapper: */
struct __ns1__bgAirHC
{
public:
	ns1__bgAirHC *ns1__bgAirHC_;	/* optional element of type ns1:bgAirHC */
public:
	int soap_type() const { return 107; } /* = unique type id SOAP_TYPE___ns1__bgAirHC */
};
#endif

#ifndef SOAP_TYPE___ns1__doubleIdleData_USCOREFC
#define SOAP_TYPE___ns1__doubleIdleData_USCOREFC (111)
/* Operation wrapper: */
struct __ns1__doubleIdleData_USCOREFC
{
public:
	ns1__doubleIdleData_USCOREFC *ns1__doubleIdleData_USCOREFC_;	/* optional element of type ns1:doubleIdleData_FC */
public:
	int soap_type() const { return 111; } /* = unique type id SOAP_TYPE___ns1__doubleIdleData_USCOREFC */
};
#endif

#ifndef SOAP_TYPE___ns1__cgjLASelfcheck
#define SOAP_TYPE___ns1__cgjLASelfcheck (115)
/* Operation wrapper: */
struct __ns1__cgjLASelfcheck
{
public:
	ns1__cgjLASelfcheck *ns1__cgjLASelfcheck_;	/* optional element of type ns1:cgjLASelfcheck */
public:
	int soap_type() const { return 115; } /* = unique type id SOAP_TYPE___ns1__cgjLASelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__cgjSelfcheck
#define SOAP_TYPE___ns1__cgjSelfcheck (119)
/* Operation wrapper: */
struct __ns1__cgjSelfcheck
{
public:
	ns1__cgjSelfcheck *ns1__cgjSelfcheck_;	/* optional element of type ns1:cgjSelfcheck */
public:
	int soap_type() const { return 119; } /* = unique type id SOAP_TYPE___ns1__cgjSelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__obdResult
#define SOAP_TYPE___ns1__obdResult (123)
/* Operation wrapper: */
struct __ns1__obdResult
{
public:
	ns1__obdResult *ns1__obdResult_;	/* optional element of type ns1:obdResult */
public:
	int soap_type() const { return 123; } /* = unique type id SOAP_TYPE___ns1__obdResult */
};
#endif

#ifndef SOAP_TYPE___ns1__doubleIdleLog_USCOREFC
#define SOAP_TYPE___ns1__doubleIdleLog_USCOREFC (127)
/* Operation wrapper: */
struct __ns1__doubleIdleLog_USCOREFC
{
public:
	ns1__doubleIdleLog_USCOREFC *ns1__doubleIdleLog_USCOREFC_;	/* optional element of type ns1:doubleIdleLog_FC */
public:
	int soap_type() const { return 127; } /* = unique type id SOAP_TYPE___ns1__doubleIdleLog_USCOREFC */
};
#endif

#ifndef SOAP_TYPE___ns1__vmasLog
#define SOAP_TYPE___ns1__vmasLog (131)
/* Operation wrapper: */
struct __ns1__vmasLog
{
public:
	ns1__vmasLog *ns1__vmasLog_;	/* optional element of type ns1:vmasLog */
public:
	int soap_type() const { return 131; } /* = unique type id SOAP_TYPE___ns1__vmasLog */
};
#endif

#ifndef SOAP_TYPE___ns1__ydjSelfcheck
#define SOAP_TYPE___ns1__ydjSelfcheck (135)
/* Operation wrapper: */
struct __ns1__ydjSelfcheck
{
public:
	ns1__ydjSelfcheck *ns1__ydjSelfcheck_;	/* optional element of type ns1:ydjSelfcheck */
public:
	int soap_type() const { return 135; } /* = unique type id SOAP_TYPE___ns1__ydjSelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__dyhwSelfcheck
#define SOAP_TYPE___ns1__dyhwSelfcheck (139)
/* Operation wrapper: */
struct __ns1__dyhwSelfcheck
{
public:
	ns1__dyhwSelfcheck *ns1__dyhwSelfcheck_;	/* optional element of type ns1:dyhwSelfcheck */
public:
	int soap_type() const { return 139; } /* = unique type id SOAP_TYPE___ns1__dyhwSelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__loadDownLog
#define SOAP_TYPE___ns1__loadDownLog (143)
/* Operation wrapper: */
struct __ns1__loadDownLog
{
public:
	ns1__loadDownLog *ns1__loadDownLog_;	/* optional element of type ns1:loadDownLog */
public:
	int soap_type() const { return 143; } /* = unique type id SOAP_TYPE___ns1__loadDownLog */
};
#endif

#ifndef SOAP_TYPE___ns1__dyhwAdjust
#define SOAP_TYPE___ns1__dyhwAdjust (147)
/* Operation wrapper: */
struct __ns1__dyhwAdjust
{
public:
	ns1__dyhwAdjust *ns1__dyhwAdjust_;	/* optional element of type ns1:dyhwAdjust */
public:
	int soap_type() const { return 147; } /* = unique type id SOAP_TYPE___ns1__dyhwAdjust */
};
#endif

#ifndef SOAP_TYPE___ns1__obdResultLog
#define SOAP_TYPE___ns1__obdResultLog (151)
/* Operation wrapper: */
struct __ns1__obdResultLog
{
public:
	ns1__obdResultLog *ns1__obdResultLog_;	/* optional element of type ns1:obdResultLog */
public:
	int soap_type() const { return 151; } /* = unique type id SOAP_TYPE___ns1__obdResultLog */
};
#endif

#ifndef SOAP_TYPE___ns1__getCarInfo_USCOREFC
#define SOAP_TYPE___ns1__getCarInfo_USCOREFC (154)
/* Operation wrapper: */
struct __ns1__getCarInfo_USCOREFC
{
public:
	ns1__getCarInfo_USCOREFC *ns1__getCarInfo_USCOREFC_;	/* optional element of type ns1:getCarInfo_FC */
public:
	int soap_type() const { return 154; } /* = unique type id SOAP_TYPE___ns1__getCarInfo_USCOREFC */
};
#endif

#ifndef SOAP_TYPE___ns1__cycdyhwAdjust
#define SOAP_TYPE___ns1__cycdyhwAdjust (158)
/* Operation wrapper: */
struct __ns1__cycdyhwAdjust
{
public:
	ns1__cycdyhwAdjust *ns1__cycdyhwAdjust_;	/* optional element of type ns1:cycdyhwAdjust */
public:
	int soap_type() const { return 158; } /* = unique type id SOAP_TYPE___ns1__cycdyhwAdjust */
};
#endif

#ifndef SOAP_TYPE___ns1__hjcsgyqSelfcheck
#define SOAP_TYPE___ns1__hjcsgyqSelfcheck (162)
/* Operation wrapper: */
struct __ns1__hjcsgyqSelfcheck
{
public:
	ns1__hjcsgyqSelfcheck *ns1__hjcsgyqSelfcheck_;	/* optional element of type ns1:hjcsgyqSelfcheck */
public:
	int soap_type() const { return 162; } /* = unique type id SOAP_TYPE___ns1__hjcsgyqSelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__pqfxySelfcheck
#define SOAP_TYPE___ns1__pqfxySelfcheck (166)
/* Operation wrapper: */
struct __ns1__pqfxySelfcheck
{
public:
	ns1__pqfxySelfcheck *ns1__pqfxySelfcheck_;	/* optional element of type ns1:pqfxySelfcheck */
public:
	int soap_type() const { return 166; } /* = unique type id SOAP_TYPE___ns1__pqfxySelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC
#define SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC (170)
/* Operation wrapper: */
struct __ns1__lightproofSmokeDataLog_USCOREFC
{
public:
	ns1__lightproofSmokeDataLog_USCOREFC *ns1__lightproofSmokeDataLog_USCOREFC_;	/* optional element of type ns1:lightproofSmokeDataLog_FC */
public:
	int soap_type() const { return 170; } /* = unique type id SOAP_TYPE___ns1__lightproofSmokeDataLog_USCOREFC */
};
#endif

#ifndef SOAP_TYPE___ns1__loadDownData
#define SOAP_TYPE___ns1__loadDownData (174)
/* Operation wrapper: */
struct __ns1__loadDownData
{
public:
	ns1__loadDownData *ns1__loadDownData_;	/* optional element of type ns1:loadDownData */
public:
	int soap_type() const { return 174; } /* = unique type id SOAP_TYPE___ns1__loadDownData */
};
#endif

#ifndef SOAP_TYPE___ns1__vmasData
#define SOAP_TYPE___ns1__vmasData (178)
/* Operation wrapper: */
struct __ns1__vmasData
{
public:
	ns1__vmasData *ns1__vmasData_;	/* optional element of type ns1:vmasData */
public:
	int soap_type() const { return 178; } /* = unique type id SOAP_TYPE___ns1__vmasData */
};
#endif

#ifndef SOAP_TYPE___ns1__motoDbIdleData
#define SOAP_TYPE___ns1__motoDbIdleData (182)
/* Operation wrapper: */
struct __ns1__motoDbIdleData
{
public:
	ns1__motoDbIdleData *ns1__motoDbIdleData_;	/* optional element of type ns1:motoDbIdleData */
public:
	int soap_type() const { return 182; } /* = unique type id SOAP_TYPE___ns1__motoDbIdleData */
};
#endif

#ifndef SOAP_TYPE___ns1__getSatate
#define SOAP_TYPE___ns1__getSatate (186)
/* Operation wrapper: */
struct __ns1__getSatate
{
public:
	ns1__getSatate *ns1__getSatate_;	/* optional element of type ns1:getSatate */
public:
	int soap_type() const { return 186; } /* = unique type id SOAP_TYPE___ns1__getSatate */
};
#endif

#ifndef SOAP_TYPE___ns1__doubleIdleData
#define SOAP_TYPE___ns1__doubleIdleData (189)
/* Operation wrapper: */
struct __ns1__doubleIdleData
{
public:
	ns1__doubleIdleData *ns1__doubleIdleData_;	/* optional element of type ns1:doubleIdleData */
public:
	int soap_type() const { return 189; } /* = unique type id SOAP_TYPE___ns1__doubleIdleData */
};
#endif

#ifndef SOAP_TYPE___ns1__doubleIdleLog
#define SOAP_TYPE___ns1__doubleIdleLog (192)
/* Operation wrapper: */
struct __ns1__doubleIdleLog
{
public:
	ns1__doubleIdleLog *ns1__doubleIdleLog_;	/* optional element of type ns1:doubleIdleLog */
public:
	int soap_type() const { return 192; } /* = unique type id SOAP_TYPE___ns1__doubleIdleLog */
};
#endif

#ifndef SOAP_TYPE___ns1__cgjPLHPSelfcheck
#define SOAP_TYPE___ns1__cgjPLHPSelfcheck (196)
/* Operation wrapper: */
struct __ns1__cgjPLHPSelfcheck
{
public:
	ns1__cgjPLHPSelfcheck *ns1__cgjPLHPSelfcheck_;	/* optional element of type ns1:cgjPLHPSelfcheck */
public:
	int soap_type() const { return 196; } /* = unique type id SOAP_TYPE___ns1__cgjPLHPSelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__wqfxyAdjust
#define SOAP_TYPE___ns1__wqfxyAdjust (200)
/* Operation wrapper: */
struct __ns1__wqfxyAdjust
{
public:
	ns1__wqfxyAdjust *ns1__wqfxyAdjust_;	/* optional element of type ns1:wqfxyAdjust */
public:
	int soap_type() const { return 200; } /* = unique type id SOAP_TYPE___ns1__wqfxyAdjust */
};
#endif

#ifndef SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC
#define SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC (204)
/* Operation wrapper: */
struct __ns1__lightproofSmokeData_USCOREFC
{
public:
	ns1__lightproofSmokeData_USCOREFC *ns1__lightproofSmokeData_USCOREFC_;	/* optional element of type ns1:lightproofSmokeData_FC */
public:
	int soap_type() const { return 204; } /* = unique type id SOAP_TYPE___ns1__lightproofSmokeData_USCOREFC */
};
#endif

#ifndef SOAP_TYPE___ns1__lightproofSmokeData
#define SOAP_TYPE___ns1__lightproofSmokeData (207)
/* Operation wrapper: */
struct __ns1__lightproofSmokeData
{
public:
	ns1__lightproofSmokeData *ns1__lightproofSmokeData_;	/* optional element of type ns1:lightproofSmokeData */
public:
	int soap_type() const { return 207; } /* = unique type id SOAP_TYPE___ns1__lightproofSmokeData */
};
#endif

#ifndef SOAP_TYPE___ns1__qyfxSelfcheck
#define SOAP_TYPE___ns1__qyfxSelfcheck (211)
/* Operation wrapper: */
struct __ns1__qyfxSelfcheck
{
public:
	ns1__qyfxSelfcheck *ns1__qyfxSelfcheck_;	/* optional element of type ns1:qyfxSelfcheck */
public:
	int soap_type() const { return 211; } /* = unique type id SOAP_TYPE___ns1__qyfxSelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__sdsqtfxySelfcheck
#define SOAP_TYPE___ns1__sdsqtfxySelfcheck (215)
/* Operation wrapper: */
struct __ns1__sdsqtfxySelfcheck
{
public:
	ns1__sdsqtfxySelfcheck *ns1__sdsqtfxySelfcheck_;	/* optional element of type ns1:sdsqtfxySelfcheck */
public:
	int soap_type() const { return 215; } /* = unique type id SOAP_TYPE___ns1__sdsqtfxySelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__sendMessage_USCOREFC
#define SOAP_TYPE___ns1__sendMessage_USCOREFC (218)
/* Operation wrapper: */
struct __ns1__sendMessage_USCOREFC
{
public:
	ns1__sendMessage_USCOREFC *ns1__sendMessage_USCOREFC_;	/* optional element of type ns1:sendMessage_FC */
public:
	int soap_type() const { return 218; } /* = unique type id SOAP_TYPE___ns1__sendMessage_USCOREFC */
};
#endif

#ifndef SOAP_TYPE___ns1__wqfxySelfcheck
#define SOAP_TYPE___ns1__wqfxySelfcheck (222)
/* Operation wrapper: */
struct __ns1__wqfxySelfcheck
{
public:
	ns1__wqfxySelfcheck *ns1__wqfxySelfcheck_;	/* optional element of type ns1:wqfxySelfcheck */
public:
	int soap_type() const { return 222; } /* = unique type id SOAP_TYPE___ns1__wqfxySelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__cgjALPSelfcheck
#define SOAP_TYPE___ns1__cgjALPSelfcheck (226)
/* Operation wrapper: */
struct __ns1__cgjALPSelfcheck
{
public:
	ns1__cgjALPSelfcheck *ns1__cgjALPSelfcheck_;	/* optional element of type ns1:cgjALPSelfcheck */
public:
	int soap_type() const { return 226; } /* = unique type id SOAP_TYPE___ns1__cgjALPSelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__lljSelfcheck
#define SOAP_TYPE___ns1__lljSelfcheck (230)
/* Operation wrapper: */
struct __ns1__lljSelfcheck
{
public:
	ns1__lljSelfcheck *ns1__lljSelfcheck_;	/* optional element of type ns1:lljSelfcheck */
public:
	int soap_type() const { return 230; } /* = unique type id SOAP_TYPE___ns1__lljSelfcheck */
};
#endif

#ifndef SOAP_TYPE___ns1__cgjLSPSelfcheck
#define SOAP_TYPE___ns1__cgjLSPSelfcheck (234)
/* Operation wrapper: */
struct __ns1__cgjLSPSelfcheck
{
public:
	ns1__cgjLSPSelfcheck *ns1__cgjLSPSelfcheck_;	/* optional element of type ns1:cgjLSPSelfcheck */
public:
	int soap_type() const { return 234; } /* = unique type id SOAP_TYPE___ns1__cgjLSPSelfcheck */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (235)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 235; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (236)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 236; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (238)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 238; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (241)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 241; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (242)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 242; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
