/* soapC.cpp
   Generated by gSOAP 2.8.21 from sjjk.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.21 2020-03-16 13:03:28 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__qycObdIuprResponse:
		return soap_in_ns1__qycObdIuprResponse(soap, NULL, NULL, "ns1:qycObdIuprResponse");
	case SOAP_TYPE_ns1__qycObdIupr:
		return soap_in_ns1__qycObdIupr(soap, NULL, NULL, "ns1:qycObdIupr");
	case SOAP_TYPE_ns1__sdsJgsjResponse:
		return soap_in_ns1__sdsJgsjResponse(soap, NULL, NULL, "ns1:sdsJgsjResponse");
	case SOAP_TYPE_ns1__sdsJgsj:
		return soap_in_ns1__sdsJgsj(soap, NULL, NULL, "ns1:sdsJgsj");
	case SOAP_TYPE_ns1__cycObdIuprResponse:
		return soap_in_ns1__cycObdIuprResponse(soap, NULL, NULL, "ns1:cycObdIuprResponse");
	case SOAP_TYPE_ns1__cycObdIupr:
		return soap_in_ns1__cycObdIupr(soap, NULL, NULL, "ns1:cycObdIupr");
	case SOAP_TYPE_ns1__wqfxyzjResponse:
		return soap_in_ns1__wqfxyzjResponse(soap, NULL, NULL, "ns1:wqfxyzjResponse");
	case SOAP_TYPE_ns1__wqfxyzj:
		return soap_in_ns1__wqfxyzj(soap, NULL, NULL, "ns1:wqfxyzj");
	case SOAP_TYPE_ns1__jzjsGcsjResponse:
		return soap_in_ns1__jzjsGcsjResponse(soap, NULL, NULL, "ns1:jzjsGcsjResponse");
	case SOAP_TYPE_ns1__jzjsGcsj:
		return soap_in_ns1__jzjsGcsj(soap, NULL, NULL, "ns1:jzjsGcsj");
	case SOAP_TYPE_ns1__jystGcsjResponse:
		return soap_in_ns1__jystGcsjResponse(soap, NULL, NULL, "ns1:jystGcsjResponse");
	case SOAP_TYPE_ns1__jystGcsj:
		return soap_in_ns1__jystGcsj(soap, NULL, NULL, "ns1:jystGcsj");
	case SOAP_TYPE_ns1__jczrylbResponse:
		return soap_in_ns1__jczrylbResponse(soap, NULL, NULL, "ns1:jczrylbResponse");
	case SOAP_TYPE_ns1__jczrylb:
		return soap_in_ns1__jczrylb(soap, NULL, NULL, "ns1:jczrylb");
	case SOAP_TYPE_ns1__lgmhdJgsjResponse:
		return soap_in_ns1__lgmhdJgsjResponse(soap, NULL, NULL, "ns1:lgmhdJgsjResponse");
	case SOAP_TYPE_ns1__lgmhdJgsj:
		return soap_in_ns1__lgmhdJgsj(soap, NULL, NULL, "ns1:lgmhdJgsj");
	case SOAP_TYPE_ns1__hjcsyzjResponse:
		return soap_in_ns1__hjcsyzjResponse(soap, NULL, NULL, "ns1:hjcsyzjResponse");
	case SOAP_TYPE_ns1__hjcsyzj:
		return soap_in_ns1__hjcsyzj(soap, NULL, NULL, "ns1:hjcsyzj");
	case SOAP_TYPE_ns1__btgJgsjResponse:
		return soap_in_ns1__btgJgsjResponse(soap, NULL, NULL, "ns1:btgJgsjResponse");
	case SOAP_TYPE_ns1__btgJgsj:
		return soap_in_ns1__btgJgsj(soap, NULL, NULL, "ns1:btgJgsj");
	case SOAP_TYPE_ns1__getDjztResponse:
		return soap_in_ns1__getDjztResponse(soap, NULL, NULL, "ns1:getDjztResponse");
	case SOAP_TYPE_ns1__getDjzt:
		return soap_in_ns1__getDjzt(soap, NULL, NULL, "ns1:getDjzt");
	case SOAP_TYPE_ns1__xxtzResponse:
		return soap_in_ns1__xxtzResponse(soap, NULL, NULL, "ns1:xxtzResponse");
	case SOAP_TYPE_ns1__xxtz:
		return soap_in_ns1__xxtz(soap, NULL, NULL, "ns1:xxtz");
	case SOAP_TYPE_ns1__cgjzjResponse:
		return soap_in_ns1__cgjzjResponse(soap, NULL, NULL, "ns1:cgjzjResponse");
	case SOAP_TYPE_ns1__cgjzj:
		return soap_in_ns1__cgjzj(soap, NULL, NULL, "ns1:cgjzj");
	case SOAP_TYPE_ns1__obdGcsjResponse:
		return soap_in_ns1__obdGcsjResponse(soap, NULL, NULL, "ns1:obdGcsjResponse");
	case SOAP_TYPE_ns1__obdGcsj:
		return soap_in_ns1__obdGcsj(soap, NULL, NULL, "ns1:obdGcsj");
	case SOAP_TYPE_ns1__wtJgsjResponse:
		return soap_in_ns1__wtJgsjResponse(soap, NULL, NULL, "ns1:wtJgsjResponse");
	case SOAP_TYPE_ns1__wtJgsj:
		return soap_in_ns1__wtJgsj(soap, NULL, NULL, "ns1:wtJgsj");
	case SOAP_TYPE_ns1__wtGcsjResponse:
		return soap_in_ns1__wtGcsjResponse(soap, NULL, NULL, "ns1:wtGcsjResponse");
	case SOAP_TYPE_ns1__wtGcsj:
		return soap_in_ns1__wtGcsj(soap, NULL, NULL, "ns1:wtGcsj");
	case SOAP_TYPE_ns1__jzjsJgsjResponse:
		return soap_in_ns1__jzjsJgsjResponse(soap, NULL, NULL, "ns1:jzjsJgsjResponse");
	case SOAP_TYPE_ns1__jzjsJgsj:
		return soap_in_ns1__jzjsJgsj(soap, NULL, NULL, "ns1:jzjsJgsj");
	case SOAP_TYPE_ns1__getDjclxxResponse:
		return soap_in_ns1__getDjclxxResponse(soap, NULL, NULL, "ns1:getDjclxxResponse");
	case SOAP_TYPE_ns1__getDjclxx:
		return soap_in_ns1__getDjclxx(soap, NULL, NULL, "ns1:getDjclxx");
	case SOAP_TYPE_ns1__lgmhdGcsjResponse:
		return soap_in_ns1__lgmhdGcsjResponse(soap, NULL, NULL, "ns1:lgmhdGcsjResponse");
	case SOAP_TYPE_ns1__lgmhdGcsj:
		return soap_in_ns1__lgmhdGcsj(soap, NULL, NULL, "ns1:lgmhdGcsj");
	case SOAP_TYPE_ns1__obdDjlbResponse:
		return soap_in_ns1__obdDjlbResponse(soap, NULL, NULL, "ns1:obdDjlbResponse");
	case SOAP_TYPE_ns1__obdDjlb:
		return soap_in_ns1__obdDjlb(soap, NULL, NULL, "ns1:obdDjlb");
	case SOAP_TYPE_ns1__fwqsjtbResponse:
		return soap_in_ns1__fwqsjtbResponse(soap, NULL, NULL, "ns1:fwqsjtbResponse");
	case SOAP_TYPE_ns1__fwqsjtb:
		return soap_in_ns1__fwqsjtb(soap, NULL, NULL, "ns1:fwqsjtb");
	case SOAP_TYPE_ns1__lljzjResponse:
		return soap_in_ns1__lljzjResponse(soap, NULL, NULL, "ns1:lljzjResponse");
	case SOAP_TYPE_ns1__lljzj:
		return soap_in_ns1__lljzj(soap, NULL, NULL, "ns1:lljzj");
	case SOAP_TYPE_ns1__btgGcsjResponse:
		return soap_in_ns1__btgGcsjResponse(soap, NULL, NULL, "ns1:btgGcsjResponse");
	case SOAP_TYPE_ns1__btgGcsj:
		return soap_in_ns1__btgGcsj(soap, NULL, NULL, "ns1:btgGcsj");
	case SOAP_TYPE_ns1__ryzfJysjResponse:
		return soap_in_ns1__ryzfJysjResponse(soap, NULL, NULL, "ns1:ryzfJysjResponse");
	case SOAP_TYPE_ns1__ryzfJysj:
		return soap_in_ns1__ryzfJysj(soap, NULL, NULL, "ns1:ryzfJysj");
	case SOAP_TYPE_ns1__wgjcJgsjResponse:
		return soap_in_ns1__wgjcJgsjResponse(soap, NULL, NULL, "ns1:wgjcJgsjResponse");
	case SOAP_TYPE_ns1__wgjcJgsj:
		return soap_in_ns1__wgjcJgsj(soap, NULL, NULL, "ns1:wgjcJgsj");
	case SOAP_TYPE_ns1__jystJgsjResponse:
		return soap_in_ns1__jystJgsjResponse(soap, NULL, NULL, "ns1:jystJgsjResponse");
	case SOAP_TYPE_ns1__jystJgsj:
		return soap_in_ns1__jystJgsj(soap, NULL, NULL, "ns1:jystJgsj");
	case SOAP_TYPE_ns1__wqfxybdResponse:
		return soap_in_ns1__wqfxybdResponse(soap, NULL, NULL, "ns1:wqfxybdResponse");
	case SOAP_TYPE_ns1__wqfxybd:
		return soap_in_ns1__wqfxybd(soap, NULL, NULL, "ns1:wqfxybd");
	case SOAP_TYPE_ns1__ydjzjResponse:
		return soap_in_ns1__ydjzjResponse(soap, NULL, NULL, "ns1:ydjzjResponse");
	case SOAP_TYPE_ns1__ydjzj:
		return soap_in_ns1__ydjzj(soap, NULL, NULL, "ns1:ydjzj");
	case SOAP_TYPE_ns1__obdJgsjResponse:
		return soap_in_ns1__obdJgsjResponse(soap, NULL, NULL, "ns1:obdJgsjResponse");
	case SOAP_TYPE_ns1__obdJgsj:
		return soap_in_ns1__obdJgsj(soap, NULL, NULL, "ns1:obdJgsj");
	case SOAP_TYPE_ns1__gkrjbbhResponse:
		return soap_in_ns1__gkrjbbhResponse(soap, NULL, NULL, "ns1:gkrjbbhResponse");
	case SOAP_TYPE_ns1__gkrjbbh:
		return soap_in_ns1__gkrjbbh(soap, NULL, NULL, "ns1:gkrjbbh");
	case SOAP_TYPE_ns1__getAccessTokenResponse:
		return soap_in_ns1__getAccessTokenResponse(soap, NULL, NULL, "ns1:getAccessTokenResponse");
	case SOAP_TYPE_ns1__getAccessToken:
		return soap_in_ns1__getAccessToken(soap, NULL, NULL, "ns1:getAccessToken");
	case SOAP_TYPE_ns1__sdsGcsjResponse:
		return soap_in_ns1__sdsGcsjResponse(soap, NULL, NULL, "ns1:sdsGcsjResponse");
	case SOAP_TYPE_ns1__sdsGcsj:
		return soap_in_ns1__sdsGcsj(soap, NULL, NULL, "ns1:sdsGcsj");
	case SOAP_TYPE_PointerTons1__qycObdIupr:
		return soap_in_PointerTons1__qycObdIupr(soap, NULL, NULL, "ns1:qycObdIupr");
	case SOAP_TYPE_PointerTons1__sdsJgsj:
		return soap_in_PointerTons1__sdsJgsj(soap, NULL, NULL, "ns1:sdsJgsj");
	case SOAP_TYPE_PointerTons1__cycObdIupr:
		return soap_in_PointerTons1__cycObdIupr(soap, NULL, NULL, "ns1:cycObdIupr");
	case SOAP_TYPE_PointerTons1__wqfxyzj:
		return soap_in_PointerTons1__wqfxyzj(soap, NULL, NULL, "ns1:wqfxyzj");
	case SOAP_TYPE_PointerTons1__jzjsGcsj:
		return soap_in_PointerTons1__jzjsGcsj(soap, NULL, NULL, "ns1:jzjsGcsj");
	case SOAP_TYPE_PointerTons1__jystGcsj:
		return soap_in_PointerTons1__jystGcsj(soap, NULL, NULL, "ns1:jystGcsj");
	case SOAP_TYPE_PointerTons1__lgmhdJgsj:
		return soap_in_PointerTons1__lgmhdJgsj(soap, NULL, NULL, "ns1:lgmhdJgsj");
	case SOAP_TYPE_PointerTons1__jczrylb:
		return soap_in_PointerTons1__jczrylb(soap, NULL, NULL, "ns1:jczrylb");
	case SOAP_TYPE_PointerTons1__hjcsyzj:
		return soap_in_PointerTons1__hjcsyzj(soap, NULL, NULL, "ns1:hjcsyzj");
	case SOAP_TYPE_PointerTons1__btgJgsj:
		return soap_in_PointerTons1__btgJgsj(soap, NULL, NULL, "ns1:btgJgsj");
	case SOAP_TYPE_PointerTons1__xxtz:
		return soap_in_PointerTons1__xxtz(soap, NULL, NULL, "ns1:xxtz");
	case SOAP_TYPE_PointerTons1__getDjzt:
		return soap_in_PointerTons1__getDjzt(soap, NULL, NULL, "ns1:getDjzt");
	case SOAP_TYPE_PointerTons1__cgjzj:
		return soap_in_PointerTons1__cgjzj(soap, NULL, NULL, "ns1:cgjzj");
	case SOAP_TYPE_PointerTons1__wtJgsj:
		return soap_in_PointerTons1__wtJgsj(soap, NULL, NULL, "ns1:wtJgsj");
	case SOAP_TYPE_PointerTons1__obdGcsj:
		return soap_in_PointerTons1__obdGcsj(soap, NULL, NULL, "ns1:obdGcsj");
	case SOAP_TYPE_PointerTons1__wtGcsj:
		return soap_in_PointerTons1__wtGcsj(soap, NULL, NULL, "ns1:wtGcsj");
	case SOAP_TYPE_PointerTons1__jzjsJgsj:
		return soap_in_PointerTons1__jzjsJgsj(soap, NULL, NULL, "ns1:jzjsJgsj");
	case SOAP_TYPE_PointerTons1__getDjclxx:
		return soap_in_PointerTons1__getDjclxx(soap, NULL, NULL, "ns1:getDjclxx");
	case SOAP_TYPE_PointerTons1__lgmhdGcsj:
		return soap_in_PointerTons1__lgmhdGcsj(soap, NULL, NULL, "ns1:lgmhdGcsj");
	case SOAP_TYPE_PointerTons1__obdDjlb:
		return soap_in_PointerTons1__obdDjlb(soap, NULL, NULL, "ns1:obdDjlb");
	case SOAP_TYPE_PointerTons1__fwqsjtb:
		return soap_in_PointerTons1__fwqsjtb(soap, NULL, NULL, "ns1:fwqsjtb");
	case SOAP_TYPE_PointerTons1__lljzj:
		return soap_in_PointerTons1__lljzj(soap, NULL, NULL, "ns1:lljzj");
	case SOAP_TYPE_PointerTons1__btgGcsj:
		return soap_in_PointerTons1__btgGcsj(soap, NULL, NULL, "ns1:btgGcsj");
	case SOAP_TYPE_PointerTons1__ryzfJysj:
		return soap_in_PointerTons1__ryzfJysj(soap, NULL, NULL, "ns1:ryzfJysj");
	case SOAP_TYPE_PointerTons1__wgjcJgsj:
		return soap_in_PointerTons1__wgjcJgsj(soap, NULL, NULL, "ns1:wgjcJgsj");
	case SOAP_TYPE_PointerTons1__jystJgsj:
		return soap_in_PointerTons1__jystJgsj(soap, NULL, NULL, "ns1:jystJgsj");
	case SOAP_TYPE_PointerTons1__wqfxybd:
		return soap_in_PointerTons1__wqfxybd(soap, NULL, NULL, "ns1:wqfxybd");
	case SOAP_TYPE_PointerTons1__ydjzj:
		return soap_in_PointerTons1__ydjzj(soap, NULL, NULL, "ns1:ydjzj");
	case SOAP_TYPE_PointerTons1__obdJgsj:
		return soap_in_PointerTons1__obdJgsj(soap, NULL, NULL, "ns1:obdJgsj");
	case SOAP_TYPE_PointerTons1__gkrjbbh:
		return soap_in_PointerTons1__gkrjbbh(soap, NULL, NULL, "ns1:gkrjbbh");
	case SOAP_TYPE_PointerTons1__getAccessToken:
		return soap_in_PointerTons1__getAccessToken(soap, NULL, NULL, "ns1:getAccessToken");
	case SOAP_TYPE_PointerTons1__sdsGcsj:
		return soap_in_PointerTons1__sdsGcsj(soap, NULL, NULL, "ns1:sdsGcsj");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_in_PointerTostd__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:qycObdIuprResponse"))
		{	*type = SOAP_TYPE_ns1__qycObdIuprResponse;
			return soap_in_ns1__qycObdIuprResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:qycObdIupr"))
		{	*type = SOAP_TYPE_ns1__qycObdIupr;
			return soap_in_ns1__qycObdIupr(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sdsJgsjResponse"))
		{	*type = SOAP_TYPE_ns1__sdsJgsjResponse;
			return soap_in_ns1__sdsJgsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sdsJgsj"))
		{	*type = SOAP_TYPE_ns1__sdsJgsj;
			return soap_in_ns1__sdsJgsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cycObdIuprResponse"))
		{	*type = SOAP_TYPE_ns1__cycObdIuprResponse;
			return soap_in_ns1__cycObdIuprResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cycObdIupr"))
		{	*type = SOAP_TYPE_ns1__cycObdIupr;
			return soap_in_ns1__cycObdIupr(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wqfxyzjResponse"))
		{	*type = SOAP_TYPE_ns1__wqfxyzjResponse;
			return soap_in_ns1__wqfxyzjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wqfxyzj"))
		{	*type = SOAP_TYPE_ns1__wqfxyzj;
			return soap_in_ns1__wqfxyzj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jzjsGcsjResponse"))
		{	*type = SOAP_TYPE_ns1__jzjsGcsjResponse;
			return soap_in_ns1__jzjsGcsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jzjsGcsj"))
		{	*type = SOAP_TYPE_ns1__jzjsGcsj;
			return soap_in_ns1__jzjsGcsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jystGcsjResponse"))
		{	*type = SOAP_TYPE_ns1__jystGcsjResponse;
			return soap_in_ns1__jystGcsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jystGcsj"))
		{	*type = SOAP_TYPE_ns1__jystGcsj;
			return soap_in_ns1__jystGcsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jczrylbResponse"))
		{	*type = SOAP_TYPE_ns1__jczrylbResponse;
			return soap_in_ns1__jczrylbResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jczrylb"))
		{	*type = SOAP_TYPE_ns1__jczrylb;
			return soap_in_ns1__jczrylb(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lgmhdJgsjResponse"))
		{	*type = SOAP_TYPE_ns1__lgmhdJgsjResponse;
			return soap_in_ns1__lgmhdJgsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lgmhdJgsj"))
		{	*type = SOAP_TYPE_ns1__lgmhdJgsj;
			return soap_in_ns1__lgmhdJgsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hjcsyzjResponse"))
		{	*type = SOAP_TYPE_ns1__hjcsyzjResponse;
			return soap_in_ns1__hjcsyzjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hjcsyzj"))
		{	*type = SOAP_TYPE_ns1__hjcsyzj;
			return soap_in_ns1__hjcsyzj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:btgJgsjResponse"))
		{	*type = SOAP_TYPE_ns1__btgJgsjResponse;
			return soap_in_ns1__btgJgsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:btgJgsj"))
		{	*type = SOAP_TYPE_ns1__btgJgsj;
			return soap_in_ns1__btgJgsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDjztResponse"))
		{	*type = SOAP_TYPE_ns1__getDjztResponse;
			return soap_in_ns1__getDjztResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDjzt"))
		{	*type = SOAP_TYPE_ns1__getDjzt;
			return soap_in_ns1__getDjzt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:xxtzResponse"))
		{	*type = SOAP_TYPE_ns1__xxtzResponse;
			return soap_in_ns1__xxtzResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:xxtz"))
		{	*type = SOAP_TYPE_ns1__xxtz;
			return soap_in_ns1__xxtz(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjzjResponse"))
		{	*type = SOAP_TYPE_ns1__cgjzjResponse;
			return soap_in_ns1__cgjzjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cgjzj"))
		{	*type = SOAP_TYPE_ns1__cgjzj;
			return soap_in_ns1__cgjzj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:obdGcsjResponse"))
		{	*type = SOAP_TYPE_ns1__obdGcsjResponse;
			return soap_in_ns1__obdGcsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:obdGcsj"))
		{	*type = SOAP_TYPE_ns1__obdGcsj;
			return soap_in_ns1__obdGcsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wtJgsjResponse"))
		{	*type = SOAP_TYPE_ns1__wtJgsjResponse;
			return soap_in_ns1__wtJgsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wtJgsj"))
		{	*type = SOAP_TYPE_ns1__wtJgsj;
			return soap_in_ns1__wtJgsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wtGcsjResponse"))
		{	*type = SOAP_TYPE_ns1__wtGcsjResponse;
			return soap_in_ns1__wtGcsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wtGcsj"))
		{	*type = SOAP_TYPE_ns1__wtGcsj;
			return soap_in_ns1__wtGcsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jzjsJgsjResponse"))
		{	*type = SOAP_TYPE_ns1__jzjsJgsjResponse;
			return soap_in_ns1__jzjsJgsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jzjsJgsj"))
		{	*type = SOAP_TYPE_ns1__jzjsJgsj;
			return soap_in_ns1__jzjsJgsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDjclxxResponse"))
		{	*type = SOAP_TYPE_ns1__getDjclxxResponse;
			return soap_in_ns1__getDjclxxResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDjclxx"))
		{	*type = SOAP_TYPE_ns1__getDjclxx;
			return soap_in_ns1__getDjclxx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lgmhdGcsjResponse"))
		{	*type = SOAP_TYPE_ns1__lgmhdGcsjResponse;
			return soap_in_ns1__lgmhdGcsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lgmhdGcsj"))
		{	*type = SOAP_TYPE_ns1__lgmhdGcsj;
			return soap_in_ns1__lgmhdGcsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:obdDjlbResponse"))
		{	*type = SOAP_TYPE_ns1__obdDjlbResponse;
			return soap_in_ns1__obdDjlbResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:obdDjlb"))
		{	*type = SOAP_TYPE_ns1__obdDjlb;
			return soap_in_ns1__obdDjlb(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fwqsjtbResponse"))
		{	*type = SOAP_TYPE_ns1__fwqsjtbResponse;
			return soap_in_ns1__fwqsjtbResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fwqsjtb"))
		{	*type = SOAP_TYPE_ns1__fwqsjtb;
			return soap_in_ns1__fwqsjtb(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lljzjResponse"))
		{	*type = SOAP_TYPE_ns1__lljzjResponse;
			return soap_in_ns1__lljzjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lljzj"))
		{	*type = SOAP_TYPE_ns1__lljzj;
			return soap_in_ns1__lljzj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:btgGcsjResponse"))
		{	*type = SOAP_TYPE_ns1__btgGcsjResponse;
			return soap_in_ns1__btgGcsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:btgGcsj"))
		{	*type = SOAP_TYPE_ns1__btgGcsj;
			return soap_in_ns1__btgGcsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ryzfJysjResponse"))
		{	*type = SOAP_TYPE_ns1__ryzfJysjResponse;
			return soap_in_ns1__ryzfJysjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ryzfJysj"))
		{	*type = SOAP_TYPE_ns1__ryzfJysj;
			return soap_in_ns1__ryzfJysj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wgjcJgsjResponse"))
		{	*type = SOAP_TYPE_ns1__wgjcJgsjResponse;
			return soap_in_ns1__wgjcJgsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wgjcJgsj"))
		{	*type = SOAP_TYPE_ns1__wgjcJgsj;
			return soap_in_ns1__wgjcJgsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jystJgsjResponse"))
		{	*type = SOAP_TYPE_ns1__jystJgsjResponse;
			return soap_in_ns1__jystJgsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jystJgsj"))
		{	*type = SOAP_TYPE_ns1__jystJgsj;
			return soap_in_ns1__jystJgsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wqfxybdResponse"))
		{	*type = SOAP_TYPE_ns1__wqfxybdResponse;
			return soap_in_ns1__wqfxybdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wqfxybd"))
		{	*type = SOAP_TYPE_ns1__wqfxybd;
			return soap_in_ns1__wqfxybd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ydjzjResponse"))
		{	*type = SOAP_TYPE_ns1__ydjzjResponse;
			return soap_in_ns1__ydjzjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ydjzj"))
		{	*type = SOAP_TYPE_ns1__ydjzj;
			return soap_in_ns1__ydjzj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:obdJgsjResponse"))
		{	*type = SOAP_TYPE_ns1__obdJgsjResponse;
			return soap_in_ns1__obdJgsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:obdJgsj"))
		{	*type = SOAP_TYPE_ns1__obdJgsj;
			return soap_in_ns1__obdJgsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gkrjbbhResponse"))
		{	*type = SOAP_TYPE_ns1__gkrjbbhResponse;
			return soap_in_ns1__gkrjbbhResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gkrjbbh"))
		{	*type = SOAP_TYPE_ns1__gkrjbbh;
			return soap_in_ns1__gkrjbbh(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccessTokenResponse"))
		{	*type = SOAP_TYPE_ns1__getAccessTokenResponse;
			return soap_in_ns1__getAccessTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccessToken"))
		{	*type = SOAP_TYPE_ns1__getAccessToken;
			return soap_in_ns1__getAccessToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sdsGcsjResponse"))
		{	*type = SOAP_TYPE_ns1__sdsGcsjResponse;
			return soap_in_ns1__sdsGcsjResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sdsGcsj"))
		{	*type = SOAP_TYPE_ns1__sdsGcsj;
			return soap_in_ns1__sdsGcsj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__qycObdIuprResponse:
		return ((ns1__qycObdIuprResponse *)ptr)->soap_out(soap, tag, id, "ns1:qycObdIuprResponse");
	case SOAP_TYPE_ns1__qycObdIupr:
		return ((ns1__qycObdIupr *)ptr)->soap_out(soap, tag, id, "ns1:qycObdIupr");
	case SOAP_TYPE_ns1__sdsJgsjResponse:
		return ((ns1__sdsJgsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:sdsJgsjResponse");
	case SOAP_TYPE_ns1__sdsJgsj:
		return ((ns1__sdsJgsj *)ptr)->soap_out(soap, tag, id, "ns1:sdsJgsj");
	case SOAP_TYPE_ns1__cycObdIuprResponse:
		return ((ns1__cycObdIuprResponse *)ptr)->soap_out(soap, tag, id, "ns1:cycObdIuprResponse");
	case SOAP_TYPE_ns1__cycObdIupr:
		return ((ns1__cycObdIupr *)ptr)->soap_out(soap, tag, id, "ns1:cycObdIupr");
	case SOAP_TYPE_ns1__wqfxyzjResponse:
		return ((ns1__wqfxyzjResponse *)ptr)->soap_out(soap, tag, id, "ns1:wqfxyzjResponse");
	case SOAP_TYPE_ns1__wqfxyzj:
		return ((ns1__wqfxyzj *)ptr)->soap_out(soap, tag, id, "ns1:wqfxyzj");
	case SOAP_TYPE_ns1__jzjsGcsjResponse:
		return ((ns1__jzjsGcsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:jzjsGcsjResponse");
	case SOAP_TYPE_ns1__jzjsGcsj:
		return ((ns1__jzjsGcsj *)ptr)->soap_out(soap, tag, id, "ns1:jzjsGcsj");
	case SOAP_TYPE_ns1__jystGcsjResponse:
		return ((ns1__jystGcsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:jystGcsjResponse");
	case SOAP_TYPE_ns1__jystGcsj:
		return ((ns1__jystGcsj *)ptr)->soap_out(soap, tag, id, "ns1:jystGcsj");
	case SOAP_TYPE_ns1__jczrylbResponse:
		return ((ns1__jczrylbResponse *)ptr)->soap_out(soap, tag, id, "ns1:jczrylbResponse");
	case SOAP_TYPE_ns1__jczrylb:
		return ((ns1__jczrylb *)ptr)->soap_out(soap, tag, id, "ns1:jczrylb");
	case SOAP_TYPE_ns1__lgmhdJgsjResponse:
		return ((ns1__lgmhdJgsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:lgmhdJgsjResponse");
	case SOAP_TYPE_ns1__lgmhdJgsj:
		return ((ns1__lgmhdJgsj *)ptr)->soap_out(soap, tag, id, "ns1:lgmhdJgsj");
	case SOAP_TYPE_ns1__hjcsyzjResponse:
		return ((ns1__hjcsyzjResponse *)ptr)->soap_out(soap, tag, id, "ns1:hjcsyzjResponse");
	case SOAP_TYPE_ns1__hjcsyzj:
		return ((ns1__hjcsyzj *)ptr)->soap_out(soap, tag, id, "ns1:hjcsyzj");
	case SOAP_TYPE_ns1__btgJgsjResponse:
		return ((ns1__btgJgsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:btgJgsjResponse");
	case SOAP_TYPE_ns1__btgJgsj:
		return ((ns1__btgJgsj *)ptr)->soap_out(soap, tag, id, "ns1:btgJgsj");
	case SOAP_TYPE_ns1__getDjztResponse:
		return ((ns1__getDjztResponse *)ptr)->soap_out(soap, tag, id, "ns1:getDjztResponse");
	case SOAP_TYPE_ns1__getDjzt:
		return ((ns1__getDjzt *)ptr)->soap_out(soap, tag, id, "ns1:getDjzt");
	case SOAP_TYPE_ns1__xxtzResponse:
		return ((ns1__xxtzResponse *)ptr)->soap_out(soap, tag, id, "ns1:xxtzResponse");
	case SOAP_TYPE_ns1__xxtz:
		return ((ns1__xxtz *)ptr)->soap_out(soap, tag, id, "ns1:xxtz");
	case SOAP_TYPE_ns1__cgjzjResponse:
		return ((ns1__cgjzjResponse *)ptr)->soap_out(soap, tag, id, "ns1:cgjzjResponse");
	case SOAP_TYPE_ns1__cgjzj:
		return ((ns1__cgjzj *)ptr)->soap_out(soap, tag, id, "ns1:cgjzj");
	case SOAP_TYPE_ns1__obdGcsjResponse:
		return ((ns1__obdGcsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:obdGcsjResponse");
	case SOAP_TYPE_ns1__obdGcsj:
		return ((ns1__obdGcsj *)ptr)->soap_out(soap, tag, id, "ns1:obdGcsj");
	case SOAP_TYPE_ns1__wtJgsjResponse:
		return ((ns1__wtJgsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:wtJgsjResponse");
	case SOAP_TYPE_ns1__wtJgsj:
		return ((ns1__wtJgsj *)ptr)->soap_out(soap, tag, id, "ns1:wtJgsj");
	case SOAP_TYPE_ns1__wtGcsjResponse:
		return ((ns1__wtGcsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:wtGcsjResponse");
	case SOAP_TYPE_ns1__wtGcsj:
		return ((ns1__wtGcsj *)ptr)->soap_out(soap, tag, id, "ns1:wtGcsj");
	case SOAP_TYPE_ns1__jzjsJgsjResponse:
		return ((ns1__jzjsJgsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:jzjsJgsjResponse");
	case SOAP_TYPE_ns1__jzjsJgsj:
		return ((ns1__jzjsJgsj *)ptr)->soap_out(soap, tag, id, "ns1:jzjsJgsj");
	case SOAP_TYPE_ns1__getDjclxxResponse:
		return ((ns1__getDjclxxResponse *)ptr)->soap_out(soap, tag, id, "ns1:getDjclxxResponse");
	case SOAP_TYPE_ns1__getDjclxx:
		return ((ns1__getDjclxx *)ptr)->soap_out(soap, tag, id, "ns1:getDjclxx");
	case SOAP_TYPE_ns1__lgmhdGcsjResponse:
		return ((ns1__lgmhdGcsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:lgmhdGcsjResponse");
	case SOAP_TYPE_ns1__lgmhdGcsj:
		return ((ns1__lgmhdGcsj *)ptr)->soap_out(soap, tag, id, "ns1:lgmhdGcsj");
	case SOAP_TYPE_ns1__obdDjlbResponse:
		return ((ns1__obdDjlbResponse *)ptr)->soap_out(soap, tag, id, "ns1:obdDjlbResponse");
	case SOAP_TYPE_ns1__obdDjlb:
		return ((ns1__obdDjlb *)ptr)->soap_out(soap, tag, id, "ns1:obdDjlb");
	case SOAP_TYPE_ns1__fwqsjtbResponse:
		return ((ns1__fwqsjtbResponse *)ptr)->soap_out(soap, tag, id, "ns1:fwqsjtbResponse");
	case SOAP_TYPE_ns1__fwqsjtb:
		return ((ns1__fwqsjtb *)ptr)->soap_out(soap, tag, id, "ns1:fwqsjtb");
	case SOAP_TYPE_ns1__lljzjResponse:
		return ((ns1__lljzjResponse *)ptr)->soap_out(soap, tag, id, "ns1:lljzjResponse");
	case SOAP_TYPE_ns1__lljzj:
		return ((ns1__lljzj *)ptr)->soap_out(soap, tag, id, "ns1:lljzj");
	case SOAP_TYPE_ns1__btgGcsjResponse:
		return ((ns1__btgGcsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:btgGcsjResponse");
	case SOAP_TYPE_ns1__btgGcsj:
		return ((ns1__btgGcsj *)ptr)->soap_out(soap, tag, id, "ns1:btgGcsj");
	case SOAP_TYPE_ns1__ryzfJysjResponse:
		return ((ns1__ryzfJysjResponse *)ptr)->soap_out(soap, tag, id, "ns1:ryzfJysjResponse");
	case SOAP_TYPE_ns1__ryzfJysj:
		return ((ns1__ryzfJysj *)ptr)->soap_out(soap, tag, id, "ns1:ryzfJysj");
	case SOAP_TYPE_ns1__wgjcJgsjResponse:
		return ((ns1__wgjcJgsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:wgjcJgsjResponse");
	case SOAP_TYPE_ns1__wgjcJgsj:
		return ((ns1__wgjcJgsj *)ptr)->soap_out(soap, tag, id, "ns1:wgjcJgsj");
	case SOAP_TYPE_ns1__jystJgsjResponse:
		return ((ns1__jystJgsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:jystJgsjResponse");
	case SOAP_TYPE_ns1__jystJgsj:
		return ((ns1__jystJgsj *)ptr)->soap_out(soap, tag, id, "ns1:jystJgsj");
	case SOAP_TYPE_ns1__wqfxybdResponse:
		return ((ns1__wqfxybdResponse *)ptr)->soap_out(soap, tag, id, "ns1:wqfxybdResponse");
	case SOAP_TYPE_ns1__wqfxybd:
		return ((ns1__wqfxybd *)ptr)->soap_out(soap, tag, id, "ns1:wqfxybd");
	case SOAP_TYPE_ns1__ydjzjResponse:
		return ((ns1__ydjzjResponse *)ptr)->soap_out(soap, tag, id, "ns1:ydjzjResponse");
	case SOAP_TYPE_ns1__ydjzj:
		return ((ns1__ydjzj *)ptr)->soap_out(soap, tag, id, "ns1:ydjzj");
	case SOAP_TYPE_ns1__obdJgsjResponse:
		return ((ns1__obdJgsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:obdJgsjResponse");
	case SOAP_TYPE_ns1__obdJgsj:
		return ((ns1__obdJgsj *)ptr)->soap_out(soap, tag, id, "ns1:obdJgsj");
	case SOAP_TYPE_ns1__gkrjbbhResponse:
		return ((ns1__gkrjbbhResponse *)ptr)->soap_out(soap, tag, id, "ns1:gkrjbbhResponse");
	case SOAP_TYPE_ns1__gkrjbbh:
		return ((ns1__gkrjbbh *)ptr)->soap_out(soap, tag, id, "ns1:gkrjbbh");
	case SOAP_TYPE_ns1__getAccessTokenResponse:
		return ((ns1__getAccessTokenResponse *)ptr)->soap_out(soap, tag, id, "ns1:getAccessTokenResponse");
	case SOAP_TYPE_ns1__getAccessToken:
		return ((ns1__getAccessToken *)ptr)->soap_out(soap, tag, id, "ns1:getAccessToken");
	case SOAP_TYPE_ns1__sdsGcsjResponse:
		return ((ns1__sdsGcsjResponse *)ptr)->soap_out(soap, tag, id, "ns1:sdsGcsjResponse");
	case SOAP_TYPE_ns1__sdsGcsj:
		return ((ns1__sdsGcsj *)ptr)->soap_out(soap, tag, id, "ns1:sdsGcsj");
	case SOAP_TYPE_PointerTons1__qycObdIupr:
		return soap_out_PointerTons1__qycObdIupr(soap, tag, id, (ns1__qycObdIupr *const*)ptr, "ns1:qycObdIupr");
	case SOAP_TYPE_PointerTons1__sdsJgsj:
		return soap_out_PointerTons1__sdsJgsj(soap, tag, id, (ns1__sdsJgsj *const*)ptr, "ns1:sdsJgsj");
	case SOAP_TYPE_PointerTons1__cycObdIupr:
		return soap_out_PointerTons1__cycObdIupr(soap, tag, id, (ns1__cycObdIupr *const*)ptr, "ns1:cycObdIupr");
	case SOAP_TYPE_PointerTons1__wqfxyzj:
		return soap_out_PointerTons1__wqfxyzj(soap, tag, id, (ns1__wqfxyzj *const*)ptr, "ns1:wqfxyzj");
	case SOAP_TYPE_PointerTons1__jzjsGcsj:
		return soap_out_PointerTons1__jzjsGcsj(soap, tag, id, (ns1__jzjsGcsj *const*)ptr, "ns1:jzjsGcsj");
	case SOAP_TYPE_PointerTons1__jystGcsj:
		return soap_out_PointerTons1__jystGcsj(soap, tag, id, (ns1__jystGcsj *const*)ptr, "ns1:jystGcsj");
	case SOAP_TYPE_PointerTons1__lgmhdJgsj:
		return soap_out_PointerTons1__lgmhdJgsj(soap, tag, id, (ns1__lgmhdJgsj *const*)ptr, "ns1:lgmhdJgsj");
	case SOAP_TYPE_PointerTons1__jczrylb:
		return soap_out_PointerTons1__jczrylb(soap, tag, id, (ns1__jczrylb *const*)ptr, "ns1:jczrylb");
	case SOAP_TYPE_PointerTons1__hjcsyzj:
		return soap_out_PointerTons1__hjcsyzj(soap, tag, id, (ns1__hjcsyzj *const*)ptr, "ns1:hjcsyzj");
	case SOAP_TYPE_PointerTons1__btgJgsj:
		return soap_out_PointerTons1__btgJgsj(soap, tag, id, (ns1__btgJgsj *const*)ptr, "ns1:btgJgsj");
	case SOAP_TYPE_PointerTons1__xxtz:
		return soap_out_PointerTons1__xxtz(soap, tag, id, (ns1__xxtz *const*)ptr, "ns1:xxtz");
	case SOAP_TYPE_PointerTons1__getDjzt:
		return soap_out_PointerTons1__getDjzt(soap, tag, id, (ns1__getDjzt *const*)ptr, "ns1:getDjzt");
	case SOAP_TYPE_PointerTons1__cgjzj:
		return soap_out_PointerTons1__cgjzj(soap, tag, id, (ns1__cgjzj *const*)ptr, "ns1:cgjzj");
	case SOAP_TYPE_PointerTons1__wtJgsj:
		return soap_out_PointerTons1__wtJgsj(soap, tag, id, (ns1__wtJgsj *const*)ptr, "ns1:wtJgsj");
	case SOAP_TYPE_PointerTons1__obdGcsj:
		return soap_out_PointerTons1__obdGcsj(soap, tag, id, (ns1__obdGcsj *const*)ptr, "ns1:obdGcsj");
	case SOAP_TYPE_PointerTons1__wtGcsj:
		return soap_out_PointerTons1__wtGcsj(soap, tag, id, (ns1__wtGcsj *const*)ptr, "ns1:wtGcsj");
	case SOAP_TYPE_PointerTons1__jzjsJgsj:
		return soap_out_PointerTons1__jzjsJgsj(soap, tag, id, (ns1__jzjsJgsj *const*)ptr, "ns1:jzjsJgsj");
	case SOAP_TYPE_PointerTons1__getDjclxx:
		return soap_out_PointerTons1__getDjclxx(soap, tag, id, (ns1__getDjclxx *const*)ptr, "ns1:getDjclxx");
	case SOAP_TYPE_PointerTons1__lgmhdGcsj:
		return soap_out_PointerTons1__lgmhdGcsj(soap, tag, id, (ns1__lgmhdGcsj *const*)ptr, "ns1:lgmhdGcsj");
	case SOAP_TYPE_PointerTons1__obdDjlb:
		return soap_out_PointerTons1__obdDjlb(soap, tag, id, (ns1__obdDjlb *const*)ptr, "ns1:obdDjlb");
	case SOAP_TYPE_PointerTons1__fwqsjtb:
		return soap_out_PointerTons1__fwqsjtb(soap, tag, id, (ns1__fwqsjtb *const*)ptr, "ns1:fwqsjtb");
	case SOAP_TYPE_PointerTons1__lljzj:
		return soap_out_PointerTons1__lljzj(soap, tag, id, (ns1__lljzj *const*)ptr, "ns1:lljzj");
	case SOAP_TYPE_PointerTons1__btgGcsj:
		return soap_out_PointerTons1__btgGcsj(soap, tag, id, (ns1__btgGcsj *const*)ptr, "ns1:btgGcsj");
	case SOAP_TYPE_PointerTons1__ryzfJysj:
		return soap_out_PointerTons1__ryzfJysj(soap, tag, id, (ns1__ryzfJysj *const*)ptr, "ns1:ryzfJysj");
	case SOAP_TYPE_PointerTons1__wgjcJgsj:
		return soap_out_PointerTons1__wgjcJgsj(soap, tag, id, (ns1__wgjcJgsj *const*)ptr, "ns1:wgjcJgsj");
	case SOAP_TYPE_PointerTons1__jystJgsj:
		return soap_out_PointerTons1__jystJgsj(soap, tag, id, (ns1__jystJgsj *const*)ptr, "ns1:jystJgsj");
	case SOAP_TYPE_PointerTons1__wqfxybd:
		return soap_out_PointerTons1__wqfxybd(soap, tag, id, (ns1__wqfxybd *const*)ptr, "ns1:wqfxybd");
	case SOAP_TYPE_PointerTons1__ydjzj:
		return soap_out_PointerTons1__ydjzj(soap, tag, id, (ns1__ydjzj *const*)ptr, "ns1:ydjzj");
	case SOAP_TYPE_PointerTons1__obdJgsj:
		return soap_out_PointerTons1__obdJgsj(soap, tag, id, (ns1__obdJgsj *const*)ptr, "ns1:obdJgsj");
	case SOAP_TYPE_PointerTons1__gkrjbbh:
		return soap_out_PointerTons1__gkrjbbh(soap, tag, id, (ns1__gkrjbbh *const*)ptr, "ns1:gkrjbbh");
	case SOAP_TYPE_PointerTons1__getAccessToken:
		return soap_out_PointerTons1__getAccessToken(soap, tag, id, (ns1__getAccessToken *const*)ptr, "ns1:getAccessToken");
	case SOAP_TYPE_PointerTons1__sdsGcsj:
		return soap_out_PointerTons1__sdsGcsj(soap, tag, id, (ns1__sdsGcsj *const*)ptr, "ns1:sdsGcsj");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_out_PointerTostd__wstring(soap, tag, id, (std::wstring *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_ns1__qycObdIuprResponse:
		((ns1__qycObdIuprResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__qycObdIupr:
		((ns1__qycObdIupr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sdsJgsjResponse:
		((ns1__sdsJgsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sdsJgsj:
		((ns1__sdsJgsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cycObdIuprResponse:
		((ns1__cycObdIuprResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cycObdIupr:
		((ns1__cycObdIupr *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wqfxyzjResponse:
		((ns1__wqfxyzjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wqfxyzj:
		((ns1__wqfxyzj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__jzjsGcsjResponse:
		((ns1__jzjsGcsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__jzjsGcsj:
		((ns1__jzjsGcsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__jystGcsjResponse:
		((ns1__jystGcsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__jystGcsj:
		((ns1__jystGcsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__jczrylbResponse:
		((ns1__jczrylbResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__jczrylb:
		((ns1__jczrylb *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lgmhdJgsjResponse:
		((ns1__lgmhdJgsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lgmhdJgsj:
		((ns1__lgmhdJgsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__hjcsyzjResponse:
		((ns1__hjcsyzjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__hjcsyzj:
		((ns1__hjcsyzj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__btgJgsjResponse:
		((ns1__btgJgsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__btgJgsj:
		((ns1__btgJgsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDjztResponse:
		((ns1__getDjztResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDjzt:
		((ns1__getDjzt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__xxtzResponse:
		((ns1__xxtzResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__xxtz:
		((ns1__xxtz *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjzjResponse:
		((ns1__cgjzjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cgjzj:
		((ns1__cgjzj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__obdGcsjResponse:
		((ns1__obdGcsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__obdGcsj:
		((ns1__obdGcsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wtJgsjResponse:
		((ns1__wtJgsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wtJgsj:
		((ns1__wtJgsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wtGcsjResponse:
		((ns1__wtGcsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wtGcsj:
		((ns1__wtGcsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__jzjsJgsjResponse:
		((ns1__jzjsJgsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__jzjsJgsj:
		((ns1__jzjsJgsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDjclxxResponse:
		((ns1__getDjclxxResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDjclxx:
		((ns1__getDjclxx *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lgmhdGcsjResponse:
		((ns1__lgmhdGcsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lgmhdGcsj:
		((ns1__lgmhdGcsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__obdDjlbResponse:
		((ns1__obdDjlbResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__obdDjlb:
		((ns1__obdDjlb *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__fwqsjtbResponse:
		((ns1__fwqsjtbResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__fwqsjtb:
		((ns1__fwqsjtb *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lljzjResponse:
		((ns1__lljzjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lljzj:
		((ns1__lljzj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__btgGcsjResponse:
		((ns1__btgGcsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__btgGcsj:
		((ns1__btgGcsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ryzfJysjResponse:
		((ns1__ryzfJysjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ryzfJysj:
		((ns1__ryzfJysj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wgjcJgsjResponse:
		((ns1__wgjcJgsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wgjcJgsj:
		((ns1__wgjcJgsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__jystJgsjResponse:
		((ns1__jystJgsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__jystJgsj:
		((ns1__jystJgsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wqfxybdResponse:
		((ns1__wqfxybdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wqfxybd:
		((ns1__wqfxybd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ydjzjResponse:
		((ns1__ydjzjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ydjzj:
		((ns1__ydjzj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__obdJgsjResponse:
		((ns1__obdJgsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__obdJgsj:
		((ns1__obdJgsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gkrjbbhResponse:
		((ns1__gkrjbbhResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gkrjbbh:
		((ns1__gkrjbbh *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getAccessTokenResponse:
		((ns1__getAccessTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getAccessToken:
		((ns1__getAccessToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sdsGcsjResponse:
		((ns1__sdsGcsjResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sdsGcsj:
		((ns1__sdsGcsj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__qycObdIupr:
		soap_serialize___ns1__qycObdIupr(soap, (const struct __ns1__qycObdIupr *)ptr);
		break;
	case SOAP_TYPE___ns1__sdsJgsj:
		soap_serialize___ns1__sdsJgsj(soap, (const struct __ns1__sdsJgsj *)ptr);
		break;
	case SOAP_TYPE___ns1__cycObdIupr:
		soap_serialize___ns1__cycObdIupr(soap, (const struct __ns1__cycObdIupr *)ptr);
		break;
	case SOAP_TYPE___ns1__wqfxyzj:
		soap_serialize___ns1__wqfxyzj(soap, (const struct __ns1__wqfxyzj *)ptr);
		break;
	case SOAP_TYPE___ns1__jzjsGcsj:
		soap_serialize___ns1__jzjsGcsj(soap, (const struct __ns1__jzjsGcsj *)ptr);
		break;
	case SOAP_TYPE___ns1__jystGcsj:
		soap_serialize___ns1__jystGcsj(soap, (const struct __ns1__jystGcsj *)ptr);
		break;
	case SOAP_TYPE___ns1__lgmhdJgsj:
		soap_serialize___ns1__lgmhdJgsj(soap, (const struct __ns1__lgmhdJgsj *)ptr);
		break;
	case SOAP_TYPE___ns1__jczrylb:
		soap_serialize___ns1__jczrylb(soap, (const struct __ns1__jczrylb *)ptr);
		break;
	case SOAP_TYPE___ns1__hjcsyzj:
		soap_serialize___ns1__hjcsyzj(soap, (const struct __ns1__hjcsyzj *)ptr);
		break;
	case SOAP_TYPE___ns1__btgJgsj:
		soap_serialize___ns1__btgJgsj(soap, (const struct __ns1__btgJgsj *)ptr);
		break;
	case SOAP_TYPE___ns1__xxtz:
		soap_serialize___ns1__xxtz(soap, (const struct __ns1__xxtz *)ptr);
		break;
	case SOAP_TYPE___ns1__getDjzt:
		soap_serialize___ns1__getDjzt(soap, (const struct __ns1__getDjzt *)ptr);
		break;
	case SOAP_TYPE___ns1__cgjzj:
		soap_serialize___ns1__cgjzj(soap, (const struct __ns1__cgjzj *)ptr);
		break;
	case SOAP_TYPE___ns1__wtJgsj:
		soap_serialize___ns1__wtJgsj(soap, (const struct __ns1__wtJgsj *)ptr);
		break;
	case SOAP_TYPE___ns1__obdGcsj:
		soap_serialize___ns1__obdGcsj(soap, (const struct __ns1__obdGcsj *)ptr);
		break;
	case SOAP_TYPE___ns1__wtGcsj:
		soap_serialize___ns1__wtGcsj(soap, (const struct __ns1__wtGcsj *)ptr);
		break;
	case SOAP_TYPE___ns1__jzjsJgsj:
		soap_serialize___ns1__jzjsJgsj(soap, (const struct __ns1__jzjsJgsj *)ptr);
		break;
	case SOAP_TYPE___ns1__getDjclxx:
		soap_serialize___ns1__getDjclxx(soap, (const struct __ns1__getDjclxx *)ptr);
		break;
	case SOAP_TYPE___ns1__lgmhdGcsj:
		soap_serialize___ns1__lgmhdGcsj(soap, (const struct __ns1__lgmhdGcsj *)ptr);
		break;
	case SOAP_TYPE___ns1__obdDjlb:
		soap_serialize___ns1__obdDjlb(soap, (const struct __ns1__obdDjlb *)ptr);
		break;
	case SOAP_TYPE___ns1__fwqsjtb:
		soap_serialize___ns1__fwqsjtb(soap, (const struct __ns1__fwqsjtb *)ptr);
		break;
	case SOAP_TYPE___ns1__lljzj:
		soap_serialize___ns1__lljzj(soap, (const struct __ns1__lljzj *)ptr);
		break;
	case SOAP_TYPE___ns1__btgGcsj:
		soap_serialize___ns1__btgGcsj(soap, (const struct __ns1__btgGcsj *)ptr);
		break;
	case SOAP_TYPE___ns1__ryzfJysj:
		soap_serialize___ns1__ryzfJysj(soap, (const struct __ns1__ryzfJysj *)ptr);
		break;
	case SOAP_TYPE___ns1__wgjcJgsj:
		soap_serialize___ns1__wgjcJgsj(soap, (const struct __ns1__wgjcJgsj *)ptr);
		break;
	case SOAP_TYPE___ns1__jystJgsj:
		soap_serialize___ns1__jystJgsj(soap, (const struct __ns1__jystJgsj *)ptr);
		break;
	case SOAP_TYPE___ns1__wqfxybd:
		soap_serialize___ns1__wqfxybd(soap, (const struct __ns1__wqfxybd *)ptr);
		break;
	case SOAP_TYPE___ns1__ydjzj:
		soap_serialize___ns1__ydjzj(soap, (const struct __ns1__ydjzj *)ptr);
		break;
	case SOAP_TYPE___ns1__obdJgsj:
		soap_serialize___ns1__obdJgsj(soap, (const struct __ns1__obdJgsj *)ptr);
		break;
	case SOAP_TYPE___ns1__gkrjbbh:
		soap_serialize___ns1__gkrjbbh(soap, (const struct __ns1__gkrjbbh *)ptr);
		break;
	case SOAP_TYPE___ns1__getAccessToken:
		soap_serialize___ns1__getAccessToken(soap, (const struct __ns1__getAccessToken *)ptr);
		break;
	case SOAP_TYPE___ns1__sdsGcsj:
		soap_serialize___ns1__sdsGcsj(soap, (const struct __ns1__sdsGcsj *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__qycObdIupr:
		soap_serialize_PointerTons1__qycObdIupr(soap, (ns1__qycObdIupr *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sdsJgsj:
		soap_serialize_PointerTons1__sdsJgsj(soap, (ns1__sdsJgsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cycObdIupr:
		soap_serialize_PointerTons1__cycObdIupr(soap, (ns1__cycObdIupr *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wqfxyzj:
		soap_serialize_PointerTons1__wqfxyzj(soap, (ns1__wqfxyzj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__jzjsGcsj:
		soap_serialize_PointerTons1__jzjsGcsj(soap, (ns1__jzjsGcsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__jystGcsj:
		soap_serialize_PointerTons1__jystGcsj(soap, (ns1__jystGcsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__lgmhdJgsj:
		soap_serialize_PointerTons1__lgmhdJgsj(soap, (ns1__lgmhdJgsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__jczrylb:
		soap_serialize_PointerTons1__jczrylb(soap, (ns1__jczrylb *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__hjcsyzj:
		soap_serialize_PointerTons1__hjcsyzj(soap, (ns1__hjcsyzj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__btgJgsj:
		soap_serialize_PointerTons1__btgJgsj(soap, (ns1__btgJgsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__xxtz:
		soap_serialize_PointerTons1__xxtz(soap, (ns1__xxtz *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDjzt:
		soap_serialize_PointerTons1__getDjzt(soap, (ns1__getDjzt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cgjzj:
		soap_serialize_PointerTons1__cgjzj(soap, (ns1__cgjzj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wtJgsj:
		soap_serialize_PointerTons1__wtJgsj(soap, (ns1__wtJgsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__obdGcsj:
		soap_serialize_PointerTons1__obdGcsj(soap, (ns1__obdGcsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wtGcsj:
		soap_serialize_PointerTons1__wtGcsj(soap, (ns1__wtGcsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__jzjsJgsj:
		soap_serialize_PointerTons1__jzjsJgsj(soap, (ns1__jzjsJgsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDjclxx:
		soap_serialize_PointerTons1__getDjclxx(soap, (ns1__getDjclxx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__lgmhdGcsj:
		soap_serialize_PointerTons1__lgmhdGcsj(soap, (ns1__lgmhdGcsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__obdDjlb:
		soap_serialize_PointerTons1__obdDjlb(soap, (ns1__obdDjlb *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fwqsjtb:
		soap_serialize_PointerTons1__fwqsjtb(soap, (ns1__fwqsjtb *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__lljzj:
		soap_serialize_PointerTons1__lljzj(soap, (ns1__lljzj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__btgGcsj:
		soap_serialize_PointerTons1__btgGcsj(soap, (ns1__btgGcsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ryzfJysj:
		soap_serialize_PointerTons1__ryzfJysj(soap, (ns1__ryzfJysj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wgjcJgsj:
		soap_serialize_PointerTons1__wgjcJgsj(soap, (ns1__wgjcJgsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__jystJgsj:
		soap_serialize_PointerTons1__jystJgsj(soap, (ns1__jystJgsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wqfxybd:
		soap_serialize_PointerTons1__wqfxybd(soap, (ns1__wqfxybd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ydjzj:
		soap_serialize_PointerTons1__ydjzj(soap, (ns1__ydjzj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__obdJgsj:
		soap_serialize_PointerTons1__obdJgsj(soap, (ns1__obdJgsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gkrjbbh:
		soap_serialize_PointerTons1__gkrjbbh(soap, (ns1__gkrjbbh *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getAccessToken:
		soap_serialize_PointerTons1__getAccessToken(soap, (ns1__getAccessToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sdsGcsj:
		soap_serialize_PointerTons1__sdsGcsj(soap, (ns1__sdsGcsj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__wstring:
		soap_serialize_PointerTostd__wstring(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sdsGcsj:
		return (void*)soap_instantiate_ns1__sdsGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sdsGcsjResponse:
		return (void*)soap_instantiate_ns1__sdsGcsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAccessToken:
		return (void*)soap_instantiate_ns1__getAccessToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAccessTokenResponse:
		return (void*)soap_instantiate_ns1__getAccessTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gkrjbbh:
		return (void*)soap_instantiate_ns1__gkrjbbh(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gkrjbbhResponse:
		return (void*)soap_instantiate_ns1__gkrjbbhResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__obdJgsj:
		return (void*)soap_instantiate_ns1__obdJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__obdJgsjResponse:
		return (void*)soap_instantiate_ns1__obdJgsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ydjzj:
		return (void*)soap_instantiate_ns1__ydjzj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ydjzjResponse:
		return (void*)soap_instantiate_ns1__ydjzjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wqfxybd:
		return (void*)soap_instantiate_ns1__wqfxybd(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wqfxybdResponse:
		return (void*)soap_instantiate_ns1__wqfxybdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jystJgsj:
		return (void*)soap_instantiate_ns1__jystJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jystJgsjResponse:
		return (void*)soap_instantiate_ns1__jystJgsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wgjcJgsj:
		return (void*)soap_instantiate_ns1__wgjcJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wgjcJgsjResponse:
		return (void*)soap_instantiate_ns1__wgjcJgsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ryzfJysj:
		return (void*)soap_instantiate_ns1__ryzfJysj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ryzfJysjResponse:
		return (void*)soap_instantiate_ns1__ryzfJysjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__btgGcsj:
		return (void*)soap_instantiate_ns1__btgGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__btgGcsjResponse:
		return (void*)soap_instantiate_ns1__btgGcsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lljzj:
		return (void*)soap_instantiate_ns1__lljzj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lljzjResponse:
		return (void*)soap_instantiate_ns1__lljzjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fwqsjtb:
		return (void*)soap_instantiate_ns1__fwqsjtb(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fwqsjtbResponse:
		return (void*)soap_instantiate_ns1__fwqsjtbResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__obdDjlb:
		return (void*)soap_instantiate_ns1__obdDjlb(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__obdDjlbResponse:
		return (void*)soap_instantiate_ns1__obdDjlbResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lgmhdGcsj:
		return (void*)soap_instantiate_ns1__lgmhdGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lgmhdGcsjResponse:
		return (void*)soap_instantiate_ns1__lgmhdGcsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDjclxx:
		return (void*)soap_instantiate_ns1__getDjclxx(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDjclxxResponse:
		return (void*)soap_instantiate_ns1__getDjclxxResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jzjsJgsj:
		return (void*)soap_instantiate_ns1__jzjsJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jzjsJgsjResponse:
		return (void*)soap_instantiate_ns1__jzjsJgsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wtGcsj:
		return (void*)soap_instantiate_ns1__wtGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wtGcsjResponse:
		return (void*)soap_instantiate_ns1__wtGcsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wtJgsj:
		return (void*)soap_instantiate_ns1__wtJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wtJgsjResponse:
		return (void*)soap_instantiate_ns1__wtJgsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__obdGcsj:
		return (void*)soap_instantiate_ns1__obdGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__obdGcsjResponse:
		return (void*)soap_instantiate_ns1__obdGcsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjzj:
		return (void*)soap_instantiate_ns1__cgjzj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cgjzjResponse:
		return (void*)soap_instantiate_ns1__cgjzjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__xxtz:
		return (void*)soap_instantiate_ns1__xxtz(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__xxtzResponse:
		return (void*)soap_instantiate_ns1__xxtzResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDjzt:
		return (void*)soap_instantiate_ns1__getDjzt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDjztResponse:
		return (void*)soap_instantiate_ns1__getDjztResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__btgJgsj:
		return (void*)soap_instantiate_ns1__btgJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__btgJgsjResponse:
		return (void*)soap_instantiate_ns1__btgJgsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__hjcsyzj:
		return (void*)soap_instantiate_ns1__hjcsyzj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__hjcsyzjResponse:
		return (void*)soap_instantiate_ns1__hjcsyzjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lgmhdJgsj:
		return (void*)soap_instantiate_ns1__lgmhdJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lgmhdJgsjResponse:
		return (void*)soap_instantiate_ns1__lgmhdJgsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jczrylb:
		return (void*)soap_instantiate_ns1__jczrylb(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jczrylbResponse:
		return (void*)soap_instantiate_ns1__jczrylbResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jystGcsj:
		return (void*)soap_instantiate_ns1__jystGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jystGcsjResponse:
		return (void*)soap_instantiate_ns1__jystGcsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jzjsGcsj:
		return (void*)soap_instantiate_ns1__jzjsGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jzjsGcsjResponse:
		return (void*)soap_instantiate_ns1__jzjsGcsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wqfxyzj:
		return (void*)soap_instantiate_ns1__wqfxyzj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wqfxyzjResponse:
		return (void*)soap_instantiate_ns1__wqfxyzjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cycObdIupr:
		return (void*)soap_instantiate_ns1__cycObdIupr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cycObdIuprResponse:
		return (void*)soap_instantiate_ns1__cycObdIuprResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sdsJgsj:
		return (void*)soap_instantiate_ns1__sdsJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sdsJgsjResponse:
		return (void*)soap_instantiate_ns1__sdsJgsjResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__qycObdIupr:
		return (void*)soap_instantiate_ns1__qycObdIupr(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__qycObdIuprResponse:
		return (void*)soap_instantiate_ns1__qycObdIuprResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sdsGcsj:
		return (void*)soap_instantiate___ns1__sdsGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAccessToken:
		return (void*)soap_instantiate___ns1__getAccessToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__gkrjbbh:
		return (void*)soap_instantiate___ns1__gkrjbbh(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__obdJgsj:
		return (void*)soap_instantiate___ns1__obdJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ydjzj:
		return (void*)soap_instantiate___ns1__ydjzj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__wqfxybd:
		return (void*)soap_instantiate___ns1__wqfxybd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__jystJgsj:
		return (void*)soap_instantiate___ns1__jystJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__wgjcJgsj:
		return (void*)soap_instantiate___ns1__wgjcJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ryzfJysj:
		return (void*)soap_instantiate___ns1__ryzfJysj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__btgGcsj:
		return (void*)soap_instantiate___ns1__btgGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lljzj:
		return (void*)soap_instantiate___ns1__lljzj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__fwqsjtb:
		return (void*)soap_instantiate___ns1__fwqsjtb(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__obdDjlb:
		return (void*)soap_instantiate___ns1__obdDjlb(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lgmhdGcsj:
		return (void*)soap_instantiate___ns1__lgmhdGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDjclxx:
		return (void*)soap_instantiate___ns1__getDjclxx(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__jzjsJgsj:
		return (void*)soap_instantiate___ns1__jzjsJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__wtGcsj:
		return (void*)soap_instantiate___ns1__wtGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__obdGcsj:
		return (void*)soap_instantiate___ns1__obdGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__wtJgsj:
		return (void*)soap_instantiate___ns1__wtJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cgjzj:
		return (void*)soap_instantiate___ns1__cgjzj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDjzt:
		return (void*)soap_instantiate___ns1__getDjzt(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__xxtz:
		return (void*)soap_instantiate___ns1__xxtz(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__btgJgsj:
		return (void*)soap_instantiate___ns1__btgJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__hjcsyzj:
		return (void*)soap_instantiate___ns1__hjcsyzj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__jczrylb:
		return (void*)soap_instantiate___ns1__jczrylb(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lgmhdJgsj:
		return (void*)soap_instantiate___ns1__lgmhdJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__jystGcsj:
		return (void*)soap_instantiate___ns1__jystGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__jzjsGcsj:
		return (void*)soap_instantiate___ns1__jzjsGcsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__wqfxyzj:
		return (void*)soap_instantiate___ns1__wqfxyzj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cycObdIupr:
		return (void*)soap_instantiate___ns1__cycObdIupr(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sdsJgsj:
		return (void*)soap_instantiate___ns1__sdsJgsj(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__qycObdIupr:
		return (void*)soap_instantiate___ns1__qycObdIupr(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sdsGcsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__sdsGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sdsGcsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sdsGcsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__sdsGcsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sdsGcsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAccessToken:
		if (p->size < 0)
			SOAP_DELETE((ns1__getAccessToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getAccessToken*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAccessTokenResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getAccessTokenResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getAccessTokenResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__gkrjbbh:
		if (p->size < 0)
			SOAP_DELETE((ns1__gkrjbbh*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__gkrjbbh*)p->ptr);
		break;
	case SOAP_TYPE_ns1__gkrjbbhResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__gkrjbbhResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__gkrjbbhResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__obdJgsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__obdJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__obdJgsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__obdJgsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__obdJgsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__obdJgsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ydjzj:
		if (p->size < 0)
			SOAP_DELETE((ns1__ydjzj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ydjzj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ydjzjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__ydjzjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ydjzjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wqfxybd:
		if (p->size < 0)
			SOAP_DELETE((ns1__wqfxybd*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wqfxybd*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wqfxybdResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__wqfxybdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wqfxybdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jystJgsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__jystJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__jystJgsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jystJgsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__jystJgsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__jystJgsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wgjcJgsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__wgjcJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wgjcJgsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wgjcJgsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__wgjcJgsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wgjcJgsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ryzfJysj:
		if (p->size < 0)
			SOAP_DELETE((ns1__ryzfJysj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ryzfJysj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ryzfJysjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__ryzfJysjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ryzfJysjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__btgGcsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__btgGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__btgGcsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__btgGcsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__btgGcsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__btgGcsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lljzj:
		if (p->size < 0)
			SOAP_DELETE((ns1__lljzj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lljzj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lljzjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__lljzjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lljzjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__fwqsjtb:
		if (p->size < 0)
			SOAP_DELETE((ns1__fwqsjtb*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__fwqsjtb*)p->ptr);
		break;
	case SOAP_TYPE_ns1__fwqsjtbResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__fwqsjtbResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__fwqsjtbResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__obdDjlb:
		if (p->size < 0)
			SOAP_DELETE((ns1__obdDjlb*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__obdDjlb*)p->ptr);
		break;
	case SOAP_TYPE_ns1__obdDjlbResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__obdDjlbResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__obdDjlbResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lgmhdGcsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__lgmhdGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lgmhdGcsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lgmhdGcsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__lgmhdGcsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lgmhdGcsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDjclxx:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDjclxx*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDjclxx*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDjclxxResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDjclxxResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDjclxxResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jzjsJgsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__jzjsJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__jzjsJgsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jzjsJgsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__jzjsJgsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__jzjsJgsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wtGcsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__wtGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wtGcsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wtGcsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__wtGcsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wtGcsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wtJgsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__wtJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wtJgsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wtJgsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__wtJgsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wtJgsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__obdGcsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__obdGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__obdGcsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__obdGcsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__obdGcsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__obdGcsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjzj:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjzj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjzj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cgjzjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__cgjzjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cgjzjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__xxtz:
		if (p->size < 0)
			SOAP_DELETE((ns1__xxtz*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__xxtz*)p->ptr);
		break;
	case SOAP_TYPE_ns1__xxtzResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__xxtzResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__xxtzResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDjzt:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDjzt*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDjzt*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDjztResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDjztResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDjztResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__btgJgsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__btgJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__btgJgsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__btgJgsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__btgJgsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__btgJgsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__hjcsyzj:
		if (p->size < 0)
			SOAP_DELETE((ns1__hjcsyzj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__hjcsyzj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__hjcsyzjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__hjcsyzjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__hjcsyzjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lgmhdJgsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__lgmhdJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lgmhdJgsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lgmhdJgsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__lgmhdJgsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lgmhdJgsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jczrylb:
		if (p->size < 0)
			SOAP_DELETE((ns1__jczrylb*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__jczrylb*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jczrylbResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__jczrylbResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__jczrylbResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jystGcsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__jystGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__jystGcsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jystGcsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__jystGcsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__jystGcsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jzjsGcsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__jzjsGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__jzjsGcsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jzjsGcsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__jzjsGcsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__jzjsGcsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wqfxyzj:
		if (p->size < 0)
			SOAP_DELETE((ns1__wqfxyzj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wqfxyzj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wqfxyzjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__wqfxyzjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wqfxyzjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cycObdIupr:
		if (p->size < 0)
			SOAP_DELETE((ns1__cycObdIupr*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cycObdIupr*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cycObdIuprResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__cycObdIuprResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cycObdIuprResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sdsJgsj:
		if (p->size < 0)
			SOAP_DELETE((ns1__sdsJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sdsJgsj*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sdsJgsjResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__sdsJgsjResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sdsJgsjResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__qycObdIupr:
		if (p->size < 0)
			SOAP_DELETE((ns1__qycObdIupr*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__qycObdIupr*)p->ptr);
		break;
	case SOAP_TYPE_ns1__qycObdIuprResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__qycObdIuprResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__qycObdIuprResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sdsGcsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sdsGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sdsGcsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAccessToken:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAccessToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAccessToken*)p->ptr);
		break;
	case SOAP_TYPE___ns1__gkrjbbh:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__gkrjbbh*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__gkrjbbh*)p->ptr);
		break;
	case SOAP_TYPE___ns1__obdJgsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__obdJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__obdJgsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__ydjzj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__ydjzj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__ydjzj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__wqfxybd:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__wqfxybd*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__wqfxybd*)p->ptr);
		break;
	case SOAP_TYPE___ns1__jystJgsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__jystJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__jystJgsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__wgjcJgsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__wgjcJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__wgjcJgsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__ryzfJysj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__ryzfJysj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__ryzfJysj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__btgGcsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__btgGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__btgGcsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lljzj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lljzj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lljzj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__fwqsjtb:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__fwqsjtb*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__fwqsjtb*)p->ptr);
		break;
	case SOAP_TYPE___ns1__obdDjlb:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__obdDjlb*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__obdDjlb*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lgmhdGcsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lgmhdGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lgmhdGcsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDjclxx:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDjclxx*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDjclxx*)p->ptr);
		break;
	case SOAP_TYPE___ns1__jzjsJgsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__jzjsJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__jzjsJgsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__wtGcsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__wtGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__wtGcsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__obdGcsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__obdGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__obdGcsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__wtJgsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__wtJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__wtJgsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cgjzj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cgjzj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cgjzj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDjzt:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDjzt*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDjzt*)p->ptr);
		break;
	case SOAP_TYPE___ns1__xxtz:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__xxtz*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__xxtz*)p->ptr);
		break;
	case SOAP_TYPE___ns1__btgJgsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__btgJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__btgJgsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__hjcsyzj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__hjcsyzj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__hjcsyzj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__jczrylb:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__jczrylb*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__jczrylb*)p->ptr);
		break;
	case SOAP_TYPE___ns1__lgmhdJgsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__lgmhdJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__lgmhdJgsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__jystGcsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__jystGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__jystGcsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__jzjsGcsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__jzjsGcsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__jzjsGcsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__wqfxyzj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__wqfxyzj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__wqfxyzj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cycObdIupr:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cycObdIupr*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cycObdIupr*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sdsJgsj:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sdsJgsj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sdsJgsj*)p->ptr);
		break;
	case SOAP_TYPE___ns1__qycObdIupr:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__qycObdIupr*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__qycObdIupr*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_std__wstring, 0, sizeof(std::wstring), 0, soap_copy_std__wstring);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_std__wstring);
	if (soap_out_std__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__wstring, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::wstring);
		if (size)
			*size = sizeof(std::wstring);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::wstring, n);
		if (size)
			*size = n * sizeof(std::wstring);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::wstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::wstring %p -> %p\n", q, p));
	*(std::wstring*)p = *(std::wstring*)q;
}

void ns1__qycObdIuprResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__qycObdIuprResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__qycObdIuprResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qycObdIuprResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__qycObdIuprResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__qycObdIuprResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__qycObdIuprResponse(struct soap *soap, const char *tag, int id, const ns1__qycObdIuprResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__qycObdIuprResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__qycObdIuprResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__qycObdIuprResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__qycObdIuprResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__qycObdIuprResponse * SOAP_FMAC4 soap_in_ns1__qycObdIuprResponse(struct soap *soap, const char *tag, ns1__qycObdIuprResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__qycObdIuprResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__qycObdIuprResponse, sizeof(ns1__qycObdIuprResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__qycObdIuprResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__qycObdIuprResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__qycObdIuprResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__qycObdIuprResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__qycObdIuprResponse, 0, sizeof(ns1__qycObdIuprResponse), 0, soap_copy_ns1__qycObdIuprResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__qycObdIuprResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__qycObdIuprResponse);
	if (this->soap_out(soap, tag?tag:"ns1:qycObdIuprResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__qycObdIuprResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__qycObdIuprResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__qycObdIuprResponse * SOAP_FMAC4 soap_get_ns1__qycObdIuprResponse(struct soap *soap, ns1__qycObdIuprResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__qycObdIuprResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__qycObdIuprResponse * SOAP_FMAC2 soap_instantiate_ns1__qycObdIuprResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__qycObdIuprResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__qycObdIuprResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__qycObdIuprResponse);
		if (size)
			*size = sizeof(ns1__qycObdIuprResponse);
		((ns1__qycObdIuprResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__qycObdIuprResponse, n);
		if (size)
			*size = n * sizeof(ns1__qycObdIuprResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__qycObdIuprResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__qycObdIuprResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__qycObdIuprResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__qycObdIuprResponse %p -> %p\n", q, p));
	*(ns1__qycObdIuprResponse*)p = *(ns1__qycObdIuprResponse*)q;
}

void ns1__qycObdIupr::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__qycObdIupr::lsh = NULL;
	soap_default_int(soap, &this->ns1__qycObdIupr::chqz1jccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::chqz1fhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::chqz1iuprl);
	soap_default_int(soap, &this->ns1__qycObdIupr::chqz2jccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::chqz2fhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::chqz2iuprl);
	soap_default_int(soap, &this->ns1__qycObdIupr::qycgqz1jccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::qycgqz1fhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::qycgqz1iuprl);
	soap_default_int(soap, &this->ns1__qycObdIupr::qycgqz2jccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::qycgqz2fhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::qycgqz2iuprl);
	soap_default_int(soap, &this->ns1__qycObdIupr::hycgqz1jccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::hycgqz1fhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::hycgqz1iuprl);
	soap_default_int(soap, &this->ns1__qycObdIupr::hycgqz2jccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::hycgqz2fhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::hycgqz2iuprl);
	soap_default_int(soap, &this->ns1__qycObdIupr::evapjccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::evapfhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::evapiuprl);
	soap_default_int(soap, &this->ns1__qycObdIupr::egrvvtjccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::egrvvtfhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::egrvvtiuprl);
	soap_default_int(soap, &this->ns1__qycObdIupr::gpfz1jccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::gpfz1fhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::gpfz1iuprl);
	soap_default_int(soap, &this->ns1__qycObdIupr::gpfz2jccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::gpfz2fhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::gpfz2iuprl);
	soap_default_int(soap, &this->ns1__qycObdIupr::eckqpsxtjccs);
	soap_default_int(soap, &this->ns1__qycObdIupr::eckqpsxtfhtjcs);
	soap_default_double(soap, &this->ns1__qycObdIupr::eckqpsxtiuprl);
	/* transient soap skipped */
}

void ns1__qycObdIupr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__qycObdIupr::lsh);
	/* transient soap skipped */
#endif
}

int ns1__qycObdIupr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__qycObdIupr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__qycObdIupr(struct soap *soap, const char *tag, int id, const ns1__qycObdIupr *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__qycObdIupr), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__qycObdIupr::lsh), ""))
		return soap->error;
	if (soap_out_int(soap, "chqz1jccs", -1, &(a->ns1__qycObdIupr::chqz1jccs), ""))
		return soap->error;
	if (soap_out_int(soap, "chqz1fhtjcs", -1, &(a->ns1__qycObdIupr::chqz1fhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "chqz1iuprl", -1, &(a->ns1__qycObdIupr::chqz1iuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "chqz2jccs", -1, &(a->ns1__qycObdIupr::chqz2jccs), ""))
		return soap->error;
	if (soap_out_int(soap, "chqz2fhtjcs", -1, &(a->ns1__qycObdIupr::chqz2fhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "chqz2iuprl", -1, &(a->ns1__qycObdIupr::chqz2iuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "qycgqz1jccs", -1, &(a->ns1__qycObdIupr::qycgqz1jccs), ""))
		return soap->error;
	if (soap_out_int(soap, "qycgqz1fhtjcs", -1, &(a->ns1__qycObdIupr::qycgqz1fhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "qycgqz1iuprl", -1, &(a->ns1__qycObdIupr::qycgqz1iuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "qycgqz2jccs", -1, &(a->ns1__qycObdIupr::qycgqz2jccs), ""))
		return soap->error;
	if (soap_out_int(soap, "qycgqz2fhtjcs", -1, &(a->ns1__qycObdIupr::qycgqz2fhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "qycgqz2iuprl", -1, &(a->ns1__qycObdIupr::qycgqz2iuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "hycgqz1jccs", -1, &(a->ns1__qycObdIupr::hycgqz1jccs), ""))
		return soap->error;
	if (soap_out_int(soap, "hycgqz1fhtjcs", -1, &(a->ns1__qycObdIupr::hycgqz1fhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "hycgqz1iuprl", -1, &(a->ns1__qycObdIupr::hycgqz1iuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "hycgqz2jccs", -1, &(a->ns1__qycObdIupr::hycgqz2jccs), ""))
		return soap->error;
	if (soap_out_int(soap, "hycgqz2fhtjcs", -1, &(a->ns1__qycObdIupr::hycgqz2fhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "hycgqz2iuprl", -1, &(a->ns1__qycObdIupr::hycgqz2iuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "evapjccs", -1, &(a->ns1__qycObdIupr::evapjccs), ""))
		return soap->error;
	if (soap_out_int(soap, "evapfhtjcs", -1, &(a->ns1__qycObdIupr::evapfhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "evapiuprl", -1, &(a->ns1__qycObdIupr::evapiuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "egrvvtjccs", -1, &(a->ns1__qycObdIupr::egrvvtjccs), ""))
		return soap->error;
	if (soap_out_int(soap, "egrvvtfhtjcs", -1, &(a->ns1__qycObdIupr::egrvvtfhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "egrvvtiuprl", -1, &(a->ns1__qycObdIupr::egrvvtiuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "gpfz1jccs", -1, &(a->ns1__qycObdIupr::gpfz1jccs), ""))
		return soap->error;
	if (soap_out_int(soap, "gpfz1fhtjcs", -1, &(a->ns1__qycObdIupr::gpfz1fhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "gpfz1iuprl", -1, &(a->ns1__qycObdIupr::gpfz1iuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "gpfz2jccs", -1, &(a->ns1__qycObdIupr::gpfz2jccs), ""))
		return soap->error;
	if (soap_out_int(soap, "gpfz2fhtjcs", -1, &(a->ns1__qycObdIupr::gpfz2fhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "gpfz2iuprl", -1, &(a->ns1__qycObdIupr::gpfz2iuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "eckqpsxtjccs", -1, &(a->ns1__qycObdIupr::eckqpsxtjccs), ""))
		return soap->error;
	if (soap_out_int(soap, "eckqpsxtfhtjcs", -1, &(a->ns1__qycObdIupr::eckqpsxtfhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "eckqpsxtiuprl", -1, &(a->ns1__qycObdIupr::eckqpsxtiuprl), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__qycObdIupr::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__qycObdIupr(soap, tag, this, type);
}

SOAP_FMAC3 ns1__qycObdIupr * SOAP_FMAC4 soap_in_ns1__qycObdIupr(struct soap *soap, const char *tag, ns1__qycObdIupr *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__qycObdIupr *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__qycObdIupr, sizeof(ns1__qycObdIupr), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__qycObdIupr)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__qycObdIupr *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_chqz1jccs1 = 1;
	size_t soap_flag_chqz1fhtjcs1 = 1;
	size_t soap_flag_chqz1iuprl1 = 1;
	size_t soap_flag_chqz2jccs1 = 1;
	size_t soap_flag_chqz2fhtjcs1 = 1;
	size_t soap_flag_chqz2iuprl1 = 1;
	size_t soap_flag_qycgqz1jccs1 = 1;
	size_t soap_flag_qycgqz1fhtjcs1 = 1;
	size_t soap_flag_qycgqz1iuprl1 = 1;
	size_t soap_flag_qycgqz2jccs1 = 1;
	size_t soap_flag_qycgqz2fhtjcs1 = 1;
	size_t soap_flag_qycgqz2iuprl1 = 1;
	size_t soap_flag_hycgqz1jccs1 = 1;
	size_t soap_flag_hycgqz1fhtjcs1 = 1;
	size_t soap_flag_hycgqz1iuprl1 = 1;
	size_t soap_flag_hycgqz2jccs1 = 1;
	size_t soap_flag_hycgqz2fhtjcs1 = 1;
	size_t soap_flag_hycgqz2iuprl1 = 1;
	size_t soap_flag_evapjccs1 = 1;
	size_t soap_flag_evapfhtjcs1 = 1;
	size_t soap_flag_evapiuprl1 = 1;
	size_t soap_flag_egrvvtjccs1 = 1;
	size_t soap_flag_egrvvtfhtjcs1 = 1;
	size_t soap_flag_egrvvtiuprl1 = 1;
	size_t soap_flag_gpfz1jccs1 = 1;
	size_t soap_flag_gpfz1fhtjcs1 = 1;
	size_t soap_flag_gpfz1iuprl1 = 1;
	size_t soap_flag_gpfz2jccs1 = 1;
	size_t soap_flag_gpfz2fhtjcs1 = 1;
	size_t soap_flag_gpfz2iuprl1 = 1;
	size_t soap_flag_eckqpsxtjccs1 = 1;
	size_t soap_flag_eckqpsxtfhtjcs1 = 1;
	size_t soap_flag_eckqpsxtiuprl1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__qycObdIupr::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_chqz1jccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chqz1jccs", &(a->ns1__qycObdIupr::chqz1jccs), "xsd:int"))
				{	soap_flag_chqz1jccs1--;
					continue;
				}
			if (soap_flag_chqz1fhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chqz1fhtjcs", &(a->ns1__qycObdIupr::chqz1fhtjcs), "xsd:int"))
				{	soap_flag_chqz1fhtjcs1--;
					continue;
				}
			if (soap_flag_chqz1iuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "chqz1iuprl", &(a->ns1__qycObdIupr::chqz1iuprl), "xsd:double"))
				{	soap_flag_chqz1iuprl1--;
					continue;
				}
			if (soap_flag_chqz2jccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chqz2jccs", &(a->ns1__qycObdIupr::chqz2jccs), "xsd:int"))
				{	soap_flag_chqz2jccs1--;
					continue;
				}
			if (soap_flag_chqz2fhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "chqz2fhtjcs", &(a->ns1__qycObdIupr::chqz2fhtjcs), "xsd:int"))
				{	soap_flag_chqz2fhtjcs1--;
					continue;
				}
			if (soap_flag_chqz2iuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "chqz2iuprl", &(a->ns1__qycObdIupr::chqz2iuprl), "xsd:double"))
				{	soap_flag_chqz2iuprl1--;
					continue;
				}
			if (soap_flag_qycgqz1jccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "qycgqz1jccs", &(a->ns1__qycObdIupr::qycgqz1jccs), "xsd:int"))
				{	soap_flag_qycgqz1jccs1--;
					continue;
				}
			if (soap_flag_qycgqz1fhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "qycgqz1fhtjcs", &(a->ns1__qycObdIupr::qycgqz1fhtjcs), "xsd:int"))
				{	soap_flag_qycgqz1fhtjcs1--;
					continue;
				}
			if (soap_flag_qycgqz1iuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "qycgqz1iuprl", &(a->ns1__qycObdIupr::qycgqz1iuprl), "xsd:double"))
				{	soap_flag_qycgqz1iuprl1--;
					continue;
				}
			if (soap_flag_qycgqz2jccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "qycgqz2jccs", &(a->ns1__qycObdIupr::qycgqz2jccs), "xsd:int"))
				{	soap_flag_qycgqz2jccs1--;
					continue;
				}
			if (soap_flag_qycgqz2fhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "qycgqz2fhtjcs", &(a->ns1__qycObdIupr::qycgqz2fhtjcs), "xsd:int"))
				{	soap_flag_qycgqz2fhtjcs1--;
					continue;
				}
			if (soap_flag_qycgqz2iuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "qycgqz2iuprl", &(a->ns1__qycObdIupr::qycgqz2iuprl), "xsd:double"))
				{	soap_flag_qycgqz2iuprl1--;
					continue;
				}
			if (soap_flag_hycgqz1jccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "hycgqz1jccs", &(a->ns1__qycObdIupr::hycgqz1jccs), "xsd:int"))
				{	soap_flag_hycgqz1jccs1--;
					continue;
				}
			if (soap_flag_hycgqz1fhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "hycgqz1fhtjcs", &(a->ns1__qycObdIupr::hycgqz1fhtjcs), "xsd:int"))
				{	soap_flag_hycgqz1fhtjcs1--;
					continue;
				}
			if (soap_flag_hycgqz1iuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hycgqz1iuprl", &(a->ns1__qycObdIupr::hycgqz1iuprl), "xsd:double"))
				{	soap_flag_hycgqz1iuprl1--;
					continue;
				}
			if (soap_flag_hycgqz2jccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "hycgqz2jccs", &(a->ns1__qycObdIupr::hycgqz2jccs), "xsd:int"))
				{	soap_flag_hycgqz2jccs1--;
					continue;
				}
			if (soap_flag_hycgqz2fhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "hycgqz2fhtjcs", &(a->ns1__qycObdIupr::hycgqz2fhtjcs), "xsd:int"))
				{	soap_flag_hycgqz2fhtjcs1--;
					continue;
				}
			if (soap_flag_hycgqz2iuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hycgqz2iuprl", &(a->ns1__qycObdIupr::hycgqz2iuprl), "xsd:double"))
				{	soap_flag_hycgqz2iuprl1--;
					continue;
				}
			if (soap_flag_evapjccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "evapjccs", &(a->ns1__qycObdIupr::evapjccs), "xsd:int"))
				{	soap_flag_evapjccs1--;
					continue;
				}
			if (soap_flag_evapfhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "evapfhtjcs", &(a->ns1__qycObdIupr::evapfhtjcs), "xsd:int"))
				{	soap_flag_evapfhtjcs1--;
					continue;
				}
			if (soap_flag_evapiuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "evapiuprl", &(a->ns1__qycObdIupr::evapiuprl), "xsd:double"))
				{	soap_flag_evapiuprl1--;
					continue;
				}
			if (soap_flag_egrvvtjccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "egrvvtjccs", &(a->ns1__qycObdIupr::egrvvtjccs), "xsd:int"))
				{	soap_flag_egrvvtjccs1--;
					continue;
				}
			if (soap_flag_egrvvtfhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "egrvvtfhtjcs", &(a->ns1__qycObdIupr::egrvvtfhtjcs), "xsd:int"))
				{	soap_flag_egrvvtfhtjcs1--;
					continue;
				}
			if (soap_flag_egrvvtiuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "egrvvtiuprl", &(a->ns1__qycObdIupr::egrvvtiuprl), "xsd:double"))
				{	soap_flag_egrvvtiuprl1--;
					continue;
				}
			if (soap_flag_gpfz1jccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "gpfz1jccs", &(a->ns1__qycObdIupr::gpfz1jccs), "xsd:int"))
				{	soap_flag_gpfz1jccs1--;
					continue;
				}
			if (soap_flag_gpfz1fhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "gpfz1fhtjcs", &(a->ns1__qycObdIupr::gpfz1fhtjcs), "xsd:int"))
				{	soap_flag_gpfz1fhtjcs1--;
					continue;
				}
			if (soap_flag_gpfz1iuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gpfz1iuprl", &(a->ns1__qycObdIupr::gpfz1iuprl), "xsd:double"))
				{	soap_flag_gpfz1iuprl1--;
					continue;
				}
			if (soap_flag_gpfz2jccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "gpfz2jccs", &(a->ns1__qycObdIupr::gpfz2jccs), "xsd:int"))
				{	soap_flag_gpfz2jccs1--;
					continue;
				}
			if (soap_flag_gpfz2fhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "gpfz2fhtjcs", &(a->ns1__qycObdIupr::gpfz2fhtjcs), "xsd:int"))
				{	soap_flag_gpfz2fhtjcs1--;
					continue;
				}
			if (soap_flag_gpfz2iuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gpfz2iuprl", &(a->ns1__qycObdIupr::gpfz2iuprl), "xsd:double"))
				{	soap_flag_gpfz2iuprl1--;
					continue;
				}
			if (soap_flag_eckqpsxtjccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "eckqpsxtjccs", &(a->ns1__qycObdIupr::eckqpsxtjccs), "xsd:int"))
				{	soap_flag_eckqpsxtjccs1--;
					continue;
				}
			if (soap_flag_eckqpsxtfhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "eckqpsxtfhtjcs", &(a->ns1__qycObdIupr::eckqpsxtfhtjcs), "xsd:int"))
				{	soap_flag_eckqpsxtfhtjcs1--;
					continue;
				}
			if (soap_flag_eckqpsxtiuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "eckqpsxtiuprl", &(a->ns1__qycObdIupr::eckqpsxtiuprl), "xsd:double"))
				{	soap_flag_eckqpsxtiuprl1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__qycObdIupr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__qycObdIupr, 0, sizeof(ns1__qycObdIupr), 0, soap_copy_ns1__qycObdIupr);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_chqz1jccs1 > 0 || soap_flag_chqz1fhtjcs1 > 0 || soap_flag_chqz1iuprl1 > 0 || soap_flag_chqz2jccs1 > 0 || soap_flag_chqz2fhtjcs1 > 0 || soap_flag_chqz2iuprl1 > 0 || soap_flag_qycgqz1jccs1 > 0 || soap_flag_qycgqz1fhtjcs1 > 0 || soap_flag_qycgqz1iuprl1 > 0 || soap_flag_qycgqz2jccs1 > 0 || soap_flag_qycgqz2fhtjcs1 > 0 || soap_flag_qycgqz2iuprl1 > 0 || soap_flag_hycgqz1jccs1 > 0 || soap_flag_hycgqz1fhtjcs1 > 0 || soap_flag_hycgqz1iuprl1 > 0 || soap_flag_hycgqz2jccs1 > 0 || soap_flag_hycgqz2fhtjcs1 > 0 || soap_flag_hycgqz2iuprl1 > 0 || soap_flag_evapjccs1 > 0 || soap_flag_evapfhtjcs1 > 0 || soap_flag_evapiuprl1 > 0 || soap_flag_egrvvtjccs1 > 0 || soap_flag_egrvvtfhtjcs1 > 0 || soap_flag_egrvvtiuprl1 > 0 || soap_flag_gpfz1jccs1 > 0 || soap_flag_gpfz1fhtjcs1 > 0 || soap_flag_gpfz1iuprl1 > 0 || soap_flag_gpfz2jccs1 > 0 || soap_flag_gpfz2fhtjcs1 > 0 || soap_flag_gpfz2iuprl1 > 0 || soap_flag_eckqpsxtjccs1 > 0 || soap_flag_eckqpsxtfhtjcs1 > 0 || soap_flag_eckqpsxtiuprl1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__qycObdIupr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__qycObdIupr);
	if (this->soap_out(soap, tag?tag:"ns1:qycObdIupr", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__qycObdIupr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__qycObdIupr(soap, this, tag, type);
}

SOAP_FMAC3 ns1__qycObdIupr * SOAP_FMAC4 soap_get_ns1__qycObdIupr(struct soap *soap, ns1__qycObdIupr *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__qycObdIupr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__qycObdIupr * SOAP_FMAC2 soap_instantiate_ns1__qycObdIupr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__qycObdIupr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__qycObdIupr, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__qycObdIupr);
		if (size)
			*size = sizeof(ns1__qycObdIupr);
		((ns1__qycObdIupr*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__qycObdIupr, n);
		if (size)
			*size = n * sizeof(ns1__qycObdIupr);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__qycObdIupr*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__qycObdIupr*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__qycObdIupr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__qycObdIupr %p -> %p\n", q, p));
	*(ns1__qycObdIupr*)p = *(ns1__qycObdIupr*)q;
}

void ns1__sdsJgsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sdsJgsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__sdsJgsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsJgsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__sdsJgsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sdsJgsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sdsJgsjResponse(struct soap *soap, const char *tag, int id, const ns1__sdsJgsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sdsJgsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__sdsJgsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sdsJgsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sdsJgsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sdsJgsjResponse * SOAP_FMAC4 soap_in_ns1__sdsJgsjResponse(struct soap *soap, const char *tag, ns1__sdsJgsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sdsJgsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sdsJgsjResponse, sizeof(ns1__sdsJgsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sdsJgsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sdsJgsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__sdsJgsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sdsJgsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sdsJgsjResponse, 0, sizeof(ns1__sdsJgsjResponse), 0, soap_copy_ns1__sdsJgsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__sdsJgsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__sdsJgsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:sdsJgsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sdsJgsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sdsJgsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sdsJgsjResponse * SOAP_FMAC4 soap_get_ns1__sdsJgsjResponse(struct soap *soap, ns1__sdsJgsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sdsJgsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sdsJgsjResponse * SOAP_FMAC2 soap_instantiate_ns1__sdsJgsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sdsJgsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sdsJgsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sdsJgsjResponse);
		if (size)
			*size = sizeof(ns1__sdsJgsjResponse);
		((ns1__sdsJgsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sdsJgsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__sdsJgsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sdsJgsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sdsJgsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sdsJgsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sdsJgsjResponse %p -> %p\n", q, p));
	*(ns1__sdsJgsjResponse*)p = *(ns1__sdsJgsjResponse*)q;
}

void ns1__sdsJgsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sdsJgsj::lsh = NULL;
	this->ns1__sdsJgsj::accessToken = NULL;
	soap_default_double(soap, &this->ns1__sdsJgsj::dszs);
	soap_default_double(soap, &this->ns1__sdsJgsj::dsyw);
	soap_default_double(soap, &this->ns1__sdsJgsj::gdszs);
	soap_default_double(soap, &this->ns1__sdsJgsj::gdsyw);
	soap_default_double(soap, &this->ns1__sdsJgsj::dsco);
	soap_default_double(soap, &this->ns1__sdsJgsj::dshc);
	soap_default_double(soap, &this->ns1__sdsJgsj::gdsco);
	soap_default_double(soap, &this->ns1__sdsJgsj::gdshc);
	soap_default_double(soap, &this->ns1__sdsJgsj::glkqxs);
	soap_default_double(soap, &this->ns1__sdsJgsj::wd);
	soap_default_double(soap, &this->ns1__sdsJgsj::sd);
	soap_default_double(soap, &this->ns1__sdsJgsj::dqy);
	this->ns1__sdsJgsj::kssj = NULL;
	this->ns1__sdsJgsj::jssj = NULL;
	/* transient soap skipped */
}

void ns1__sdsJgsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsJgsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsJgsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsJgsj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsJgsj::jssj);
	/* transient soap skipped */
#endif
}

int ns1__sdsJgsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sdsJgsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sdsJgsj(struct soap *soap, const char *tag, int id, const ns1__sdsJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sdsJgsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__sdsJgsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__sdsJgsj::accessToken), ""))
		return soap->error;
	if (soap_out_double(soap, "dszs", -1, &(a->ns1__sdsJgsj::dszs), ""))
		return soap->error;
	if (soap_out_double(soap, "dsyw", -1, &(a->ns1__sdsJgsj::dsyw), ""))
		return soap->error;
	if (soap_out_double(soap, "gdszs", -1, &(a->ns1__sdsJgsj::gdszs), ""))
		return soap->error;
	if (soap_out_double(soap, "gdsyw", -1, &(a->ns1__sdsJgsj::gdsyw), ""))
		return soap->error;
	if (soap_out_double(soap, "dsco", -1, &(a->ns1__sdsJgsj::dsco), ""))
		return soap->error;
	if (soap_out_double(soap, "dshc", -1, &(a->ns1__sdsJgsj::dshc), ""))
		return soap->error;
	if (soap_out_double(soap, "gdsco", -1, &(a->ns1__sdsJgsj::gdsco), ""))
		return soap->error;
	if (soap_out_double(soap, "gdshc", -1, &(a->ns1__sdsJgsj::gdshc), ""))
		return soap->error;
	if (soap_out_double(soap, "glkqxs", -1, &(a->ns1__sdsJgsj::glkqxs), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__sdsJgsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__sdsJgsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__sdsJgsj::dqy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__sdsJgsj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__sdsJgsj::jssj), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sdsJgsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sdsJgsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sdsJgsj * SOAP_FMAC4 soap_in_ns1__sdsJgsj(struct soap *soap, const char *tag, ns1__sdsJgsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sdsJgsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sdsJgsj, sizeof(ns1__sdsJgsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sdsJgsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sdsJgsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_dszs1 = 1;
	size_t soap_flag_dsyw1 = 1;
	size_t soap_flag_gdszs1 = 1;
	size_t soap_flag_gdsyw1 = 1;
	size_t soap_flag_dsco1 = 1;
	size_t soap_flag_dshc1 = 1;
	size_t soap_flag_gdsco1 = 1;
	size_t soap_flag_gdshc1 = 1;
	size_t soap_flag_glkqxs1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__sdsJgsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__sdsJgsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_dszs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dszs", &(a->ns1__sdsJgsj::dszs), "xsd:double"))
				{	soap_flag_dszs1--;
					continue;
				}
			if (soap_flag_dsyw1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dsyw", &(a->ns1__sdsJgsj::dsyw), "xsd:double"))
				{	soap_flag_dsyw1--;
					continue;
				}
			if (soap_flag_gdszs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gdszs", &(a->ns1__sdsJgsj::gdszs), "xsd:double"))
				{	soap_flag_gdszs1--;
					continue;
				}
			if (soap_flag_gdsyw1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gdsyw", &(a->ns1__sdsJgsj::gdsyw), "xsd:double"))
				{	soap_flag_gdsyw1--;
					continue;
				}
			if (soap_flag_dsco1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dsco", &(a->ns1__sdsJgsj::dsco), "xsd:double"))
				{	soap_flag_dsco1--;
					continue;
				}
			if (soap_flag_dshc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dshc", &(a->ns1__sdsJgsj::dshc), "xsd:double"))
				{	soap_flag_dshc1--;
					continue;
				}
			if (soap_flag_gdsco1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gdsco", &(a->ns1__sdsJgsj::gdsco), "xsd:double"))
				{	soap_flag_gdsco1--;
					continue;
				}
			if (soap_flag_gdshc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gdshc", &(a->ns1__sdsJgsj::gdshc), "xsd:double"))
				{	soap_flag_gdshc1--;
					continue;
				}
			if (soap_flag_glkqxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "glkqxs", &(a->ns1__sdsJgsj::glkqxs), "xsd:double"))
				{	soap_flag_glkqxs1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__sdsJgsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__sdsJgsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__sdsJgsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__sdsJgsj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__sdsJgsj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sdsJgsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sdsJgsj, 0, sizeof(ns1__sdsJgsj), 0, soap_copy_ns1__sdsJgsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dszs1 > 0 || soap_flag_dsyw1 > 0 || soap_flag_gdszs1 > 0 || soap_flag_gdsyw1 > 0 || soap_flag_dsco1 > 0 || soap_flag_dshc1 > 0 || soap_flag_gdsco1 > 0 || soap_flag_gdshc1 > 0 || soap_flag_glkqxs1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__sdsJgsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__sdsJgsj);
	if (this->soap_out(soap, tag?tag:"ns1:sdsJgsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sdsJgsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sdsJgsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sdsJgsj * SOAP_FMAC4 soap_get_ns1__sdsJgsj(struct soap *soap, ns1__sdsJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sdsJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sdsJgsj * SOAP_FMAC2 soap_instantiate_ns1__sdsJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sdsJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sdsJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sdsJgsj);
		if (size)
			*size = sizeof(ns1__sdsJgsj);
		((ns1__sdsJgsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sdsJgsj, n);
		if (size)
			*size = n * sizeof(ns1__sdsJgsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sdsJgsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sdsJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sdsJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sdsJgsj %p -> %p\n", q, p));
	*(ns1__sdsJgsj*)p = *(ns1__sdsJgsj*)q;
}

void ns1__cycObdIuprResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__cycObdIuprResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__cycObdIuprResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cycObdIuprResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__cycObdIuprResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cycObdIuprResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cycObdIuprResponse(struct soap *soap, const char *tag, int id, const ns1__cycObdIuprResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cycObdIuprResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__cycObdIuprResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cycObdIuprResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cycObdIuprResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cycObdIuprResponse * SOAP_FMAC4 soap_in_ns1__cycObdIuprResponse(struct soap *soap, const char *tag, ns1__cycObdIuprResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cycObdIuprResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cycObdIuprResponse, sizeof(ns1__cycObdIuprResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cycObdIuprResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cycObdIuprResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__cycObdIuprResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cycObdIuprResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cycObdIuprResponse, 0, sizeof(ns1__cycObdIuprResponse), 0, soap_copy_ns1__cycObdIuprResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__cycObdIuprResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cycObdIuprResponse);
	if (this->soap_out(soap, tag?tag:"ns1:cycObdIuprResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cycObdIuprResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cycObdIuprResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cycObdIuprResponse * SOAP_FMAC4 soap_get_ns1__cycObdIuprResponse(struct soap *soap, ns1__cycObdIuprResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cycObdIuprResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cycObdIuprResponse * SOAP_FMAC2 soap_instantiate_ns1__cycObdIuprResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cycObdIuprResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cycObdIuprResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cycObdIuprResponse);
		if (size)
			*size = sizeof(ns1__cycObdIuprResponse);
		((ns1__cycObdIuprResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cycObdIuprResponse, n);
		if (size)
			*size = n * sizeof(ns1__cycObdIuprResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cycObdIuprResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cycObdIuprResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cycObdIuprResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cycObdIuprResponse %p -> %p\n", q, p));
	*(ns1__cycObdIuprResponse*)p = *(ns1__cycObdIuprResponse*)q;
}

void ns1__cycObdIupr::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__cycObdIupr::lsh = NULL;
	soap_default_int(soap, &this->ns1__cycObdIupr::nmhcchqjccs);
	soap_default_int(soap, &this->ns1__cycObdIupr::nmhcchqfhtjcs);
	soap_default_double(soap, &this->ns1__cycObdIupr::nmhcchqiuprl);
	soap_default_int(soap, &this->ns1__cycObdIupr::noxchqjccs);
	soap_default_int(soap, &this->ns1__cycObdIupr::noxchqfhtjcs);
	soap_default_double(soap, &this->ns1__cycObdIupr::noxchqiuprl);
	soap_default_int(soap, &this->ns1__cycObdIupr::noxxfqjccs);
	soap_default_int(soap, &this->ns1__cycObdIupr::noxxfqfhtjcs);
	soap_default_double(soap, &this->ns1__cycObdIupr::noxxfqiuprl);
	soap_default_int(soap, &this->ns1__cycObdIupr::pmbjqjccs);
	soap_default_int(soap, &this->ns1__cycObdIupr::pmbjqfhtjcs);
	soap_default_double(soap, &this->ns1__cycObdIupr::pmbjqiuprl);
	soap_default_int(soap, &this->ns1__cycObdIupr::fqcgqjccs);
	soap_default_int(soap, &this->ns1__cycObdIupr::fqcgqfhtjcs);
	soap_default_double(soap, &this->ns1__cycObdIupr::fqcgqiuprl);
	soap_default_int(soap, &this->ns1__cycObdIupr::egrvvtjccs);
	soap_default_int(soap, &this->ns1__cycObdIupr::egrvvtfhtjcs);
	soap_default_double(soap, &this->ns1__cycObdIupr::egrvvtiuprl);
	soap_default_int(soap, &this->ns1__cycObdIupr::zyyljccs);
	soap_default_int(soap, &this->ns1__cycObdIupr::zyylfhtjcs);
	soap_default_double(soap, &this->ns1__cycObdIupr::zyyliuprl);
	/* transient soap skipped */
}

void ns1__cycObdIupr::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cycObdIupr::lsh);
	/* transient soap skipped */
#endif
}

int ns1__cycObdIupr::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cycObdIupr(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cycObdIupr(struct soap *soap, const char *tag, int id, const ns1__cycObdIupr *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cycObdIupr), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__cycObdIupr::lsh), ""))
		return soap->error;
	if (soap_out_int(soap, "nmhcchqjccs", -1, &(a->ns1__cycObdIupr::nmhcchqjccs), ""))
		return soap->error;
	if (soap_out_int(soap, "nmhcchqfhtjcs", -1, &(a->ns1__cycObdIupr::nmhcchqfhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "nmhcchqiuprl", -1, &(a->ns1__cycObdIupr::nmhcchqiuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "noxchqjccs", -1, &(a->ns1__cycObdIupr::noxchqjccs), ""))
		return soap->error;
	if (soap_out_int(soap, "noxchqfhtjcs", -1, &(a->ns1__cycObdIupr::noxchqfhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "noxchqiuprl", -1, &(a->ns1__cycObdIupr::noxchqiuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "noxxfqjccs", -1, &(a->ns1__cycObdIupr::noxxfqjccs), ""))
		return soap->error;
	if (soap_out_int(soap, "noxxfqfhtjcs", -1, &(a->ns1__cycObdIupr::noxxfqfhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "noxxfqiuprl", -1, &(a->ns1__cycObdIupr::noxxfqiuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "pmbjqjccs", -1, &(a->ns1__cycObdIupr::pmbjqjccs), ""))
		return soap->error;
	if (soap_out_int(soap, "pmbjqfhtjcs", -1, &(a->ns1__cycObdIupr::pmbjqfhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "pmbjqiuprl", -1, &(a->ns1__cycObdIupr::pmbjqiuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "fqcgqjccs", -1, &(a->ns1__cycObdIupr::fqcgqjccs), ""))
		return soap->error;
	if (soap_out_int(soap, "fqcgqfhtjcs", -1, &(a->ns1__cycObdIupr::fqcgqfhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "fqcgqiuprl", -1, &(a->ns1__cycObdIupr::fqcgqiuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "egrvvtjccs", -1, &(a->ns1__cycObdIupr::egrvvtjccs), ""))
		return soap->error;
	if (soap_out_int(soap, "egrvvtfhtjcs", -1, &(a->ns1__cycObdIupr::egrvvtfhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "egrvvtiuprl", -1, &(a->ns1__cycObdIupr::egrvvtiuprl), ""))
		return soap->error;
	if (soap_out_int(soap, "zyyljccs", -1, &(a->ns1__cycObdIupr::zyyljccs), ""))
		return soap->error;
	if (soap_out_int(soap, "zyylfhtjcs", -1, &(a->ns1__cycObdIupr::zyylfhtjcs), ""))
		return soap->error;
	if (soap_out_double(soap, "zyyliuprl", -1, &(a->ns1__cycObdIupr::zyyliuprl), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cycObdIupr::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cycObdIupr(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cycObdIupr * SOAP_FMAC4 soap_in_ns1__cycObdIupr(struct soap *soap, const char *tag, ns1__cycObdIupr *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cycObdIupr *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cycObdIupr, sizeof(ns1__cycObdIupr), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cycObdIupr)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cycObdIupr *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_nmhcchqjccs1 = 1;
	size_t soap_flag_nmhcchqfhtjcs1 = 1;
	size_t soap_flag_nmhcchqiuprl1 = 1;
	size_t soap_flag_noxchqjccs1 = 1;
	size_t soap_flag_noxchqfhtjcs1 = 1;
	size_t soap_flag_noxchqiuprl1 = 1;
	size_t soap_flag_noxxfqjccs1 = 1;
	size_t soap_flag_noxxfqfhtjcs1 = 1;
	size_t soap_flag_noxxfqiuprl1 = 1;
	size_t soap_flag_pmbjqjccs1 = 1;
	size_t soap_flag_pmbjqfhtjcs1 = 1;
	size_t soap_flag_pmbjqiuprl1 = 1;
	size_t soap_flag_fqcgqjccs1 = 1;
	size_t soap_flag_fqcgqfhtjcs1 = 1;
	size_t soap_flag_fqcgqiuprl1 = 1;
	size_t soap_flag_egrvvtjccs1 = 1;
	size_t soap_flag_egrvvtfhtjcs1 = 1;
	size_t soap_flag_egrvvtiuprl1 = 1;
	size_t soap_flag_zyyljccs1 = 1;
	size_t soap_flag_zyylfhtjcs1 = 1;
	size_t soap_flag_zyyliuprl1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__cycObdIupr::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_nmhcchqjccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nmhcchqjccs", &(a->ns1__cycObdIupr::nmhcchqjccs), "xsd:int"))
				{	soap_flag_nmhcchqjccs1--;
					continue;
				}
			if (soap_flag_nmhcchqfhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nmhcchqfhtjcs", &(a->ns1__cycObdIupr::nmhcchqfhtjcs), "xsd:int"))
				{	soap_flag_nmhcchqfhtjcs1--;
					continue;
				}
			if (soap_flag_nmhcchqiuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nmhcchqiuprl", &(a->ns1__cycObdIupr::nmhcchqiuprl), "xsd:double"))
				{	soap_flag_nmhcchqiuprl1--;
					continue;
				}
			if (soap_flag_noxchqjccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "noxchqjccs", &(a->ns1__cycObdIupr::noxchqjccs), "xsd:int"))
				{	soap_flag_noxchqjccs1--;
					continue;
				}
			if (soap_flag_noxchqfhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "noxchqfhtjcs", &(a->ns1__cycObdIupr::noxchqfhtjcs), "xsd:int"))
				{	soap_flag_noxchqfhtjcs1--;
					continue;
				}
			if (soap_flag_noxchqiuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "noxchqiuprl", &(a->ns1__cycObdIupr::noxchqiuprl), "xsd:double"))
				{	soap_flag_noxchqiuprl1--;
					continue;
				}
			if (soap_flag_noxxfqjccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "noxxfqjccs", &(a->ns1__cycObdIupr::noxxfqjccs), "xsd:int"))
				{	soap_flag_noxxfqjccs1--;
					continue;
				}
			if (soap_flag_noxxfqfhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "noxxfqfhtjcs", &(a->ns1__cycObdIupr::noxxfqfhtjcs), "xsd:int"))
				{	soap_flag_noxxfqfhtjcs1--;
					continue;
				}
			if (soap_flag_noxxfqiuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "noxxfqiuprl", &(a->ns1__cycObdIupr::noxxfqiuprl), "xsd:double"))
				{	soap_flag_noxxfqiuprl1--;
					continue;
				}
			if (soap_flag_pmbjqjccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "pmbjqjccs", &(a->ns1__cycObdIupr::pmbjqjccs), "xsd:int"))
				{	soap_flag_pmbjqjccs1--;
					continue;
				}
			if (soap_flag_pmbjqfhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "pmbjqfhtjcs", &(a->ns1__cycObdIupr::pmbjqfhtjcs), "xsd:int"))
				{	soap_flag_pmbjqfhtjcs1--;
					continue;
				}
			if (soap_flag_pmbjqiuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "pmbjqiuprl", &(a->ns1__cycObdIupr::pmbjqiuprl), "xsd:double"))
				{	soap_flag_pmbjqiuprl1--;
					continue;
				}
			if (soap_flag_fqcgqjccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fqcgqjccs", &(a->ns1__cycObdIupr::fqcgqjccs), "xsd:int"))
				{	soap_flag_fqcgqjccs1--;
					continue;
				}
			if (soap_flag_fqcgqfhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fqcgqfhtjcs", &(a->ns1__cycObdIupr::fqcgqfhtjcs), "xsd:int"))
				{	soap_flag_fqcgqfhtjcs1--;
					continue;
				}
			if (soap_flag_fqcgqiuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fqcgqiuprl", &(a->ns1__cycObdIupr::fqcgqiuprl), "xsd:double"))
				{	soap_flag_fqcgqiuprl1--;
					continue;
				}
			if (soap_flag_egrvvtjccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "egrvvtjccs", &(a->ns1__cycObdIupr::egrvvtjccs), "xsd:int"))
				{	soap_flag_egrvvtjccs1--;
					continue;
				}
			if (soap_flag_egrvvtfhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "egrvvtfhtjcs", &(a->ns1__cycObdIupr::egrvvtfhtjcs), "xsd:int"))
				{	soap_flag_egrvvtfhtjcs1--;
					continue;
				}
			if (soap_flag_egrvvtiuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "egrvvtiuprl", &(a->ns1__cycObdIupr::egrvvtiuprl), "xsd:double"))
				{	soap_flag_egrvvtiuprl1--;
					continue;
				}
			if (soap_flag_zyyljccs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zyyljccs", &(a->ns1__cycObdIupr::zyyljccs), "xsd:int"))
				{	soap_flag_zyyljccs1--;
					continue;
				}
			if (soap_flag_zyylfhtjcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zyylfhtjcs", &(a->ns1__cycObdIupr::zyylfhtjcs), "xsd:int"))
				{	soap_flag_zyylfhtjcs1--;
					continue;
				}
			if (soap_flag_zyyliuprl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zyyliuprl", &(a->ns1__cycObdIupr::zyyliuprl), "xsd:double"))
				{	soap_flag_zyyliuprl1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cycObdIupr *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cycObdIupr, 0, sizeof(ns1__cycObdIupr), 0, soap_copy_ns1__cycObdIupr);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nmhcchqjccs1 > 0 || soap_flag_nmhcchqfhtjcs1 > 0 || soap_flag_nmhcchqiuprl1 > 0 || soap_flag_noxchqjccs1 > 0 || soap_flag_noxchqfhtjcs1 > 0 || soap_flag_noxchqiuprl1 > 0 || soap_flag_noxxfqjccs1 > 0 || soap_flag_noxxfqfhtjcs1 > 0 || soap_flag_noxxfqiuprl1 > 0 || soap_flag_pmbjqjccs1 > 0 || soap_flag_pmbjqfhtjcs1 > 0 || soap_flag_pmbjqiuprl1 > 0 || soap_flag_fqcgqjccs1 > 0 || soap_flag_fqcgqfhtjcs1 > 0 || soap_flag_fqcgqiuprl1 > 0 || soap_flag_egrvvtjccs1 > 0 || soap_flag_egrvvtfhtjcs1 > 0 || soap_flag_egrvvtiuprl1 > 0 || soap_flag_zyyljccs1 > 0 || soap_flag_zyylfhtjcs1 > 0 || soap_flag_zyyliuprl1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cycObdIupr::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cycObdIupr);
	if (this->soap_out(soap, tag?tag:"ns1:cycObdIupr", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cycObdIupr::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cycObdIupr(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cycObdIupr * SOAP_FMAC4 soap_get_ns1__cycObdIupr(struct soap *soap, ns1__cycObdIupr *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cycObdIupr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cycObdIupr * SOAP_FMAC2 soap_instantiate_ns1__cycObdIupr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cycObdIupr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cycObdIupr, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cycObdIupr);
		if (size)
			*size = sizeof(ns1__cycObdIupr);
		((ns1__cycObdIupr*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cycObdIupr, n);
		if (size)
			*size = n * sizeof(ns1__cycObdIupr);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cycObdIupr*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cycObdIupr*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cycObdIupr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cycObdIupr %p -> %p\n", q, p));
	*(ns1__cycObdIupr*)p = *(ns1__cycObdIupr*)q;
}

void ns1__wqfxyzjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wqfxyzjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__wqfxyzjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyzjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__wqfxyzjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wqfxyzjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wqfxyzjResponse(struct soap *soap, const char *tag, int id, const ns1__wqfxyzjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wqfxyzjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__wqfxyzjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wqfxyzjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wqfxyzjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wqfxyzjResponse * SOAP_FMAC4 soap_in_ns1__wqfxyzjResponse(struct soap *soap, const char *tag, ns1__wqfxyzjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wqfxyzjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wqfxyzjResponse, sizeof(ns1__wqfxyzjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wqfxyzjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wqfxyzjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__wqfxyzjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wqfxyzjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wqfxyzjResponse, 0, sizeof(ns1__wqfxyzjResponse), 0, soap_copy_ns1__wqfxyzjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wqfxyzjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wqfxyzjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:wqfxyzjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wqfxyzjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wqfxyzjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wqfxyzjResponse * SOAP_FMAC4 soap_get_ns1__wqfxyzjResponse(struct soap *soap, ns1__wqfxyzjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wqfxyzjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wqfxyzjResponse * SOAP_FMAC2 soap_instantiate_ns1__wqfxyzjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wqfxyzjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wqfxyzjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wqfxyzjResponse);
		if (size)
			*size = sizeof(ns1__wqfxyzjResponse);
		((ns1__wqfxyzjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wqfxyzjResponse, n);
		if (size)
			*size = n * sizeof(ns1__wqfxyzjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wqfxyzjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wqfxyzjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wqfxyzjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wqfxyzjResponse %p -> %p\n", q, p));
	*(ns1__wqfxyzjResponse*)p = *(ns1__wqfxyzjResponse*)q;
}

void ns1__wqfxyzj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wqfxyzj::accessToken = NULL;
	this->ns1__wqfxyzj::jcjg = NULL;
	this->ns1__wqfxyzj::kssj = NULL;
	this->ns1__wqfxyzj::jssj = NULL;
	this->ns1__wqfxyzj::bz = NULL;
	/* transient soap skipped */
}

void ns1__wqfxyzj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyzj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyzj::jcjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyzj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyzj::jssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxyzj::bz);
	/* transient soap skipped */
#endif
}

int ns1__wqfxyzj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wqfxyzj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wqfxyzj(struct soap *soap, const char *tag, int id, const ns1__wqfxyzj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wqfxyzj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__wqfxyzj::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jcjg", -1, &(a->ns1__wqfxyzj::jcjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__wqfxyzj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__wqfxyzj::jssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bz", -1, &(a->ns1__wqfxyzj::bz), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wqfxyzj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wqfxyzj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wqfxyzj * SOAP_FMAC4 soap_in_ns1__wqfxyzj(struct soap *soap, const char *tag, ns1__wqfxyzj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wqfxyzj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wqfxyzj, sizeof(ns1__wqfxyzj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wqfxyzj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wqfxyzj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_jcjg1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	size_t soap_flag_bz1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__wqfxyzj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_jcjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jcjg", &(a->ns1__wqfxyzj::jcjg), "xsd:string"))
				{	soap_flag_jcjg1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__wqfxyzj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__wqfxyzj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			if (soap_flag_bz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bz", &(a->ns1__wqfxyzj::bz), "xsd:string"))
				{	soap_flag_bz1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wqfxyzj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wqfxyzj, 0, sizeof(ns1__wqfxyzj), 0, soap_copy_ns1__wqfxyzj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wqfxyzj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wqfxyzj);
	if (this->soap_out(soap, tag?tag:"ns1:wqfxyzj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wqfxyzj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wqfxyzj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wqfxyzj * SOAP_FMAC4 soap_get_ns1__wqfxyzj(struct soap *soap, ns1__wqfxyzj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wqfxyzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wqfxyzj * SOAP_FMAC2 soap_instantiate_ns1__wqfxyzj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wqfxyzj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wqfxyzj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wqfxyzj);
		if (size)
			*size = sizeof(ns1__wqfxyzj);
		((ns1__wqfxyzj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wqfxyzj, n);
		if (size)
			*size = n * sizeof(ns1__wqfxyzj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wqfxyzj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wqfxyzj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wqfxyzj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wqfxyzj %p -> %p\n", q, p));
	*(ns1__wqfxyzj*)p = *(ns1__wqfxyzj*)q;
}

void ns1__jzjsGcsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__jzjsGcsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__jzjsGcsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jzjsGcsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__jzjsGcsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__jzjsGcsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jzjsGcsjResponse(struct soap *soap, const char *tag, int id, const ns1__jzjsGcsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jzjsGcsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__jzjsGcsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__jzjsGcsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__jzjsGcsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__jzjsGcsjResponse * SOAP_FMAC4 soap_in_ns1__jzjsGcsjResponse(struct soap *soap, const char *tag, ns1__jzjsGcsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__jzjsGcsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jzjsGcsjResponse, sizeof(ns1__jzjsGcsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__jzjsGcsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__jzjsGcsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__jzjsGcsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__jzjsGcsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jzjsGcsjResponse, 0, sizeof(ns1__jzjsGcsjResponse), 0, soap_copy_ns1__jzjsGcsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__jzjsGcsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__jzjsGcsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:jzjsGcsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__jzjsGcsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__jzjsGcsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__jzjsGcsjResponse * SOAP_FMAC4 soap_get_ns1__jzjsGcsjResponse(struct soap *soap, ns1__jzjsGcsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jzjsGcsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__jzjsGcsjResponse * SOAP_FMAC2 soap_instantiate_ns1__jzjsGcsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jzjsGcsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jzjsGcsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__jzjsGcsjResponse);
		if (size)
			*size = sizeof(ns1__jzjsGcsjResponse);
		((ns1__jzjsGcsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__jzjsGcsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__jzjsGcsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__jzjsGcsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__jzjsGcsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jzjsGcsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__jzjsGcsjResponse %p -> %p\n", q, p));
	*(ns1__jzjsGcsjResponse*)p = *(ns1__jzjsGcsjResponse*)q;
}

void ns1__jzjsGcsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__jzjsGcsj::lsh = NULL;
	this->ns1__jzjsGcsj::accessToken = NULL;
	this->ns1__jzjsGcsj::qssx = NULL;
	this->ns1__jzjsGcsj::gklx = NULL;
	soap_default_int(soap, &this->ns1__jzjsGcsj::jcsxh);
	soap_default_double(soap, &this->ns1__jzjsGcsj::gxsxs);
	soap_default_double(soap, &this->ns1__jzjsGcsj::ydz);
	soap_default_double(soap, &this->ns1__jzjsGcsj::sscs);
	soap_default_double(soap, &this->ns1__jzjsGcsj::fdjzs);
	soap_default_double(soap, &this->ns1__jzjsGcsj::nl);
	soap_default_double(soap, &this->ns1__jzjsGcsj::nj);
	soap_default_double(soap, &this->ns1__jzjsGcsj::scgl);
	soap_default_double(soap, &this->ns1__jzjsGcsj::glxzxs);
	soap_default_double(soap, &this->ns1__jzjsGcsj::xzhgl);
	soap_default_double(soap, &this->ns1__jzjsGcsj::nox);
	soap_default_double(soap, &this->ns1__jzjsGcsj::co2);
	soap_default_double(soap, &this->ns1__jzjsGcsj::wd);
	soap_default_double(soap, &this->ns1__jzjsGcsj::sd);
	soap_default_double(soap, &this->ns1__jzjsGcsj::dqy);
	/* transient soap skipped */
}

void ns1__jzjsGcsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jzjsGcsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jzjsGcsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jzjsGcsj::qssx);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jzjsGcsj::gklx);
	/* transient soap skipped */
#endif
}

int ns1__jzjsGcsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__jzjsGcsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jzjsGcsj(struct soap *soap, const char *tag, int id, const ns1__jzjsGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jzjsGcsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__jzjsGcsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__jzjsGcsj::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qssx", -1, &(a->ns1__jzjsGcsj::qssx), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gklx", -1, &(a->ns1__jzjsGcsj::gklx), ""))
		return soap->error;
	if (soap_out_int(soap, "jcsxh", -1, &(a->ns1__jzjsGcsj::jcsxh), ""))
		return soap->error;
	if (soap_out_double(soap, "gxsxs", -1, &(a->ns1__jzjsGcsj::gxsxs), ""))
		return soap->error;
	if (soap_out_double(soap, "ydz", -1, &(a->ns1__jzjsGcsj::ydz), ""))
		return soap->error;
	if (soap_out_double(soap, "sscs", -1, &(a->ns1__jzjsGcsj::sscs), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzs", -1, &(a->ns1__jzjsGcsj::fdjzs), ""))
		return soap->error;
	if (soap_out_double(soap, "nl", -1, &(a->ns1__jzjsGcsj::nl), ""))
		return soap->error;
	if (soap_out_double(soap, "nj", -1, &(a->ns1__jzjsGcsj::nj), ""))
		return soap->error;
	if (soap_out_double(soap, "scgl", -1, &(a->ns1__jzjsGcsj::scgl), ""))
		return soap->error;
	if (soap_out_double(soap, "glxzxs", -1, &(a->ns1__jzjsGcsj::glxzxs), ""))
		return soap->error;
	if (soap_out_double(soap, "xzhgl", -1, &(a->ns1__jzjsGcsj::xzhgl), ""))
		return soap->error;
	if (soap_out_double(soap, "nox", -1, &(a->ns1__jzjsGcsj::nox), ""))
		return soap->error;
	if (soap_out_double(soap, "co2", -1, &(a->ns1__jzjsGcsj::co2), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__jzjsGcsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__jzjsGcsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__jzjsGcsj::dqy), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__jzjsGcsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__jzjsGcsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__jzjsGcsj * SOAP_FMAC4 soap_in_ns1__jzjsGcsj(struct soap *soap, const char *tag, ns1__jzjsGcsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__jzjsGcsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jzjsGcsj, sizeof(ns1__jzjsGcsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__jzjsGcsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__jzjsGcsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_qssx1 = 1;
	size_t soap_flag_gklx1 = 1;
	size_t soap_flag_jcsxh1 = 1;
	size_t soap_flag_gxsxs1 = 1;
	size_t soap_flag_ydz1 = 1;
	size_t soap_flag_sscs1 = 1;
	size_t soap_flag_fdjzs1 = 1;
	size_t soap_flag_nl1 = 1;
	size_t soap_flag_nj1 = 1;
	size_t soap_flag_scgl1 = 1;
	size_t soap_flag_glxzxs1 = 1;
	size_t soap_flag_xzhgl1 = 1;
	size_t soap_flag_nox1 = 1;
	size_t soap_flag_co21 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__jzjsGcsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__jzjsGcsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_qssx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qssx", &(a->ns1__jzjsGcsj::qssx), "xsd:string"))
				{	soap_flag_qssx1--;
					continue;
				}
			if (soap_flag_gklx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gklx", &(a->ns1__jzjsGcsj::gklx), "xsd:string"))
				{	soap_flag_gklx1--;
					continue;
				}
			if (soap_flag_jcsxh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "jcsxh", &(a->ns1__jzjsGcsj::jcsxh), "xsd:int"))
				{	soap_flag_jcsxh1--;
					continue;
				}
			if (soap_flag_gxsxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gxsxs", &(a->ns1__jzjsGcsj::gxsxs), "xsd:double"))
				{	soap_flag_gxsxs1--;
					continue;
				}
			if (soap_flag_ydz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ydz", &(a->ns1__jzjsGcsj::ydz), "xsd:double"))
				{	soap_flag_ydz1--;
					continue;
				}
			if (soap_flag_sscs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sscs", &(a->ns1__jzjsGcsj::sscs), "xsd:double"))
				{	soap_flag_sscs1--;
					continue;
				}
			if (soap_flag_fdjzs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzs", &(a->ns1__jzjsGcsj::fdjzs), "xsd:double"))
				{	soap_flag_fdjzs1--;
					continue;
				}
			if (soap_flag_nl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nl", &(a->ns1__jzjsGcsj::nl), "xsd:double"))
				{	soap_flag_nl1--;
					continue;
				}
			if (soap_flag_nj1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nj", &(a->ns1__jzjsGcsj::nj), "xsd:double"))
				{	soap_flag_nj1--;
					continue;
				}
			if (soap_flag_scgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "scgl", &(a->ns1__jzjsGcsj::scgl), "xsd:double"))
				{	soap_flag_scgl1--;
					continue;
				}
			if (soap_flag_glxzxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "glxzxs", &(a->ns1__jzjsGcsj::glxzxs), "xsd:double"))
				{	soap_flag_glxzxs1--;
					continue;
				}
			if (soap_flag_xzhgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "xzhgl", &(a->ns1__jzjsGcsj::xzhgl), "xsd:double"))
				{	soap_flag_xzhgl1--;
					continue;
				}
			if (soap_flag_nox1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nox", &(a->ns1__jzjsGcsj::nox), "xsd:double"))
				{	soap_flag_nox1--;
					continue;
				}
			if (soap_flag_co21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co2", &(a->ns1__jzjsGcsj::co2), "xsd:double"))
				{	soap_flag_co21--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__jzjsGcsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__jzjsGcsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__jzjsGcsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__jzjsGcsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jzjsGcsj, 0, sizeof(ns1__jzjsGcsj), 0, soap_copy_ns1__jzjsGcsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jcsxh1 > 0 || soap_flag_gxsxs1 > 0 || soap_flag_ydz1 > 0 || soap_flag_sscs1 > 0 || soap_flag_fdjzs1 > 0 || soap_flag_nl1 > 0 || soap_flag_nj1 > 0 || soap_flag_scgl1 > 0 || soap_flag_glxzxs1 > 0 || soap_flag_xzhgl1 > 0 || soap_flag_nox1 > 0 || soap_flag_co21 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__jzjsGcsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__jzjsGcsj);
	if (this->soap_out(soap, tag?tag:"ns1:jzjsGcsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__jzjsGcsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__jzjsGcsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__jzjsGcsj * SOAP_FMAC4 soap_get_ns1__jzjsGcsj(struct soap *soap, ns1__jzjsGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jzjsGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__jzjsGcsj * SOAP_FMAC2 soap_instantiate_ns1__jzjsGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jzjsGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jzjsGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__jzjsGcsj);
		if (size)
			*size = sizeof(ns1__jzjsGcsj);
		((ns1__jzjsGcsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__jzjsGcsj, n);
		if (size)
			*size = n * sizeof(ns1__jzjsGcsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__jzjsGcsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__jzjsGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jzjsGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__jzjsGcsj %p -> %p\n", q, p));
	*(ns1__jzjsGcsj*)p = *(ns1__jzjsGcsj*)q;
}

void ns1__jystGcsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__jystGcsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__jystGcsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jystGcsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__jystGcsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__jystGcsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jystGcsjResponse(struct soap *soap, const char *tag, int id, const ns1__jystGcsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jystGcsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__jystGcsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__jystGcsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__jystGcsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__jystGcsjResponse * SOAP_FMAC4 soap_in_ns1__jystGcsjResponse(struct soap *soap, const char *tag, ns1__jystGcsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__jystGcsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jystGcsjResponse, sizeof(ns1__jystGcsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__jystGcsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__jystGcsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__jystGcsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__jystGcsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jystGcsjResponse, 0, sizeof(ns1__jystGcsjResponse), 0, soap_copy_ns1__jystGcsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__jystGcsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__jystGcsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:jystGcsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__jystGcsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__jystGcsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__jystGcsjResponse * SOAP_FMAC4 soap_get_ns1__jystGcsjResponse(struct soap *soap, ns1__jystGcsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jystGcsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__jystGcsjResponse * SOAP_FMAC2 soap_instantiate_ns1__jystGcsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jystGcsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jystGcsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__jystGcsjResponse);
		if (size)
			*size = sizeof(ns1__jystGcsjResponse);
		((ns1__jystGcsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__jystGcsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__jystGcsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__jystGcsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__jystGcsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jystGcsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__jystGcsjResponse %p -> %p\n", q, p));
	*(ns1__jystGcsjResponse*)p = *(ns1__jystGcsjResponse*)q;
}

void ns1__jystGcsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__jystGcsj::lsh = NULL;
	this->ns1__jystGcsj::accessToken = NULL;
	this->ns1__jystGcsj::qssx = NULL;
	this->ns1__jystGcsj::gklx = NULL;
	soap_default_int(soap, &this->ns1__jystGcsj::jcsxh);
	soap_default_double(soap, &this->ns1__jystGcsj::wxzhc);
	soap_default_double(soap, &this->ns1__jystGcsj::hc);
	soap_default_double(soap, &this->ns1__jystGcsj::wxzco);
	soap_default_double(soap, &this->ns1__jystGcsj::co);
	soap_default_double(soap, &this->ns1__jystGcsj::co2);
	soap_default_double(soap, &this->ns1__jystGcsj::wxznox);
	soap_default_double(soap, &this->ns1__jystGcsj::nox);
	soap_default_double(soap, &this->ns1__jystGcsj::o2);
	soap_default_double(soap, &this->ns1__jystGcsj::sjll);
	soap_default_double(soap, &this->ns1__jystGcsj::bzll);
	soap_default_double(soap, &this->ns1__jystGcsj::wqll);
	soap_default_double(soap, &this->ns1__jystGcsj::cs);
	soap_default_double(soap, &this->ns1__jystGcsj::bzss);
	soap_default_double(soap, &this->ns1__jystGcsj::fdjzs);
	soap_default_double(soap, &this->ns1__jystGcsj::glkqxs);
	soap_default_double(soap, &this->ns1__jystGcsj::xsxzxs);
	soap_default_double(soap, &this->ns1__jystGcsj::nosdxzxs);
	soap_default_double(soap, &this->ns1__jystGcsj::xsb);
	soap_default_double(soap, &this->ns1__jystGcsj::jzgl);
	soap_default_double(soap, &this->ns1__jystGcsj::jsgl);
	soap_default_double(soap, &this->ns1__jystGcsj::zsgl);
	soap_default_double(soap, &this->ns1__jystGcsj::lljqy);
	soap_default_double(soap, &this->ns1__jystGcsj::lljwd);
	soap_default_double(soap, &this->ns1__jystGcsj::nl);
	soap_default_double(soap, &this->ns1__jystGcsj::fxyglyl);
	soap_default_double(soap, &this->ns1__jystGcsj::scfz);
	soap_default_double(soap, &this->ns1__jystGcsj::wd);
	soap_default_double(soap, &this->ns1__jystGcsj::sd);
	soap_default_double(soap, &this->ns1__jystGcsj::dqy);
	/* transient soap skipped */
}

void ns1__jystGcsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jystGcsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jystGcsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jystGcsj::qssx);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jystGcsj::gklx);
	/* transient soap skipped */
#endif
}

int ns1__jystGcsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__jystGcsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jystGcsj(struct soap *soap, const char *tag, int id, const ns1__jystGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jystGcsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__jystGcsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__jystGcsj::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qssx", -1, &(a->ns1__jystGcsj::qssx), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gklx", -1, &(a->ns1__jystGcsj::gklx), ""))
		return soap->error;
	if (soap_out_int(soap, "jcsxh", -1, &(a->ns1__jystGcsj::jcsxh), ""))
		return soap->error;
	if (soap_out_double(soap, "wxzhc", -1, &(a->ns1__jystGcsj::wxzhc), ""))
		return soap->error;
	if (soap_out_double(soap, "hc", -1, &(a->ns1__jystGcsj::hc), ""))
		return soap->error;
	if (soap_out_double(soap, "wxzco", -1, &(a->ns1__jystGcsj::wxzco), ""))
		return soap->error;
	if (soap_out_double(soap, "co", -1, &(a->ns1__jystGcsj::co), ""))
		return soap->error;
	if (soap_out_double(soap, "co2", -1, &(a->ns1__jystGcsj::co2), ""))
		return soap->error;
	if (soap_out_double(soap, "wxznox", -1, &(a->ns1__jystGcsj::wxznox), ""))
		return soap->error;
	if (soap_out_double(soap, "nox", -1, &(a->ns1__jystGcsj::nox), ""))
		return soap->error;
	if (soap_out_double(soap, "o2", -1, &(a->ns1__jystGcsj::o2), ""))
		return soap->error;
	if (soap_out_double(soap, "sjll", -1, &(a->ns1__jystGcsj::sjll), ""))
		return soap->error;
	if (soap_out_double(soap, "bzll", -1, &(a->ns1__jystGcsj::bzll), ""))
		return soap->error;
	if (soap_out_double(soap, "wqll", -1, &(a->ns1__jystGcsj::wqll), ""))
		return soap->error;
	if (soap_out_double(soap, "cs", -1, &(a->ns1__jystGcsj::cs), ""))
		return soap->error;
	if (soap_out_double(soap, "bzss", -1, &(a->ns1__jystGcsj::bzss), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzs", -1, &(a->ns1__jystGcsj::fdjzs), ""))
		return soap->error;
	if (soap_out_double(soap, "glkqxs", -1, &(a->ns1__jystGcsj::glkqxs), ""))
		return soap->error;
	if (soap_out_double(soap, "xsxzxs", -1, &(a->ns1__jystGcsj::xsxzxs), ""))
		return soap->error;
	if (soap_out_double(soap, "nosdxzxs", -1, &(a->ns1__jystGcsj::nosdxzxs), ""))
		return soap->error;
	if (soap_out_double(soap, "xsb", -1, &(a->ns1__jystGcsj::xsb), ""))
		return soap->error;
	if (soap_out_double(soap, "jzgl", -1, &(a->ns1__jystGcsj::jzgl), ""))
		return soap->error;
	if (soap_out_double(soap, "jsgl", -1, &(a->ns1__jystGcsj::jsgl), ""))
		return soap->error;
	if (soap_out_double(soap, "zsgl", -1, &(a->ns1__jystGcsj::zsgl), ""))
		return soap->error;
	if (soap_out_double(soap, "lljqy", -1, &(a->ns1__jystGcsj::lljqy), ""))
		return soap->error;
	if (soap_out_double(soap, "lljwd", -1, &(a->ns1__jystGcsj::lljwd), ""))
		return soap->error;
	if (soap_out_double(soap, "nl", -1, &(a->ns1__jystGcsj::nl), ""))
		return soap->error;
	if (soap_out_double(soap, "fxyglyl", -1, &(a->ns1__jystGcsj::fxyglyl), ""))
		return soap->error;
	if (soap_out_double(soap, "scfz", -1, &(a->ns1__jystGcsj::scfz), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__jystGcsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__jystGcsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__jystGcsj::dqy), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__jystGcsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__jystGcsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__jystGcsj * SOAP_FMAC4 soap_in_ns1__jystGcsj(struct soap *soap, const char *tag, ns1__jystGcsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__jystGcsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jystGcsj, sizeof(ns1__jystGcsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__jystGcsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__jystGcsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_qssx1 = 1;
	size_t soap_flag_gklx1 = 1;
	size_t soap_flag_jcsxh1 = 1;
	size_t soap_flag_wxzhc1 = 1;
	size_t soap_flag_hc1 = 1;
	size_t soap_flag_wxzco1 = 1;
	size_t soap_flag_co1 = 1;
	size_t soap_flag_co21 = 1;
	size_t soap_flag_wxznox1 = 1;
	size_t soap_flag_nox1 = 1;
	size_t soap_flag_o21 = 1;
	size_t soap_flag_sjll1 = 1;
	size_t soap_flag_bzll1 = 1;
	size_t soap_flag_wqll1 = 1;
	size_t soap_flag_cs1 = 1;
	size_t soap_flag_bzss1 = 1;
	size_t soap_flag_fdjzs1 = 1;
	size_t soap_flag_glkqxs1 = 1;
	size_t soap_flag_xsxzxs1 = 1;
	size_t soap_flag_nosdxzxs1 = 1;
	size_t soap_flag_xsb1 = 1;
	size_t soap_flag_jzgl1 = 1;
	size_t soap_flag_jsgl1 = 1;
	size_t soap_flag_zsgl1 = 1;
	size_t soap_flag_lljqy1 = 1;
	size_t soap_flag_lljwd1 = 1;
	size_t soap_flag_nl1 = 1;
	size_t soap_flag_fxyglyl1 = 1;
	size_t soap_flag_scfz1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__jystGcsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__jystGcsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_qssx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qssx", &(a->ns1__jystGcsj::qssx), "xsd:string"))
				{	soap_flag_qssx1--;
					continue;
				}
			if (soap_flag_gklx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gklx", &(a->ns1__jystGcsj::gklx), "xsd:string"))
				{	soap_flag_gklx1--;
					continue;
				}
			if (soap_flag_jcsxh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "jcsxh", &(a->ns1__jystGcsj::jcsxh), "xsd:int"))
				{	soap_flag_jcsxh1--;
					continue;
				}
			if (soap_flag_wxzhc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wxzhc", &(a->ns1__jystGcsj::wxzhc), "xsd:double"))
				{	soap_flag_wxzhc1--;
					continue;
				}
			if (soap_flag_hc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hc", &(a->ns1__jystGcsj::hc), "xsd:double"))
				{	soap_flag_hc1--;
					continue;
				}
			if (soap_flag_wxzco1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wxzco", &(a->ns1__jystGcsj::wxzco), "xsd:double"))
				{	soap_flag_wxzco1--;
					continue;
				}
			if (soap_flag_co1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co", &(a->ns1__jystGcsj::co), "xsd:double"))
				{	soap_flag_co1--;
					continue;
				}
			if (soap_flag_co21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co2", &(a->ns1__jystGcsj::co2), "xsd:double"))
				{	soap_flag_co21--;
					continue;
				}
			if (soap_flag_wxznox1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wxznox", &(a->ns1__jystGcsj::wxznox), "xsd:double"))
				{	soap_flag_wxznox1--;
					continue;
				}
			if (soap_flag_nox1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nox", &(a->ns1__jystGcsj::nox), "xsd:double"))
				{	soap_flag_nox1--;
					continue;
				}
			if (soap_flag_o21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "o2", &(a->ns1__jystGcsj::o2), "xsd:double"))
				{	soap_flag_o21--;
					continue;
				}
			if (soap_flag_sjll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjll", &(a->ns1__jystGcsj::sjll), "xsd:double"))
				{	soap_flag_sjll1--;
					continue;
				}
			if (soap_flag_bzll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bzll", &(a->ns1__jystGcsj::bzll), "xsd:double"))
				{	soap_flag_bzll1--;
					continue;
				}
			if (soap_flag_wqll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wqll", &(a->ns1__jystGcsj::wqll), "xsd:double"))
				{	soap_flag_wqll1--;
					continue;
				}
			if (soap_flag_cs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "cs", &(a->ns1__jystGcsj::cs), "xsd:double"))
				{	soap_flag_cs1--;
					continue;
				}
			if (soap_flag_bzss1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bzss", &(a->ns1__jystGcsj::bzss), "xsd:double"))
				{	soap_flag_bzss1--;
					continue;
				}
			if (soap_flag_fdjzs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzs", &(a->ns1__jystGcsj::fdjzs), "xsd:double"))
				{	soap_flag_fdjzs1--;
					continue;
				}
			if (soap_flag_glkqxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "glkqxs", &(a->ns1__jystGcsj::glkqxs), "xsd:double"))
				{	soap_flag_glkqxs1--;
					continue;
				}
			if (soap_flag_xsxzxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "xsxzxs", &(a->ns1__jystGcsj::xsxzxs), "xsd:double"))
				{	soap_flag_xsxzxs1--;
					continue;
				}
			if (soap_flag_nosdxzxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nosdxzxs", &(a->ns1__jystGcsj::nosdxzxs), "xsd:double"))
				{	soap_flag_nosdxzxs1--;
					continue;
				}
			if (soap_flag_xsb1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "xsb", &(a->ns1__jystGcsj::xsb), "xsd:double"))
				{	soap_flag_xsb1--;
					continue;
				}
			if (soap_flag_jzgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jzgl", &(a->ns1__jystGcsj::jzgl), "xsd:double"))
				{	soap_flag_jzgl1--;
					continue;
				}
			if (soap_flag_jsgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jsgl", &(a->ns1__jystGcsj::jsgl), "xsd:double"))
				{	soap_flag_jsgl1--;
					continue;
				}
			if (soap_flag_zsgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zsgl", &(a->ns1__jystGcsj::zsgl), "xsd:double"))
				{	soap_flag_zsgl1--;
					continue;
				}
			if (soap_flag_lljqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lljqy", &(a->ns1__jystGcsj::lljqy), "xsd:double"))
				{	soap_flag_lljqy1--;
					continue;
				}
			if (soap_flag_lljwd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lljwd", &(a->ns1__jystGcsj::lljwd), "xsd:double"))
				{	soap_flag_lljwd1--;
					continue;
				}
			if (soap_flag_nl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nl", &(a->ns1__jystGcsj::nl), "xsd:double"))
				{	soap_flag_nl1--;
					continue;
				}
			if (soap_flag_fxyglyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fxyglyl", &(a->ns1__jystGcsj::fxyglyl), "xsd:double"))
				{	soap_flag_fxyglyl1--;
					continue;
				}
			if (soap_flag_scfz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "scfz", &(a->ns1__jystGcsj::scfz), "xsd:double"))
				{	soap_flag_scfz1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__jystGcsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__jystGcsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__jystGcsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__jystGcsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jystGcsj, 0, sizeof(ns1__jystGcsj), 0, soap_copy_ns1__jystGcsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jcsxh1 > 0 || soap_flag_wxzhc1 > 0 || soap_flag_hc1 > 0 || soap_flag_wxzco1 > 0 || soap_flag_co1 > 0 || soap_flag_co21 > 0 || soap_flag_wxznox1 > 0 || soap_flag_nox1 > 0 || soap_flag_o21 > 0 || soap_flag_sjll1 > 0 || soap_flag_bzll1 > 0 || soap_flag_wqll1 > 0 || soap_flag_cs1 > 0 || soap_flag_bzss1 > 0 || soap_flag_fdjzs1 > 0 || soap_flag_glkqxs1 > 0 || soap_flag_xsxzxs1 > 0 || soap_flag_nosdxzxs1 > 0 || soap_flag_xsb1 > 0 || soap_flag_jzgl1 > 0 || soap_flag_jsgl1 > 0 || soap_flag_zsgl1 > 0 || soap_flag_lljqy1 > 0 || soap_flag_lljwd1 > 0 || soap_flag_nl1 > 0 || soap_flag_fxyglyl1 > 0 || soap_flag_scfz1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__jystGcsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__jystGcsj);
	if (this->soap_out(soap, tag?tag:"ns1:jystGcsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__jystGcsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__jystGcsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__jystGcsj * SOAP_FMAC4 soap_get_ns1__jystGcsj(struct soap *soap, ns1__jystGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jystGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__jystGcsj * SOAP_FMAC2 soap_instantiate_ns1__jystGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jystGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jystGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__jystGcsj);
		if (size)
			*size = sizeof(ns1__jystGcsj);
		((ns1__jystGcsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__jystGcsj, n);
		if (size)
			*size = n * sizeof(ns1__jystGcsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__jystGcsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__jystGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jystGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__jystGcsj %p -> %p\n", q, p));
	*(ns1__jystGcsj*)p = *(ns1__jystGcsj*)q;
}

void ns1__jczrylbResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__jczrylbResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__jczrylbResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jczrylbResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__jczrylbResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__jczrylbResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jczrylbResponse(struct soap *soap, const char *tag, int id, const ns1__jczrylbResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jczrylbResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__jczrylbResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__jczrylbResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__jczrylbResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__jczrylbResponse * SOAP_FMAC4 soap_in_ns1__jczrylbResponse(struct soap *soap, const char *tag, ns1__jczrylbResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__jczrylbResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jczrylbResponse, sizeof(ns1__jczrylbResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__jczrylbResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__jczrylbResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__jczrylbResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__jczrylbResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jczrylbResponse, 0, sizeof(ns1__jczrylbResponse), 0, soap_copy_ns1__jczrylbResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__jczrylbResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__jczrylbResponse);
	if (this->soap_out(soap, tag?tag:"ns1:jczrylbResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__jczrylbResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__jczrylbResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__jczrylbResponse * SOAP_FMAC4 soap_get_ns1__jczrylbResponse(struct soap *soap, ns1__jczrylbResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jczrylbResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__jczrylbResponse * SOAP_FMAC2 soap_instantiate_ns1__jczrylbResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jczrylbResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jczrylbResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__jczrylbResponse);
		if (size)
			*size = sizeof(ns1__jczrylbResponse);
		((ns1__jczrylbResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__jczrylbResponse, n);
		if (size)
			*size = n * sizeof(ns1__jczrylbResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__jczrylbResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__jczrylbResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jczrylbResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__jczrylbResponse %p -> %p\n", q, p));
	*(ns1__jczrylbResponse*)p = *(ns1__jczrylbResponse*)q;
}

void ns1__jczrylb::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__jczrylb::jczbh = NULL;
	this->ns1__jczrylb::jsdm = NULL;
	/* transient soap skipped */
}

void ns1__jczrylb::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jczrylb::jczbh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jczrylb::jsdm);
	/* transient soap skipped */
#endif
}

int ns1__jczrylb::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__jczrylb(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jczrylb(struct soap *soap, const char *tag, int id, const ns1__jczrylb *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jczrylb), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jczbh", -1, &(a->ns1__jczrylb::jczbh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jsdm", -1, &(a->ns1__jczrylb::jsdm), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__jczrylb::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__jczrylb(soap, tag, this, type);
}

SOAP_FMAC3 ns1__jczrylb * SOAP_FMAC4 soap_in_ns1__jczrylb(struct soap *soap, const char *tag, ns1__jczrylb *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__jczrylb *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jczrylb, sizeof(ns1__jczrylb), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__jczrylb)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__jczrylb *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jczbh1 = 1;
	size_t soap_flag_jsdm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jczbh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jczbh", &(a->ns1__jczrylb::jczbh), "xsd:string"))
				{	soap_flag_jczbh1--;
					continue;
				}
			if (soap_flag_jsdm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jsdm", &(a->ns1__jczrylb::jsdm), "xsd:string"))
				{	soap_flag_jsdm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__jczrylb *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jczrylb, 0, sizeof(ns1__jczrylb), 0, soap_copy_ns1__jczrylb);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__jczrylb::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__jczrylb);
	if (this->soap_out(soap, tag?tag:"ns1:jczrylb", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__jczrylb::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__jczrylb(soap, this, tag, type);
}

SOAP_FMAC3 ns1__jczrylb * SOAP_FMAC4 soap_get_ns1__jczrylb(struct soap *soap, ns1__jczrylb *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jczrylb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__jczrylb * SOAP_FMAC2 soap_instantiate_ns1__jczrylb(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jczrylb(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jczrylb, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__jczrylb);
		if (size)
			*size = sizeof(ns1__jczrylb);
		((ns1__jczrylb*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__jczrylb, n);
		if (size)
			*size = n * sizeof(ns1__jczrylb);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__jczrylb*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__jczrylb*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jczrylb(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__jczrylb %p -> %p\n", q, p));
	*(ns1__jczrylb*)p = *(ns1__jczrylb*)q;
}

void ns1__lgmhdJgsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lgmhdJgsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__lgmhdJgsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lgmhdJgsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__lgmhdJgsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lgmhdJgsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lgmhdJgsjResponse(struct soap *soap, const char *tag, int id, const ns1__lgmhdJgsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lgmhdJgsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__lgmhdJgsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lgmhdJgsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lgmhdJgsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lgmhdJgsjResponse * SOAP_FMAC4 soap_in_ns1__lgmhdJgsjResponse(struct soap *soap, const char *tag, ns1__lgmhdJgsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lgmhdJgsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lgmhdJgsjResponse, sizeof(ns1__lgmhdJgsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lgmhdJgsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lgmhdJgsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__lgmhdJgsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lgmhdJgsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lgmhdJgsjResponse, 0, sizeof(ns1__lgmhdJgsjResponse), 0, soap_copy_ns1__lgmhdJgsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__lgmhdJgsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lgmhdJgsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:lgmhdJgsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lgmhdJgsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lgmhdJgsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lgmhdJgsjResponse * SOAP_FMAC4 soap_get_ns1__lgmhdJgsjResponse(struct soap *soap, ns1__lgmhdJgsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lgmhdJgsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lgmhdJgsjResponse * SOAP_FMAC2 soap_instantiate_ns1__lgmhdJgsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lgmhdJgsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lgmhdJgsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lgmhdJgsjResponse);
		if (size)
			*size = sizeof(ns1__lgmhdJgsjResponse);
		((ns1__lgmhdJgsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lgmhdJgsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__lgmhdJgsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lgmhdJgsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lgmhdJgsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lgmhdJgsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lgmhdJgsjResponse %p -> %p\n", q, p));
	*(ns1__lgmhdJgsjResponse*)p = *(ns1__lgmhdJgsjResponse*)q;
}

void ns1__lgmhdJgsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lgmhdJgsj::lsh = NULL;
	this->ns1__lgmhdJgsj::accessToken = NULL;
	soap_default_double(soap, &this->ns1__lgmhdJgsj::lgmhd);
	soap_default_double(soap, &this->ns1__lgmhdJgsj::fdjzs);
	soap_default_double(soap, &this->ns1__lgmhdJgsj::wd);
	soap_default_double(soap, &this->ns1__lgmhdJgsj::sd);
	soap_default_double(soap, &this->ns1__lgmhdJgsj::dqy);
	this->ns1__lgmhdJgsj::kssj = NULL;
	this->ns1__lgmhdJgsj::jssj = NULL;
	/* transient soap skipped */
}

void ns1__lgmhdJgsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lgmhdJgsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lgmhdJgsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lgmhdJgsj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lgmhdJgsj::jssj);
	/* transient soap skipped */
#endif
}

int ns1__lgmhdJgsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lgmhdJgsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lgmhdJgsj(struct soap *soap, const char *tag, int id, const ns1__lgmhdJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lgmhdJgsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__lgmhdJgsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__lgmhdJgsj::accessToken), ""))
		return soap->error;
	if (soap_out_double(soap, "lgmhd", -1, &(a->ns1__lgmhdJgsj::lgmhd), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzs", -1, &(a->ns1__lgmhdJgsj::fdjzs), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__lgmhdJgsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__lgmhdJgsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__lgmhdJgsj::dqy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__lgmhdJgsj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__lgmhdJgsj::jssj), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lgmhdJgsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lgmhdJgsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lgmhdJgsj * SOAP_FMAC4 soap_in_ns1__lgmhdJgsj(struct soap *soap, const char *tag, ns1__lgmhdJgsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lgmhdJgsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lgmhdJgsj, sizeof(ns1__lgmhdJgsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lgmhdJgsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lgmhdJgsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_lgmhd1 = 1;
	size_t soap_flag_fdjzs1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__lgmhdJgsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__lgmhdJgsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_lgmhd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lgmhd", &(a->ns1__lgmhdJgsj::lgmhd), "xsd:double"))
				{	soap_flag_lgmhd1--;
					continue;
				}
			if (soap_flag_fdjzs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzs", &(a->ns1__lgmhdJgsj::fdjzs), "xsd:double"))
				{	soap_flag_fdjzs1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__lgmhdJgsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__lgmhdJgsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__lgmhdJgsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__lgmhdJgsj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__lgmhdJgsj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lgmhdJgsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lgmhdJgsj, 0, sizeof(ns1__lgmhdJgsj), 0, soap_copy_ns1__lgmhdJgsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lgmhd1 > 0 || soap_flag_fdjzs1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lgmhdJgsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lgmhdJgsj);
	if (this->soap_out(soap, tag?tag:"ns1:lgmhdJgsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lgmhdJgsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lgmhdJgsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lgmhdJgsj * SOAP_FMAC4 soap_get_ns1__lgmhdJgsj(struct soap *soap, ns1__lgmhdJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lgmhdJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lgmhdJgsj * SOAP_FMAC2 soap_instantiate_ns1__lgmhdJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lgmhdJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lgmhdJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lgmhdJgsj);
		if (size)
			*size = sizeof(ns1__lgmhdJgsj);
		((ns1__lgmhdJgsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lgmhdJgsj, n);
		if (size)
			*size = n * sizeof(ns1__lgmhdJgsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lgmhdJgsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lgmhdJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lgmhdJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lgmhdJgsj %p -> %p\n", q, p));
	*(ns1__lgmhdJgsj*)p = *(ns1__lgmhdJgsj*)q;
}

void ns1__hjcsyzjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__hjcsyzjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__hjcsyzjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__hjcsyzjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__hjcsyzjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__hjcsyzjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__hjcsyzjResponse(struct soap *soap, const char *tag, int id, const ns1__hjcsyzjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__hjcsyzjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__hjcsyzjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__hjcsyzjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__hjcsyzjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__hjcsyzjResponse * SOAP_FMAC4 soap_in_ns1__hjcsyzjResponse(struct soap *soap, const char *tag, ns1__hjcsyzjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__hjcsyzjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__hjcsyzjResponse, sizeof(ns1__hjcsyzjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__hjcsyzjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__hjcsyzjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__hjcsyzjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__hjcsyzjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__hjcsyzjResponse, 0, sizeof(ns1__hjcsyzjResponse), 0, soap_copy_ns1__hjcsyzjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__hjcsyzjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__hjcsyzjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:hjcsyzjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__hjcsyzjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__hjcsyzjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__hjcsyzjResponse * SOAP_FMAC4 soap_get_ns1__hjcsyzjResponse(struct soap *soap, ns1__hjcsyzjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__hjcsyzjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__hjcsyzjResponse * SOAP_FMAC2 soap_instantiate_ns1__hjcsyzjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__hjcsyzjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__hjcsyzjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__hjcsyzjResponse);
		if (size)
			*size = sizeof(ns1__hjcsyzjResponse);
		((ns1__hjcsyzjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__hjcsyzjResponse, n);
		if (size)
			*size = n * sizeof(ns1__hjcsyzjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__hjcsyzjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__hjcsyzjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__hjcsyzjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__hjcsyzjResponse %p -> %p\n", q, p));
	*(ns1__hjcsyzjResponse*)p = *(ns1__hjcsyzjResponse*)q;
}

void ns1__hjcsyzj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__hjcsyzj::accessToken = NULL;
	soap_default_double(soap, &this->ns1__hjcsyzj::sjhjwd);
	soap_default_double(soap, &this->ns1__hjcsyzj::clhjwd);
	soap_default_double(soap, &this->ns1__hjcsyzj::sjhjsd);
	soap_default_double(soap, &this->ns1__hjcsyzj::clhjsd);
	soap_default_double(soap, &this->ns1__hjcsyzj::sjdqyl);
	soap_default_double(soap, &this->ns1__hjcsyzj::cldqyl);
	this->ns1__hjcsyzj::kssj = NULL;
	this->ns1__hjcsyzj::jssj = NULL;
	this->ns1__hjcsyzj::bz = NULL;
	/* transient soap skipped */
}

void ns1__hjcsyzj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__hjcsyzj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__hjcsyzj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__hjcsyzj::jssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__hjcsyzj::bz);
	/* transient soap skipped */
#endif
}

int ns1__hjcsyzj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__hjcsyzj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__hjcsyzj(struct soap *soap, const char *tag, int id, const ns1__hjcsyzj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__hjcsyzj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__hjcsyzj::accessToken), ""))
		return soap->error;
	if (soap_out_double(soap, "sjhjwd", -1, &(a->ns1__hjcsyzj::sjhjwd), ""))
		return soap->error;
	if (soap_out_double(soap, "clhjwd", -1, &(a->ns1__hjcsyzj::clhjwd), ""))
		return soap->error;
	if (soap_out_double(soap, "sjhjsd", -1, &(a->ns1__hjcsyzj::sjhjsd), ""))
		return soap->error;
	if (soap_out_double(soap, "clhjsd", -1, &(a->ns1__hjcsyzj::clhjsd), ""))
		return soap->error;
	if (soap_out_double(soap, "sjdqyl", -1, &(a->ns1__hjcsyzj::sjdqyl), ""))
		return soap->error;
	if (soap_out_double(soap, "cldqyl", -1, &(a->ns1__hjcsyzj::cldqyl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__hjcsyzj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__hjcsyzj::jssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bz", -1, &(a->ns1__hjcsyzj::bz), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__hjcsyzj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__hjcsyzj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__hjcsyzj * SOAP_FMAC4 soap_in_ns1__hjcsyzj(struct soap *soap, const char *tag, ns1__hjcsyzj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__hjcsyzj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__hjcsyzj, sizeof(ns1__hjcsyzj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__hjcsyzj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__hjcsyzj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_sjhjwd1 = 1;
	size_t soap_flag_clhjwd1 = 1;
	size_t soap_flag_sjhjsd1 = 1;
	size_t soap_flag_clhjsd1 = 1;
	size_t soap_flag_sjdqyl1 = 1;
	size_t soap_flag_cldqyl1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	size_t soap_flag_bz1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__hjcsyzj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_sjhjwd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjhjwd", &(a->ns1__hjcsyzj::sjhjwd), "xsd:double"))
				{	soap_flag_sjhjwd1--;
					continue;
				}
			if (soap_flag_clhjwd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "clhjwd", &(a->ns1__hjcsyzj::clhjwd), "xsd:double"))
				{	soap_flag_clhjwd1--;
					continue;
				}
			if (soap_flag_sjhjsd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjhjsd", &(a->ns1__hjcsyzj::sjhjsd), "xsd:double"))
				{	soap_flag_sjhjsd1--;
					continue;
				}
			if (soap_flag_clhjsd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "clhjsd", &(a->ns1__hjcsyzj::clhjsd), "xsd:double"))
				{	soap_flag_clhjsd1--;
					continue;
				}
			if (soap_flag_sjdqyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjdqyl", &(a->ns1__hjcsyzj::sjdqyl), "xsd:double"))
				{	soap_flag_sjdqyl1--;
					continue;
				}
			if (soap_flag_cldqyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "cldqyl", &(a->ns1__hjcsyzj::cldqyl), "xsd:double"))
				{	soap_flag_cldqyl1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__hjcsyzj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__hjcsyzj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			if (soap_flag_bz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bz", &(a->ns1__hjcsyzj::bz), "xsd:string"))
				{	soap_flag_bz1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__hjcsyzj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__hjcsyzj, 0, sizeof(ns1__hjcsyzj), 0, soap_copy_ns1__hjcsyzj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sjhjwd1 > 0 || soap_flag_clhjwd1 > 0 || soap_flag_sjhjsd1 > 0 || soap_flag_clhjsd1 > 0 || soap_flag_sjdqyl1 > 0 || soap_flag_cldqyl1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__hjcsyzj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__hjcsyzj);
	if (this->soap_out(soap, tag?tag:"ns1:hjcsyzj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__hjcsyzj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__hjcsyzj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__hjcsyzj * SOAP_FMAC4 soap_get_ns1__hjcsyzj(struct soap *soap, ns1__hjcsyzj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__hjcsyzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__hjcsyzj * SOAP_FMAC2 soap_instantiate_ns1__hjcsyzj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__hjcsyzj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__hjcsyzj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__hjcsyzj);
		if (size)
			*size = sizeof(ns1__hjcsyzj);
		((ns1__hjcsyzj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__hjcsyzj, n);
		if (size)
			*size = n * sizeof(ns1__hjcsyzj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__hjcsyzj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__hjcsyzj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__hjcsyzj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__hjcsyzj %p -> %p\n", q, p));
	*(ns1__hjcsyzj*)p = *(ns1__hjcsyzj*)q;
}

void ns1__btgJgsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__btgJgsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__btgJgsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__btgJgsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__btgJgsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__btgJgsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__btgJgsjResponse(struct soap *soap, const char *tag, int id, const ns1__btgJgsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__btgJgsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__btgJgsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__btgJgsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__btgJgsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__btgJgsjResponse * SOAP_FMAC4 soap_in_ns1__btgJgsjResponse(struct soap *soap, const char *tag, ns1__btgJgsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__btgJgsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__btgJgsjResponse, sizeof(ns1__btgJgsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__btgJgsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__btgJgsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__btgJgsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__btgJgsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__btgJgsjResponse, 0, sizeof(ns1__btgJgsjResponse), 0, soap_copy_ns1__btgJgsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__btgJgsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__btgJgsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:btgJgsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__btgJgsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__btgJgsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__btgJgsjResponse * SOAP_FMAC4 soap_get_ns1__btgJgsjResponse(struct soap *soap, ns1__btgJgsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__btgJgsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__btgJgsjResponse * SOAP_FMAC2 soap_instantiate_ns1__btgJgsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__btgJgsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__btgJgsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__btgJgsjResponse);
		if (size)
			*size = sizeof(ns1__btgJgsjResponse);
		((ns1__btgJgsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__btgJgsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__btgJgsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__btgJgsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__btgJgsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__btgJgsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__btgJgsjResponse %p -> %p\n", q, p));
	*(ns1__btgJgsjResponse*)p = *(ns1__btgJgsjResponse*)q;
}

void ns1__btgJgsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__btgJgsj::lsh = NULL;
	this->ns1__btgJgsj::accessToken = NULL;
	soap_default_double(soap, &this->ns1__btgJgsj::ydz1);
	soap_default_double(soap, &this->ns1__btgJgsj::zs1);
	soap_default_double(soap, &this->ns1__btgJgsj::ydz2);
	soap_default_double(soap, &this->ns1__btgJgsj::zs2);
	soap_default_double(soap, &this->ns1__btgJgsj::ydz3);
	soap_default_double(soap, &this->ns1__btgJgsj::zs3);
	soap_default_double(soap, &this->ns1__btgJgsj::dszs);
	soap_default_double(soap, &this->ns1__btgJgsj::wd);
	soap_default_double(soap, &this->ns1__btgJgsj::sd);
	soap_default_double(soap, &this->ns1__btgJgsj::dqy);
	this->ns1__btgJgsj::kssj = NULL;
	this->ns1__btgJgsj::jssj = NULL;
	/* transient soap skipped */
}

void ns1__btgJgsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__btgJgsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__btgJgsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__btgJgsj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__btgJgsj::jssj);
	/* transient soap skipped */
#endif
}

int ns1__btgJgsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__btgJgsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__btgJgsj(struct soap *soap, const char *tag, int id, const ns1__btgJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__btgJgsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__btgJgsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__btgJgsj::accessToken), ""))
		return soap->error;
	if (soap_out_double(soap, "ydz1", -1, &(a->ns1__btgJgsj::ydz1), ""))
		return soap->error;
	if (soap_out_double(soap, "zs1", -1, &(a->ns1__btgJgsj::zs1), ""))
		return soap->error;
	if (soap_out_double(soap, "ydz2", -1, &(a->ns1__btgJgsj::ydz2), ""))
		return soap->error;
	if (soap_out_double(soap, "zs2", -1, &(a->ns1__btgJgsj::zs2), ""))
		return soap->error;
	if (soap_out_double(soap, "ydz3", -1, &(a->ns1__btgJgsj::ydz3), ""))
		return soap->error;
	if (soap_out_double(soap, "zs3", -1, &(a->ns1__btgJgsj::zs3), ""))
		return soap->error;
	if (soap_out_double(soap, "dszs", -1, &(a->ns1__btgJgsj::dszs), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__btgJgsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__btgJgsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__btgJgsj::dqy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__btgJgsj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__btgJgsj::jssj), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__btgJgsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__btgJgsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__btgJgsj * SOAP_FMAC4 soap_in_ns1__btgJgsj(struct soap *soap, const char *tag, ns1__btgJgsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__btgJgsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__btgJgsj, sizeof(ns1__btgJgsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__btgJgsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__btgJgsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_ydz11 = 1;
	size_t soap_flag_zs11 = 1;
	size_t soap_flag_ydz21 = 1;
	size_t soap_flag_zs21 = 1;
	size_t soap_flag_ydz31 = 1;
	size_t soap_flag_zs31 = 1;
	size_t soap_flag_dszs1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__btgJgsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__btgJgsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_ydz11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ydz1", &(a->ns1__btgJgsj::ydz1), "xsd:double"))
				{	soap_flag_ydz11--;
					continue;
				}
			if (soap_flag_zs11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zs1", &(a->ns1__btgJgsj::zs1), "xsd:double"))
				{	soap_flag_zs11--;
					continue;
				}
			if (soap_flag_ydz21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ydz2", &(a->ns1__btgJgsj::ydz2), "xsd:double"))
				{	soap_flag_ydz21--;
					continue;
				}
			if (soap_flag_zs21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zs2", &(a->ns1__btgJgsj::zs2), "xsd:double"))
				{	soap_flag_zs21--;
					continue;
				}
			if (soap_flag_ydz31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ydz3", &(a->ns1__btgJgsj::ydz3), "xsd:double"))
				{	soap_flag_ydz31--;
					continue;
				}
			if (soap_flag_zs31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zs3", &(a->ns1__btgJgsj::zs3), "xsd:double"))
				{	soap_flag_zs31--;
					continue;
				}
			if (soap_flag_dszs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dszs", &(a->ns1__btgJgsj::dszs), "xsd:double"))
				{	soap_flag_dszs1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__btgJgsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__btgJgsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__btgJgsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__btgJgsj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__btgJgsj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__btgJgsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__btgJgsj, 0, sizeof(ns1__btgJgsj), 0, soap_copy_ns1__btgJgsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ydz11 > 0 || soap_flag_zs11 > 0 || soap_flag_ydz21 > 0 || soap_flag_zs21 > 0 || soap_flag_ydz31 > 0 || soap_flag_zs31 > 0 || soap_flag_dszs1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__btgJgsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__btgJgsj);
	if (this->soap_out(soap, tag?tag:"ns1:btgJgsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__btgJgsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__btgJgsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__btgJgsj * SOAP_FMAC4 soap_get_ns1__btgJgsj(struct soap *soap, ns1__btgJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__btgJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__btgJgsj * SOAP_FMAC2 soap_instantiate_ns1__btgJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__btgJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__btgJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__btgJgsj);
		if (size)
			*size = sizeof(ns1__btgJgsj);
		((ns1__btgJgsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__btgJgsj, n);
		if (size)
			*size = n * sizeof(ns1__btgJgsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__btgJgsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__btgJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__btgJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__btgJgsj %p -> %p\n", q, p));
	*(ns1__btgJgsj*)p = *(ns1__btgJgsj*)q;
}

void ns1__getDjztResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDjztResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getDjztResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getDjztResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__getDjztResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDjztResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDjztResponse(struct soap *soap, const char *tag, int id, const ns1__getDjztResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDjztResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__getDjztResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getDjztResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDjztResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDjztResponse * SOAP_FMAC4 soap_in_ns1__getDjztResponse(struct soap *soap, const char *tag, ns1__getDjztResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDjztResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDjztResponse, sizeof(ns1__getDjztResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDjztResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDjztResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__getDjztResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDjztResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDjztResponse, 0, sizeof(ns1__getDjztResponse), 0, soap_copy_ns1__getDjztResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDjztResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getDjztResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDjztResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDjztResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDjztResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDjztResponse * SOAP_FMAC4 soap_get_ns1__getDjztResponse(struct soap *soap, ns1__getDjztResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDjztResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDjztResponse * SOAP_FMAC2 soap_instantiate_ns1__getDjztResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDjztResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDjztResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDjztResponse);
		if (size)
			*size = sizeof(ns1__getDjztResponse);
		((ns1__getDjztResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getDjztResponse, n);
		if (size)
			*size = n * sizeof(ns1__getDjztResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getDjztResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getDjztResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDjztResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDjztResponse %p -> %p\n", q, p));
	*(ns1__getDjztResponse*)p = *(ns1__getDjztResponse*)q;
}

void ns1__getDjzt::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDjzt::accessToken = NULL;
	/* transient soap skipped */
}

void ns1__getDjzt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getDjzt::accessToken);
	/* transient soap skipped */
#endif
}

int ns1__getDjzt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDjzt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDjzt(struct soap *soap, const char *tag, int id, const ns1__getDjzt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDjzt), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__getDjzt::accessToken), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getDjzt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDjzt(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDjzt * SOAP_FMAC4 soap_in_ns1__getDjzt(struct soap *soap, const char *tag, ns1__getDjzt *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDjzt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDjzt, sizeof(ns1__getDjzt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDjzt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDjzt *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_accessToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__getDjzt::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDjzt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDjzt, 0, sizeof(ns1__getDjzt), 0, soap_copy_ns1__getDjzt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDjzt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getDjzt);
	if (this->soap_out(soap, tag?tag:"ns1:getDjzt", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDjzt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDjzt(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDjzt * SOAP_FMAC4 soap_get_ns1__getDjzt(struct soap *soap, ns1__getDjzt *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDjzt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDjzt * SOAP_FMAC2 soap_instantiate_ns1__getDjzt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDjzt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDjzt, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDjzt);
		if (size)
			*size = sizeof(ns1__getDjzt);
		((ns1__getDjzt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getDjzt, n);
		if (size)
			*size = n * sizeof(ns1__getDjzt);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getDjzt*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getDjzt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDjzt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDjzt %p -> %p\n", q, p));
	*(ns1__getDjzt*)p = *(ns1__getDjzt*)q;
}

void ns1__xxtzResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__xxtzResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__xxtzResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__xxtzResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__xxtzResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__xxtzResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__xxtzResponse(struct soap *soap, const char *tag, int id, const ns1__xxtzResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__xxtzResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__xxtzResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__xxtzResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__xxtzResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__xxtzResponse * SOAP_FMAC4 soap_in_ns1__xxtzResponse(struct soap *soap, const char *tag, ns1__xxtzResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__xxtzResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__xxtzResponse, sizeof(ns1__xxtzResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__xxtzResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__xxtzResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__xxtzResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__xxtzResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__xxtzResponse, 0, sizeof(ns1__xxtzResponse), 0, soap_copy_ns1__xxtzResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__xxtzResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__xxtzResponse);
	if (this->soap_out(soap, tag?tag:"ns1:xxtzResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__xxtzResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__xxtzResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__xxtzResponse * SOAP_FMAC4 soap_get_ns1__xxtzResponse(struct soap *soap, ns1__xxtzResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__xxtzResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__xxtzResponse * SOAP_FMAC2 soap_instantiate_ns1__xxtzResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__xxtzResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__xxtzResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__xxtzResponse);
		if (size)
			*size = sizeof(ns1__xxtzResponse);
		((ns1__xxtzResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__xxtzResponse, n);
		if (size)
			*size = n * sizeof(ns1__xxtzResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__xxtzResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__xxtzResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__xxtzResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__xxtzResponse %p -> %p\n", q, p));
	*(ns1__xxtzResponse*)p = *(ns1__xxtzResponse*)q;
}

void ns1__xxtz::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__xxtz::lsh = NULL;
	this->ns1__xxtz::accessToken = NULL;
	this->ns1__xxtz::code = NULL;
	this->ns1__xxtz::message = NULL;
	/* transient soap skipped */
}

void ns1__xxtz::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__xxtz::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__xxtz::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__xxtz::code);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__xxtz::message);
	/* transient soap skipped */
#endif
}

int ns1__xxtz::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__xxtz(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__xxtz(struct soap *soap, const char *tag, int id, const ns1__xxtz *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__xxtz), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__xxtz::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__xxtz::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "code", -1, &(a->ns1__xxtz::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__xxtz::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__xxtz::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__xxtz(soap, tag, this, type);
}

SOAP_FMAC3 ns1__xxtz * SOAP_FMAC4 soap_in_ns1__xxtz(struct soap *soap, const char *tag, ns1__xxtz *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__xxtz *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__xxtz, sizeof(ns1__xxtz), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__xxtz)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__xxtz *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__xxtz::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__xxtz::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "code", &(a->ns1__xxtz::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__xxtz::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__xxtz *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__xxtz, 0, sizeof(ns1__xxtz), 0, soap_copy_ns1__xxtz);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__xxtz::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__xxtz);
	if (this->soap_out(soap, tag?tag:"ns1:xxtz", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__xxtz::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__xxtz(soap, this, tag, type);
}

SOAP_FMAC3 ns1__xxtz * SOAP_FMAC4 soap_get_ns1__xxtz(struct soap *soap, ns1__xxtz *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__xxtz(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__xxtz * SOAP_FMAC2 soap_instantiate_ns1__xxtz(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__xxtz(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__xxtz, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__xxtz);
		if (size)
			*size = sizeof(ns1__xxtz);
		((ns1__xxtz*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__xxtz, n);
		if (size)
			*size = n * sizeof(ns1__xxtz);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__xxtz*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__xxtz*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__xxtz(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__xxtz %p -> %p\n", q, p));
	*(ns1__xxtz*)p = *(ns1__xxtz*)q;
}

void ns1__cgjzjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__cgjzjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__cgjzjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjzjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__cgjzjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjzjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjzjResponse(struct soap *soap, const char *tag, int id, const ns1__cgjzjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjzjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__cgjzjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjzjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjzjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjzjResponse * SOAP_FMAC4 soap_in_ns1__cgjzjResponse(struct soap *soap, const char *tag, ns1__cgjzjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjzjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjzjResponse, sizeof(ns1__cgjzjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjzjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjzjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__cgjzjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjzjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjzjResponse, 0, sizeof(ns1__cgjzjResponse), 0, soap_copy_ns1__cgjzjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__cgjzjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjzjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:cgjzjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjzjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjzjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjzjResponse * SOAP_FMAC4 soap_get_ns1__cgjzjResponse(struct soap *soap, ns1__cgjzjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjzjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjzjResponse * SOAP_FMAC2 soap_instantiate_ns1__cgjzjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjzjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjzjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjzjResponse);
		if (size)
			*size = sizeof(ns1__cgjzjResponse);
		((ns1__cgjzjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjzjResponse, n);
		if (size)
			*size = n * sizeof(ns1__cgjzjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjzjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjzjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjzjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjzjResponse %p -> %p\n", q, p));
	*(ns1__cgjzjResponse*)p = *(ns1__cgjzjResponse*)q;
}

void ns1__cgjzj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__cgjzj::accessToken = NULL;
	soap_default_double(soap, &this->ns1__cgjzj::gsjzllsj);
	soap_default_double(soap, &this->ns1__cgjzj::gsjzsjsj);
	soap_default_double(soap, &this->ns1__cgjzj::dsjzllsj);
	soap_default_double(soap, &this->ns1__cgjzj::dsjzsjsj);
	soap_default_double(soap, &this->ns1__cgjzj::gsjzns);
	soap_default_double(soap, &this->ns1__cgjzj::dsjzns);
	soap_default_double(soap, &this->ns1__cgjzj::gsjzhxgl);
	soap_default_double(soap, &this->ns1__cgjzj::dsjzhxgl);
	soap_default_double(soap, &this->ns1__cgjzj::jbgl);
	this->ns1__cgjzj::gsjzjcjg = NULL;
	this->ns1__cgjzj::dsjzjcjg = NULL;
	this->ns1__cgjzj::jcjg = NULL;
	this->ns1__cgjzj::kssj = NULL;
	this->ns1__cgjzj::jssj = NULL;
	this->ns1__cgjzj::bz = NULL;
	/* transient soap skipped */
}

void ns1__cgjzj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjzj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjzj::gsjzjcjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjzj::dsjzjcjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjzj::jcjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjzj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjzj::jssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__cgjzj::bz);
	/* transient soap skipped */
#endif
}

int ns1__cgjzj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cgjzj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cgjzj(struct soap *soap, const char *tag, int id, const ns1__cgjzj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cgjzj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__cgjzj::accessToken), ""))
		return soap->error;
	if (soap_out_double(soap, "gsjzllsj", -1, &(a->ns1__cgjzj::gsjzllsj), ""))
		return soap->error;
	if (soap_out_double(soap, "gsjzsjsj", -1, &(a->ns1__cgjzj::gsjzsjsj), ""))
		return soap->error;
	if (soap_out_double(soap, "dsjzllsj", -1, &(a->ns1__cgjzj::dsjzllsj), ""))
		return soap->error;
	if (soap_out_double(soap, "dsjzsjsj", -1, &(a->ns1__cgjzj::dsjzsjsj), ""))
		return soap->error;
	if (soap_out_double(soap, "gsjzns", -1, &(a->ns1__cgjzj::gsjzns), ""))
		return soap->error;
	if (soap_out_double(soap, "dsjzns", -1, &(a->ns1__cgjzj::dsjzns), ""))
		return soap->error;
	if (soap_out_double(soap, "gsjzhxgl", -1, &(a->ns1__cgjzj::gsjzhxgl), ""))
		return soap->error;
	if (soap_out_double(soap, "dsjzhxgl", -1, &(a->ns1__cgjzj::dsjzhxgl), ""))
		return soap->error;
	if (soap_out_double(soap, "jbgl", -1, &(a->ns1__cgjzj::jbgl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gsjzjcjg", -1, &(a->ns1__cgjzj::gsjzjcjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "dsjzjcjg", -1, &(a->ns1__cgjzj::dsjzjcjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jcjg", -1, &(a->ns1__cgjzj::jcjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__cgjzj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__cgjzj::jssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bz", -1, &(a->ns1__cgjzj::bz), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cgjzj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cgjzj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cgjzj * SOAP_FMAC4 soap_in_ns1__cgjzj(struct soap *soap, const char *tag, ns1__cgjzj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cgjzj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cgjzj, sizeof(ns1__cgjzj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cgjzj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cgjzj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_gsjzllsj1 = 1;
	size_t soap_flag_gsjzsjsj1 = 1;
	size_t soap_flag_dsjzllsj1 = 1;
	size_t soap_flag_dsjzsjsj1 = 1;
	size_t soap_flag_gsjzns1 = 1;
	size_t soap_flag_dsjzns1 = 1;
	size_t soap_flag_gsjzhxgl1 = 1;
	size_t soap_flag_dsjzhxgl1 = 1;
	size_t soap_flag_jbgl1 = 1;
	size_t soap_flag_gsjzjcjg1 = 1;
	size_t soap_flag_dsjzjcjg1 = 1;
	size_t soap_flag_jcjg1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	size_t soap_flag_bz1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__cgjzj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_gsjzllsj1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gsjzllsj", &(a->ns1__cgjzj::gsjzllsj), "xsd:double"))
				{	soap_flag_gsjzllsj1--;
					continue;
				}
			if (soap_flag_gsjzsjsj1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gsjzsjsj", &(a->ns1__cgjzj::gsjzsjsj), "xsd:double"))
				{	soap_flag_gsjzsjsj1--;
					continue;
				}
			if (soap_flag_dsjzllsj1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dsjzllsj", &(a->ns1__cgjzj::dsjzllsj), "xsd:double"))
				{	soap_flag_dsjzllsj1--;
					continue;
				}
			if (soap_flag_dsjzsjsj1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dsjzsjsj", &(a->ns1__cgjzj::dsjzsjsj), "xsd:double"))
				{	soap_flag_dsjzsjsj1--;
					continue;
				}
			if (soap_flag_gsjzns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gsjzns", &(a->ns1__cgjzj::gsjzns), "xsd:double"))
				{	soap_flag_gsjzns1--;
					continue;
				}
			if (soap_flag_dsjzns1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dsjzns", &(a->ns1__cgjzj::dsjzns), "xsd:double"))
				{	soap_flag_dsjzns1--;
					continue;
				}
			if (soap_flag_gsjzhxgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "gsjzhxgl", &(a->ns1__cgjzj::gsjzhxgl), "xsd:double"))
				{	soap_flag_gsjzhxgl1--;
					continue;
				}
			if (soap_flag_dsjzhxgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dsjzhxgl", &(a->ns1__cgjzj::dsjzhxgl), "xsd:double"))
				{	soap_flag_dsjzhxgl1--;
					continue;
				}
			if (soap_flag_jbgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jbgl", &(a->ns1__cgjzj::jbgl), "xsd:double"))
				{	soap_flag_jbgl1--;
					continue;
				}
			if (soap_flag_gsjzjcjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gsjzjcjg", &(a->ns1__cgjzj::gsjzjcjg), "xsd:string"))
				{	soap_flag_gsjzjcjg1--;
					continue;
				}
			if (soap_flag_dsjzjcjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "dsjzjcjg", &(a->ns1__cgjzj::dsjzjcjg), "xsd:string"))
				{	soap_flag_dsjzjcjg1--;
					continue;
				}
			if (soap_flag_jcjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jcjg", &(a->ns1__cgjzj::jcjg), "xsd:string"))
				{	soap_flag_jcjg1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__cgjzj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__cgjzj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			if (soap_flag_bz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bz", &(a->ns1__cgjzj::bz), "xsd:string"))
				{	soap_flag_bz1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cgjzj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cgjzj, 0, sizeof(ns1__cgjzj), 0, soap_copy_ns1__cgjzj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_gsjzllsj1 > 0 || soap_flag_gsjzsjsj1 > 0 || soap_flag_dsjzllsj1 > 0 || soap_flag_dsjzsjsj1 > 0 || soap_flag_gsjzns1 > 0 || soap_flag_dsjzns1 > 0 || soap_flag_gsjzhxgl1 > 0 || soap_flag_dsjzhxgl1 > 0 || soap_flag_jbgl1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cgjzj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__cgjzj);
	if (this->soap_out(soap, tag?tag:"ns1:cgjzj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cgjzj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cgjzj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cgjzj * SOAP_FMAC4 soap_get_ns1__cgjzj(struct soap *soap, ns1__cgjzj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cgjzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cgjzj * SOAP_FMAC2 soap_instantiate_ns1__cgjzj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cgjzj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cgjzj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cgjzj);
		if (size)
			*size = sizeof(ns1__cgjzj);
		((ns1__cgjzj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cgjzj, n);
		if (size)
			*size = n * sizeof(ns1__cgjzj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cgjzj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cgjzj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cgjzj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cgjzj %p -> %p\n", q, p));
	*(ns1__cgjzj*)p = *(ns1__cgjzj*)q;
}

void ns1__obdGcsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__obdGcsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__obdGcsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdGcsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__obdGcsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__obdGcsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__obdGcsjResponse(struct soap *soap, const char *tag, int id, const ns1__obdGcsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__obdGcsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__obdGcsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__obdGcsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__obdGcsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__obdGcsjResponse * SOAP_FMAC4 soap_in_ns1__obdGcsjResponse(struct soap *soap, const char *tag, ns1__obdGcsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__obdGcsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__obdGcsjResponse, sizeof(ns1__obdGcsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__obdGcsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__obdGcsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__obdGcsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__obdGcsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__obdGcsjResponse, 0, sizeof(ns1__obdGcsjResponse), 0, soap_copy_ns1__obdGcsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__obdGcsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__obdGcsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:obdGcsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__obdGcsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__obdGcsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__obdGcsjResponse * SOAP_FMAC4 soap_get_ns1__obdGcsjResponse(struct soap *soap, ns1__obdGcsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__obdGcsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__obdGcsjResponse * SOAP_FMAC2 soap_instantiate_ns1__obdGcsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__obdGcsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__obdGcsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__obdGcsjResponse);
		if (size)
			*size = sizeof(ns1__obdGcsjResponse);
		((ns1__obdGcsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__obdGcsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__obdGcsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__obdGcsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__obdGcsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__obdGcsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__obdGcsjResponse %p -> %p\n", q, p));
	*(ns1__obdGcsjResponse*)p = *(ns1__obdGcsjResponse*)q;
}

void ns1__obdGcsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__obdGcsj::lsh = NULL;
	this->ns1__obdGcsj::accessToken = NULL;
	this->ns1__obdGcsj::qssx = NULL;
	this->ns1__obdGcsj::jcsxh = NULL;
	soap_default_double(soap, &this->ns1__obdGcsj::jqmjdkd);
	soap_default_double(soap, &this->ns1__obdGcsj::fhz);
	soap_default_double(soap, &this->ns1__obdGcsj::ycgqxh);
	soap_default_double(soap, &this->ns1__obdGcsj::glkqxs);
	soap_default_double(soap, &this->ns1__obdGcsj::cs);
	soap_default_double(soap, &this->ns1__obdGcsj::fdjgl);
	soap_default_double(soap, &this->ns1__obdGcsj::fdjzs);
	soap_default_double(soap, &this->ns1__obdGcsj::jql);
	soap_default_double(soap, &this->ns1__obdGcsj::jqyl);
	soap_default_double(soap, &this->ns1__obdGcsj::zyyl);
	soap_default_double(soap, &this->ns1__obdGcsj::ymkd);
	soap_default_double(soap, &this->ns1__obdGcsj::hyl);
	soap_default_double(soap, &this->ns1__obdGcsj::nycgqnd);
	soap_default_double(soap, &this->ns1__obdGcsj::nspsl);
	soap_default_double(soap, &this->ns1__obdGcsj::pqwd);
	soap_default_double(soap, &this->ns1__obdGcsj::klbzqyc);
	soap_default_double(soap, &this->ns1__obdGcsj::egrkd);
	soap_default_double(soap, &this->ns1__obdGcsj::rypsyl);
	/* transient soap skipped */
}

void ns1__obdGcsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdGcsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdGcsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdGcsj::qssx);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdGcsj::jcsxh);
	/* transient soap skipped */
#endif
}

int ns1__obdGcsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__obdGcsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__obdGcsj(struct soap *soap, const char *tag, int id, const ns1__obdGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__obdGcsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__obdGcsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__obdGcsj::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qssx", -1, &(a->ns1__obdGcsj::qssx), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jcsxh", -1, &(a->ns1__obdGcsj::jcsxh), ""))
		return soap->error;
	if (soap_out_double(soap, "jqmjdkd", -1, &(a->ns1__obdGcsj::jqmjdkd), ""))
		return soap->error;
	if (soap_out_double(soap, "fhz", -1, &(a->ns1__obdGcsj::fhz), ""))
		return soap->error;
	if (soap_out_double(soap, "ycgqxh", -1, &(a->ns1__obdGcsj::ycgqxh), ""))
		return soap->error;
	if (soap_out_double(soap, "glkqxs", -1, &(a->ns1__obdGcsj::glkqxs), ""))
		return soap->error;
	if (soap_out_double(soap, "cs", -1, &(a->ns1__obdGcsj::cs), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjgl", -1, &(a->ns1__obdGcsj::fdjgl), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzs", -1, &(a->ns1__obdGcsj::fdjzs), ""))
		return soap->error;
	if (soap_out_double(soap, "jql", -1, &(a->ns1__obdGcsj::jql), ""))
		return soap->error;
	if (soap_out_double(soap, "jqyl", -1, &(a->ns1__obdGcsj::jqyl), ""))
		return soap->error;
	if (soap_out_double(soap, "zyyl", -1, &(a->ns1__obdGcsj::zyyl), ""))
		return soap->error;
	if (soap_out_double(soap, "ymkd", -1, &(a->ns1__obdGcsj::ymkd), ""))
		return soap->error;
	if (soap_out_double(soap, "hyl", -1, &(a->ns1__obdGcsj::hyl), ""))
		return soap->error;
	if (soap_out_double(soap, "nycgqnd", -1, &(a->ns1__obdGcsj::nycgqnd), ""))
		return soap->error;
	if (soap_out_double(soap, "nspsl", -1, &(a->ns1__obdGcsj::nspsl), ""))
		return soap->error;
	if (soap_out_double(soap, "pqwd", -1, &(a->ns1__obdGcsj::pqwd), ""))
		return soap->error;
	if (soap_out_double(soap, "klbzqyc", -1, &(a->ns1__obdGcsj::klbzqyc), ""))
		return soap->error;
	if (soap_out_double(soap, "egrkd", -1, &(a->ns1__obdGcsj::egrkd), ""))
		return soap->error;
	if (soap_out_double(soap, "rypsyl", -1, &(a->ns1__obdGcsj::rypsyl), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__obdGcsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__obdGcsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__obdGcsj * SOAP_FMAC4 soap_in_ns1__obdGcsj(struct soap *soap, const char *tag, ns1__obdGcsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__obdGcsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__obdGcsj, sizeof(ns1__obdGcsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__obdGcsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__obdGcsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_qssx1 = 1;
	size_t soap_flag_jcsxh1 = 1;
	size_t soap_flag_jqmjdkd1 = 1;
	size_t soap_flag_fhz1 = 1;
	size_t soap_flag_ycgqxh1 = 1;
	size_t soap_flag_glkqxs1 = 1;
	size_t soap_flag_cs1 = 1;
	size_t soap_flag_fdjgl1 = 1;
	size_t soap_flag_fdjzs1 = 1;
	size_t soap_flag_jql1 = 1;
	size_t soap_flag_jqyl1 = 1;
	size_t soap_flag_zyyl1 = 1;
	size_t soap_flag_ymkd1 = 1;
	size_t soap_flag_hyl1 = 1;
	size_t soap_flag_nycgqnd1 = 1;
	size_t soap_flag_nspsl1 = 1;
	size_t soap_flag_pqwd1 = 1;
	size_t soap_flag_klbzqyc1 = 1;
	size_t soap_flag_egrkd1 = 1;
	size_t soap_flag_rypsyl1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__obdGcsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__obdGcsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_qssx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qssx", &(a->ns1__obdGcsj::qssx), "xsd:string"))
				{	soap_flag_qssx1--;
					continue;
				}
			if (soap_flag_jcsxh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jcsxh", &(a->ns1__obdGcsj::jcsxh), "xsd:string"))
				{	soap_flag_jcsxh1--;
					continue;
				}
			if (soap_flag_jqmjdkd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jqmjdkd", &(a->ns1__obdGcsj::jqmjdkd), "xsd:double"))
				{	soap_flag_jqmjdkd1--;
					continue;
				}
			if (soap_flag_fhz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fhz", &(a->ns1__obdGcsj::fhz), "xsd:double"))
				{	soap_flag_fhz1--;
					continue;
				}
			if (soap_flag_ycgqxh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ycgqxh", &(a->ns1__obdGcsj::ycgqxh), "xsd:double"))
				{	soap_flag_ycgqxh1--;
					continue;
				}
			if (soap_flag_glkqxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "glkqxs", &(a->ns1__obdGcsj::glkqxs), "xsd:double"))
				{	soap_flag_glkqxs1--;
					continue;
				}
			if (soap_flag_cs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "cs", &(a->ns1__obdGcsj::cs), "xsd:double"))
				{	soap_flag_cs1--;
					continue;
				}
			if (soap_flag_fdjgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjgl", &(a->ns1__obdGcsj::fdjgl), "xsd:double"))
				{	soap_flag_fdjgl1--;
					continue;
				}
			if (soap_flag_fdjzs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzs", &(a->ns1__obdGcsj::fdjzs), "xsd:double"))
				{	soap_flag_fdjzs1--;
					continue;
				}
			if (soap_flag_jql1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jql", &(a->ns1__obdGcsj::jql), "xsd:double"))
				{	soap_flag_jql1--;
					continue;
				}
			if (soap_flag_jqyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jqyl", &(a->ns1__obdGcsj::jqyl), "xsd:double"))
				{	soap_flag_jqyl1--;
					continue;
				}
			if (soap_flag_zyyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zyyl", &(a->ns1__obdGcsj::zyyl), "xsd:double"))
				{	soap_flag_zyyl1--;
					continue;
				}
			if (soap_flag_ymkd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ymkd", &(a->ns1__obdGcsj::ymkd), "xsd:double"))
				{	soap_flag_ymkd1--;
					continue;
				}
			if (soap_flag_hyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hyl", &(a->ns1__obdGcsj::hyl), "xsd:double"))
				{	soap_flag_hyl1--;
					continue;
				}
			if (soap_flag_nycgqnd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nycgqnd", &(a->ns1__obdGcsj::nycgqnd), "xsd:double"))
				{	soap_flag_nycgqnd1--;
					continue;
				}
			if (soap_flag_nspsl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nspsl", &(a->ns1__obdGcsj::nspsl), "xsd:double"))
				{	soap_flag_nspsl1--;
					continue;
				}
			if (soap_flag_pqwd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "pqwd", &(a->ns1__obdGcsj::pqwd), "xsd:double"))
				{	soap_flag_pqwd1--;
					continue;
				}
			if (soap_flag_klbzqyc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "klbzqyc", &(a->ns1__obdGcsj::klbzqyc), "xsd:double"))
				{	soap_flag_klbzqyc1--;
					continue;
				}
			if (soap_flag_egrkd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "egrkd", &(a->ns1__obdGcsj::egrkd), "xsd:double"))
				{	soap_flag_egrkd1--;
					continue;
				}
			if (soap_flag_rypsyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "rypsyl", &(a->ns1__obdGcsj::rypsyl), "xsd:double"))
				{	soap_flag_rypsyl1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__obdGcsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__obdGcsj, 0, sizeof(ns1__obdGcsj), 0, soap_copy_ns1__obdGcsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jqmjdkd1 > 0 || soap_flag_fhz1 > 0 || soap_flag_ycgqxh1 > 0 || soap_flag_glkqxs1 > 0 || soap_flag_cs1 > 0 || soap_flag_fdjgl1 > 0 || soap_flag_fdjzs1 > 0 || soap_flag_jql1 > 0 || soap_flag_jqyl1 > 0 || soap_flag_zyyl1 > 0 || soap_flag_ymkd1 > 0 || soap_flag_hyl1 > 0 || soap_flag_nycgqnd1 > 0 || soap_flag_nspsl1 > 0 || soap_flag_pqwd1 > 0 || soap_flag_klbzqyc1 > 0 || soap_flag_egrkd1 > 0 || soap_flag_rypsyl1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__obdGcsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__obdGcsj);
	if (this->soap_out(soap, tag?tag:"ns1:obdGcsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__obdGcsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__obdGcsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__obdGcsj * SOAP_FMAC4 soap_get_ns1__obdGcsj(struct soap *soap, ns1__obdGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__obdGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__obdGcsj * SOAP_FMAC2 soap_instantiate_ns1__obdGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__obdGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__obdGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__obdGcsj);
		if (size)
			*size = sizeof(ns1__obdGcsj);
		((ns1__obdGcsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__obdGcsj, n);
		if (size)
			*size = n * sizeof(ns1__obdGcsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__obdGcsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__obdGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__obdGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__obdGcsj %p -> %p\n", q, p));
	*(ns1__obdGcsj*)p = *(ns1__obdGcsj*)q;
}

void ns1__wtJgsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wtJgsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__wtJgsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wtJgsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__wtJgsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wtJgsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wtJgsjResponse(struct soap *soap, const char *tag, int id, const ns1__wtJgsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wtJgsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__wtJgsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wtJgsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wtJgsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wtJgsjResponse * SOAP_FMAC4 soap_in_ns1__wtJgsjResponse(struct soap *soap, const char *tag, ns1__wtJgsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wtJgsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wtJgsjResponse, sizeof(ns1__wtJgsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wtJgsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wtJgsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__wtJgsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wtJgsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wtJgsjResponse, 0, sizeof(ns1__wtJgsjResponse), 0, soap_copy_ns1__wtJgsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wtJgsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wtJgsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:wtJgsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wtJgsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wtJgsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wtJgsjResponse * SOAP_FMAC4 soap_get_ns1__wtJgsjResponse(struct soap *soap, ns1__wtJgsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wtJgsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wtJgsjResponse * SOAP_FMAC2 soap_instantiate_ns1__wtJgsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wtJgsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wtJgsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wtJgsjResponse);
		if (size)
			*size = sizeof(ns1__wtJgsjResponse);
		((ns1__wtJgsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wtJgsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__wtJgsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wtJgsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wtJgsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wtJgsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wtJgsjResponse %p -> %p\n", q, p));
	*(ns1__wtJgsjResponse*)p = *(ns1__wtJgsjResponse*)q;
}

void ns1__wtJgsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wtJgsj::lsh = NULL;
	this->ns1__wtJgsj::accessToken = NULL;
	soap_default_double(soap, &this->ns1__wtJgsj::hc5025);
	soap_default_double(soap, &this->ns1__wtJgsj::co5025);
	soap_default_double(soap, &this->ns1__wtJgsj::no5025);
	soap_default_double(soap, &this->ns1__wtJgsj::fdjzs5025);
	soap_default_double(soap, &this->ns1__wtJgsj::fdjyw5025);
	soap_default_double(soap, &this->ns1__wtJgsj::pjcs5025);
	soap_default_double(soap, &this->ns1__wtJgsj::zgl5025);
	soap_default_double(soap, &this->ns1__wtJgsj::hc2540);
	soap_default_double(soap, &this->ns1__wtJgsj::co2540);
	soap_default_double(soap, &this->ns1__wtJgsj::no2540);
	soap_default_double(soap, &this->ns1__wtJgsj::fdjzs2540);
	soap_default_double(soap, &this->ns1__wtJgsj::fdjyw2540);
	soap_default_double(soap, &this->ns1__wtJgsj::pjcs2540);
	soap_default_double(soap, &this->ns1__wtJgsj::zgl2540);
	soap_default_double(soap, &this->ns1__wtJgsj::glkqxs);
	soap_default_double(soap, &this->ns1__wtJgsj::wd);
	soap_default_double(soap, &this->ns1__wtJgsj::sd);
	soap_default_double(soap, &this->ns1__wtJgsj::dqy);
	this->ns1__wtJgsj::kssj = NULL;
	this->ns1__wtJgsj::jssj = NULL;
	/* transient soap skipped */
}

void ns1__wtJgsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wtJgsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wtJgsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wtJgsj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wtJgsj::jssj);
	/* transient soap skipped */
#endif
}

int ns1__wtJgsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wtJgsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wtJgsj(struct soap *soap, const char *tag, int id, const ns1__wtJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wtJgsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__wtJgsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__wtJgsj::accessToken), ""))
		return soap->error;
	if (soap_out_double(soap, "hc5025", -1, &(a->ns1__wtJgsj::hc5025), ""))
		return soap->error;
	if (soap_out_double(soap, "co5025", -1, &(a->ns1__wtJgsj::co5025), ""))
		return soap->error;
	if (soap_out_double(soap, "no5025", -1, &(a->ns1__wtJgsj::no5025), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzs5025", -1, &(a->ns1__wtJgsj::fdjzs5025), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjyw5025", -1, &(a->ns1__wtJgsj::fdjyw5025), ""))
		return soap->error;
	if (soap_out_double(soap, "pjcs5025", -1, &(a->ns1__wtJgsj::pjcs5025), ""))
		return soap->error;
	if (soap_out_double(soap, "zgl5025", -1, &(a->ns1__wtJgsj::zgl5025), ""))
		return soap->error;
	if (soap_out_double(soap, "hc2540", -1, &(a->ns1__wtJgsj::hc2540), ""))
		return soap->error;
	if (soap_out_double(soap, "co2540", -1, &(a->ns1__wtJgsj::co2540), ""))
		return soap->error;
	if (soap_out_double(soap, "no2540", -1, &(a->ns1__wtJgsj::no2540), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzs2540", -1, &(a->ns1__wtJgsj::fdjzs2540), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjyw2540", -1, &(a->ns1__wtJgsj::fdjyw2540), ""))
		return soap->error;
	if (soap_out_double(soap, "pjcs2540", -1, &(a->ns1__wtJgsj::pjcs2540), ""))
		return soap->error;
	if (soap_out_double(soap, "zgl2540", -1, &(a->ns1__wtJgsj::zgl2540), ""))
		return soap->error;
	if (soap_out_double(soap, "glkqxs", -1, &(a->ns1__wtJgsj::glkqxs), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__wtJgsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__wtJgsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__wtJgsj::dqy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__wtJgsj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__wtJgsj::jssj), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wtJgsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wtJgsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wtJgsj * SOAP_FMAC4 soap_in_ns1__wtJgsj(struct soap *soap, const char *tag, ns1__wtJgsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wtJgsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wtJgsj, sizeof(ns1__wtJgsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wtJgsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wtJgsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_hc50251 = 1;
	size_t soap_flag_co50251 = 1;
	size_t soap_flag_no50251 = 1;
	size_t soap_flag_fdjzs50251 = 1;
	size_t soap_flag_fdjyw50251 = 1;
	size_t soap_flag_pjcs50251 = 1;
	size_t soap_flag_zgl50251 = 1;
	size_t soap_flag_hc25401 = 1;
	size_t soap_flag_co25401 = 1;
	size_t soap_flag_no25401 = 1;
	size_t soap_flag_fdjzs25401 = 1;
	size_t soap_flag_fdjyw25401 = 1;
	size_t soap_flag_pjcs25401 = 1;
	size_t soap_flag_zgl25401 = 1;
	size_t soap_flag_glkqxs1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__wtJgsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__wtJgsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_hc50251 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hc5025", &(a->ns1__wtJgsj::hc5025), "xsd:double"))
				{	soap_flag_hc50251--;
					continue;
				}
			if (soap_flag_co50251 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co5025", &(a->ns1__wtJgsj::co5025), "xsd:double"))
				{	soap_flag_co50251--;
					continue;
				}
			if (soap_flag_no50251 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "no5025", &(a->ns1__wtJgsj::no5025), "xsd:double"))
				{	soap_flag_no50251--;
					continue;
				}
			if (soap_flag_fdjzs50251 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzs5025", &(a->ns1__wtJgsj::fdjzs5025), "xsd:double"))
				{	soap_flag_fdjzs50251--;
					continue;
				}
			if (soap_flag_fdjyw50251 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjyw5025", &(a->ns1__wtJgsj::fdjyw5025), "xsd:double"))
				{	soap_flag_fdjyw50251--;
					continue;
				}
			if (soap_flag_pjcs50251 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "pjcs5025", &(a->ns1__wtJgsj::pjcs5025), "xsd:double"))
				{	soap_flag_pjcs50251--;
					continue;
				}
			if (soap_flag_zgl50251 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zgl5025", &(a->ns1__wtJgsj::zgl5025), "xsd:double"))
				{	soap_flag_zgl50251--;
					continue;
				}
			if (soap_flag_hc25401 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hc2540", &(a->ns1__wtJgsj::hc2540), "xsd:double"))
				{	soap_flag_hc25401--;
					continue;
				}
			if (soap_flag_co25401 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co2540", &(a->ns1__wtJgsj::co2540), "xsd:double"))
				{	soap_flag_co25401--;
					continue;
				}
			if (soap_flag_no25401 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "no2540", &(a->ns1__wtJgsj::no2540), "xsd:double"))
				{	soap_flag_no25401--;
					continue;
				}
			if (soap_flag_fdjzs25401 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzs2540", &(a->ns1__wtJgsj::fdjzs2540), "xsd:double"))
				{	soap_flag_fdjzs25401--;
					continue;
				}
			if (soap_flag_fdjyw25401 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjyw2540", &(a->ns1__wtJgsj::fdjyw2540), "xsd:double"))
				{	soap_flag_fdjyw25401--;
					continue;
				}
			if (soap_flag_pjcs25401 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "pjcs2540", &(a->ns1__wtJgsj::pjcs2540), "xsd:double"))
				{	soap_flag_pjcs25401--;
					continue;
				}
			if (soap_flag_zgl25401 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zgl2540", &(a->ns1__wtJgsj::zgl2540), "xsd:double"))
				{	soap_flag_zgl25401--;
					continue;
				}
			if (soap_flag_glkqxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "glkqxs", &(a->ns1__wtJgsj::glkqxs), "xsd:double"))
				{	soap_flag_glkqxs1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__wtJgsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__wtJgsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__wtJgsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__wtJgsj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__wtJgsj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wtJgsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wtJgsj, 0, sizeof(ns1__wtJgsj), 0, soap_copy_ns1__wtJgsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hc50251 > 0 || soap_flag_co50251 > 0 || soap_flag_no50251 > 0 || soap_flag_fdjzs50251 > 0 || soap_flag_fdjyw50251 > 0 || soap_flag_pjcs50251 > 0 || soap_flag_zgl50251 > 0 || soap_flag_hc25401 > 0 || soap_flag_co25401 > 0 || soap_flag_no25401 > 0 || soap_flag_fdjzs25401 > 0 || soap_flag_fdjyw25401 > 0 || soap_flag_pjcs25401 > 0 || soap_flag_zgl25401 > 0 || soap_flag_glkqxs1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__wtJgsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wtJgsj);
	if (this->soap_out(soap, tag?tag:"ns1:wtJgsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wtJgsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wtJgsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wtJgsj * SOAP_FMAC4 soap_get_ns1__wtJgsj(struct soap *soap, ns1__wtJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wtJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wtJgsj * SOAP_FMAC2 soap_instantiate_ns1__wtJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wtJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wtJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wtJgsj);
		if (size)
			*size = sizeof(ns1__wtJgsj);
		((ns1__wtJgsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wtJgsj, n);
		if (size)
			*size = n * sizeof(ns1__wtJgsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wtJgsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wtJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wtJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wtJgsj %p -> %p\n", q, p));
	*(ns1__wtJgsj*)p = *(ns1__wtJgsj*)q;
}

void ns1__wtGcsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wtGcsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__wtGcsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wtGcsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__wtGcsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wtGcsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wtGcsjResponse(struct soap *soap, const char *tag, int id, const ns1__wtGcsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wtGcsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__wtGcsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wtGcsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wtGcsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wtGcsjResponse * SOAP_FMAC4 soap_in_ns1__wtGcsjResponse(struct soap *soap, const char *tag, ns1__wtGcsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wtGcsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wtGcsjResponse, sizeof(ns1__wtGcsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wtGcsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wtGcsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__wtGcsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wtGcsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wtGcsjResponse, 0, sizeof(ns1__wtGcsjResponse), 0, soap_copy_ns1__wtGcsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wtGcsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wtGcsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:wtGcsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wtGcsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wtGcsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wtGcsjResponse * SOAP_FMAC4 soap_get_ns1__wtGcsjResponse(struct soap *soap, ns1__wtGcsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wtGcsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wtGcsjResponse * SOAP_FMAC2 soap_instantiate_ns1__wtGcsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wtGcsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wtGcsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wtGcsjResponse);
		if (size)
			*size = sizeof(ns1__wtGcsjResponse);
		((ns1__wtGcsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wtGcsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__wtGcsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wtGcsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wtGcsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wtGcsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wtGcsjResponse %p -> %p\n", q, p));
	*(ns1__wtGcsjResponse*)p = *(ns1__wtGcsjResponse*)q;
}

void ns1__wtGcsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wtGcsj::lsh = NULL;
	this->ns1__wtGcsj::accessToken = NULL;
	this->ns1__wtGcsj::qssx = NULL;
	this->ns1__wtGcsj::gklx = NULL;
	soap_default_int(soap, &this->ns1__wtGcsj::jcsxh);
	soap_default_double(soap, &this->ns1__wtGcsj::wxzhc);
	soap_default_double(soap, &this->ns1__wtGcsj::wxzco);
	soap_default_double(soap, &this->ns1__wtGcsj::wxzno);
	soap_default_double(soap, &this->ns1__wtGcsj::hc);
	soap_default_double(soap, &this->ns1__wtGcsj::co);
	soap_default_double(soap, &this->ns1__wtGcsj::no);
	soap_default_double(soap, &this->ns1__wtGcsj::o2);
	soap_default_double(soap, &this->ns1__wtGcsj::co2);
	soap_default_double(soap, &this->ns1__wtGcsj::cs);
	soap_default_double(soap, &this->ns1__wtGcsj::zs);
	soap_default_double(soap, &this->ns1__wtGcsj::xsxzxs);
	soap_default_double(soap, &this->ns1__wtGcsj::sdxzxs);
	soap_default_double(soap, &this->ns1__wtGcsj::glkqxs);
	soap_default_double(soap, &this->ns1__wtGcsj::dpcgjfz);
	soap_default_double(soap, &this->ns1__wtGcsj::zjzgl);
	soap_default_double(soap, &this->ns1__wtGcsj::jsgl);
	soap_default_double(soap, &this->ns1__wtGcsj::zsgl);
	soap_default_double(soap, &this->ns1__wtGcsj::nl);
	soap_default_double(soap, &this->ns1__wtGcsj::fxyglyl);
	soap_default_double(soap, &this->ns1__wtGcsj::wd);
	soap_default_double(soap, &this->ns1__wtGcsj::sd);
	soap_default_double(soap, &this->ns1__wtGcsj::dqy);
	soap_default_double(soap, &this->ns1__wtGcsj::yw);
	/* transient soap skipped */
}

void ns1__wtGcsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wtGcsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wtGcsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wtGcsj::qssx);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wtGcsj::gklx);
	/* transient soap skipped */
#endif
}

int ns1__wtGcsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wtGcsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wtGcsj(struct soap *soap, const char *tag, int id, const ns1__wtGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wtGcsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__wtGcsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__wtGcsj::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qssx", -1, &(a->ns1__wtGcsj::qssx), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gklx", -1, &(a->ns1__wtGcsj::gklx), ""))
		return soap->error;
	if (soap_out_int(soap, "jcsxh", -1, &(a->ns1__wtGcsj::jcsxh), ""))
		return soap->error;
	if (soap_out_double(soap, "wxzhc", -1, &(a->ns1__wtGcsj::wxzhc), ""))
		return soap->error;
	if (soap_out_double(soap, "wxzco", -1, &(a->ns1__wtGcsj::wxzco), ""))
		return soap->error;
	if (soap_out_double(soap, "wxzno", -1, &(a->ns1__wtGcsj::wxzno), ""))
		return soap->error;
	if (soap_out_double(soap, "hc", -1, &(a->ns1__wtGcsj::hc), ""))
		return soap->error;
	if (soap_out_double(soap, "co", -1, &(a->ns1__wtGcsj::co), ""))
		return soap->error;
	if (soap_out_double(soap, "no", -1, &(a->ns1__wtGcsj::no), ""))
		return soap->error;
	if (soap_out_double(soap, "o2", -1, &(a->ns1__wtGcsj::o2), ""))
		return soap->error;
	if (soap_out_double(soap, "co2", -1, &(a->ns1__wtGcsj::co2), ""))
		return soap->error;
	if (soap_out_double(soap, "cs", -1, &(a->ns1__wtGcsj::cs), ""))
		return soap->error;
	if (soap_out_double(soap, "zs", -1, &(a->ns1__wtGcsj::zs), ""))
		return soap->error;
	if (soap_out_double(soap, "xsxzxs", -1, &(a->ns1__wtGcsj::xsxzxs), ""))
		return soap->error;
	if (soap_out_double(soap, "sdxzxs", -1, &(a->ns1__wtGcsj::sdxzxs), ""))
		return soap->error;
	if (soap_out_double(soap, "glkqxs", -1, &(a->ns1__wtGcsj::glkqxs), ""))
		return soap->error;
	if (soap_out_double(soap, "dpcgjfz", -1, &(a->ns1__wtGcsj::dpcgjfz), ""))
		return soap->error;
	if (soap_out_double(soap, "zjzgl", -1, &(a->ns1__wtGcsj::zjzgl), ""))
		return soap->error;
	if (soap_out_double(soap, "jsgl", -1, &(a->ns1__wtGcsj::jsgl), ""))
		return soap->error;
	if (soap_out_double(soap, "zsgl", -1, &(a->ns1__wtGcsj::zsgl), ""))
		return soap->error;
	if (soap_out_double(soap, "nl", -1, &(a->ns1__wtGcsj::nl), ""))
		return soap->error;
	if (soap_out_double(soap, "fxyglyl", -1, &(a->ns1__wtGcsj::fxyglyl), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__wtGcsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__wtGcsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__wtGcsj::dqy), ""))
		return soap->error;
	if (soap_out_double(soap, "yw", -1, &(a->ns1__wtGcsj::yw), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wtGcsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wtGcsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wtGcsj * SOAP_FMAC4 soap_in_ns1__wtGcsj(struct soap *soap, const char *tag, ns1__wtGcsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wtGcsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wtGcsj, sizeof(ns1__wtGcsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wtGcsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wtGcsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_qssx1 = 1;
	size_t soap_flag_gklx1 = 1;
	size_t soap_flag_jcsxh1 = 1;
	size_t soap_flag_wxzhc1 = 1;
	size_t soap_flag_wxzco1 = 1;
	size_t soap_flag_wxzno1 = 1;
	size_t soap_flag_hc1 = 1;
	size_t soap_flag_co1 = 1;
	size_t soap_flag_no1 = 1;
	size_t soap_flag_o21 = 1;
	size_t soap_flag_co21 = 1;
	size_t soap_flag_cs1 = 1;
	size_t soap_flag_zs1 = 1;
	size_t soap_flag_xsxzxs1 = 1;
	size_t soap_flag_sdxzxs1 = 1;
	size_t soap_flag_glkqxs1 = 1;
	size_t soap_flag_dpcgjfz1 = 1;
	size_t soap_flag_zjzgl1 = 1;
	size_t soap_flag_jsgl1 = 1;
	size_t soap_flag_zsgl1 = 1;
	size_t soap_flag_nl1 = 1;
	size_t soap_flag_fxyglyl1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	size_t soap_flag_yw1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__wtGcsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__wtGcsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_qssx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qssx", &(a->ns1__wtGcsj::qssx), "xsd:string"))
				{	soap_flag_qssx1--;
					continue;
				}
			if (soap_flag_gklx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gklx", &(a->ns1__wtGcsj::gklx), "xsd:string"))
				{	soap_flag_gklx1--;
					continue;
				}
			if (soap_flag_jcsxh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "jcsxh", &(a->ns1__wtGcsj::jcsxh), "xsd:int"))
				{	soap_flag_jcsxh1--;
					continue;
				}
			if (soap_flag_wxzhc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wxzhc", &(a->ns1__wtGcsj::wxzhc), "xsd:double"))
				{	soap_flag_wxzhc1--;
					continue;
				}
			if (soap_flag_wxzco1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wxzco", &(a->ns1__wtGcsj::wxzco), "xsd:double"))
				{	soap_flag_wxzco1--;
					continue;
				}
			if (soap_flag_wxzno1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wxzno", &(a->ns1__wtGcsj::wxzno), "xsd:double"))
				{	soap_flag_wxzno1--;
					continue;
				}
			if (soap_flag_hc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hc", &(a->ns1__wtGcsj::hc), "xsd:double"))
				{	soap_flag_hc1--;
					continue;
				}
			if (soap_flag_co1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co", &(a->ns1__wtGcsj::co), "xsd:double"))
				{	soap_flag_co1--;
					continue;
				}
			if (soap_flag_no1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "no", &(a->ns1__wtGcsj::no), "xsd:double"))
				{	soap_flag_no1--;
					continue;
				}
			if (soap_flag_o21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "o2", &(a->ns1__wtGcsj::o2), "xsd:double"))
				{	soap_flag_o21--;
					continue;
				}
			if (soap_flag_co21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co2", &(a->ns1__wtGcsj::co2), "xsd:double"))
				{	soap_flag_co21--;
					continue;
				}
			if (soap_flag_cs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "cs", &(a->ns1__wtGcsj::cs), "xsd:double"))
				{	soap_flag_cs1--;
					continue;
				}
			if (soap_flag_zs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zs", &(a->ns1__wtGcsj::zs), "xsd:double"))
				{	soap_flag_zs1--;
					continue;
				}
			if (soap_flag_xsxzxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "xsxzxs", &(a->ns1__wtGcsj::xsxzxs), "xsd:double"))
				{	soap_flag_xsxzxs1--;
					continue;
				}
			if (soap_flag_sdxzxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sdxzxs", &(a->ns1__wtGcsj::sdxzxs), "xsd:double"))
				{	soap_flag_sdxzxs1--;
					continue;
				}
			if (soap_flag_glkqxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "glkqxs", &(a->ns1__wtGcsj::glkqxs), "xsd:double"))
				{	soap_flag_glkqxs1--;
					continue;
				}
			if (soap_flag_dpcgjfz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dpcgjfz", &(a->ns1__wtGcsj::dpcgjfz), "xsd:double"))
				{	soap_flag_dpcgjfz1--;
					continue;
				}
			if (soap_flag_zjzgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zjzgl", &(a->ns1__wtGcsj::zjzgl), "xsd:double"))
				{	soap_flag_zjzgl1--;
					continue;
				}
			if (soap_flag_jsgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jsgl", &(a->ns1__wtGcsj::jsgl), "xsd:double"))
				{	soap_flag_jsgl1--;
					continue;
				}
			if (soap_flag_zsgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zsgl", &(a->ns1__wtGcsj::zsgl), "xsd:double"))
				{	soap_flag_zsgl1--;
					continue;
				}
			if (soap_flag_nl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nl", &(a->ns1__wtGcsj::nl), "xsd:double"))
				{	soap_flag_nl1--;
					continue;
				}
			if (soap_flag_fxyglyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fxyglyl", &(a->ns1__wtGcsj::fxyglyl), "xsd:double"))
				{	soap_flag_fxyglyl1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__wtGcsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__wtGcsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__wtGcsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			if (soap_flag_yw1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yw", &(a->ns1__wtGcsj::yw), "xsd:double"))
				{	soap_flag_yw1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wtGcsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wtGcsj, 0, sizeof(ns1__wtGcsj), 0, soap_copy_ns1__wtGcsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jcsxh1 > 0 || soap_flag_wxzhc1 > 0 || soap_flag_wxzco1 > 0 || soap_flag_wxzno1 > 0 || soap_flag_hc1 > 0 || soap_flag_co1 > 0 || soap_flag_no1 > 0 || soap_flag_o21 > 0 || soap_flag_co21 > 0 || soap_flag_cs1 > 0 || soap_flag_zs1 > 0 || soap_flag_xsxzxs1 > 0 || soap_flag_sdxzxs1 > 0 || soap_flag_glkqxs1 > 0 || soap_flag_dpcgjfz1 > 0 || soap_flag_zjzgl1 > 0 || soap_flag_jsgl1 > 0 || soap_flag_zsgl1 > 0 || soap_flag_nl1 > 0 || soap_flag_fxyglyl1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0 || soap_flag_yw1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__wtGcsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wtGcsj);
	if (this->soap_out(soap, tag?tag:"ns1:wtGcsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wtGcsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wtGcsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wtGcsj * SOAP_FMAC4 soap_get_ns1__wtGcsj(struct soap *soap, ns1__wtGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wtGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wtGcsj * SOAP_FMAC2 soap_instantiate_ns1__wtGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wtGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wtGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wtGcsj);
		if (size)
			*size = sizeof(ns1__wtGcsj);
		((ns1__wtGcsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wtGcsj, n);
		if (size)
			*size = n * sizeof(ns1__wtGcsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wtGcsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wtGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wtGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wtGcsj %p -> %p\n", q, p));
	*(ns1__wtGcsj*)p = *(ns1__wtGcsj*)q;
}

void ns1__jzjsJgsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__jzjsJgsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__jzjsJgsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jzjsJgsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__jzjsJgsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__jzjsJgsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jzjsJgsjResponse(struct soap *soap, const char *tag, int id, const ns1__jzjsJgsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jzjsJgsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__jzjsJgsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__jzjsJgsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__jzjsJgsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__jzjsJgsjResponse * SOAP_FMAC4 soap_in_ns1__jzjsJgsjResponse(struct soap *soap, const char *tag, ns1__jzjsJgsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__jzjsJgsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jzjsJgsjResponse, sizeof(ns1__jzjsJgsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__jzjsJgsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__jzjsJgsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__jzjsJgsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__jzjsJgsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jzjsJgsjResponse, 0, sizeof(ns1__jzjsJgsjResponse), 0, soap_copy_ns1__jzjsJgsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__jzjsJgsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__jzjsJgsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:jzjsJgsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__jzjsJgsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__jzjsJgsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__jzjsJgsjResponse * SOAP_FMAC4 soap_get_ns1__jzjsJgsjResponse(struct soap *soap, ns1__jzjsJgsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jzjsJgsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__jzjsJgsjResponse * SOAP_FMAC2 soap_instantiate_ns1__jzjsJgsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jzjsJgsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jzjsJgsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__jzjsJgsjResponse);
		if (size)
			*size = sizeof(ns1__jzjsJgsjResponse);
		((ns1__jzjsJgsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__jzjsJgsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__jzjsJgsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__jzjsJgsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__jzjsJgsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jzjsJgsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__jzjsJgsjResponse %p -> %p\n", q, p));
	*(ns1__jzjsJgsjResponse*)p = *(ns1__jzjsJgsjResponse*)q;
}

void ns1__jzjsJgsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__jzjsJgsj::lsh = NULL;
	this->ns1__jzjsJgsj::accessToken = NULL;
	soap_default_double(soap, &this->ns1__jzjsJgsj::k100);
	soap_default_double(soap, &this->ns1__jzjsJgsj::k80);
	soap_default_double(soap, &this->ns1__jzjsJgsj::nox80);
	soap_default_double(soap, &this->ns1__jzjsJgsj::zdlbgl);
	soap_default_double(soap, &this->ns1__jzjsJgsj::zdsd);
	soap_default_double(soap, &this->ns1__jzjsJgsj::fdjzs);
	soap_default_double(soap, &this->ns1__jzjsJgsj::dszs);
	soap_default_double(soap, &this->ns1__jzjsJgsj::fdjzssx);
	soap_default_double(soap, &this->ns1__jzjsJgsj::fdjzsxx);
	soap_default_double(soap, &this->ns1__jzjsJgsj::wd);
	soap_default_double(soap, &this->ns1__jzjsJgsj::sd);
	soap_default_double(soap, &this->ns1__jzjsJgsj::dqy);
	this->ns1__jzjsJgsj::kssj = NULL;
	this->ns1__jzjsJgsj::jssj = NULL;
	/* transient soap skipped */
}

void ns1__jzjsJgsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jzjsJgsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jzjsJgsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jzjsJgsj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jzjsJgsj::jssj);
	/* transient soap skipped */
#endif
}

int ns1__jzjsJgsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__jzjsJgsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jzjsJgsj(struct soap *soap, const char *tag, int id, const ns1__jzjsJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jzjsJgsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__jzjsJgsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__jzjsJgsj::accessToken), ""))
		return soap->error;
	if (soap_out_double(soap, "k100", -1, &(a->ns1__jzjsJgsj::k100), ""))
		return soap->error;
	if (soap_out_double(soap, "k80", -1, &(a->ns1__jzjsJgsj::k80), ""))
		return soap->error;
	if (soap_out_double(soap, "nox80", -1, &(a->ns1__jzjsJgsj::nox80), ""))
		return soap->error;
	if (soap_out_double(soap, "zdlbgl", -1, &(a->ns1__jzjsJgsj::zdlbgl), ""))
		return soap->error;
	if (soap_out_double(soap, "zdsd", -1, &(a->ns1__jzjsJgsj::zdsd), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzs", -1, &(a->ns1__jzjsJgsj::fdjzs), ""))
		return soap->error;
	if (soap_out_double(soap, "dszs", -1, &(a->ns1__jzjsJgsj::dszs), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzssx", -1, &(a->ns1__jzjsJgsj::fdjzssx), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzsxx", -1, &(a->ns1__jzjsJgsj::fdjzsxx), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__jzjsJgsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__jzjsJgsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__jzjsJgsj::dqy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__jzjsJgsj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__jzjsJgsj::jssj), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__jzjsJgsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__jzjsJgsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__jzjsJgsj * SOAP_FMAC4 soap_in_ns1__jzjsJgsj(struct soap *soap, const char *tag, ns1__jzjsJgsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__jzjsJgsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jzjsJgsj, sizeof(ns1__jzjsJgsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__jzjsJgsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__jzjsJgsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_k1001 = 1;
	size_t soap_flag_k801 = 1;
	size_t soap_flag_nox801 = 1;
	size_t soap_flag_zdlbgl1 = 1;
	size_t soap_flag_zdsd1 = 1;
	size_t soap_flag_fdjzs1 = 1;
	size_t soap_flag_dszs1 = 1;
	size_t soap_flag_fdjzssx1 = 1;
	size_t soap_flag_fdjzsxx1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__jzjsJgsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__jzjsJgsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_k1001 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "k100", &(a->ns1__jzjsJgsj::k100), "xsd:double"))
				{	soap_flag_k1001--;
					continue;
				}
			if (soap_flag_k801 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "k80", &(a->ns1__jzjsJgsj::k80), "xsd:double"))
				{	soap_flag_k801--;
					continue;
				}
			if (soap_flag_nox801 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nox80", &(a->ns1__jzjsJgsj::nox80), "xsd:double"))
				{	soap_flag_nox801--;
					continue;
				}
			if (soap_flag_zdlbgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zdlbgl", &(a->ns1__jzjsJgsj::zdlbgl), "xsd:double"))
				{	soap_flag_zdlbgl1--;
					continue;
				}
			if (soap_flag_zdsd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zdsd", &(a->ns1__jzjsJgsj::zdsd), "xsd:double"))
				{	soap_flag_zdsd1--;
					continue;
				}
			if (soap_flag_fdjzs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzs", &(a->ns1__jzjsJgsj::fdjzs), "xsd:double"))
				{	soap_flag_fdjzs1--;
					continue;
				}
			if (soap_flag_dszs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dszs", &(a->ns1__jzjsJgsj::dszs), "xsd:double"))
				{	soap_flag_dszs1--;
					continue;
				}
			if (soap_flag_fdjzssx1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzssx", &(a->ns1__jzjsJgsj::fdjzssx), "xsd:double"))
				{	soap_flag_fdjzssx1--;
					continue;
				}
			if (soap_flag_fdjzsxx1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzsxx", &(a->ns1__jzjsJgsj::fdjzsxx), "xsd:double"))
				{	soap_flag_fdjzsxx1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__jzjsJgsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__jzjsJgsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__jzjsJgsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__jzjsJgsj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__jzjsJgsj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__jzjsJgsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jzjsJgsj, 0, sizeof(ns1__jzjsJgsj), 0, soap_copy_ns1__jzjsJgsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_k1001 > 0 || soap_flag_k801 > 0 || soap_flag_nox801 > 0 || soap_flag_zdlbgl1 > 0 || soap_flag_zdsd1 > 0 || soap_flag_fdjzs1 > 0 || soap_flag_dszs1 > 0 || soap_flag_fdjzssx1 > 0 || soap_flag_fdjzsxx1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__jzjsJgsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__jzjsJgsj);
	if (this->soap_out(soap, tag?tag:"ns1:jzjsJgsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__jzjsJgsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__jzjsJgsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__jzjsJgsj * SOAP_FMAC4 soap_get_ns1__jzjsJgsj(struct soap *soap, ns1__jzjsJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jzjsJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__jzjsJgsj * SOAP_FMAC2 soap_instantiate_ns1__jzjsJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jzjsJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jzjsJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__jzjsJgsj);
		if (size)
			*size = sizeof(ns1__jzjsJgsj);
		((ns1__jzjsJgsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__jzjsJgsj, n);
		if (size)
			*size = n * sizeof(ns1__jzjsJgsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__jzjsJgsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__jzjsJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jzjsJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__jzjsJgsj %p -> %p\n", q, p));
	*(ns1__jzjsJgsj*)p = *(ns1__jzjsJgsj*)q;
}

void ns1__getDjclxxResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDjclxxResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getDjclxxResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getDjclxxResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__getDjclxxResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDjclxxResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDjclxxResponse(struct soap *soap, const char *tag, int id, const ns1__getDjclxxResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDjclxxResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__getDjclxxResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getDjclxxResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDjclxxResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDjclxxResponse * SOAP_FMAC4 soap_in_ns1__getDjclxxResponse(struct soap *soap, const char *tag, ns1__getDjclxxResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDjclxxResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDjclxxResponse, sizeof(ns1__getDjclxxResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDjclxxResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDjclxxResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__getDjclxxResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDjclxxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDjclxxResponse, 0, sizeof(ns1__getDjclxxResponse), 0, soap_copy_ns1__getDjclxxResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDjclxxResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getDjclxxResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDjclxxResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDjclxxResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDjclxxResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDjclxxResponse * SOAP_FMAC4 soap_get_ns1__getDjclxxResponse(struct soap *soap, ns1__getDjclxxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDjclxxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDjclxxResponse * SOAP_FMAC2 soap_instantiate_ns1__getDjclxxResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDjclxxResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDjclxxResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDjclxxResponse);
		if (size)
			*size = sizeof(ns1__getDjclxxResponse);
		((ns1__getDjclxxResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getDjclxxResponse, n);
		if (size)
			*size = n * sizeof(ns1__getDjclxxResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getDjclxxResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getDjclxxResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDjclxxResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDjclxxResponse %p -> %p\n", q, p));
	*(ns1__getDjclxxResponse*)p = *(ns1__getDjclxxResponse*)q;
}

void ns1__getDjclxx::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDjclxx::lsh = NULL;
	this->ns1__getDjclxx::accessToken = NULL;
	/* transient soap skipped */
}

void ns1__getDjclxx::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getDjclxx::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getDjclxx::accessToken);
	/* transient soap skipped */
#endif
}

int ns1__getDjclxx::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDjclxx(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDjclxx(struct soap *soap, const char *tag, int id, const ns1__getDjclxx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDjclxx), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__getDjclxx::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__getDjclxx::accessToken), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getDjclxx::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDjclxx(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDjclxx * SOAP_FMAC4 soap_in_ns1__getDjclxx(struct soap *soap, const char *tag, ns1__getDjclxx *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDjclxx *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDjclxx, sizeof(ns1__getDjclxx), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDjclxx)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDjclxx *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__getDjclxx::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__getDjclxx::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDjclxx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDjclxx, 0, sizeof(ns1__getDjclxx), 0, soap_copy_ns1__getDjclxx);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDjclxx::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getDjclxx);
	if (this->soap_out(soap, tag?tag:"ns1:getDjclxx", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDjclxx::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDjclxx(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDjclxx * SOAP_FMAC4 soap_get_ns1__getDjclxx(struct soap *soap, ns1__getDjclxx *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDjclxx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDjclxx * SOAP_FMAC2 soap_instantiate_ns1__getDjclxx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDjclxx(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDjclxx, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDjclxx);
		if (size)
			*size = sizeof(ns1__getDjclxx);
		((ns1__getDjclxx*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getDjclxx, n);
		if (size)
			*size = n * sizeof(ns1__getDjclxx);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getDjclxx*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getDjclxx*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDjclxx(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDjclxx %p -> %p\n", q, p));
	*(ns1__getDjclxx*)p = *(ns1__getDjclxx*)q;
}

void ns1__lgmhdGcsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lgmhdGcsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__lgmhdGcsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lgmhdGcsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__lgmhdGcsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lgmhdGcsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lgmhdGcsjResponse(struct soap *soap, const char *tag, int id, const ns1__lgmhdGcsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lgmhdGcsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__lgmhdGcsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lgmhdGcsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lgmhdGcsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lgmhdGcsjResponse * SOAP_FMAC4 soap_in_ns1__lgmhdGcsjResponse(struct soap *soap, const char *tag, ns1__lgmhdGcsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lgmhdGcsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lgmhdGcsjResponse, sizeof(ns1__lgmhdGcsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lgmhdGcsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lgmhdGcsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__lgmhdGcsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lgmhdGcsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lgmhdGcsjResponse, 0, sizeof(ns1__lgmhdGcsjResponse), 0, soap_copy_ns1__lgmhdGcsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__lgmhdGcsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lgmhdGcsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:lgmhdGcsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lgmhdGcsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lgmhdGcsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lgmhdGcsjResponse * SOAP_FMAC4 soap_get_ns1__lgmhdGcsjResponse(struct soap *soap, ns1__lgmhdGcsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lgmhdGcsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lgmhdGcsjResponse * SOAP_FMAC2 soap_instantiate_ns1__lgmhdGcsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lgmhdGcsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lgmhdGcsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lgmhdGcsjResponse);
		if (size)
			*size = sizeof(ns1__lgmhdGcsjResponse);
		((ns1__lgmhdGcsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lgmhdGcsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__lgmhdGcsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lgmhdGcsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lgmhdGcsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lgmhdGcsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lgmhdGcsjResponse %p -> %p\n", q, p));
	*(ns1__lgmhdGcsjResponse*)p = *(ns1__lgmhdGcsjResponse*)q;
}

void ns1__lgmhdGcsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lgmhdGcsj::lsh = NULL;
	this->ns1__lgmhdGcsj::accessToken = NULL;
	this->ns1__lgmhdGcsj::qssx = NULL;
	soap_default_int(soap, &this->ns1__lgmhdGcsj::jcsxh);
	soap_default_double(soap, &this->ns1__lgmhdGcsj::lgmhd);
	soap_default_double(soap, &this->ns1__lgmhdGcsj::fdjzs);
	soap_default_double(soap, &this->ns1__lgmhdGcsj::wd);
	soap_default_double(soap, &this->ns1__lgmhdGcsj::sd);
	soap_default_double(soap, &this->ns1__lgmhdGcsj::dqy);
	/* transient soap skipped */
}

void ns1__lgmhdGcsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lgmhdGcsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lgmhdGcsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lgmhdGcsj::qssx);
	/* transient soap skipped */
#endif
}

int ns1__lgmhdGcsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lgmhdGcsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lgmhdGcsj(struct soap *soap, const char *tag, int id, const ns1__lgmhdGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lgmhdGcsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__lgmhdGcsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__lgmhdGcsj::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qssx", -1, &(a->ns1__lgmhdGcsj::qssx), ""))
		return soap->error;
	if (soap_out_int(soap, "jcsxh", -1, &(a->ns1__lgmhdGcsj::jcsxh), ""))
		return soap->error;
	if (soap_out_double(soap, "lgmhd", -1, &(a->ns1__lgmhdGcsj::lgmhd), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzs", -1, &(a->ns1__lgmhdGcsj::fdjzs), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__lgmhdGcsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__lgmhdGcsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__lgmhdGcsj::dqy), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lgmhdGcsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lgmhdGcsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lgmhdGcsj * SOAP_FMAC4 soap_in_ns1__lgmhdGcsj(struct soap *soap, const char *tag, ns1__lgmhdGcsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lgmhdGcsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lgmhdGcsj, sizeof(ns1__lgmhdGcsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lgmhdGcsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lgmhdGcsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_qssx1 = 1;
	size_t soap_flag_jcsxh1 = 1;
	size_t soap_flag_lgmhd1 = 1;
	size_t soap_flag_fdjzs1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__lgmhdGcsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__lgmhdGcsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_qssx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qssx", &(a->ns1__lgmhdGcsj::qssx), "xsd:string"))
				{	soap_flag_qssx1--;
					continue;
				}
			if (soap_flag_jcsxh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "jcsxh", &(a->ns1__lgmhdGcsj::jcsxh), "xsd:int"))
				{	soap_flag_jcsxh1--;
					continue;
				}
			if (soap_flag_lgmhd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lgmhd", &(a->ns1__lgmhdGcsj::lgmhd), "xsd:double"))
				{	soap_flag_lgmhd1--;
					continue;
				}
			if (soap_flag_fdjzs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzs", &(a->ns1__lgmhdGcsj::fdjzs), "xsd:double"))
				{	soap_flag_fdjzs1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__lgmhdGcsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__lgmhdGcsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__lgmhdGcsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lgmhdGcsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lgmhdGcsj, 0, sizeof(ns1__lgmhdGcsj), 0, soap_copy_ns1__lgmhdGcsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jcsxh1 > 0 || soap_flag_lgmhd1 > 0 || soap_flag_fdjzs1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lgmhdGcsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lgmhdGcsj);
	if (this->soap_out(soap, tag?tag:"ns1:lgmhdGcsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lgmhdGcsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lgmhdGcsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lgmhdGcsj * SOAP_FMAC4 soap_get_ns1__lgmhdGcsj(struct soap *soap, ns1__lgmhdGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lgmhdGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lgmhdGcsj * SOAP_FMAC2 soap_instantiate_ns1__lgmhdGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lgmhdGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lgmhdGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lgmhdGcsj);
		if (size)
			*size = sizeof(ns1__lgmhdGcsj);
		((ns1__lgmhdGcsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lgmhdGcsj, n);
		if (size)
			*size = n * sizeof(ns1__lgmhdGcsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lgmhdGcsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lgmhdGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lgmhdGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lgmhdGcsj %p -> %p\n", q, p));
	*(ns1__lgmhdGcsj*)p = *(ns1__lgmhdGcsj*)q;
}

void ns1__obdDjlbResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__obdDjlbResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__obdDjlbResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdDjlbResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__obdDjlbResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__obdDjlbResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__obdDjlbResponse(struct soap *soap, const char *tag, int id, const ns1__obdDjlbResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__obdDjlbResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__obdDjlbResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__obdDjlbResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__obdDjlbResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__obdDjlbResponse * SOAP_FMAC4 soap_in_ns1__obdDjlbResponse(struct soap *soap, const char *tag, ns1__obdDjlbResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__obdDjlbResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__obdDjlbResponse, sizeof(ns1__obdDjlbResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__obdDjlbResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__obdDjlbResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__obdDjlbResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__obdDjlbResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__obdDjlbResponse, 0, sizeof(ns1__obdDjlbResponse), 0, soap_copy_ns1__obdDjlbResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__obdDjlbResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__obdDjlbResponse);
	if (this->soap_out(soap, tag?tag:"ns1:obdDjlbResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__obdDjlbResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__obdDjlbResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__obdDjlbResponse * SOAP_FMAC4 soap_get_ns1__obdDjlbResponse(struct soap *soap, ns1__obdDjlbResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__obdDjlbResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__obdDjlbResponse * SOAP_FMAC2 soap_instantiate_ns1__obdDjlbResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__obdDjlbResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__obdDjlbResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__obdDjlbResponse);
		if (size)
			*size = sizeof(ns1__obdDjlbResponse);
		((ns1__obdDjlbResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__obdDjlbResponse, n);
		if (size)
			*size = n * sizeof(ns1__obdDjlbResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__obdDjlbResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__obdDjlbResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__obdDjlbResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__obdDjlbResponse %p -> %p\n", q, p));
	*(ns1__obdDjlbResponse*)p = *(ns1__obdDjlbResponse*)q;
}

void ns1__obdDjlb::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__obdDjlb::jczbh = NULL;
	this->ns1__obdDjlb::cphm = NULL;
	/* transient soap skipped */
}

void ns1__obdDjlb::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdDjlb::jczbh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdDjlb::cphm);
	/* transient soap skipped */
#endif
}

int ns1__obdDjlb::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__obdDjlb(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__obdDjlb(struct soap *soap, const char *tag, int id, const ns1__obdDjlb *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__obdDjlb), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jczbh", -1, &(a->ns1__obdDjlb::jczbh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "cphm", -1, &(a->ns1__obdDjlb::cphm), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__obdDjlb::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__obdDjlb(soap, tag, this, type);
}

SOAP_FMAC3 ns1__obdDjlb * SOAP_FMAC4 soap_in_ns1__obdDjlb(struct soap *soap, const char *tag, ns1__obdDjlb *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__obdDjlb *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__obdDjlb, sizeof(ns1__obdDjlb), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__obdDjlb)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__obdDjlb *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jczbh1 = 1;
	size_t soap_flag_cphm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jczbh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jczbh", &(a->ns1__obdDjlb::jczbh), "xsd:string"))
				{	soap_flag_jczbh1--;
					continue;
				}
			if (soap_flag_cphm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "cphm", &(a->ns1__obdDjlb::cphm), "xsd:string"))
				{	soap_flag_cphm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__obdDjlb *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__obdDjlb, 0, sizeof(ns1__obdDjlb), 0, soap_copy_ns1__obdDjlb);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__obdDjlb::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__obdDjlb);
	if (this->soap_out(soap, tag?tag:"ns1:obdDjlb", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__obdDjlb::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__obdDjlb(soap, this, tag, type);
}

SOAP_FMAC3 ns1__obdDjlb * SOAP_FMAC4 soap_get_ns1__obdDjlb(struct soap *soap, ns1__obdDjlb *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__obdDjlb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__obdDjlb * SOAP_FMAC2 soap_instantiate_ns1__obdDjlb(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__obdDjlb(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__obdDjlb, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__obdDjlb);
		if (size)
			*size = sizeof(ns1__obdDjlb);
		((ns1__obdDjlb*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__obdDjlb, n);
		if (size)
			*size = n * sizeof(ns1__obdDjlb);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__obdDjlb*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__obdDjlb*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__obdDjlb(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__obdDjlb %p -> %p\n", q, p));
	*(ns1__obdDjlb*)p = *(ns1__obdDjlb*)q;
}

void ns1__fwqsjtbResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__fwqsjtbResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__fwqsjtbResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__fwqsjtbResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__fwqsjtbResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__fwqsjtbResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fwqsjtbResponse(struct soap *soap, const char *tag, int id, const ns1__fwqsjtbResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fwqsjtbResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__fwqsjtbResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__fwqsjtbResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__fwqsjtbResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__fwqsjtbResponse * SOAP_FMAC4 soap_in_ns1__fwqsjtbResponse(struct soap *soap, const char *tag, ns1__fwqsjtbResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__fwqsjtbResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fwqsjtbResponse, sizeof(ns1__fwqsjtbResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__fwqsjtbResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__fwqsjtbResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__fwqsjtbResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__fwqsjtbResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fwqsjtbResponse, 0, sizeof(ns1__fwqsjtbResponse), 0, soap_copy_ns1__fwqsjtbResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__fwqsjtbResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__fwqsjtbResponse);
	if (this->soap_out(soap, tag?tag:"ns1:fwqsjtbResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__fwqsjtbResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__fwqsjtbResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__fwqsjtbResponse * SOAP_FMAC4 soap_get_ns1__fwqsjtbResponse(struct soap *soap, ns1__fwqsjtbResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fwqsjtbResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__fwqsjtbResponse * SOAP_FMAC2 soap_instantiate_ns1__fwqsjtbResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__fwqsjtbResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__fwqsjtbResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__fwqsjtbResponse);
		if (size)
			*size = sizeof(ns1__fwqsjtbResponse);
		((ns1__fwqsjtbResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__fwqsjtbResponse, n);
		if (size)
			*size = n * sizeof(ns1__fwqsjtbResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__fwqsjtbResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__fwqsjtbResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__fwqsjtbResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__fwqsjtbResponse %p -> %p\n", q, p));
	*(ns1__fwqsjtbResponse*)p = *(ns1__fwqsjtbResponse*)q;
}

void ns1__fwqsjtb::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__fwqsjtb::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int ns1__fwqsjtb::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__fwqsjtb(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fwqsjtb(struct soap *soap, const char *tag, int id, const ns1__fwqsjtb *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fwqsjtb), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__fwqsjtb::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__fwqsjtb(soap, tag, this, type);
}

SOAP_FMAC3 ns1__fwqsjtb * SOAP_FMAC4 soap_in_ns1__fwqsjtb(struct soap *soap, const char *tag, ns1__fwqsjtb *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__fwqsjtb *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fwqsjtb, sizeof(ns1__fwqsjtb), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__fwqsjtb)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__fwqsjtb *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__fwqsjtb *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fwqsjtb, 0, sizeof(ns1__fwqsjtb), 0, soap_copy_ns1__fwqsjtb);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__fwqsjtb::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__fwqsjtb);
	if (this->soap_out(soap, tag?tag:"ns1:fwqsjtb", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__fwqsjtb::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__fwqsjtb(soap, this, tag, type);
}

SOAP_FMAC3 ns1__fwqsjtb * SOAP_FMAC4 soap_get_ns1__fwqsjtb(struct soap *soap, ns1__fwqsjtb *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fwqsjtb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__fwqsjtb * SOAP_FMAC2 soap_instantiate_ns1__fwqsjtb(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__fwqsjtb(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__fwqsjtb, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__fwqsjtb);
		if (size)
			*size = sizeof(ns1__fwqsjtb);
		((ns1__fwqsjtb*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__fwqsjtb, n);
		if (size)
			*size = n * sizeof(ns1__fwqsjtb);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__fwqsjtb*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__fwqsjtb*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__fwqsjtb(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__fwqsjtb %p -> %p\n", q, p));
	*(ns1__fwqsjtb*)p = *(ns1__fwqsjtb*)q;
}

void ns1__lljzjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lljzjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__lljzjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljzjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__lljzjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lljzjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lljzjResponse(struct soap *soap, const char *tag, int id, const ns1__lljzjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lljzjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__lljzjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lljzjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lljzjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lljzjResponse * SOAP_FMAC4 soap_in_ns1__lljzjResponse(struct soap *soap, const char *tag, ns1__lljzjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lljzjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lljzjResponse, sizeof(ns1__lljzjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lljzjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lljzjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__lljzjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lljzjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lljzjResponse, 0, sizeof(ns1__lljzjResponse), 0, soap_copy_ns1__lljzjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__lljzjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lljzjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:lljzjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lljzjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lljzjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lljzjResponse * SOAP_FMAC4 soap_get_ns1__lljzjResponse(struct soap *soap, ns1__lljzjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lljzjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lljzjResponse * SOAP_FMAC2 soap_instantiate_ns1__lljzjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lljzjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lljzjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lljzjResponse);
		if (size)
			*size = sizeof(ns1__lljzjResponse);
		((ns1__lljzjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lljzjResponse, n);
		if (size)
			*size = n * sizeof(ns1__lljzjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lljzjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lljzjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lljzjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lljzjResponse %p -> %p\n", q, p));
	*(ns1__lljzjResponse*)p = *(ns1__lljzjResponse*)q;
}

void ns1__lljzj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lljzj::accessToken = NULL;
	soap_default_double(soap, &this->ns1__lljzj::jqglljcjg);
	soap_default_double(soap, &this->ns1__lljzj::lljylcjcjg);
	soap_default_double(soap, &this->ns1__lljzj::yqglcbz);
	soap_default_double(soap, &this->ns1__lljzj::yqglcclz);
	soap_default_double(soap, &this->ns1__lljzj::yqglcwc);
	soap_default_double(soap, &this->ns1__lljzj::yqdlcbz);
	soap_default_double(soap, &this->ns1__lljzj::yqdlcclz);
	soap_default_double(soap, &this->ns1__lljzj::yqdlcwc);
	this->ns1__lljzj::jcjg = NULL;
	this->ns1__lljzj::kssj = NULL;
	this->ns1__lljzj::jssj = NULL;
	this->ns1__lljzj::bz = NULL;
	/* transient soap skipped */
}

void ns1__lljzj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljzj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljzj::jcjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljzj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljzj::jssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__lljzj::bz);
	/* transient soap skipped */
#endif
}

int ns1__lljzj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lljzj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lljzj(struct soap *soap, const char *tag, int id, const ns1__lljzj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lljzj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__lljzj::accessToken), ""))
		return soap->error;
	if (soap_out_double(soap, "jqglljcjg", -1, &(a->ns1__lljzj::jqglljcjg), ""))
		return soap->error;
	if (soap_out_double(soap, "lljylcjcjg", -1, &(a->ns1__lljzj::lljylcjcjg), ""))
		return soap->error;
	if (soap_out_double(soap, "yqglcbz", -1, &(a->ns1__lljzj::yqglcbz), ""))
		return soap->error;
	if (soap_out_double(soap, "yqglcclz", -1, &(a->ns1__lljzj::yqglcclz), ""))
		return soap->error;
	if (soap_out_double(soap, "yqglcwc", -1, &(a->ns1__lljzj::yqglcwc), ""))
		return soap->error;
	if (soap_out_double(soap, "yqdlcbz", -1, &(a->ns1__lljzj::yqdlcbz), ""))
		return soap->error;
	if (soap_out_double(soap, "yqdlcclz", -1, &(a->ns1__lljzj::yqdlcclz), ""))
		return soap->error;
	if (soap_out_double(soap, "yqdlcwc", -1, &(a->ns1__lljzj::yqdlcwc), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jcjg", -1, &(a->ns1__lljzj::jcjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__lljzj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__lljzj::jssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bz", -1, &(a->ns1__lljzj::bz), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lljzj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lljzj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lljzj * SOAP_FMAC4 soap_in_ns1__lljzj(struct soap *soap, const char *tag, ns1__lljzj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lljzj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lljzj, sizeof(ns1__lljzj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lljzj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lljzj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_jqglljcjg1 = 1;
	size_t soap_flag_lljylcjcjg1 = 1;
	size_t soap_flag_yqglcbz1 = 1;
	size_t soap_flag_yqglcclz1 = 1;
	size_t soap_flag_yqglcwc1 = 1;
	size_t soap_flag_yqdlcbz1 = 1;
	size_t soap_flag_yqdlcclz1 = 1;
	size_t soap_flag_yqdlcwc1 = 1;
	size_t soap_flag_jcjg1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	size_t soap_flag_bz1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__lljzj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_jqglljcjg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jqglljcjg", &(a->ns1__lljzj::jqglljcjg), "xsd:double"))
				{	soap_flag_jqglljcjg1--;
					continue;
				}
			if (soap_flag_lljylcjcjg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lljylcjcjg", &(a->ns1__lljzj::lljylcjcjg), "xsd:double"))
				{	soap_flag_lljylcjcjg1--;
					continue;
				}
			if (soap_flag_yqglcbz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yqglcbz", &(a->ns1__lljzj::yqglcbz), "xsd:double"))
				{	soap_flag_yqglcbz1--;
					continue;
				}
			if (soap_flag_yqglcclz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yqglcclz", &(a->ns1__lljzj::yqglcclz), "xsd:double"))
				{	soap_flag_yqglcclz1--;
					continue;
				}
			if (soap_flag_yqglcwc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yqglcwc", &(a->ns1__lljzj::yqglcwc), "xsd:double"))
				{	soap_flag_yqglcwc1--;
					continue;
				}
			if (soap_flag_yqdlcbz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yqdlcbz", &(a->ns1__lljzj::yqdlcbz), "xsd:double"))
				{	soap_flag_yqdlcbz1--;
					continue;
				}
			if (soap_flag_yqdlcclz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yqdlcclz", &(a->ns1__lljzj::yqdlcclz), "xsd:double"))
				{	soap_flag_yqdlcclz1--;
					continue;
				}
			if (soap_flag_yqdlcwc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yqdlcwc", &(a->ns1__lljzj::yqdlcwc), "xsd:double"))
				{	soap_flag_yqdlcwc1--;
					continue;
				}
			if (soap_flag_jcjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jcjg", &(a->ns1__lljzj::jcjg), "xsd:string"))
				{	soap_flag_jcjg1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__lljzj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__lljzj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			if (soap_flag_bz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bz", &(a->ns1__lljzj::bz), "xsd:string"))
				{	soap_flag_bz1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lljzj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lljzj, 0, sizeof(ns1__lljzj), 0, soap_copy_ns1__lljzj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jqglljcjg1 > 0 || soap_flag_lljylcjcjg1 > 0 || soap_flag_yqglcbz1 > 0 || soap_flag_yqglcclz1 > 0 || soap_flag_yqglcwc1 > 0 || soap_flag_yqdlcbz1 > 0 || soap_flag_yqdlcclz1 > 0 || soap_flag_yqdlcwc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lljzj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__lljzj);
	if (this->soap_out(soap, tag?tag:"ns1:lljzj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lljzj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lljzj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lljzj * SOAP_FMAC4 soap_get_ns1__lljzj(struct soap *soap, ns1__lljzj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lljzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lljzj * SOAP_FMAC2 soap_instantiate_ns1__lljzj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lljzj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lljzj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lljzj);
		if (size)
			*size = sizeof(ns1__lljzj);
		((ns1__lljzj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__lljzj, n);
		if (size)
			*size = n * sizeof(ns1__lljzj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__lljzj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__lljzj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lljzj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lljzj %p -> %p\n", q, p));
	*(ns1__lljzj*)p = *(ns1__lljzj*)q;
}

void ns1__btgGcsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__btgGcsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__btgGcsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__btgGcsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__btgGcsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__btgGcsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__btgGcsjResponse(struct soap *soap, const char *tag, int id, const ns1__btgGcsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__btgGcsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__btgGcsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__btgGcsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__btgGcsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__btgGcsjResponse * SOAP_FMAC4 soap_in_ns1__btgGcsjResponse(struct soap *soap, const char *tag, ns1__btgGcsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__btgGcsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__btgGcsjResponse, sizeof(ns1__btgGcsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__btgGcsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__btgGcsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__btgGcsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__btgGcsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__btgGcsjResponse, 0, sizeof(ns1__btgGcsjResponse), 0, soap_copy_ns1__btgGcsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__btgGcsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__btgGcsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:btgGcsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__btgGcsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__btgGcsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__btgGcsjResponse * SOAP_FMAC4 soap_get_ns1__btgGcsjResponse(struct soap *soap, ns1__btgGcsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__btgGcsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__btgGcsjResponse * SOAP_FMAC2 soap_instantiate_ns1__btgGcsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__btgGcsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__btgGcsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__btgGcsjResponse);
		if (size)
			*size = sizeof(ns1__btgGcsjResponse);
		((ns1__btgGcsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__btgGcsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__btgGcsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__btgGcsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__btgGcsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__btgGcsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__btgGcsjResponse %p -> %p\n", q, p));
	*(ns1__btgGcsjResponse*)p = *(ns1__btgGcsjResponse*)q;
}

void ns1__btgGcsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__btgGcsj::lsh = NULL;
	this->ns1__btgGcsj::accessToken = NULL;
	this->ns1__btgGcsj::qssx = NULL;
	this->ns1__btgGcsj::gklx = NULL;
	soap_default_int(soap, &this->ns1__btgGcsj::jcsxh);
	soap_default_double(soap, &this->ns1__btgGcsj::ydz);
	soap_default_double(soap, &this->ns1__btgGcsj::fdjzs);
	soap_default_double(soap, &this->ns1__btgGcsj::yw);
	soap_default_double(soap, &this->ns1__btgGcsj::wd);
	soap_default_double(soap, &this->ns1__btgGcsj::sd);
	soap_default_double(soap, &this->ns1__btgGcsj::dqy);
	/* transient soap skipped */
}

void ns1__btgGcsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__btgGcsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__btgGcsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__btgGcsj::qssx);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__btgGcsj::gklx);
	/* transient soap skipped */
#endif
}

int ns1__btgGcsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__btgGcsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__btgGcsj(struct soap *soap, const char *tag, int id, const ns1__btgGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__btgGcsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__btgGcsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__btgGcsj::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qssx", -1, &(a->ns1__btgGcsj::qssx), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gklx", -1, &(a->ns1__btgGcsj::gklx), ""))
		return soap->error;
	if (soap_out_int(soap, "jcsxh", -1, &(a->ns1__btgGcsj::jcsxh), ""))
		return soap->error;
	if (soap_out_double(soap, "ydz", -1, &(a->ns1__btgGcsj::ydz), ""))
		return soap->error;
	if (soap_out_double(soap, "fdjzs", -1, &(a->ns1__btgGcsj::fdjzs), ""))
		return soap->error;
	if (soap_out_double(soap, "yw", -1, &(a->ns1__btgGcsj::yw), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__btgGcsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__btgGcsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__btgGcsj::dqy), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__btgGcsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__btgGcsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__btgGcsj * SOAP_FMAC4 soap_in_ns1__btgGcsj(struct soap *soap, const char *tag, ns1__btgGcsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__btgGcsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__btgGcsj, sizeof(ns1__btgGcsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__btgGcsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__btgGcsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_qssx1 = 1;
	size_t soap_flag_gklx1 = 1;
	size_t soap_flag_jcsxh1 = 1;
	size_t soap_flag_ydz1 = 1;
	size_t soap_flag_fdjzs1 = 1;
	size_t soap_flag_yw1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__btgGcsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__btgGcsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_qssx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qssx", &(a->ns1__btgGcsj::qssx), "xsd:string"))
				{	soap_flag_qssx1--;
					continue;
				}
			if (soap_flag_gklx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gklx", &(a->ns1__btgGcsj::gklx), "xsd:string"))
				{	soap_flag_gklx1--;
					continue;
				}
			if (soap_flag_jcsxh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "jcsxh", &(a->ns1__btgGcsj::jcsxh), "xsd:int"))
				{	soap_flag_jcsxh1--;
					continue;
				}
			if (soap_flag_ydz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ydz", &(a->ns1__btgGcsj::ydz), "xsd:double"))
				{	soap_flag_ydz1--;
					continue;
				}
			if (soap_flag_fdjzs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "fdjzs", &(a->ns1__btgGcsj::fdjzs), "xsd:double"))
				{	soap_flag_fdjzs1--;
					continue;
				}
			if (soap_flag_yw1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yw", &(a->ns1__btgGcsj::yw), "xsd:double"))
				{	soap_flag_yw1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__btgGcsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__btgGcsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__btgGcsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__btgGcsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__btgGcsj, 0, sizeof(ns1__btgGcsj), 0, soap_copy_ns1__btgGcsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jcsxh1 > 0 || soap_flag_ydz1 > 0 || soap_flag_fdjzs1 > 0 || soap_flag_yw1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__btgGcsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__btgGcsj);
	if (this->soap_out(soap, tag?tag:"ns1:btgGcsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__btgGcsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__btgGcsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__btgGcsj * SOAP_FMAC4 soap_get_ns1__btgGcsj(struct soap *soap, ns1__btgGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__btgGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__btgGcsj * SOAP_FMAC2 soap_instantiate_ns1__btgGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__btgGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__btgGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__btgGcsj);
		if (size)
			*size = sizeof(ns1__btgGcsj);
		((ns1__btgGcsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__btgGcsj, n);
		if (size)
			*size = n * sizeof(ns1__btgGcsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__btgGcsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__btgGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__btgGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__btgGcsj %p -> %p\n", q, p));
	*(ns1__btgGcsj*)p = *(ns1__btgGcsj*)q;
}

void ns1__ryzfJysjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ryzfJysjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__ryzfJysjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ryzfJysjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__ryzfJysjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ryzfJysjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ryzfJysjResponse(struct soap *soap, const char *tag, int id, const ns1__ryzfJysjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ryzfJysjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__ryzfJysjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ryzfJysjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ryzfJysjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ryzfJysjResponse * SOAP_FMAC4 soap_in_ns1__ryzfJysjResponse(struct soap *soap, const char *tag, ns1__ryzfJysjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ryzfJysjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ryzfJysjResponse, sizeof(ns1__ryzfJysjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ryzfJysjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ryzfJysjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__ryzfJysjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ryzfJysjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ryzfJysjResponse, 0, sizeof(ns1__ryzfJysjResponse), 0, soap_copy_ns1__ryzfJysjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ryzfJysjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__ryzfJysjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ryzfJysjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ryzfJysjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ryzfJysjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ryzfJysjResponse * SOAP_FMAC4 soap_get_ns1__ryzfJysjResponse(struct soap *soap, ns1__ryzfJysjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ryzfJysjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ryzfJysjResponse * SOAP_FMAC2 soap_instantiate_ns1__ryzfJysjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ryzfJysjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ryzfJysjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ryzfJysjResponse);
		if (size)
			*size = sizeof(ns1__ryzfJysjResponse);
		((ns1__ryzfJysjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__ryzfJysjResponse, n);
		if (size)
			*size = n * sizeof(ns1__ryzfJysjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__ryzfJysjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__ryzfJysjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ryzfJysjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ryzfJysjResponse %p -> %p\n", q, p));
	*(ns1__ryzfJysjResponse*)p = *(ns1__ryzfJysjResponse*)q;
}

void ns1__ryzfJysj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ryzfJysj::lsh = NULL;
	this->ns1__ryzfJysj::accessToken = NULL;
	soap_default_double(soap, &this->ns1__ryzfJysj::jykcsyl);
	soap_default_double(soap, &this->ns1__ryzfJysj::jykssyl);
	this->ns1__ryzfJysj::jykcsjg = NULL;
	soap_default_double(soap, &this->ns1__ryzfJysj::yxgxlll);
	soap_default_double(soap, &this->ns1__ryzfJysj::yxgcsyl);
	soap_default_double(soap, &this->ns1__ryzfJysj::yxgssyl);
	this->ns1__ryzfJysj::yxgcsjg = NULL;
	this->ns1__ryzfJysj::jcjg = NULL;
	this->ns1__ryzfJysj::kssj = NULL;
	this->ns1__ryzfJysj::jssj = NULL;
	/* transient soap skipped */
}

void ns1__ryzfJysj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ryzfJysj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ryzfJysj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ryzfJysj::jykcsjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ryzfJysj::yxgcsjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ryzfJysj::jcjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ryzfJysj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ryzfJysj::jssj);
	/* transient soap skipped */
#endif
}

int ns1__ryzfJysj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ryzfJysj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ryzfJysj(struct soap *soap, const char *tag, int id, const ns1__ryzfJysj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ryzfJysj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__ryzfJysj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__ryzfJysj::accessToken), ""))
		return soap->error;
	if (soap_out_double(soap, "jykcsyl", -1, &(a->ns1__ryzfJysj::jykcsyl), ""))
		return soap->error;
	if (soap_out_double(soap, "jykssyl", -1, &(a->ns1__ryzfJysj::jykssyl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jykcsjg", -1, &(a->ns1__ryzfJysj::jykcsjg), ""))
		return soap->error;
	if (soap_out_double(soap, "yxgxlll", -1, &(a->ns1__ryzfJysj::yxgxlll), ""))
		return soap->error;
	if (soap_out_double(soap, "yxgcsyl", -1, &(a->ns1__ryzfJysj::yxgcsyl), ""))
		return soap->error;
	if (soap_out_double(soap, "yxgssyl", -1, &(a->ns1__ryzfJysj::yxgssyl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "yxgcsjg", -1, &(a->ns1__ryzfJysj::yxgcsjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jcjg", -1, &(a->ns1__ryzfJysj::jcjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__ryzfJysj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__ryzfJysj::jssj), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ryzfJysj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ryzfJysj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ryzfJysj * SOAP_FMAC4 soap_in_ns1__ryzfJysj(struct soap *soap, const char *tag, ns1__ryzfJysj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ryzfJysj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ryzfJysj, sizeof(ns1__ryzfJysj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ryzfJysj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ryzfJysj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_jykcsyl1 = 1;
	size_t soap_flag_jykssyl1 = 1;
	size_t soap_flag_jykcsjg1 = 1;
	size_t soap_flag_yxgxlll1 = 1;
	size_t soap_flag_yxgcsyl1 = 1;
	size_t soap_flag_yxgssyl1 = 1;
	size_t soap_flag_yxgcsjg1 = 1;
	size_t soap_flag_jcjg1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__ryzfJysj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__ryzfJysj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_jykcsyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jykcsyl", &(a->ns1__ryzfJysj::jykcsyl), "xsd:double"))
				{	soap_flag_jykcsyl1--;
					continue;
				}
			if (soap_flag_jykssyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jykssyl", &(a->ns1__ryzfJysj::jykssyl), "xsd:double"))
				{	soap_flag_jykssyl1--;
					continue;
				}
			if (soap_flag_jykcsjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jykcsjg", &(a->ns1__ryzfJysj::jykcsjg), "xsd:string"))
				{	soap_flag_jykcsjg1--;
					continue;
				}
			if (soap_flag_yxgxlll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yxgxlll", &(a->ns1__ryzfJysj::yxgxlll), "xsd:double"))
				{	soap_flag_yxgxlll1--;
					continue;
				}
			if (soap_flag_yxgcsyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yxgcsyl", &(a->ns1__ryzfJysj::yxgcsyl), "xsd:double"))
				{	soap_flag_yxgcsyl1--;
					continue;
				}
			if (soap_flag_yxgssyl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "yxgssyl", &(a->ns1__ryzfJysj::yxgssyl), "xsd:double"))
				{	soap_flag_yxgssyl1--;
					continue;
				}
			if (soap_flag_yxgcsjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "yxgcsjg", &(a->ns1__ryzfJysj::yxgcsjg), "xsd:string"))
				{	soap_flag_yxgcsjg1--;
					continue;
				}
			if (soap_flag_jcjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jcjg", &(a->ns1__ryzfJysj::jcjg), "xsd:string"))
				{	soap_flag_jcjg1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__ryzfJysj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__ryzfJysj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ryzfJysj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ryzfJysj, 0, sizeof(ns1__ryzfJysj), 0, soap_copy_ns1__ryzfJysj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jykcsyl1 > 0 || soap_flag_jykssyl1 > 0 || soap_flag_yxgxlll1 > 0 || soap_flag_yxgcsyl1 > 0 || soap_flag_yxgssyl1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ryzfJysj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__ryzfJysj);
	if (this->soap_out(soap, tag?tag:"ns1:ryzfJysj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ryzfJysj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ryzfJysj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ryzfJysj * SOAP_FMAC4 soap_get_ns1__ryzfJysj(struct soap *soap, ns1__ryzfJysj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ryzfJysj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ryzfJysj * SOAP_FMAC2 soap_instantiate_ns1__ryzfJysj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ryzfJysj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ryzfJysj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ryzfJysj);
		if (size)
			*size = sizeof(ns1__ryzfJysj);
		((ns1__ryzfJysj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__ryzfJysj, n);
		if (size)
			*size = n * sizeof(ns1__ryzfJysj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__ryzfJysj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__ryzfJysj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ryzfJysj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ryzfJysj %p -> %p\n", q, p));
	*(ns1__ryzfJysj*)p = *(ns1__ryzfJysj*)q;
}

void ns1__wgjcJgsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wgjcJgsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__wgjcJgsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__wgjcJgsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wgjcJgsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wgjcJgsjResponse(struct soap *soap, const char *tag, int id, const ns1__wgjcJgsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wgjcJgsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__wgjcJgsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wgjcJgsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wgjcJgsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wgjcJgsjResponse * SOAP_FMAC4 soap_in_ns1__wgjcJgsjResponse(struct soap *soap, const char *tag, ns1__wgjcJgsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wgjcJgsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wgjcJgsjResponse, sizeof(ns1__wgjcJgsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wgjcJgsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wgjcJgsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__wgjcJgsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wgjcJgsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wgjcJgsjResponse, 0, sizeof(ns1__wgjcJgsjResponse), 0, soap_copy_ns1__wgjcJgsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wgjcJgsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wgjcJgsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:wgjcJgsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wgjcJgsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wgjcJgsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wgjcJgsjResponse * SOAP_FMAC4 soap_get_ns1__wgjcJgsjResponse(struct soap *soap, ns1__wgjcJgsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wgjcJgsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wgjcJgsjResponse * SOAP_FMAC2 soap_instantiate_ns1__wgjcJgsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wgjcJgsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wgjcJgsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wgjcJgsjResponse);
		if (size)
			*size = sizeof(ns1__wgjcJgsjResponse);
		((ns1__wgjcJgsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wgjcJgsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__wgjcJgsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wgjcJgsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wgjcJgsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wgjcJgsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wgjcJgsjResponse %p -> %p\n", q, p));
	*(ns1__wgjcJgsjResponse*)p = *(ns1__wgjcJgsjResponse*)q;
}

void ns1__wgjcJgsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wgjcJgsj::lsh = NULL;
	this->ns1__wgjcJgsj::accessToken = NULL;
	this->ns1__wgjcJgsj::cljxzk = NULL;
	this->ns1__wgjcJgsj::pqwrkzzz = NULL;
	this->ns1__wgjcJgsj::fdjsfdkb = NULL;
	this->ns1__wgjcJgsj::sfsjymhy = NULL;
	this->ns1__wgjcJgsj::qzxtfxt = NULL;
	this->ns1__wgjcJgsj::ryzfkzxt = NULL;
	this->ns1__wgjcJgsj::ybpgzqk = NULL;
	this->ns1__wgjcJgsj::sfyjxgz = NULL;
	this->ns1__wgjcJgsj::pqxtsfxl = NULL;
	this->ns1__wgjcJgsj::sfyytxl = NULL;
	this->ns1__wgjcJgsj::sfyobd = NULL;
	this->ns1__wgjcJgsj::ltqysfzc = NULL;
	this->ns1__wgjcJgsj::ltsfqjgj = NULL;
	this->ns1__wgjcJgsj::sfgbktnf = NULL;
	this->ns1__wgjcJgsj::sfzdmxgn = NULL;
	this->ns1__wgjcJgsj::yxypsfyc = NULL;
	this->ns1__wgjcJgsj::sfshgkfjc = NULL;
	this->ns1__wgjcJgsj::cyjg = NULL;
	this->ns1__wgjcJgsj::jyymc = NULL;
	this->ns1__wgjcJgsj::jysj = NULL;
	/* transient soap skipped */
}

void ns1__wgjcJgsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::cljxzk);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::pqwrkzzz);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::fdjsfdkb);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::sfsjymhy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::qzxtfxt);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::ryzfkzxt);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::ybpgzqk);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::sfyjxgz);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::pqxtsfxl);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::sfyytxl);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::sfyobd);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::ltqysfzc);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::ltsfqjgj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::sfgbktnf);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::sfzdmxgn);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::yxypsfyc);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::sfshgkfjc);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::cyjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::jyymc);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wgjcJgsj::jysj);
	/* transient soap skipped */
#endif
}

int ns1__wgjcJgsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wgjcJgsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wgjcJgsj(struct soap *soap, const char *tag, int id, const ns1__wgjcJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wgjcJgsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__wgjcJgsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__wgjcJgsj::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "cljxzk", -1, &(a->ns1__wgjcJgsj::cljxzk), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "pqwrkzzz", -1, &(a->ns1__wgjcJgsj::pqwrkzzz), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fdjsfdkb", -1, &(a->ns1__wgjcJgsj::fdjsfdkb), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "sfsjymhy", -1, &(a->ns1__wgjcJgsj::sfsjymhy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qzxtfxt", -1, &(a->ns1__wgjcJgsj::qzxtfxt), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ryzfkzxt", -1, &(a->ns1__wgjcJgsj::ryzfkzxt), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ybpgzqk", -1, &(a->ns1__wgjcJgsj::ybpgzqk), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "sfyjxgz", -1, &(a->ns1__wgjcJgsj::sfyjxgz), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "pqxtsfxl", -1, &(a->ns1__wgjcJgsj::pqxtsfxl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "sfyytxl", -1, &(a->ns1__wgjcJgsj::sfyytxl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "sfyobd", -1, &(a->ns1__wgjcJgsj::sfyobd), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ltqysfzc", -1, &(a->ns1__wgjcJgsj::ltqysfzc), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ltsfqjgj", -1, &(a->ns1__wgjcJgsj::ltsfqjgj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "sfgbktnf", -1, &(a->ns1__wgjcJgsj::sfgbktnf), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "sfzdmxgn", -1, &(a->ns1__wgjcJgsj::sfzdmxgn), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "yxypsfyc", -1, &(a->ns1__wgjcJgsj::yxypsfyc), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "sfshgkfjc", -1, &(a->ns1__wgjcJgsj::sfshgkfjc), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "cyjg", -1, &(a->ns1__wgjcJgsj::cyjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jyymc", -1, &(a->ns1__wgjcJgsj::jyymc), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jysj", -1, &(a->ns1__wgjcJgsj::jysj), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wgjcJgsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wgjcJgsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wgjcJgsj * SOAP_FMAC4 soap_in_ns1__wgjcJgsj(struct soap *soap, const char *tag, ns1__wgjcJgsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wgjcJgsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wgjcJgsj, sizeof(ns1__wgjcJgsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wgjcJgsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wgjcJgsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_cljxzk1 = 1;
	size_t soap_flag_pqwrkzzz1 = 1;
	size_t soap_flag_fdjsfdkb1 = 1;
	size_t soap_flag_sfsjymhy1 = 1;
	size_t soap_flag_qzxtfxt1 = 1;
	size_t soap_flag_ryzfkzxt1 = 1;
	size_t soap_flag_ybpgzqk1 = 1;
	size_t soap_flag_sfyjxgz1 = 1;
	size_t soap_flag_pqxtsfxl1 = 1;
	size_t soap_flag_sfyytxl1 = 1;
	size_t soap_flag_sfyobd1 = 1;
	size_t soap_flag_ltqysfzc1 = 1;
	size_t soap_flag_ltsfqjgj1 = 1;
	size_t soap_flag_sfgbktnf1 = 1;
	size_t soap_flag_sfzdmxgn1 = 1;
	size_t soap_flag_yxypsfyc1 = 1;
	size_t soap_flag_sfshgkfjc1 = 1;
	size_t soap_flag_cyjg1 = 1;
	size_t soap_flag_jyymc1 = 1;
	size_t soap_flag_jysj1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__wgjcJgsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__wgjcJgsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_cljxzk1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "cljxzk", &(a->ns1__wgjcJgsj::cljxzk), "xsd:string"))
				{	soap_flag_cljxzk1--;
					continue;
				}
			if (soap_flag_pqwrkzzz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "pqwrkzzz", &(a->ns1__wgjcJgsj::pqwrkzzz), "xsd:string"))
				{	soap_flag_pqwrkzzz1--;
					continue;
				}
			if (soap_flag_fdjsfdkb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fdjsfdkb", &(a->ns1__wgjcJgsj::fdjsfdkb), "xsd:string"))
				{	soap_flag_fdjsfdkb1--;
					continue;
				}
			if (soap_flag_sfsjymhy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "sfsjymhy", &(a->ns1__wgjcJgsj::sfsjymhy), "xsd:string"))
				{	soap_flag_sfsjymhy1--;
					continue;
				}
			if (soap_flag_qzxtfxt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qzxtfxt", &(a->ns1__wgjcJgsj::qzxtfxt), "xsd:string"))
				{	soap_flag_qzxtfxt1--;
					continue;
				}
			if (soap_flag_ryzfkzxt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ryzfkzxt", &(a->ns1__wgjcJgsj::ryzfkzxt), "xsd:string"))
				{	soap_flag_ryzfkzxt1--;
					continue;
				}
			if (soap_flag_ybpgzqk1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ybpgzqk", &(a->ns1__wgjcJgsj::ybpgzqk), "xsd:string"))
				{	soap_flag_ybpgzqk1--;
					continue;
				}
			if (soap_flag_sfyjxgz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "sfyjxgz", &(a->ns1__wgjcJgsj::sfyjxgz), "xsd:string"))
				{	soap_flag_sfyjxgz1--;
					continue;
				}
			if (soap_flag_pqxtsfxl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "pqxtsfxl", &(a->ns1__wgjcJgsj::pqxtsfxl), "xsd:string"))
				{	soap_flag_pqxtsfxl1--;
					continue;
				}
			if (soap_flag_sfyytxl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "sfyytxl", &(a->ns1__wgjcJgsj::sfyytxl), "xsd:string"))
				{	soap_flag_sfyytxl1--;
					continue;
				}
			if (soap_flag_sfyobd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "sfyobd", &(a->ns1__wgjcJgsj::sfyobd), "xsd:string"))
				{	soap_flag_sfyobd1--;
					continue;
				}
			if (soap_flag_ltqysfzc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ltqysfzc", &(a->ns1__wgjcJgsj::ltqysfzc), "xsd:string"))
				{	soap_flag_ltqysfzc1--;
					continue;
				}
			if (soap_flag_ltsfqjgj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ltsfqjgj", &(a->ns1__wgjcJgsj::ltsfqjgj), "xsd:string"))
				{	soap_flag_ltsfqjgj1--;
					continue;
				}
			if (soap_flag_sfgbktnf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "sfgbktnf", &(a->ns1__wgjcJgsj::sfgbktnf), "xsd:string"))
				{	soap_flag_sfgbktnf1--;
					continue;
				}
			if (soap_flag_sfzdmxgn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "sfzdmxgn", &(a->ns1__wgjcJgsj::sfzdmxgn), "xsd:string"))
				{	soap_flag_sfzdmxgn1--;
					continue;
				}
			if (soap_flag_yxypsfyc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "yxypsfyc", &(a->ns1__wgjcJgsj::yxypsfyc), "xsd:string"))
				{	soap_flag_yxypsfyc1--;
					continue;
				}
			if (soap_flag_sfshgkfjc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "sfshgkfjc", &(a->ns1__wgjcJgsj::sfshgkfjc), "xsd:string"))
				{	soap_flag_sfshgkfjc1--;
					continue;
				}
			if (soap_flag_cyjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "cyjg", &(a->ns1__wgjcJgsj::cyjg), "xsd:string"))
				{	soap_flag_cyjg1--;
					continue;
				}
			if (soap_flag_jyymc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jyymc", &(a->ns1__wgjcJgsj::jyymc), "xsd:string"))
				{	soap_flag_jyymc1--;
					continue;
				}
			if (soap_flag_jysj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jysj", &(a->ns1__wgjcJgsj::jysj), "xsd:string"))
				{	soap_flag_jysj1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wgjcJgsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wgjcJgsj, 0, sizeof(ns1__wgjcJgsj), 0, soap_copy_ns1__wgjcJgsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wgjcJgsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wgjcJgsj);
	if (this->soap_out(soap, tag?tag:"ns1:wgjcJgsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wgjcJgsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wgjcJgsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wgjcJgsj * SOAP_FMAC4 soap_get_ns1__wgjcJgsj(struct soap *soap, ns1__wgjcJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wgjcJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wgjcJgsj * SOAP_FMAC2 soap_instantiate_ns1__wgjcJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wgjcJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wgjcJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wgjcJgsj);
		if (size)
			*size = sizeof(ns1__wgjcJgsj);
		((ns1__wgjcJgsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wgjcJgsj, n);
		if (size)
			*size = n * sizeof(ns1__wgjcJgsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wgjcJgsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wgjcJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wgjcJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wgjcJgsj %p -> %p\n", q, p));
	*(ns1__wgjcJgsj*)p = *(ns1__wgjcJgsj*)q;
}

void ns1__jystJgsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__jystJgsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__jystJgsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jystJgsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__jystJgsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__jystJgsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jystJgsjResponse(struct soap *soap, const char *tag, int id, const ns1__jystJgsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jystJgsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__jystJgsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__jystJgsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__jystJgsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__jystJgsjResponse * SOAP_FMAC4 soap_in_ns1__jystJgsjResponse(struct soap *soap, const char *tag, ns1__jystJgsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__jystJgsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jystJgsjResponse, sizeof(ns1__jystJgsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__jystJgsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__jystJgsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__jystJgsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__jystJgsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jystJgsjResponse, 0, sizeof(ns1__jystJgsjResponse), 0, soap_copy_ns1__jystJgsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__jystJgsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__jystJgsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:jystJgsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__jystJgsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__jystJgsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__jystJgsjResponse * SOAP_FMAC4 soap_get_ns1__jystJgsjResponse(struct soap *soap, ns1__jystJgsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jystJgsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__jystJgsjResponse * SOAP_FMAC2 soap_instantiate_ns1__jystJgsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jystJgsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jystJgsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__jystJgsjResponse);
		if (size)
			*size = sizeof(ns1__jystJgsjResponse);
		((ns1__jystJgsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__jystJgsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__jystJgsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__jystJgsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__jystJgsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jystJgsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__jystJgsjResponse %p -> %p\n", q, p));
	*(ns1__jystJgsjResponse*)p = *(ns1__jystJgsjResponse*)q;
}

void ns1__jystJgsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__jystJgsj::lsh = NULL;
	this->ns1__jystJgsj::accessToken = NULL;
	soap_default_double(soap, &this->ns1__jystJgsj::co);
	soap_default_double(soap, &this->ns1__jystJgsj::hc);
	soap_default_double(soap, &this->ns1__jystJgsj::no);
	soap_default_double(soap, &this->ns1__jystJgsj::sdgl);
	soap_default_double(soap, &this->ns1__jystJgsj::sjxsjl);
	soap_default_double(soap, &this->ns1__jystJgsj::cssj);
	soap_default_double(soap, &this->ns1__jystJgsj::plcs);
	soap_default_double(soap, &this->ns1__jystJgsj::zplsj);
	soap_default_double(soap, &this->ns1__jystJgsj::wd);
	soap_default_double(soap, &this->ns1__jystJgsj::sd);
	soap_default_double(soap, &this->ns1__jystJgsj::dqy);
	soap_default_double(soap, &this->ns1__jystJgsj::ynd);
	soap_default_double(soap, &this->ns1__jystJgsj::glkqxs);
	this->ns1__jystJgsj::kssj = NULL;
	this->ns1__jystJgsj::jssj = NULL;
	/* transient soap skipped */
}

void ns1__jystJgsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jystJgsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jystJgsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jystJgsj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__jystJgsj::jssj);
	/* transient soap skipped */
#endif
}

int ns1__jystJgsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__jystJgsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jystJgsj(struct soap *soap, const char *tag, int id, const ns1__jystJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jystJgsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__jystJgsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__jystJgsj::accessToken), ""))
		return soap->error;
	if (soap_out_double(soap, "co", -1, &(a->ns1__jystJgsj::co), ""))
		return soap->error;
	if (soap_out_double(soap, "hc", -1, &(a->ns1__jystJgsj::hc), ""))
		return soap->error;
	if (soap_out_double(soap, "no", -1, &(a->ns1__jystJgsj::no), ""))
		return soap->error;
	if (soap_out_double(soap, "sdgl", -1, &(a->ns1__jystJgsj::sdgl), ""))
		return soap->error;
	if (soap_out_double(soap, "sjxsjl", -1, &(a->ns1__jystJgsj::sjxsjl), ""))
		return soap->error;
	if (soap_out_double(soap, "cssj", -1, &(a->ns1__jystJgsj::cssj), ""))
		return soap->error;
	if (soap_out_double(soap, "plcs", -1, &(a->ns1__jystJgsj::plcs), ""))
		return soap->error;
	if (soap_out_double(soap, "zplsj", -1, &(a->ns1__jystJgsj::zplsj), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__jystJgsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__jystJgsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__jystJgsj::dqy), ""))
		return soap->error;
	if (soap_out_double(soap, "ynd", -1, &(a->ns1__jystJgsj::ynd), ""))
		return soap->error;
	if (soap_out_double(soap, "glkqxs", -1, &(a->ns1__jystJgsj::glkqxs), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__jystJgsj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__jystJgsj::jssj), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__jystJgsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__jystJgsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__jystJgsj * SOAP_FMAC4 soap_in_ns1__jystJgsj(struct soap *soap, const char *tag, ns1__jystJgsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__jystJgsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jystJgsj, sizeof(ns1__jystJgsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__jystJgsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__jystJgsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_co1 = 1;
	size_t soap_flag_hc1 = 1;
	size_t soap_flag_no1 = 1;
	size_t soap_flag_sdgl1 = 1;
	size_t soap_flag_sjxsjl1 = 1;
	size_t soap_flag_cssj1 = 1;
	size_t soap_flag_plcs1 = 1;
	size_t soap_flag_zplsj1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	size_t soap_flag_ynd1 = 1;
	size_t soap_flag_glkqxs1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__jystJgsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__jystJgsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_co1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co", &(a->ns1__jystJgsj::co), "xsd:double"))
				{	soap_flag_co1--;
					continue;
				}
			if (soap_flag_hc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hc", &(a->ns1__jystJgsj::hc), "xsd:double"))
				{	soap_flag_hc1--;
					continue;
				}
			if (soap_flag_no1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "no", &(a->ns1__jystJgsj::no), "xsd:double"))
				{	soap_flag_no1--;
					continue;
				}
			if (soap_flag_sdgl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sdgl", &(a->ns1__jystJgsj::sdgl), "xsd:double"))
				{	soap_flag_sdgl1--;
					continue;
				}
			if (soap_flag_sjxsjl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjxsjl", &(a->ns1__jystJgsj::sjxsjl), "xsd:double"))
				{	soap_flag_sjxsjl1--;
					continue;
				}
			if (soap_flag_cssj1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "cssj", &(a->ns1__jystJgsj::cssj), "xsd:double"))
				{	soap_flag_cssj1--;
					continue;
				}
			if (soap_flag_plcs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "plcs", &(a->ns1__jystJgsj::plcs), "xsd:double"))
				{	soap_flag_plcs1--;
					continue;
				}
			if (soap_flag_zplsj1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "zplsj", &(a->ns1__jystJgsj::zplsj), "xsd:double"))
				{	soap_flag_zplsj1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__jystJgsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__jystJgsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__jystJgsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			if (soap_flag_ynd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ynd", &(a->ns1__jystJgsj::ynd), "xsd:double"))
				{	soap_flag_ynd1--;
					continue;
				}
			if (soap_flag_glkqxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "glkqxs", &(a->ns1__jystJgsj::glkqxs), "xsd:double"))
				{	soap_flag_glkqxs1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__jystJgsj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__jystJgsj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__jystJgsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jystJgsj, 0, sizeof(ns1__jystJgsj), 0, soap_copy_ns1__jystJgsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_co1 > 0 || soap_flag_hc1 > 0 || soap_flag_no1 > 0 || soap_flag_sdgl1 > 0 || soap_flag_sjxsjl1 > 0 || soap_flag_cssj1 > 0 || soap_flag_plcs1 > 0 || soap_flag_zplsj1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0 || soap_flag_ynd1 > 0 || soap_flag_glkqxs1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__jystJgsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__jystJgsj);
	if (this->soap_out(soap, tag?tag:"ns1:jystJgsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__jystJgsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__jystJgsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__jystJgsj * SOAP_FMAC4 soap_get_ns1__jystJgsj(struct soap *soap, ns1__jystJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jystJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__jystJgsj * SOAP_FMAC2 soap_instantiate_ns1__jystJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jystJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jystJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__jystJgsj);
		if (size)
			*size = sizeof(ns1__jystJgsj);
		((ns1__jystJgsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__jystJgsj, n);
		if (size)
			*size = n * sizeof(ns1__jystJgsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__jystJgsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__jystJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jystJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__jystJgsj %p -> %p\n", q, p));
	*(ns1__jystJgsj*)p = *(ns1__jystJgsj*)q;
}

void ns1__wqfxybdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wqfxybdResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__wqfxybdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxybdResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__wqfxybdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wqfxybdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wqfxybdResponse(struct soap *soap, const char *tag, int id, const ns1__wqfxybdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wqfxybdResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__wqfxybdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wqfxybdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wqfxybdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wqfxybdResponse * SOAP_FMAC4 soap_in_ns1__wqfxybdResponse(struct soap *soap, const char *tag, ns1__wqfxybdResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wqfxybdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wqfxybdResponse, sizeof(ns1__wqfxybdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wqfxybdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wqfxybdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__wqfxybdResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wqfxybdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wqfxybdResponse, 0, sizeof(ns1__wqfxybdResponse), 0, soap_copy_ns1__wqfxybdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wqfxybdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wqfxybdResponse);
	if (this->soap_out(soap, tag?tag:"ns1:wqfxybdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wqfxybdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wqfxybdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wqfxybdResponse * SOAP_FMAC4 soap_get_ns1__wqfxybdResponse(struct soap *soap, ns1__wqfxybdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wqfxybdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wqfxybdResponse * SOAP_FMAC2 soap_instantiate_ns1__wqfxybdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wqfxybdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wqfxybdResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wqfxybdResponse);
		if (size)
			*size = sizeof(ns1__wqfxybdResponse);
		((ns1__wqfxybdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wqfxybdResponse, n);
		if (size)
			*size = n * sizeof(ns1__wqfxybdResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wqfxybdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wqfxybdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wqfxybdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wqfxybdResponse %p -> %p\n", q, p));
	*(ns1__wqfxybdResponse*)p = *(ns1__wqfxybdResponse*)q;
}

void ns1__wqfxybd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__wqfxybd::accessToken = NULL;
	this->ns1__wqfxybd::bqlb = NULL;
	soap_default_double(soap, &this->ns1__wqfxybd::bzCO2);
	soap_default_double(soap, &this->ns1__wqfxybd::sjCO2);
	soap_default_double(soap, &this->ns1__wqfxybd::bzCO);
	soap_default_double(soap, &this->ns1__wqfxybd::sjCO);
	soap_default_double(soap, &this->ns1__wqfxybd::bzNO);
	soap_default_double(soap, &this->ns1__wqfxybd::sjNO);
	soap_default_double(soap, &this->ns1__wqfxybd::bzHC);
	soap_default_double(soap, &this->ns1__wqfxybd::sjHC);
	soap_default_double(soap, &this->ns1__wqfxybd::bzO2);
	soap_default_double(soap, &this->ns1__wqfxybd::sjO2);
	soap_default_double(soap, &this->ns1__wqfxybd::sjPEF);
	soap_default_double(soap, &this->ns1__wqfxybd::bzC3H8);
	this->ns1__wqfxybd::jcjg = NULL;
	this->ns1__wqfxybd::kssj = NULL;
	this->ns1__wqfxybd::jssj = NULL;
	this->ns1__wqfxybd::bz = NULL;
	/* transient soap skipped */
}

void ns1__wqfxybd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxybd::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxybd::bqlb);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxybd::jcjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxybd::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxybd::jssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__wqfxybd::bz);
	/* transient soap skipped */
#endif
}

int ns1__wqfxybd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wqfxybd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wqfxybd(struct soap *soap, const char *tag, int id, const ns1__wqfxybd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wqfxybd), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__wqfxybd::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bqlb", -1, &(a->ns1__wqfxybd::bqlb), ""))
		return soap->error;
	if (soap_out_double(soap, "bzCO2", -1, &(a->ns1__wqfxybd::bzCO2), ""))
		return soap->error;
	if (soap_out_double(soap, "sjCO2", -1, &(a->ns1__wqfxybd::sjCO2), ""))
		return soap->error;
	if (soap_out_double(soap, "bzCO", -1, &(a->ns1__wqfxybd::bzCO), ""))
		return soap->error;
	if (soap_out_double(soap, "sjCO", -1, &(a->ns1__wqfxybd::sjCO), ""))
		return soap->error;
	if (soap_out_double(soap, "bzNO", -1, &(a->ns1__wqfxybd::bzNO), ""))
		return soap->error;
	if (soap_out_double(soap, "sjNO", -1, &(a->ns1__wqfxybd::sjNO), ""))
		return soap->error;
	if (soap_out_double(soap, "bzHC", -1, &(a->ns1__wqfxybd::bzHC), ""))
		return soap->error;
	if (soap_out_double(soap, "sjHC", -1, &(a->ns1__wqfxybd::sjHC), ""))
		return soap->error;
	if (soap_out_double(soap, "bzO2", -1, &(a->ns1__wqfxybd::bzO2), ""))
		return soap->error;
	if (soap_out_double(soap, "sjO2", -1, &(a->ns1__wqfxybd::sjO2), ""))
		return soap->error;
	if (soap_out_double(soap, "sjPEF", -1, &(a->ns1__wqfxybd::sjPEF), ""))
		return soap->error;
	if (soap_out_double(soap, "bzC3H8", -1, &(a->ns1__wqfxybd::bzC3H8), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jcjg", -1, &(a->ns1__wqfxybd::jcjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__wqfxybd::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__wqfxybd::jssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bz", -1, &(a->ns1__wqfxybd::bz), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__wqfxybd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wqfxybd(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wqfxybd * SOAP_FMAC4 soap_in_ns1__wqfxybd(struct soap *soap, const char *tag, ns1__wqfxybd *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wqfxybd *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wqfxybd, sizeof(ns1__wqfxybd), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wqfxybd)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wqfxybd *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_bqlb1 = 1;
	size_t soap_flag_bzCO21 = 1;
	size_t soap_flag_sjCO21 = 1;
	size_t soap_flag_bzCO1 = 1;
	size_t soap_flag_sjCO1 = 1;
	size_t soap_flag_bzNO1 = 1;
	size_t soap_flag_sjNO1 = 1;
	size_t soap_flag_bzHC1 = 1;
	size_t soap_flag_sjHC1 = 1;
	size_t soap_flag_bzO21 = 1;
	size_t soap_flag_sjO21 = 1;
	size_t soap_flag_sjPEF1 = 1;
	size_t soap_flag_bzC3H81 = 1;
	size_t soap_flag_jcjg1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	size_t soap_flag_bz1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__wqfxybd::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_bqlb1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bqlb", &(a->ns1__wqfxybd::bqlb), "xsd:string"))
				{	soap_flag_bqlb1--;
					continue;
				}
			if (soap_flag_bzCO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bzCO2", &(a->ns1__wqfxybd::bzCO2), "xsd:double"))
				{	soap_flag_bzCO21--;
					continue;
				}
			if (soap_flag_sjCO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjCO2", &(a->ns1__wqfxybd::sjCO2), "xsd:double"))
				{	soap_flag_sjCO21--;
					continue;
				}
			if (soap_flag_bzCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bzCO", &(a->ns1__wqfxybd::bzCO), "xsd:double"))
				{	soap_flag_bzCO1--;
					continue;
				}
			if (soap_flag_sjCO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjCO", &(a->ns1__wqfxybd::sjCO), "xsd:double"))
				{	soap_flag_sjCO1--;
					continue;
				}
			if (soap_flag_bzNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bzNO", &(a->ns1__wqfxybd::bzNO), "xsd:double"))
				{	soap_flag_bzNO1--;
					continue;
				}
			if (soap_flag_sjNO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjNO", &(a->ns1__wqfxybd::sjNO), "xsd:double"))
				{	soap_flag_sjNO1--;
					continue;
				}
			if (soap_flag_bzHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bzHC", &(a->ns1__wqfxybd::bzHC), "xsd:double"))
				{	soap_flag_bzHC1--;
					continue;
				}
			if (soap_flag_sjHC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjHC", &(a->ns1__wqfxybd::sjHC), "xsd:double"))
				{	soap_flag_sjHC1--;
					continue;
				}
			if (soap_flag_bzO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bzO2", &(a->ns1__wqfxybd::bzO2), "xsd:double"))
				{	soap_flag_bzO21--;
					continue;
				}
			if (soap_flag_sjO21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjO2", &(a->ns1__wqfxybd::sjO2), "xsd:double"))
				{	soap_flag_sjO21--;
					continue;
				}
			if (soap_flag_sjPEF1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sjPEF", &(a->ns1__wqfxybd::sjPEF), "xsd:double"))
				{	soap_flag_sjPEF1--;
					continue;
				}
			if (soap_flag_bzC3H81 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bzC3H8", &(a->ns1__wqfxybd::bzC3H8), "xsd:double"))
				{	soap_flag_bzC3H81--;
					continue;
				}
			if (soap_flag_jcjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jcjg", &(a->ns1__wqfxybd::jcjg), "xsd:string"))
				{	soap_flag_jcjg1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__wqfxybd::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__wqfxybd::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			if (soap_flag_bz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bz", &(a->ns1__wqfxybd::bz), "xsd:string"))
				{	soap_flag_bz1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wqfxybd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wqfxybd, 0, sizeof(ns1__wqfxybd), 0, soap_copy_ns1__wqfxybd);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bzCO21 > 0 || soap_flag_sjCO21 > 0 || soap_flag_bzCO1 > 0 || soap_flag_sjCO1 > 0 || soap_flag_bzNO1 > 0 || soap_flag_sjNO1 > 0 || soap_flag_bzHC1 > 0 || soap_flag_sjHC1 > 0 || soap_flag_bzO21 > 0 || soap_flag_sjO21 > 0 || soap_flag_sjPEF1 > 0 || soap_flag_bzC3H81 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__wqfxybd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__wqfxybd);
	if (this->soap_out(soap, tag?tag:"ns1:wqfxybd", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wqfxybd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wqfxybd(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wqfxybd * SOAP_FMAC4 soap_get_ns1__wqfxybd(struct soap *soap, ns1__wqfxybd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wqfxybd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wqfxybd * SOAP_FMAC2 soap_instantiate_ns1__wqfxybd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wqfxybd(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wqfxybd, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wqfxybd);
		if (size)
			*size = sizeof(ns1__wqfxybd);
		((ns1__wqfxybd*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wqfxybd, n);
		if (size)
			*size = n * sizeof(ns1__wqfxybd);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wqfxybd*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wqfxybd*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wqfxybd(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wqfxybd %p -> %p\n", q, p));
	*(ns1__wqfxybd*)p = *(ns1__wqfxybd*)q;
}

void ns1__ydjzjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ydjzjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__ydjzjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjzjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__ydjzjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ydjzjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ydjzjResponse(struct soap *soap, const char *tag, int id, const ns1__ydjzjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ydjzjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__ydjzjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ydjzjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ydjzjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ydjzjResponse * SOAP_FMAC4 soap_in_ns1__ydjzjResponse(struct soap *soap, const char *tag, ns1__ydjzjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ydjzjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ydjzjResponse, sizeof(ns1__ydjzjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ydjzjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ydjzjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__ydjzjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ydjzjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ydjzjResponse, 0, sizeof(ns1__ydjzjResponse), 0, soap_copy_ns1__ydjzjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ydjzjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__ydjzjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ydjzjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ydjzjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ydjzjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ydjzjResponse * SOAP_FMAC4 soap_get_ns1__ydjzjResponse(struct soap *soap, ns1__ydjzjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ydjzjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ydjzjResponse * SOAP_FMAC2 soap_instantiate_ns1__ydjzjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ydjzjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ydjzjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ydjzjResponse);
		if (size)
			*size = sizeof(ns1__ydjzjResponse);
		((ns1__ydjzjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__ydjzjResponse, n);
		if (size)
			*size = n * sizeof(ns1__ydjzjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__ydjzjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__ydjzjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ydjzjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ydjzjResponse %p -> %p\n", q, p));
	*(ns1__ydjzjResponse*)p = *(ns1__ydjzjResponse*)q;
}

void ns1__ydjzj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ydjzj::accessToken = NULL;
	this->ns1__ydjzj::ldjcjg = NULL;
	soap_default_double(soap, &this->ns1__ydjzj::lgpz1);
	soap_default_double(soap, &this->ns1__ydjzj::lgpz2);
	soap_default_double(soap, &this->ns1__ydjzj::jcz1);
	soap_default_double(soap, &this->ns1__ydjzj::jcz2);
	soap_default_double(soap, &this->ns1__ydjzj::wcl1);
	soap_default_double(soap, &this->ns1__ydjzj::wcl2);
	this->ns1__ydjzj::jcjg = NULL;
	this->ns1__ydjzj::kssj = NULL;
	this->ns1__ydjzj::jssj = NULL;
	this->ns1__ydjzj::bz = NULL;
	/* transient soap skipped */
}

void ns1__ydjzj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjzj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjzj::ldjcjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjzj::jcjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjzj::kssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjzj::jssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__ydjzj::bz);
	/* transient soap skipped */
#endif
}

int ns1__ydjzj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ydjzj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ydjzj(struct soap *soap, const char *tag, int id, const ns1__ydjzj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ydjzj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__ydjzj::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ldjcjg", -1, &(a->ns1__ydjzj::ldjcjg), ""))
		return soap->error;
	if (soap_out_double(soap, "lgpz1", -1, &(a->ns1__ydjzj::lgpz1), ""))
		return soap->error;
	if (soap_out_double(soap, "lgpz2", -1, &(a->ns1__ydjzj::lgpz2), ""))
		return soap->error;
	if (soap_out_double(soap, "jcz1", -1, &(a->ns1__ydjzj::jcz1), ""))
		return soap->error;
	if (soap_out_double(soap, "jcz2", -1, &(a->ns1__ydjzj::jcz2), ""))
		return soap->error;
	if (soap_out_double(soap, "wcl1", -1, &(a->ns1__ydjzj::wcl1), ""))
		return soap->error;
	if (soap_out_double(soap, "wcl2", -1, &(a->ns1__ydjzj::wcl2), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jcjg", -1, &(a->ns1__ydjzj::jcjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "kssj", -1, &(a->ns1__ydjzj::kssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jssj", -1, &(a->ns1__ydjzj::jssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bz", -1, &(a->ns1__ydjzj::bz), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ydjzj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ydjzj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ydjzj * SOAP_FMAC4 soap_in_ns1__ydjzj(struct soap *soap, const char *tag, ns1__ydjzj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ydjzj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ydjzj, sizeof(ns1__ydjzj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ydjzj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ydjzj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_ldjcjg1 = 1;
	size_t soap_flag_lgpz11 = 1;
	size_t soap_flag_lgpz21 = 1;
	size_t soap_flag_jcz11 = 1;
	size_t soap_flag_jcz21 = 1;
	size_t soap_flag_wcl11 = 1;
	size_t soap_flag_wcl21 = 1;
	size_t soap_flag_jcjg1 = 1;
	size_t soap_flag_kssj1 = 1;
	size_t soap_flag_jssj1 = 1;
	size_t soap_flag_bz1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__ydjzj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_ldjcjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ldjcjg", &(a->ns1__ydjzj::ldjcjg), "xsd:string"))
				{	soap_flag_ldjcjg1--;
					continue;
				}
			if (soap_flag_lgpz11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lgpz1", &(a->ns1__ydjzj::lgpz1), "xsd:double"))
				{	soap_flag_lgpz11--;
					continue;
				}
			if (soap_flag_lgpz21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "lgpz2", &(a->ns1__ydjzj::lgpz2), "xsd:double"))
				{	soap_flag_lgpz21--;
					continue;
				}
			if (soap_flag_jcz11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jcz1", &(a->ns1__ydjzj::jcz1), "xsd:double"))
				{	soap_flag_jcz11--;
					continue;
				}
			if (soap_flag_jcz21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jcz2", &(a->ns1__ydjzj::jcz2), "xsd:double"))
				{	soap_flag_jcz21--;
					continue;
				}
			if (soap_flag_wcl11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wcl1", &(a->ns1__ydjzj::wcl1), "xsd:double"))
				{	soap_flag_wcl11--;
					continue;
				}
			if (soap_flag_wcl21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wcl2", &(a->ns1__ydjzj::wcl2), "xsd:double"))
				{	soap_flag_wcl21--;
					continue;
				}
			if (soap_flag_jcjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jcjg", &(a->ns1__ydjzj::jcjg), "xsd:string"))
				{	soap_flag_jcjg1--;
					continue;
				}
			if (soap_flag_kssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "kssj", &(a->ns1__ydjzj::kssj), "xsd:string"))
				{	soap_flag_kssj1--;
					continue;
				}
			if (soap_flag_jssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jssj", &(a->ns1__ydjzj::jssj), "xsd:string"))
				{	soap_flag_jssj1--;
					continue;
				}
			if (soap_flag_bz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bz", &(a->ns1__ydjzj::bz), "xsd:string"))
				{	soap_flag_bz1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ydjzj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ydjzj, 0, sizeof(ns1__ydjzj), 0, soap_copy_ns1__ydjzj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lgpz11 > 0 || soap_flag_lgpz21 > 0 || soap_flag_jcz11 > 0 || soap_flag_jcz21 > 0 || soap_flag_wcl11 > 0 || soap_flag_wcl21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ydjzj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__ydjzj);
	if (this->soap_out(soap, tag?tag:"ns1:ydjzj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ydjzj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ydjzj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ydjzj * SOAP_FMAC4 soap_get_ns1__ydjzj(struct soap *soap, ns1__ydjzj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ydjzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ydjzj * SOAP_FMAC2 soap_instantiate_ns1__ydjzj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ydjzj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ydjzj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ydjzj);
		if (size)
			*size = sizeof(ns1__ydjzj);
		((ns1__ydjzj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__ydjzj, n);
		if (size)
			*size = n * sizeof(ns1__ydjzj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__ydjzj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__ydjzj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ydjzj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ydjzj %p -> %p\n", q, p));
	*(ns1__ydjzj*)p = *(ns1__ydjzj*)q;
}

void ns1__obdJgsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__obdJgsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__obdJgsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__obdJgsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__obdJgsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__obdJgsjResponse(struct soap *soap, const char *tag, int id, const ns1__obdJgsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__obdJgsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__obdJgsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__obdJgsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__obdJgsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__obdJgsjResponse * SOAP_FMAC4 soap_in_ns1__obdJgsjResponse(struct soap *soap, const char *tag, ns1__obdJgsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__obdJgsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__obdJgsjResponse, sizeof(ns1__obdJgsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__obdJgsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__obdJgsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__obdJgsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__obdJgsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__obdJgsjResponse, 0, sizeof(ns1__obdJgsjResponse), 0, soap_copy_ns1__obdJgsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__obdJgsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__obdJgsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:obdJgsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__obdJgsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__obdJgsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__obdJgsjResponse * SOAP_FMAC4 soap_get_ns1__obdJgsjResponse(struct soap *soap, ns1__obdJgsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__obdJgsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__obdJgsjResponse * SOAP_FMAC2 soap_instantiate_ns1__obdJgsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__obdJgsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__obdJgsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__obdJgsjResponse);
		if (size)
			*size = sizeof(ns1__obdJgsjResponse);
		((ns1__obdJgsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__obdJgsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__obdJgsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__obdJgsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__obdJgsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__obdJgsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__obdJgsjResponse %p -> %p\n", q, p));
	*(ns1__obdJgsjResponse*)p = *(ns1__obdJgsjResponse*)q;
}

void ns1__obdJgsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__obdJgsj::lsh = NULL;
	this->ns1__obdJgsj::clsbm = NULL;
	this->ns1__obdJgsj::obdzsbz = NULL;
	soap_default_int(soap, &this->ns1__obdJgsj::clxslc);
	this->ns1__obdJgsj::fdjkzdycid = NULL;
	this->ns1__obdJgsj::fdjkzdycvn = NULL;
	this->ns1__obdJgsj::hclkzdycid = NULL;
	this->ns1__obdJgsj::hclkzdycvn = NULL;
	this->ns1__obdJgsj::qtkzdycid = NULL;
	this->ns1__obdJgsj::qtkzdycvn = NULL;
	this->ns1__obdJgsj::obdgzzsq = NULL;
	this->ns1__obdJgsj::obdtxqk = NULL;
	this->ns1__obdJgsj::obdzzqsfdl = NULL;
	this->ns1__obdJgsj::obdjxzt = NULL;
	this->ns1__obdJgsj::obdjcjg = NULL;
	this->ns1__obdJgsj::obdgzxx = NULL;
	this->ns1__obdJgsj::jyymc = NULL;
	this->ns1__obdJgsj::jckssj = NULL;
	this->ns1__obdJgsj::jcjssj = NULL;
	/* transient soap skipped */
}

void ns1__obdJgsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::clsbm);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::obdzsbz);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::fdjkzdycid);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::fdjkzdycvn);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::hclkzdycid);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::hclkzdycvn);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::qtkzdycid);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::qtkzdycvn);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::obdgzzsq);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::obdtxqk);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::obdzzqsfdl);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::obdjxzt);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::obdjcjg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::obdgzxx);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::jyymc);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::jckssj);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__obdJgsj::jcjssj);
	/* transient soap skipped */
#endif
}

int ns1__obdJgsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__obdJgsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__obdJgsj(struct soap *soap, const char *tag, int id, const ns1__obdJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__obdJgsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__obdJgsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "clsbm", -1, &(a->ns1__obdJgsj::clsbm), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "obdzsbz", -1, &(a->ns1__obdJgsj::obdzsbz), ""))
		return soap->error;
	if (soap_out_int(soap, "clxslc", -1, &(a->ns1__obdJgsj::clxslc), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fdjkzdycid", -1, &(a->ns1__obdJgsj::fdjkzdycid), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fdjkzdycvn", -1, &(a->ns1__obdJgsj::fdjkzdycvn), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "hclkzdycid", -1, &(a->ns1__obdJgsj::hclkzdycid), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "hclkzdycvn", -1, &(a->ns1__obdJgsj::hclkzdycvn), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qtkzdycid", -1, &(a->ns1__obdJgsj::qtkzdycid), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qtkzdycvn", -1, &(a->ns1__obdJgsj::qtkzdycvn), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "obdgzzsq", -1, &(a->ns1__obdJgsj::obdgzzsq), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "obdtxqk", -1, &(a->ns1__obdJgsj::obdtxqk), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "obdzzqsfdl", -1, &(a->ns1__obdJgsj::obdzzqsfdl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "obdjxzt", -1, &(a->ns1__obdJgsj::obdjxzt), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "obdjcjg", -1, &(a->ns1__obdJgsj::obdjcjg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "obdgzxx", -1, &(a->ns1__obdJgsj::obdgzxx), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jyymc", -1, &(a->ns1__obdJgsj::jyymc), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jckssj", -1, &(a->ns1__obdJgsj::jckssj), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jcjssj", -1, &(a->ns1__obdJgsj::jcjssj), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__obdJgsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__obdJgsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__obdJgsj * SOAP_FMAC4 soap_in_ns1__obdJgsj(struct soap *soap, const char *tag, ns1__obdJgsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__obdJgsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__obdJgsj, sizeof(ns1__obdJgsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__obdJgsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__obdJgsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_clsbm1 = 1;
	size_t soap_flag_obdzsbz1 = 1;
	size_t soap_flag_clxslc1 = 1;
	size_t soap_flag_fdjkzdycid1 = 1;
	size_t soap_flag_fdjkzdycvn1 = 1;
	size_t soap_flag_hclkzdycid1 = 1;
	size_t soap_flag_hclkzdycvn1 = 1;
	size_t soap_flag_qtkzdycid1 = 1;
	size_t soap_flag_qtkzdycvn1 = 1;
	size_t soap_flag_obdgzzsq1 = 1;
	size_t soap_flag_obdtxqk1 = 1;
	size_t soap_flag_obdzzqsfdl1 = 1;
	size_t soap_flag_obdjxzt1 = 1;
	size_t soap_flag_obdjcjg1 = 1;
	size_t soap_flag_obdgzxx1 = 1;
	size_t soap_flag_jyymc1 = 1;
	size_t soap_flag_jckssj1 = 1;
	size_t soap_flag_jcjssj1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__obdJgsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_clsbm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "clsbm", &(a->ns1__obdJgsj::clsbm), "xsd:string"))
				{	soap_flag_clsbm1--;
					continue;
				}
			if (soap_flag_obdzsbz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "obdzsbz", &(a->ns1__obdJgsj::obdzsbz), "xsd:string"))
				{	soap_flag_obdzsbz1--;
					continue;
				}
			if (soap_flag_clxslc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "clxslc", &(a->ns1__obdJgsj::clxslc), "xsd:int"))
				{	soap_flag_clxslc1--;
					continue;
				}
			if (soap_flag_fdjkzdycid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fdjkzdycid", &(a->ns1__obdJgsj::fdjkzdycid), "xsd:string"))
				{	soap_flag_fdjkzdycid1--;
					continue;
				}
			if (soap_flag_fdjkzdycvn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fdjkzdycvn", &(a->ns1__obdJgsj::fdjkzdycvn), "xsd:string"))
				{	soap_flag_fdjkzdycvn1--;
					continue;
				}
			if (soap_flag_hclkzdycid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "hclkzdycid", &(a->ns1__obdJgsj::hclkzdycid), "xsd:string"))
				{	soap_flag_hclkzdycid1--;
					continue;
				}
			if (soap_flag_hclkzdycvn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "hclkzdycvn", &(a->ns1__obdJgsj::hclkzdycvn), "xsd:string"))
				{	soap_flag_hclkzdycvn1--;
					continue;
				}
			if (soap_flag_qtkzdycid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qtkzdycid", &(a->ns1__obdJgsj::qtkzdycid), "xsd:string"))
				{	soap_flag_qtkzdycid1--;
					continue;
				}
			if (soap_flag_qtkzdycvn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qtkzdycvn", &(a->ns1__obdJgsj::qtkzdycvn), "xsd:string"))
				{	soap_flag_qtkzdycvn1--;
					continue;
				}
			if (soap_flag_obdgzzsq1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "obdgzzsq", &(a->ns1__obdJgsj::obdgzzsq), "xsd:string"))
				{	soap_flag_obdgzzsq1--;
					continue;
				}
			if (soap_flag_obdtxqk1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "obdtxqk", &(a->ns1__obdJgsj::obdtxqk), "xsd:string"))
				{	soap_flag_obdtxqk1--;
					continue;
				}
			if (soap_flag_obdzzqsfdl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "obdzzqsfdl", &(a->ns1__obdJgsj::obdzzqsfdl), "xsd:string"))
				{	soap_flag_obdzzqsfdl1--;
					continue;
				}
			if (soap_flag_obdjxzt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "obdjxzt", &(a->ns1__obdJgsj::obdjxzt), "xsd:string"))
				{	soap_flag_obdjxzt1--;
					continue;
				}
			if (soap_flag_obdjcjg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "obdjcjg", &(a->ns1__obdJgsj::obdjcjg), "xsd:string"))
				{	soap_flag_obdjcjg1--;
					continue;
				}
			if (soap_flag_obdgzxx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "obdgzxx", &(a->ns1__obdJgsj::obdgzxx), "xsd:string"))
				{	soap_flag_obdgzxx1--;
					continue;
				}
			if (soap_flag_jyymc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jyymc", &(a->ns1__obdJgsj::jyymc), "xsd:string"))
				{	soap_flag_jyymc1--;
					continue;
				}
			if (soap_flag_jckssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jckssj", &(a->ns1__obdJgsj::jckssj), "xsd:string"))
				{	soap_flag_jckssj1--;
					continue;
				}
			if (soap_flag_jcjssj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jcjssj", &(a->ns1__obdJgsj::jcjssj), "xsd:string"))
				{	soap_flag_jcjssj1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__obdJgsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__obdJgsj, 0, sizeof(ns1__obdJgsj), 0, soap_copy_ns1__obdJgsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_clxslc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__obdJgsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__obdJgsj);
	if (this->soap_out(soap, tag?tag:"ns1:obdJgsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__obdJgsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__obdJgsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__obdJgsj * SOAP_FMAC4 soap_get_ns1__obdJgsj(struct soap *soap, ns1__obdJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__obdJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__obdJgsj * SOAP_FMAC2 soap_instantiate_ns1__obdJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__obdJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__obdJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__obdJgsj);
		if (size)
			*size = sizeof(ns1__obdJgsj);
		((ns1__obdJgsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__obdJgsj, n);
		if (size)
			*size = n * sizeof(ns1__obdJgsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__obdJgsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__obdJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__obdJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__obdJgsj %p -> %p\n", q, p));
	*(ns1__obdJgsj*)p = *(ns1__obdJgsj*)q;
}

void ns1__gkrjbbhResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__gkrjbbhResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__gkrjbbhResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gkrjbbhResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__gkrjbbhResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gkrjbbhResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gkrjbbhResponse(struct soap *soap, const char *tag, int id, const ns1__gkrjbbhResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gkrjbbhResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__gkrjbbhResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gkrjbbhResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gkrjbbhResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gkrjbbhResponse * SOAP_FMAC4 soap_in_ns1__gkrjbbhResponse(struct soap *soap, const char *tag, ns1__gkrjbbhResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gkrjbbhResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gkrjbbhResponse, sizeof(ns1__gkrjbbhResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gkrjbbhResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gkrjbbhResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__gkrjbbhResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gkrjbbhResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gkrjbbhResponse, 0, sizeof(ns1__gkrjbbhResponse), 0, soap_copy_ns1__gkrjbbhResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__gkrjbbhResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__gkrjbbhResponse);
	if (this->soap_out(soap, tag?tag:"ns1:gkrjbbhResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__gkrjbbhResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gkrjbbhResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gkrjbbhResponse * SOAP_FMAC4 soap_get_ns1__gkrjbbhResponse(struct soap *soap, ns1__gkrjbbhResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gkrjbbhResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__gkrjbbhResponse * SOAP_FMAC2 soap_instantiate_ns1__gkrjbbhResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gkrjbbhResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gkrjbbhResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__gkrjbbhResponse);
		if (size)
			*size = sizeof(ns1__gkrjbbhResponse);
		((ns1__gkrjbbhResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__gkrjbbhResponse, n);
		if (size)
			*size = n * sizeof(ns1__gkrjbbhResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__gkrjbbhResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__gkrjbbhResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gkrjbbhResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gkrjbbhResponse %p -> %p\n", q, p));
	*(ns1__gkrjbbhResponse*)p = *(ns1__gkrjbbhResponse*)q;
}

void ns1__gkrjbbh::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__gkrjbbh::accessToken = NULL;
	this->ns1__gkrjbbh::bbh = NULL;
	/* transient soap skipped */
}

void ns1__gkrjbbh::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gkrjbbh::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gkrjbbh::bbh);
	/* transient soap skipped */
#endif
}

int ns1__gkrjbbh::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gkrjbbh(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gkrjbbh(struct soap *soap, const char *tag, int id, const ns1__gkrjbbh *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gkrjbbh), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__gkrjbbh::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bbh", -1, &(a->ns1__gkrjbbh::bbh), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gkrjbbh::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gkrjbbh(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gkrjbbh * SOAP_FMAC4 soap_in_ns1__gkrjbbh(struct soap *soap, const char *tag, ns1__gkrjbbh *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gkrjbbh *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gkrjbbh, sizeof(ns1__gkrjbbh), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gkrjbbh)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gkrjbbh *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_bbh1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__gkrjbbh::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_bbh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bbh", &(a->ns1__gkrjbbh::bbh), "xsd:string"))
				{	soap_flag_bbh1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gkrjbbh *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gkrjbbh, 0, sizeof(ns1__gkrjbbh), 0, soap_copy_ns1__gkrjbbh);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__gkrjbbh::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__gkrjbbh);
	if (this->soap_out(soap, tag?tag:"ns1:gkrjbbh", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__gkrjbbh::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gkrjbbh(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gkrjbbh * SOAP_FMAC4 soap_get_ns1__gkrjbbh(struct soap *soap, ns1__gkrjbbh *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gkrjbbh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__gkrjbbh * SOAP_FMAC2 soap_instantiate_ns1__gkrjbbh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gkrjbbh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gkrjbbh, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__gkrjbbh);
		if (size)
			*size = sizeof(ns1__gkrjbbh);
		((ns1__gkrjbbh*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__gkrjbbh, n);
		if (size)
			*size = n * sizeof(ns1__gkrjbbh);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__gkrjbbh*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__gkrjbbh*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gkrjbbh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gkrjbbh %p -> %p\n", q, p));
	*(ns1__gkrjbbh*)p = *(ns1__gkrjbbh*)q;
}

void ns1__getAccessTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getAccessTokenResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getAccessTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getAccessTokenResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__getAccessTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getAccessTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAccessTokenResponse(struct soap *soap, const char *tag, int id, const ns1__getAccessTokenResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAccessTokenResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__getAccessTokenResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getAccessTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getAccessTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getAccessTokenResponse * SOAP_FMAC4 soap_in_ns1__getAccessTokenResponse(struct soap *soap, const char *tag, ns1__getAccessTokenResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getAccessTokenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAccessTokenResponse, sizeof(ns1__getAccessTokenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getAccessTokenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getAccessTokenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__getAccessTokenResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getAccessTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAccessTokenResponse, 0, sizeof(ns1__getAccessTokenResponse), 0, soap_copy_ns1__getAccessTokenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getAccessTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getAccessTokenResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getAccessTokenResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getAccessTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getAccessTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getAccessTokenResponse * SOAP_FMAC4 soap_get_ns1__getAccessTokenResponse(struct soap *soap, ns1__getAccessTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAccessTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getAccessTokenResponse * SOAP_FMAC2 soap_instantiate_ns1__getAccessTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAccessTokenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAccessTokenResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAccessTokenResponse);
		if (size)
			*size = sizeof(ns1__getAccessTokenResponse);
		((ns1__getAccessTokenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getAccessTokenResponse, n);
		if (size)
			*size = n * sizeof(ns1__getAccessTokenResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getAccessTokenResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getAccessTokenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAccessTokenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getAccessTokenResponse %p -> %p\n", q, p));
	*(ns1__getAccessTokenResponse*)p = *(ns1__getAccessTokenResponse*)q;
}

void ns1__getAccessToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getAccessToken::jcxbh = NULL;
	/* transient soap skipped */
}

void ns1__getAccessToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__getAccessToken::jcxbh);
	/* transient soap skipped */
#endif
}

int ns1__getAccessToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getAccessToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAccessToken(struct soap *soap, const char *tag, int id, const ns1__getAccessToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAccessToken), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "jcxbh", -1, &(a->ns1__getAccessToken::jcxbh), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getAccessToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getAccessToken(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getAccessToken * SOAP_FMAC4 soap_in_ns1__getAccessToken(struct soap *soap, const char *tag, ns1__getAccessToken *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getAccessToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAccessToken, sizeof(ns1__getAccessToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getAccessToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getAccessToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jcxbh1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jcxbh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "jcxbh", &(a->ns1__getAccessToken::jcxbh), "xsd:string"))
				{	soap_flag_jcxbh1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getAccessToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAccessToken, 0, sizeof(ns1__getAccessToken), 0, soap_copy_ns1__getAccessToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getAccessToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__getAccessToken);
	if (this->soap_out(soap, tag?tag:"ns1:getAccessToken", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getAccessToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getAccessToken(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getAccessToken * SOAP_FMAC4 soap_get_ns1__getAccessToken(struct soap *soap, ns1__getAccessToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAccessToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getAccessToken * SOAP_FMAC2 soap_instantiate_ns1__getAccessToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAccessToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAccessToken, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAccessToken);
		if (size)
			*size = sizeof(ns1__getAccessToken);
		((ns1__getAccessToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getAccessToken, n);
		if (size)
			*size = n * sizeof(ns1__getAccessToken);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getAccessToken*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getAccessToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAccessToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getAccessToken %p -> %p\n", q, p));
	*(ns1__getAccessToken*)p = *(ns1__getAccessToken*)q;
}

void ns1__sdsGcsjResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sdsGcsjResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__sdsGcsjResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsGcsjResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__sdsGcsjResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sdsGcsjResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sdsGcsjResponse(struct soap *soap, const char *tag, int id, const ns1__sdsGcsjResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sdsGcsjResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "return", -1, &(a->ns1__sdsGcsjResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sdsGcsjResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sdsGcsjResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sdsGcsjResponse * SOAP_FMAC4 soap_in_ns1__sdsGcsjResponse(struct soap *soap, const char *tag, ns1__sdsGcsjResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sdsGcsjResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sdsGcsjResponse, sizeof(ns1__sdsGcsjResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sdsGcsjResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sdsGcsjResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(a->ns1__sdsGcsjResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sdsGcsjResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sdsGcsjResponse, 0, sizeof(ns1__sdsGcsjResponse), 0, soap_copy_ns1__sdsGcsjResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__sdsGcsjResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__sdsGcsjResponse);
	if (this->soap_out(soap, tag?tag:"ns1:sdsGcsjResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sdsGcsjResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sdsGcsjResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sdsGcsjResponse * SOAP_FMAC4 soap_get_ns1__sdsGcsjResponse(struct soap *soap, ns1__sdsGcsjResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sdsGcsjResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sdsGcsjResponse * SOAP_FMAC2 soap_instantiate_ns1__sdsGcsjResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sdsGcsjResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sdsGcsjResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sdsGcsjResponse);
		if (size)
			*size = sizeof(ns1__sdsGcsjResponse);
		((ns1__sdsGcsjResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sdsGcsjResponse, n);
		if (size)
			*size = n * sizeof(ns1__sdsGcsjResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sdsGcsjResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sdsGcsjResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sdsGcsjResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sdsGcsjResponse %p -> %p\n", q, p));
	*(ns1__sdsGcsjResponse*)p = *(ns1__sdsGcsjResponse*)q;
}

void ns1__sdsGcsj::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sdsGcsj::lsh = NULL;
	this->ns1__sdsGcsj::accessToken = NULL;
	this->ns1__sdsGcsj::qssx = NULL;
	this->ns1__sdsGcsj::gklx = NULL;
	soap_default_int(soap, &this->ns1__sdsGcsj::jcsxh);
	soap_default_double(soap, &this->ns1__sdsGcsj::hc);
	soap_default_double(soap, &this->ns1__sdsGcsj::co);
	soap_default_double(soap, &this->ns1__sdsGcsj::co2);
	soap_default_double(soap, &this->ns1__sdsGcsj::o2);
	soap_default_double(soap, &this->ns1__sdsGcsj::glkqxs);
	soap_default_double(soap, &this->ns1__sdsGcsj::jyyw);
	this->ns1__sdsGcsj::fdjzs = NULL;
	soap_default_double(soap, &this->ns1__sdsGcsj::wd);
	soap_default_double(soap, &this->ns1__sdsGcsj::sd);
	soap_default_double(soap, &this->ns1__sdsGcsj::dqy);
	/* transient soap skipped */
}

void ns1__sdsGcsj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsGcsj::lsh);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsGcsj::accessToken);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsGcsj::qssx);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsGcsj::gklx);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__sdsGcsj::fdjzs);
	/* transient soap skipped */
#endif
}

int ns1__sdsGcsj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sdsGcsj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sdsGcsj(struct soap *soap, const char *tag, int id, const ns1__sdsGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sdsGcsj), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "lsh", -1, &(a->ns1__sdsGcsj::lsh), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "accessToken", -1, &(a->ns1__sdsGcsj::accessToken), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "qssx", -1, &(a->ns1__sdsGcsj::qssx), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gklx", -1, &(a->ns1__sdsGcsj::gklx), ""))
		return soap->error;
	if (soap_out_int(soap, "jcsxh", -1, &(a->ns1__sdsGcsj::jcsxh), ""))
		return soap->error;
	if (soap_out_double(soap, "hc", -1, &(a->ns1__sdsGcsj::hc), ""))
		return soap->error;
	if (soap_out_double(soap, "co", -1, &(a->ns1__sdsGcsj::co), ""))
		return soap->error;
	if (soap_out_double(soap, "co2", -1, &(a->ns1__sdsGcsj::co2), ""))
		return soap->error;
	if (soap_out_double(soap, "o2", -1, &(a->ns1__sdsGcsj::o2), ""))
		return soap->error;
	if (soap_out_double(soap, "glkqxs", -1, &(a->ns1__sdsGcsj::glkqxs), ""))
		return soap->error;
	if (soap_out_double(soap, "jyyw", -1, &(a->ns1__sdsGcsj::jyyw), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fdjzs", -1, &(a->ns1__sdsGcsj::fdjzs), ""))
		return soap->error;
	if (soap_out_double(soap, "wd", -1, &(a->ns1__sdsGcsj::wd), ""))
		return soap->error;
	if (soap_out_double(soap, "sd", -1, &(a->ns1__sdsGcsj::sd), ""))
		return soap->error;
	if (soap_out_double(soap, "dqy", -1, &(a->ns1__sdsGcsj::dqy), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sdsGcsj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sdsGcsj(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sdsGcsj * SOAP_FMAC4 soap_in_ns1__sdsGcsj(struct soap *soap, const char *tag, ns1__sdsGcsj *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sdsGcsj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sdsGcsj, sizeof(ns1__sdsGcsj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sdsGcsj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sdsGcsj *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lsh1 = 1;
	size_t soap_flag_accessToken1 = 1;
	size_t soap_flag_qssx1 = 1;
	size_t soap_flag_gklx1 = 1;
	size_t soap_flag_jcsxh1 = 1;
	size_t soap_flag_hc1 = 1;
	size_t soap_flag_co1 = 1;
	size_t soap_flag_co21 = 1;
	size_t soap_flag_o21 = 1;
	size_t soap_flag_glkqxs1 = 1;
	size_t soap_flag_jyyw1 = 1;
	size_t soap_flag_fdjzs1 = 1;
	size_t soap_flag_wd1 = 1;
	size_t soap_flag_sd1 = 1;
	size_t soap_flag_dqy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lsh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "lsh", &(a->ns1__sdsGcsj::lsh), "xsd:string"))
				{	soap_flag_lsh1--;
					continue;
				}
			if (soap_flag_accessToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "accessToken", &(a->ns1__sdsGcsj::accessToken), "xsd:string"))
				{	soap_flag_accessToken1--;
					continue;
				}
			if (soap_flag_qssx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "qssx", &(a->ns1__sdsGcsj::qssx), "xsd:string"))
				{	soap_flag_qssx1--;
					continue;
				}
			if (soap_flag_gklx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gklx", &(a->ns1__sdsGcsj::gklx), "xsd:string"))
				{	soap_flag_gklx1--;
					continue;
				}
			if (soap_flag_jcsxh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "jcsxh", &(a->ns1__sdsGcsj::jcsxh), "xsd:int"))
				{	soap_flag_jcsxh1--;
					continue;
				}
			if (soap_flag_hc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "hc", &(a->ns1__sdsGcsj::hc), "xsd:double"))
				{	soap_flag_hc1--;
					continue;
				}
			if (soap_flag_co1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co", &(a->ns1__sdsGcsj::co), "xsd:double"))
				{	soap_flag_co1--;
					continue;
				}
			if (soap_flag_co21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "co2", &(a->ns1__sdsGcsj::co2), "xsd:double"))
				{	soap_flag_co21--;
					continue;
				}
			if (soap_flag_o21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "o2", &(a->ns1__sdsGcsj::o2), "xsd:double"))
				{	soap_flag_o21--;
					continue;
				}
			if (soap_flag_glkqxs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "glkqxs", &(a->ns1__sdsGcsj::glkqxs), "xsd:double"))
				{	soap_flag_glkqxs1--;
					continue;
				}
			if (soap_flag_jyyw1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "jyyw", &(a->ns1__sdsGcsj::jyyw), "xsd:double"))
				{	soap_flag_jyyw1--;
					continue;
				}
			if (soap_flag_fdjzs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fdjzs", &(a->ns1__sdsGcsj::fdjzs), "xsd:string"))
				{	soap_flag_fdjzs1--;
					continue;
				}
			if (soap_flag_wd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "wd", &(a->ns1__sdsGcsj::wd), "xsd:double"))
				{	soap_flag_wd1--;
					continue;
				}
			if (soap_flag_sd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "sd", &(a->ns1__sdsGcsj::sd), "xsd:double"))
				{	soap_flag_sd1--;
					continue;
				}
			if (soap_flag_dqy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dqy", &(a->ns1__sdsGcsj::dqy), "xsd:double"))
				{	soap_flag_dqy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sdsGcsj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sdsGcsj, 0, sizeof(ns1__sdsGcsj), 0, soap_copy_ns1__sdsGcsj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jcsxh1 > 0 || soap_flag_hc1 > 0 || soap_flag_co1 > 0 || soap_flag_co21 > 0 || soap_flag_o21 > 0 || soap_flag_glkqxs1 > 0 || soap_flag_jyyw1 > 0 || soap_flag_wd1 > 0 || soap_flag_sd1 > 0 || soap_flag_dqy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__sdsGcsj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__sdsGcsj);
	if (this->soap_out(soap, tag?tag:"ns1:sdsGcsj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sdsGcsj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sdsGcsj(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sdsGcsj * SOAP_FMAC4 soap_get_ns1__sdsGcsj(struct soap *soap, ns1__sdsGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sdsGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sdsGcsj * SOAP_FMAC2 soap_instantiate_ns1__sdsGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sdsGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sdsGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sdsGcsj);
		if (size)
			*size = sizeof(ns1__sdsGcsj);
		((ns1__sdsGcsj*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sdsGcsj, n);
		if (size)
			*size = n * sizeof(ns1__sdsGcsj);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sdsGcsj*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sdsGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sdsGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sdsGcsj %p -> %p\n", q, p));
	*(ns1__sdsGcsj*)p = *(ns1__sdsGcsj*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__qycObdIupr(struct soap *soap, struct __ns1__qycObdIupr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__qycObdIupr_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__qycObdIupr(struct soap *soap, const struct __ns1__qycObdIupr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__qycObdIupr(soap, &a->ns1__qycObdIupr_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__qycObdIupr(struct soap *soap, const char *tag, int id, const struct __ns1__qycObdIupr *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__qycObdIupr(soap, "ns1:qycObdIupr", -1, &a->ns1__qycObdIupr_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__qycObdIupr * SOAP_FMAC4 soap_in___ns1__qycObdIupr(struct soap *soap, const char *tag, struct __ns1__qycObdIupr *a, const char *type)
{
	size_t soap_flag_ns1__qycObdIupr_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__qycObdIupr *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__qycObdIupr, sizeof(struct __ns1__qycObdIupr), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__qycObdIupr(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__qycObdIupr_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__qycObdIupr(soap, "ns1:qycObdIupr", &a->ns1__qycObdIupr_, "ns1:qycObdIupr"))
				{	soap_flag_ns1__qycObdIupr_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__qycObdIupr(struct soap *soap, const struct __ns1__qycObdIupr *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__qycObdIupr(soap, tag?tag:"-ns1:qycObdIupr", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__qycObdIupr * SOAP_FMAC4 soap_get___ns1__qycObdIupr(struct soap *soap, struct __ns1__qycObdIupr *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__qycObdIupr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__qycObdIupr * SOAP_FMAC2 soap_instantiate___ns1__qycObdIupr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__qycObdIupr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__qycObdIupr, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__qycObdIupr);
		if (size)
			*size = sizeof(struct __ns1__qycObdIupr);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__qycObdIupr, n);
		if (size)
			*size = n * sizeof(struct __ns1__qycObdIupr);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__qycObdIupr*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__qycObdIupr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__qycObdIupr %p -> %p\n", q, p));
	*(struct __ns1__qycObdIupr*)p = *(struct __ns1__qycObdIupr*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sdsJgsj(struct soap *soap, struct __ns1__sdsJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sdsJgsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sdsJgsj(struct soap *soap, const struct __ns1__sdsJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__sdsJgsj(soap, &a->ns1__sdsJgsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sdsJgsj(struct soap *soap, const char *tag, int id, const struct __ns1__sdsJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__sdsJgsj(soap, "ns1:sdsJgsj", -1, &a->ns1__sdsJgsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sdsJgsj * SOAP_FMAC4 soap_in___ns1__sdsJgsj(struct soap *soap, const char *tag, struct __ns1__sdsJgsj *a, const char *type)
{
	size_t soap_flag_ns1__sdsJgsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sdsJgsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sdsJgsj, sizeof(struct __ns1__sdsJgsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sdsJgsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sdsJgsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sdsJgsj(soap, "ns1:sdsJgsj", &a->ns1__sdsJgsj_, "ns1:sdsJgsj"))
				{	soap_flag_ns1__sdsJgsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sdsJgsj(struct soap *soap, const struct __ns1__sdsJgsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sdsJgsj(soap, tag?tag:"-ns1:sdsJgsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sdsJgsj * SOAP_FMAC4 soap_get___ns1__sdsJgsj(struct soap *soap, struct __ns1__sdsJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sdsJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sdsJgsj * SOAP_FMAC2 soap_instantiate___ns1__sdsJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sdsJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sdsJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sdsJgsj);
		if (size)
			*size = sizeof(struct __ns1__sdsJgsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__sdsJgsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__sdsJgsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__sdsJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sdsJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sdsJgsj %p -> %p\n", q, p));
	*(struct __ns1__sdsJgsj*)p = *(struct __ns1__sdsJgsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cycObdIupr(struct soap *soap, struct __ns1__cycObdIupr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cycObdIupr_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cycObdIupr(struct soap *soap, const struct __ns1__cycObdIupr *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cycObdIupr(soap, &a->ns1__cycObdIupr_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cycObdIupr(struct soap *soap, const char *tag, int id, const struct __ns1__cycObdIupr *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cycObdIupr(soap, "ns1:cycObdIupr", -1, &a->ns1__cycObdIupr_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cycObdIupr * SOAP_FMAC4 soap_in___ns1__cycObdIupr(struct soap *soap, const char *tag, struct __ns1__cycObdIupr *a, const char *type)
{
	size_t soap_flag_ns1__cycObdIupr_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cycObdIupr *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cycObdIupr, sizeof(struct __ns1__cycObdIupr), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cycObdIupr(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cycObdIupr_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cycObdIupr(soap, "ns1:cycObdIupr", &a->ns1__cycObdIupr_, "ns1:cycObdIupr"))
				{	soap_flag_ns1__cycObdIupr_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cycObdIupr(struct soap *soap, const struct __ns1__cycObdIupr *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cycObdIupr(soap, tag?tag:"-ns1:cycObdIupr", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cycObdIupr * SOAP_FMAC4 soap_get___ns1__cycObdIupr(struct soap *soap, struct __ns1__cycObdIupr *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cycObdIupr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cycObdIupr * SOAP_FMAC2 soap_instantiate___ns1__cycObdIupr(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cycObdIupr(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cycObdIupr, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cycObdIupr);
		if (size)
			*size = sizeof(struct __ns1__cycObdIupr);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cycObdIupr, n);
		if (size)
			*size = n * sizeof(struct __ns1__cycObdIupr);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cycObdIupr*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cycObdIupr(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cycObdIupr %p -> %p\n", q, p));
	*(struct __ns1__cycObdIupr*)p = *(struct __ns1__cycObdIupr*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wqfxyzj(struct soap *soap, struct __ns1__wqfxyzj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wqfxyzj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wqfxyzj(struct soap *soap, const struct __ns1__wqfxyzj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__wqfxyzj(soap, &a->ns1__wqfxyzj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wqfxyzj(struct soap *soap, const char *tag, int id, const struct __ns1__wqfxyzj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__wqfxyzj(soap, "ns1:wqfxyzj", -1, &a->ns1__wqfxyzj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxyzj * SOAP_FMAC4 soap_in___ns1__wqfxyzj(struct soap *soap, const char *tag, struct __ns1__wqfxyzj *a, const char *type)
{
	size_t soap_flag_ns1__wqfxyzj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__wqfxyzj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wqfxyzj, sizeof(struct __ns1__wqfxyzj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wqfxyzj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wqfxyzj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wqfxyzj(soap, "ns1:wqfxyzj", &a->ns1__wqfxyzj_, "ns1:wqfxyzj"))
				{	soap_flag_ns1__wqfxyzj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wqfxyzj(struct soap *soap, const struct __ns1__wqfxyzj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wqfxyzj(soap, tag?tag:"-ns1:wqfxyzj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxyzj * SOAP_FMAC4 soap_get___ns1__wqfxyzj(struct soap *soap, struct __ns1__wqfxyzj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wqfxyzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__wqfxyzj * SOAP_FMAC2 soap_instantiate___ns1__wqfxyzj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__wqfxyzj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__wqfxyzj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__wqfxyzj);
		if (size)
			*size = sizeof(struct __ns1__wqfxyzj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__wqfxyzj, n);
		if (size)
			*size = n * sizeof(struct __ns1__wqfxyzj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__wqfxyzj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__wqfxyzj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__wqfxyzj %p -> %p\n", q, p));
	*(struct __ns1__wqfxyzj*)p = *(struct __ns1__wqfxyzj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__jzjsGcsj(struct soap *soap, struct __ns1__jzjsGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__jzjsGcsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__jzjsGcsj(struct soap *soap, const struct __ns1__jzjsGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__jzjsGcsj(soap, &a->ns1__jzjsGcsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__jzjsGcsj(struct soap *soap, const char *tag, int id, const struct __ns1__jzjsGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__jzjsGcsj(soap, "ns1:jzjsGcsj", -1, &a->ns1__jzjsGcsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jzjsGcsj * SOAP_FMAC4 soap_in___ns1__jzjsGcsj(struct soap *soap, const char *tag, struct __ns1__jzjsGcsj *a, const char *type)
{
	size_t soap_flag_ns1__jzjsGcsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__jzjsGcsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__jzjsGcsj, sizeof(struct __ns1__jzjsGcsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__jzjsGcsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__jzjsGcsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__jzjsGcsj(soap, "ns1:jzjsGcsj", &a->ns1__jzjsGcsj_, "ns1:jzjsGcsj"))
				{	soap_flag_ns1__jzjsGcsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__jzjsGcsj(struct soap *soap, const struct __ns1__jzjsGcsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__jzjsGcsj(soap, tag?tag:"-ns1:jzjsGcsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jzjsGcsj * SOAP_FMAC4 soap_get___ns1__jzjsGcsj(struct soap *soap, struct __ns1__jzjsGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__jzjsGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__jzjsGcsj * SOAP_FMAC2 soap_instantiate___ns1__jzjsGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__jzjsGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__jzjsGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__jzjsGcsj);
		if (size)
			*size = sizeof(struct __ns1__jzjsGcsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__jzjsGcsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__jzjsGcsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__jzjsGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__jzjsGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__jzjsGcsj %p -> %p\n", q, p));
	*(struct __ns1__jzjsGcsj*)p = *(struct __ns1__jzjsGcsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__jystGcsj(struct soap *soap, struct __ns1__jystGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__jystGcsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__jystGcsj(struct soap *soap, const struct __ns1__jystGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__jystGcsj(soap, &a->ns1__jystGcsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__jystGcsj(struct soap *soap, const char *tag, int id, const struct __ns1__jystGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__jystGcsj(soap, "ns1:jystGcsj", -1, &a->ns1__jystGcsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jystGcsj * SOAP_FMAC4 soap_in___ns1__jystGcsj(struct soap *soap, const char *tag, struct __ns1__jystGcsj *a, const char *type)
{
	size_t soap_flag_ns1__jystGcsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__jystGcsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__jystGcsj, sizeof(struct __ns1__jystGcsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__jystGcsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__jystGcsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__jystGcsj(soap, "ns1:jystGcsj", &a->ns1__jystGcsj_, "ns1:jystGcsj"))
				{	soap_flag_ns1__jystGcsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__jystGcsj(struct soap *soap, const struct __ns1__jystGcsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__jystGcsj(soap, tag?tag:"-ns1:jystGcsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jystGcsj * SOAP_FMAC4 soap_get___ns1__jystGcsj(struct soap *soap, struct __ns1__jystGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__jystGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__jystGcsj * SOAP_FMAC2 soap_instantiate___ns1__jystGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__jystGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__jystGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__jystGcsj);
		if (size)
			*size = sizeof(struct __ns1__jystGcsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__jystGcsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__jystGcsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__jystGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__jystGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__jystGcsj %p -> %p\n", q, p));
	*(struct __ns1__jystGcsj*)p = *(struct __ns1__jystGcsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lgmhdJgsj(struct soap *soap, struct __ns1__lgmhdJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lgmhdJgsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lgmhdJgsj(struct soap *soap, const struct __ns1__lgmhdJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lgmhdJgsj(soap, &a->ns1__lgmhdJgsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lgmhdJgsj(struct soap *soap, const char *tag, int id, const struct __ns1__lgmhdJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lgmhdJgsj(soap, "ns1:lgmhdJgsj", -1, &a->ns1__lgmhdJgsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lgmhdJgsj * SOAP_FMAC4 soap_in___ns1__lgmhdJgsj(struct soap *soap, const char *tag, struct __ns1__lgmhdJgsj *a, const char *type)
{
	size_t soap_flag_ns1__lgmhdJgsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lgmhdJgsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lgmhdJgsj, sizeof(struct __ns1__lgmhdJgsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lgmhdJgsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lgmhdJgsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lgmhdJgsj(soap, "ns1:lgmhdJgsj", &a->ns1__lgmhdJgsj_, "ns1:lgmhdJgsj"))
				{	soap_flag_ns1__lgmhdJgsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lgmhdJgsj(struct soap *soap, const struct __ns1__lgmhdJgsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lgmhdJgsj(soap, tag?tag:"-ns1:lgmhdJgsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lgmhdJgsj * SOAP_FMAC4 soap_get___ns1__lgmhdJgsj(struct soap *soap, struct __ns1__lgmhdJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lgmhdJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lgmhdJgsj * SOAP_FMAC2 soap_instantiate___ns1__lgmhdJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lgmhdJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lgmhdJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lgmhdJgsj);
		if (size)
			*size = sizeof(struct __ns1__lgmhdJgsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lgmhdJgsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__lgmhdJgsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lgmhdJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lgmhdJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lgmhdJgsj %p -> %p\n", q, p));
	*(struct __ns1__lgmhdJgsj*)p = *(struct __ns1__lgmhdJgsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__jczrylb(struct soap *soap, struct __ns1__jczrylb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__jczrylb_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__jczrylb(struct soap *soap, const struct __ns1__jczrylb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__jczrylb(soap, &a->ns1__jczrylb_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__jczrylb(struct soap *soap, const char *tag, int id, const struct __ns1__jczrylb *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__jczrylb(soap, "ns1:jczrylb", -1, &a->ns1__jczrylb_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jczrylb * SOAP_FMAC4 soap_in___ns1__jczrylb(struct soap *soap, const char *tag, struct __ns1__jczrylb *a, const char *type)
{
	size_t soap_flag_ns1__jczrylb_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__jczrylb *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__jczrylb, sizeof(struct __ns1__jczrylb), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__jczrylb(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__jczrylb_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__jczrylb(soap, "ns1:jczrylb", &a->ns1__jczrylb_, "ns1:jczrylb"))
				{	soap_flag_ns1__jczrylb_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__jczrylb(struct soap *soap, const struct __ns1__jczrylb *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__jczrylb(soap, tag?tag:"-ns1:jczrylb", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jczrylb * SOAP_FMAC4 soap_get___ns1__jczrylb(struct soap *soap, struct __ns1__jczrylb *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__jczrylb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__jczrylb * SOAP_FMAC2 soap_instantiate___ns1__jczrylb(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__jczrylb(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__jczrylb, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__jczrylb);
		if (size)
			*size = sizeof(struct __ns1__jczrylb);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__jczrylb, n);
		if (size)
			*size = n * sizeof(struct __ns1__jczrylb);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__jczrylb*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__jczrylb(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__jczrylb %p -> %p\n", q, p));
	*(struct __ns1__jczrylb*)p = *(struct __ns1__jczrylb*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__hjcsyzj(struct soap *soap, struct __ns1__hjcsyzj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__hjcsyzj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__hjcsyzj(struct soap *soap, const struct __ns1__hjcsyzj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__hjcsyzj(soap, &a->ns1__hjcsyzj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__hjcsyzj(struct soap *soap, const char *tag, int id, const struct __ns1__hjcsyzj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__hjcsyzj(soap, "ns1:hjcsyzj", -1, &a->ns1__hjcsyzj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hjcsyzj * SOAP_FMAC4 soap_in___ns1__hjcsyzj(struct soap *soap, const char *tag, struct __ns1__hjcsyzj *a, const char *type)
{
	size_t soap_flag_ns1__hjcsyzj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__hjcsyzj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__hjcsyzj, sizeof(struct __ns1__hjcsyzj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__hjcsyzj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__hjcsyzj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__hjcsyzj(soap, "ns1:hjcsyzj", &a->ns1__hjcsyzj_, "ns1:hjcsyzj"))
				{	soap_flag_ns1__hjcsyzj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__hjcsyzj(struct soap *soap, const struct __ns1__hjcsyzj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__hjcsyzj(soap, tag?tag:"-ns1:hjcsyzj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__hjcsyzj * SOAP_FMAC4 soap_get___ns1__hjcsyzj(struct soap *soap, struct __ns1__hjcsyzj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__hjcsyzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__hjcsyzj * SOAP_FMAC2 soap_instantiate___ns1__hjcsyzj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__hjcsyzj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__hjcsyzj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__hjcsyzj);
		if (size)
			*size = sizeof(struct __ns1__hjcsyzj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__hjcsyzj, n);
		if (size)
			*size = n * sizeof(struct __ns1__hjcsyzj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__hjcsyzj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__hjcsyzj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__hjcsyzj %p -> %p\n", q, p));
	*(struct __ns1__hjcsyzj*)p = *(struct __ns1__hjcsyzj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__btgJgsj(struct soap *soap, struct __ns1__btgJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__btgJgsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__btgJgsj(struct soap *soap, const struct __ns1__btgJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__btgJgsj(soap, &a->ns1__btgJgsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__btgJgsj(struct soap *soap, const char *tag, int id, const struct __ns1__btgJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__btgJgsj(soap, "ns1:btgJgsj", -1, &a->ns1__btgJgsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__btgJgsj * SOAP_FMAC4 soap_in___ns1__btgJgsj(struct soap *soap, const char *tag, struct __ns1__btgJgsj *a, const char *type)
{
	size_t soap_flag_ns1__btgJgsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__btgJgsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__btgJgsj, sizeof(struct __ns1__btgJgsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__btgJgsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__btgJgsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__btgJgsj(soap, "ns1:btgJgsj", &a->ns1__btgJgsj_, "ns1:btgJgsj"))
				{	soap_flag_ns1__btgJgsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__btgJgsj(struct soap *soap, const struct __ns1__btgJgsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__btgJgsj(soap, tag?tag:"-ns1:btgJgsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__btgJgsj * SOAP_FMAC4 soap_get___ns1__btgJgsj(struct soap *soap, struct __ns1__btgJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__btgJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__btgJgsj * SOAP_FMAC2 soap_instantiate___ns1__btgJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__btgJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__btgJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__btgJgsj);
		if (size)
			*size = sizeof(struct __ns1__btgJgsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__btgJgsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__btgJgsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__btgJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__btgJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__btgJgsj %p -> %p\n", q, p));
	*(struct __ns1__btgJgsj*)p = *(struct __ns1__btgJgsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__xxtz(struct soap *soap, struct __ns1__xxtz *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__xxtz_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__xxtz(struct soap *soap, const struct __ns1__xxtz *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__xxtz(soap, &a->ns1__xxtz_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__xxtz(struct soap *soap, const char *tag, int id, const struct __ns1__xxtz *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__xxtz(soap, "ns1:xxtz", -1, &a->ns1__xxtz_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__xxtz * SOAP_FMAC4 soap_in___ns1__xxtz(struct soap *soap, const char *tag, struct __ns1__xxtz *a, const char *type)
{
	size_t soap_flag_ns1__xxtz_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__xxtz *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__xxtz, sizeof(struct __ns1__xxtz), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__xxtz(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__xxtz_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__xxtz(soap, "ns1:xxtz", &a->ns1__xxtz_, "ns1:xxtz"))
				{	soap_flag_ns1__xxtz_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__xxtz(struct soap *soap, const struct __ns1__xxtz *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__xxtz(soap, tag?tag:"-ns1:xxtz", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__xxtz * SOAP_FMAC4 soap_get___ns1__xxtz(struct soap *soap, struct __ns1__xxtz *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__xxtz(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__xxtz * SOAP_FMAC2 soap_instantiate___ns1__xxtz(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__xxtz(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__xxtz, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__xxtz);
		if (size)
			*size = sizeof(struct __ns1__xxtz);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__xxtz, n);
		if (size)
			*size = n * sizeof(struct __ns1__xxtz);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__xxtz*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__xxtz(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__xxtz %p -> %p\n", q, p));
	*(struct __ns1__xxtz*)p = *(struct __ns1__xxtz*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDjzt(struct soap *soap, struct __ns1__getDjzt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDjzt_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDjzt(struct soap *soap, const struct __ns1__getDjzt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__getDjzt(soap, &a->ns1__getDjzt_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDjzt(struct soap *soap, const char *tag, int id, const struct __ns1__getDjzt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__getDjzt(soap, "ns1:getDjzt", -1, &a->ns1__getDjzt_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDjzt * SOAP_FMAC4 soap_in___ns1__getDjzt(struct soap *soap, const char *tag, struct __ns1__getDjzt *a, const char *type)
{
	size_t soap_flag_ns1__getDjzt_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getDjzt *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDjzt, sizeof(struct __ns1__getDjzt), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDjzt(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDjzt_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getDjzt(soap, "ns1:getDjzt", &a->ns1__getDjzt_, "ns1:getDjzt"))
				{	soap_flag_ns1__getDjzt_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDjzt(struct soap *soap, const struct __ns1__getDjzt *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDjzt(soap, tag?tag:"-ns1:getDjzt", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDjzt * SOAP_FMAC4 soap_get___ns1__getDjzt(struct soap *soap, struct __ns1__getDjzt *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDjzt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDjzt * SOAP_FMAC2 soap_instantiate___ns1__getDjzt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDjzt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDjzt, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDjzt);
		if (size)
			*size = sizeof(struct __ns1__getDjzt);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getDjzt, n);
		if (size)
			*size = n * sizeof(struct __ns1__getDjzt);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getDjzt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDjzt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDjzt %p -> %p\n", q, p));
	*(struct __ns1__getDjzt*)p = *(struct __ns1__getDjzt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cgjzj(struct soap *soap, struct __ns1__cgjzj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cgjzj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cgjzj(struct soap *soap, const struct __ns1__cgjzj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__cgjzj(soap, &a->ns1__cgjzj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cgjzj(struct soap *soap, const char *tag, int id, const struct __ns1__cgjzj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__cgjzj(soap, "ns1:cgjzj", -1, &a->ns1__cgjzj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjzj * SOAP_FMAC4 soap_in___ns1__cgjzj(struct soap *soap, const char *tag, struct __ns1__cgjzj *a, const char *type)
{
	size_t soap_flag_ns1__cgjzj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cgjzj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cgjzj, sizeof(struct __ns1__cgjzj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cgjzj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cgjzj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cgjzj(soap, "ns1:cgjzj", &a->ns1__cgjzj_, "ns1:cgjzj"))
				{	soap_flag_ns1__cgjzj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cgjzj(struct soap *soap, const struct __ns1__cgjzj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cgjzj(soap, tag?tag:"-ns1:cgjzj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cgjzj * SOAP_FMAC4 soap_get___ns1__cgjzj(struct soap *soap, struct __ns1__cgjzj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cgjzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cgjzj * SOAP_FMAC2 soap_instantiate___ns1__cgjzj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cgjzj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cgjzj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cgjzj);
		if (size)
			*size = sizeof(struct __ns1__cgjzj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cgjzj, n);
		if (size)
			*size = n * sizeof(struct __ns1__cgjzj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cgjzj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cgjzj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cgjzj %p -> %p\n", q, p));
	*(struct __ns1__cgjzj*)p = *(struct __ns1__cgjzj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wtJgsj(struct soap *soap, struct __ns1__wtJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wtJgsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wtJgsj(struct soap *soap, const struct __ns1__wtJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__wtJgsj(soap, &a->ns1__wtJgsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wtJgsj(struct soap *soap, const char *tag, int id, const struct __ns1__wtJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__wtJgsj(soap, "ns1:wtJgsj", -1, &a->ns1__wtJgsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wtJgsj * SOAP_FMAC4 soap_in___ns1__wtJgsj(struct soap *soap, const char *tag, struct __ns1__wtJgsj *a, const char *type)
{
	size_t soap_flag_ns1__wtJgsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__wtJgsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wtJgsj, sizeof(struct __ns1__wtJgsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wtJgsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wtJgsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wtJgsj(soap, "ns1:wtJgsj", &a->ns1__wtJgsj_, "ns1:wtJgsj"))
				{	soap_flag_ns1__wtJgsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wtJgsj(struct soap *soap, const struct __ns1__wtJgsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wtJgsj(soap, tag?tag:"-ns1:wtJgsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wtJgsj * SOAP_FMAC4 soap_get___ns1__wtJgsj(struct soap *soap, struct __ns1__wtJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wtJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__wtJgsj * SOAP_FMAC2 soap_instantiate___ns1__wtJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__wtJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__wtJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__wtJgsj);
		if (size)
			*size = sizeof(struct __ns1__wtJgsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__wtJgsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__wtJgsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__wtJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__wtJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__wtJgsj %p -> %p\n", q, p));
	*(struct __ns1__wtJgsj*)p = *(struct __ns1__wtJgsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__obdGcsj(struct soap *soap, struct __ns1__obdGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__obdGcsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__obdGcsj(struct soap *soap, const struct __ns1__obdGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__obdGcsj(soap, &a->ns1__obdGcsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__obdGcsj(struct soap *soap, const char *tag, int id, const struct __ns1__obdGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__obdGcsj(soap, "ns1:obdGcsj", -1, &a->ns1__obdGcsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdGcsj * SOAP_FMAC4 soap_in___ns1__obdGcsj(struct soap *soap, const char *tag, struct __ns1__obdGcsj *a, const char *type)
{
	size_t soap_flag_ns1__obdGcsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__obdGcsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__obdGcsj, sizeof(struct __ns1__obdGcsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__obdGcsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__obdGcsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__obdGcsj(soap, "ns1:obdGcsj", &a->ns1__obdGcsj_, "ns1:obdGcsj"))
				{	soap_flag_ns1__obdGcsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__obdGcsj(struct soap *soap, const struct __ns1__obdGcsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__obdGcsj(soap, tag?tag:"-ns1:obdGcsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdGcsj * SOAP_FMAC4 soap_get___ns1__obdGcsj(struct soap *soap, struct __ns1__obdGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__obdGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__obdGcsj * SOAP_FMAC2 soap_instantiate___ns1__obdGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__obdGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__obdGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__obdGcsj);
		if (size)
			*size = sizeof(struct __ns1__obdGcsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__obdGcsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__obdGcsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__obdGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__obdGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__obdGcsj %p -> %p\n", q, p));
	*(struct __ns1__obdGcsj*)p = *(struct __ns1__obdGcsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wtGcsj(struct soap *soap, struct __ns1__wtGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wtGcsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wtGcsj(struct soap *soap, const struct __ns1__wtGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__wtGcsj(soap, &a->ns1__wtGcsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wtGcsj(struct soap *soap, const char *tag, int id, const struct __ns1__wtGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__wtGcsj(soap, "ns1:wtGcsj", -1, &a->ns1__wtGcsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wtGcsj * SOAP_FMAC4 soap_in___ns1__wtGcsj(struct soap *soap, const char *tag, struct __ns1__wtGcsj *a, const char *type)
{
	size_t soap_flag_ns1__wtGcsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__wtGcsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wtGcsj, sizeof(struct __ns1__wtGcsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wtGcsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wtGcsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wtGcsj(soap, "ns1:wtGcsj", &a->ns1__wtGcsj_, "ns1:wtGcsj"))
				{	soap_flag_ns1__wtGcsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wtGcsj(struct soap *soap, const struct __ns1__wtGcsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wtGcsj(soap, tag?tag:"-ns1:wtGcsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wtGcsj * SOAP_FMAC4 soap_get___ns1__wtGcsj(struct soap *soap, struct __ns1__wtGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wtGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__wtGcsj * SOAP_FMAC2 soap_instantiate___ns1__wtGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__wtGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__wtGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__wtGcsj);
		if (size)
			*size = sizeof(struct __ns1__wtGcsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__wtGcsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__wtGcsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__wtGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__wtGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__wtGcsj %p -> %p\n", q, p));
	*(struct __ns1__wtGcsj*)p = *(struct __ns1__wtGcsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__jzjsJgsj(struct soap *soap, struct __ns1__jzjsJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__jzjsJgsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__jzjsJgsj(struct soap *soap, const struct __ns1__jzjsJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__jzjsJgsj(soap, &a->ns1__jzjsJgsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__jzjsJgsj(struct soap *soap, const char *tag, int id, const struct __ns1__jzjsJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__jzjsJgsj(soap, "ns1:jzjsJgsj", -1, &a->ns1__jzjsJgsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jzjsJgsj * SOAP_FMAC4 soap_in___ns1__jzjsJgsj(struct soap *soap, const char *tag, struct __ns1__jzjsJgsj *a, const char *type)
{
	size_t soap_flag_ns1__jzjsJgsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__jzjsJgsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__jzjsJgsj, sizeof(struct __ns1__jzjsJgsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__jzjsJgsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__jzjsJgsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__jzjsJgsj(soap, "ns1:jzjsJgsj", &a->ns1__jzjsJgsj_, "ns1:jzjsJgsj"))
				{	soap_flag_ns1__jzjsJgsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__jzjsJgsj(struct soap *soap, const struct __ns1__jzjsJgsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__jzjsJgsj(soap, tag?tag:"-ns1:jzjsJgsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jzjsJgsj * SOAP_FMAC4 soap_get___ns1__jzjsJgsj(struct soap *soap, struct __ns1__jzjsJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__jzjsJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__jzjsJgsj * SOAP_FMAC2 soap_instantiate___ns1__jzjsJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__jzjsJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__jzjsJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__jzjsJgsj);
		if (size)
			*size = sizeof(struct __ns1__jzjsJgsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__jzjsJgsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__jzjsJgsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__jzjsJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__jzjsJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__jzjsJgsj %p -> %p\n", q, p));
	*(struct __ns1__jzjsJgsj*)p = *(struct __ns1__jzjsJgsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDjclxx(struct soap *soap, struct __ns1__getDjclxx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDjclxx_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDjclxx(struct soap *soap, const struct __ns1__getDjclxx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__getDjclxx(soap, &a->ns1__getDjclxx_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDjclxx(struct soap *soap, const char *tag, int id, const struct __ns1__getDjclxx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__getDjclxx(soap, "ns1:getDjclxx", -1, &a->ns1__getDjclxx_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDjclxx * SOAP_FMAC4 soap_in___ns1__getDjclxx(struct soap *soap, const char *tag, struct __ns1__getDjclxx *a, const char *type)
{
	size_t soap_flag_ns1__getDjclxx_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getDjclxx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDjclxx, sizeof(struct __ns1__getDjclxx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDjclxx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDjclxx_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getDjclxx(soap, "ns1:getDjclxx", &a->ns1__getDjclxx_, "ns1:getDjclxx"))
				{	soap_flag_ns1__getDjclxx_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDjclxx(struct soap *soap, const struct __ns1__getDjclxx *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDjclxx(soap, tag?tag:"-ns1:getDjclxx", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDjclxx * SOAP_FMAC4 soap_get___ns1__getDjclxx(struct soap *soap, struct __ns1__getDjclxx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDjclxx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDjclxx * SOAP_FMAC2 soap_instantiate___ns1__getDjclxx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDjclxx(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDjclxx, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDjclxx);
		if (size)
			*size = sizeof(struct __ns1__getDjclxx);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getDjclxx, n);
		if (size)
			*size = n * sizeof(struct __ns1__getDjclxx);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getDjclxx*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDjclxx(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDjclxx %p -> %p\n", q, p));
	*(struct __ns1__getDjclxx*)p = *(struct __ns1__getDjclxx*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lgmhdGcsj(struct soap *soap, struct __ns1__lgmhdGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lgmhdGcsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lgmhdGcsj(struct soap *soap, const struct __ns1__lgmhdGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lgmhdGcsj(soap, &a->ns1__lgmhdGcsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lgmhdGcsj(struct soap *soap, const char *tag, int id, const struct __ns1__lgmhdGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lgmhdGcsj(soap, "ns1:lgmhdGcsj", -1, &a->ns1__lgmhdGcsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lgmhdGcsj * SOAP_FMAC4 soap_in___ns1__lgmhdGcsj(struct soap *soap, const char *tag, struct __ns1__lgmhdGcsj *a, const char *type)
{
	size_t soap_flag_ns1__lgmhdGcsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lgmhdGcsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lgmhdGcsj, sizeof(struct __ns1__lgmhdGcsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lgmhdGcsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lgmhdGcsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lgmhdGcsj(soap, "ns1:lgmhdGcsj", &a->ns1__lgmhdGcsj_, "ns1:lgmhdGcsj"))
				{	soap_flag_ns1__lgmhdGcsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lgmhdGcsj(struct soap *soap, const struct __ns1__lgmhdGcsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lgmhdGcsj(soap, tag?tag:"-ns1:lgmhdGcsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lgmhdGcsj * SOAP_FMAC4 soap_get___ns1__lgmhdGcsj(struct soap *soap, struct __ns1__lgmhdGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lgmhdGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lgmhdGcsj * SOAP_FMAC2 soap_instantiate___ns1__lgmhdGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lgmhdGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lgmhdGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lgmhdGcsj);
		if (size)
			*size = sizeof(struct __ns1__lgmhdGcsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lgmhdGcsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__lgmhdGcsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lgmhdGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lgmhdGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lgmhdGcsj %p -> %p\n", q, p));
	*(struct __ns1__lgmhdGcsj*)p = *(struct __ns1__lgmhdGcsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__obdDjlb(struct soap *soap, struct __ns1__obdDjlb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__obdDjlb_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__obdDjlb(struct soap *soap, const struct __ns1__obdDjlb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__obdDjlb(soap, &a->ns1__obdDjlb_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__obdDjlb(struct soap *soap, const char *tag, int id, const struct __ns1__obdDjlb *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__obdDjlb(soap, "ns1:obdDjlb", -1, &a->ns1__obdDjlb_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdDjlb * SOAP_FMAC4 soap_in___ns1__obdDjlb(struct soap *soap, const char *tag, struct __ns1__obdDjlb *a, const char *type)
{
	size_t soap_flag_ns1__obdDjlb_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__obdDjlb *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__obdDjlb, sizeof(struct __ns1__obdDjlb), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__obdDjlb(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__obdDjlb_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__obdDjlb(soap, "ns1:obdDjlb", &a->ns1__obdDjlb_, "ns1:obdDjlb"))
				{	soap_flag_ns1__obdDjlb_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__obdDjlb(struct soap *soap, const struct __ns1__obdDjlb *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__obdDjlb(soap, tag?tag:"-ns1:obdDjlb", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdDjlb * SOAP_FMAC4 soap_get___ns1__obdDjlb(struct soap *soap, struct __ns1__obdDjlb *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__obdDjlb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__obdDjlb * SOAP_FMAC2 soap_instantiate___ns1__obdDjlb(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__obdDjlb(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__obdDjlb, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__obdDjlb);
		if (size)
			*size = sizeof(struct __ns1__obdDjlb);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__obdDjlb, n);
		if (size)
			*size = n * sizeof(struct __ns1__obdDjlb);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__obdDjlb*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__obdDjlb(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__obdDjlb %p -> %p\n", q, p));
	*(struct __ns1__obdDjlb*)p = *(struct __ns1__obdDjlb*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__fwqsjtb(struct soap *soap, struct __ns1__fwqsjtb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__fwqsjtb_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__fwqsjtb(struct soap *soap, const struct __ns1__fwqsjtb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__fwqsjtb(soap, &a->ns1__fwqsjtb_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__fwqsjtb(struct soap *soap, const char *tag, int id, const struct __ns1__fwqsjtb *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__fwqsjtb(soap, "ns1:fwqsjtb", -1, &a->ns1__fwqsjtb_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fwqsjtb * SOAP_FMAC4 soap_in___ns1__fwqsjtb(struct soap *soap, const char *tag, struct __ns1__fwqsjtb *a, const char *type)
{
	size_t soap_flag_ns1__fwqsjtb_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__fwqsjtb *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__fwqsjtb, sizeof(struct __ns1__fwqsjtb), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__fwqsjtb(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__fwqsjtb_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__fwqsjtb(soap, "ns1:fwqsjtb", &a->ns1__fwqsjtb_, "ns1:fwqsjtb"))
				{	soap_flag_ns1__fwqsjtb_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__fwqsjtb(struct soap *soap, const struct __ns1__fwqsjtb *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__fwqsjtb(soap, tag?tag:"-ns1:fwqsjtb", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fwqsjtb * SOAP_FMAC4 soap_get___ns1__fwqsjtb(struct soap *soap, struct __ns1__fwqsjtb *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__fwqsjtb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__fwqsjtb * SOAP_FMAC2 soap_instantiate___ns1__fwqsjtb(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__fwqsjtb(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__fwqsjtb, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__fwqsjtb);
		if (size)
			*size = sizeof(struct __ns1__fwqsjtb);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__fwqsjtb, n);
		if (size)
			*size = n * sizeof(struct __ns1__fwqsjtb);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__fwqsjtb*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__fwqsjtb(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__fwqsjtb %p -> %p\n", q, p));
	*(struct __ns1__fwqsjtb*)p = *(struct __ns1__fwqsjtb*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lljzj(struct soap *soap, struct __ns1__lljzj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lljzj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lljzj(struct soap *soap, const struct __ns1__lljzj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__lljzj(soap, &a->ns1__lljzj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lljzj(struct soap *soap, const char *tag, int id, const struct __ns1__lljzj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__lljzj(soap, "ns1:lljzj", -1, &a->ns1__lljzj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lljzj * SOAP_FMAC4 soap_in___ns1__lljzj(struct soap *soap, const char *tag, struct __ns1__lljzj *a, const char *type)
{
	size_t soap_flag_ns1__lljzj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lljzj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lljzj, sizeof(struct __ns1__lljzj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lljzj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lljzj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__lljzj(soap, "ns1:lljzj", &a->ns1__lljzj_, "ns1:lljzj"))
				{	soap_flag_ns1__lljzj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lljzj(struct soap *soap, const struct __ns1__lljzj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lljzj(soap, tag?tag:"-ns1:lljzj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lljzj * SOAP_FMAC4 soap_get___ns1__lljzj(struct soap *soap, struct __ns1__lljzj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lljzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__lljzj * SOAP_FMAC2 soap_instantiate___ns1__lljzj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lljzj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__lljzj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__lljzj);
		if (size)
			*size = sizeof(struct __ns1__lljzj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__lljzj, n);
		if (size)
			*size = n * sizeof(struct __ns1__lljzj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__lljzj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__lljzj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__lljzj %p -> %p\n", q, p));
	*(struct __ns1__lljzj*)p = *(struct __ns1__lljzj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__btgGcsj(struct soap *soap, struct __ns1__btgGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__btgGcsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__btgGcsj(struct soap *soap, const struct __ns1__btgGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__btgGcsj(soap, &a->ns1__btgGcsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__btgGcsj(struct soap *soap, const char *tag, int id, const struct __ns1__btgGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__btgGcsj(soap, "ns1:btgGcsj", -1, &a->ns1__btgGcsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__btgGcsj * SOAP_FMAC4 soap_in___ns1__btgGcsj(struct soap *soap, const char *tag, struct __ns1__btgGcsj *a, const char *type)
{
	size_t soap_flag_ns1__btgGcsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__btgGcsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__btgGcsj, sizeof(struct __ns1__btgGcsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__btgGcsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__btgGcsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__btgGcsj(soap, "ns1:btgGcsj", &a->ns1__btgGcsj_, "ns1:btgGcsj"))
				{	soap_flag_ns1__btgGcsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__btgGcsj(struct soap *soap, const struct __ns1__btgGcsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__btgGcsj(soap, tag?tag:"-ns1:btgGcsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__btgGcsj * SOAP_FMAC4 soap_get___ns1__btgGcsj(struct soap *soap, struct __ns1__btgGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__btgGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__btgGcsj * SOAP_FMAC2 soap_instantiate___ns1__btgGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__btgGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__btgGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__btgGcsj);
		if (size)
			*size = sizeof(struct __ns1__btgGcsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__btgGcsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__btgGcsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__btgGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__btgGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__btgGcsj %p -> %p\n", q, p));
	*(struct __ns1__btgGcsj*)p = *(struct __ns1__btgGcsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ryzfJysj(struct soap *soap, struct __ns1__ryzfJysj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ryzfJysj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ryzfJysj(struct soap *soap, const struct __ns1__ryzfJysj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ryzfJysj(soap, &a->ns1__ryzfJysj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ryzfJysj(struct soap *soap, const char *tag, int id, const struct __ns1__ryzfJysj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ryzfJysj(soap, "ns1:ryzfJysj", -1, &a->ns1__ryzfJysj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ryzfJysj * SOAP_FMAC4 soap_in___ns1__ryzfJysj(struct soap *soap, const char *tag, struct __ns1__ryzfJysj *a, const char *type)
{
	size_t soap_flag_ns1__ryzfJysj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ryzfJysj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ryzfJysj, sizeof(struct __ns1__ryzfJysj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ryzfJysj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ryzfJysj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ryzfJysj(soap, "ns1:ryzfJysj", &a->ns1__ryzfJysj_, "ns1:ryzfJysj"))
				{	soap_flag_ns1__ryzfJysj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ryzfJysj(struct soap *soap, const struct __ns1__ryzfJysj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ryzfJysj(soap, tag?tag:"-ns1:ryzfJysj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ryzfJysj * SOAP_FMAC4 soap_get___ns1__ryzfJysj(struct soap *soap, struct __ns1__ryzfJysj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ryzfJysj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__ryzfJysj * SOAP_FMAC2 soap_instantiate___ns1__ryzfJysj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ryzfJysj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__ryzfJysj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ryzfJysj);
		if (size)
			*size = sizeof(struct __ns1__ryzfJysj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__ryzfJysj, n);
		if (size)
			*size = n * sizeof(struct __ns1__ryzfJysj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__ryzfJysj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ryzfJysj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ryzfJysj %p -> %p\n", q, p));
	*(struct __ns1__ryzfJysj*)p = *(struct __ns1__ryzfJysj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wgjcJgsj(struct soap *soap, struct __ns1__wgjcJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wgjcJgsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wgjcJgsj(struct soap *soap, const struct __ns1__wgjcJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__wgjcJgsj(soap, &a->ns1__wgjcJgsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wgjcJgsj(struct soap *soap, const char *tag, int id, const struct __ns1__wgjcJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__wgjcJgsj(soap, "ns1:wgjcJgsj", -1, &a->ns1__wgjcJgsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wgjcJgsj * SOAP_FMAC4 soap_in___ns1__wgjcJgsj(struct soap *soap, const char *tag, struct __ns1__wgjcJgsj *a, const char *type)
{
	size_t soap_flag_ns1__wgjcJgsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__wgjcJgsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wgjcJgsj, sizeof(struct __ns1__wgjcJgsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wgjcJgsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wgjcJgsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wgjcJgsj(soap, "ns1:wgjcJgsj", &a->ns1__wgjcJgsj_, "ns1:wgjcJgsj"))
				{	soap_flag_ns1__wgjcJgsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wgjcJgsj(struct soap *soap, const struct __ns1__wgjcJgsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wgjcJgsj(soap, tag?tag:"-ns1:wgjcJgsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wgjcJgsj * SOAP_FMAC4 soap_get___ns1__wgjcJgsj(struct soap *soap, struct __ns1__wgjcJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wgjcJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__wgjcJgsj * SOAP_FMAC2 soap_instantiate___ns1__wgjcJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__wgjcJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__wgjcJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__wgjcJgsj);
		if (size)
			*size = sizeof(struct __ns1__wgjcJgsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__wgjcJgsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__wgjcJgsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__wgjcJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__wgjcJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__wgjcJgsj %p -> %p\n", q, p));
	*(struct __ns1__wgjcJgsj*)p = *(struct __ns1__wgjcJgsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__jystJgsj(struct soap *soap, struct __ns1__jystJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__jystJgsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__jystJgsj(struct soap *soap, const struct __ns1__jystJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__jystJgsj(soap, &a->ns1__jystJgsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__jystJgsj(struct soap *soap, const char *tag, int id, const struct __ns1__jystJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__jystJgsj(soap, "ns1:jystJgsj", -1, &a->ns1__jystJgsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jystJgsj * SOAP_FMAC4 soap_in___ns1__jystJgsj(struct soap *soap, const char *tag, struct __ns1__jystJgsj *a, const char *type)
{
	size_t soap_flag_ns1__jystJgsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__jystJgsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__jystJgsj, sizeof(struct __ns1__jystJgsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__jystJgsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__jystJgsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__jystJgsj(soap, "ns1:jystJgsj", &a->ns1__jystJgsj_, "ns1:jystJgsj"))
				{	soap_flag_ns1__jystJgsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__jystJgsj(struct soap *soap, const struct __ns1__jystJgsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__jystJgsj(soap, tag?tag:"-ns1:jystJgsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jystJgsj * SOAP_FMAC4 soap_get___ns1__jystJgsj(struct soap *soap, struct __ns1__jystJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__jystJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__jystJgsj * SOAP_FMAC2 soap_instantiate___ns1__jystJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__jystJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__jystJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__jystJgsj);
		if (size)
			*size = sizeof(struct __ns1__jystJgsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__jystJgsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__jystJgsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__jystJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__jystJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__jystJgsj %p -> %p\n", q, p));
	*(struct __ns1__jystJgsj*)p = *(struct __ns1__jystJgsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__wqfxybd(struct soap *soap, struct __ns1__wqfxybd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__wqfxybd_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__wqfxybd(struct soap *soap, const struct __ns1__wqfxybd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__wqfxybd(soap, &a->ns1__wqfxybd_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__wqfxybd(struct soap *soap, const char *tag, int id, const struct __ns1__wqfxybd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__wqfxybd(soap, "ns1:wqfxybd", -1, &a->ns1__wqfxybd_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxybd * SOAP_FMAC4 soap_in___ns1__wqfxybd(struct soap *soap, const char *tag, struct __ns1__wqfxybd *a, const char *type)
{
	size_t soap_flag_ns1__wqfxybd_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__wqfxybd *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__wqfxybd, sizeof(struct __ns1__wqfxybd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__wqfxybd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__wqfxybd_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wqfxybd(soap, "ns1:wqfxybd", &a->ns1__wqfxybd_, "ns1:wqfxybd"))
				{	soap_flag_ns1__wqfxybd_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__wqfxybd(struct soap *soap, const struct __ns1__wqfxybd *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__wqfxybd(soap, tag?tag:"-ns1:wqfxybd", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__wqfxybd * SOAP_FMAC4 soap_get___ns1__wqfxybd(struct soap *soap, struct __ns1__wqfxybd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__wqfxybd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__wqfxybd * SOAP_FMAC2 soap_instantiate___ns1__wqfxybd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__wqfxybd(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__wqfxybd, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__wqfxybd);
		if (size)
			*size = sizeof(struct __ns1__wqfxybd);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__wqfxybd, n);
		if (size)
			*size = n * sizeof(struct __ns1__wqfxybd);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__wqfxybd*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__wqfxybd(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__wqfxybd %p -> %p\n", q, p));
	*(struct __ns1__wqfxybd*)p = *(struct __ns1__wqfxybd*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ydjzj(struct soap *soap, struct __ns1__ydjzj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ydjzj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ydjzj(struct soap *soap, const struct __ns1__ydjzj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ydjzj(soap, &a->ns1__ydjzj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ydjzj(struct soap *soap, const char *tag, int id, const struct __ns1__ydjzj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__ydjzj(soap, "ns1:ydjzj", -1, &a->ns1__ydjzj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ydjzj * SOAP_FMAC4 soap_in___ns1__ydjzj(struct soap *soap, const char *tag, struct __ns1__ydjzj *a, const char *type)
{
	size_t soap_flag_ns1__ydjzj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ydjzj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ydjzj, sizeof(struct __ns1__ydjzj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ydjzj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ydjzj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ydjzj(soap, "ns1:ydjzj", &a->ns1__ydjzj_, "ns1:ydjzj"))
				{	soap_flag_ns1__ydjzj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ydjzj(struct soap *soap, const struct __ns1__ydjzj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ydjzj(soap, tag?tag:"-ns1:ydjzj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ydjzj * SOAP_FMAC4 soap_get___ns1__ydjzj(struct soap *soap, struct __ns1__ydjzj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ydjzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__ydjzj * SOAP_FMAC2 soap_instantiate___ns1__ydjzj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ydjzj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__ydjzj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ydjzj);
		if (size)
			*size = sizeof(struct __ns1__ydjzj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__ydjzj, n);
		if (size)
			*size = n * sizeof(struct __ns1__ydjzj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__ydjzj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ydjzj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ydjzj %p -> %p\n", q, p));
	*(struct __ns1__ydjzj*)p = *(struct __ns1__ydjzj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__obdJgsj(struct soap *soap, struct __ns1__obdJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__obdJgsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__obdJgsj(struct soap *soap, const struct __ns1__obdJgsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__obdJgsj(soap, &a->ns1__obdJgsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__obdJgsj(struct soap *soap, const char *tag, int id, const struct __ns1__obdJgsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__obdJgsj(soap, "ns1:obdJgsj", -1, &a->ns1__obdJgsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdJgsj * SOAP_FMAC4 soap_in___ns1__obdJgsj(struct soap *soap, const char *tag, struct __ns1__obdJgsj *a, const char *type)
{
	size_t soap_flag_ns1__obdJgsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__obdJgsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__obdJgsj, sizeof(struct __ns1__obdJgsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__obdJgsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__obdJgsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__obdJgsj(soap, "ns1:obdJgsj", &a->ns1__obdJgsj_, "ns1:obdJgsj"))
				{	soap_flag_ns1__obdJgsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__obdJgsj(struct soap *soap, const struct __ns1__obdJgsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__obdJgsj(soap, tag?tag:"-ns1:obdJgsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__obdJgsj * SOAP_FMAC4 soap_get___ns1__obdJgsj(struct soap *soap, struct __ns1__obdJgsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__obdJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__obdJgsj * SOAP_FMAC2 soap_instantiate___ns1__obdJgsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__obdJgsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__obdJgsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__obdJgsj);
		if (size)
			*size = sizeof(struct __ns1__obdJgsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__obdJgsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__obdJgsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__obdJgsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__obdJgsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__obdJgsj %p -> %p\n", q, p));
	*(struct __ns1__obdJgsj*)p = *(struct __ns1__obdJgsj*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__gkrjbbh(struct soap *soap, struct __ns1__gkrjbbh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__gkrjbbh_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__gkrjbbh(struct soap *soap, const struct __ns1__gkrjbbh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__gkrjbbh(soap, &a->ns1__gkrjbbh_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__gkrjbbh(struct soap *soap, const char *tag, int id, const struct __ns1__gkrjbbh *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__gkrjbbh(soap, "ns1:gkrjbbh", -1, &a->ns1__gkrjbbh_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__gkrjbbh * SOAP_FMAC4 soap_in___ns1__gkrjbbh(struct soap *soap, const char *tag, struct __ns1__gkrjbbh *a, const char *type)
{
	size_t soap_flag_ns1__gkrjbbh_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__gkrjbbh *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__gkrjbbh, sizeof(struct __ns1__gkrjbbh), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__gkrjbbh(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__gkrjbbh_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gkrjbbh(soap, "ns1:gkrjbbh", &a->ns1__gkrjbbh_, "ns1:gkrjbbh"))
				{	soap_flag_ns1__gkrjbbh_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__gkrjbbh(struct soap *soap, const struct __ns1__gkrjbbh *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__gkrjbbh(soap, tag?tag:"-ns1:gkrjbbh", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__gkrjbbh * SOAP_FMAC4 soap_get___ns1__gkrjbbh(struct soap *soap, struct __ns1__gkrjbbh *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__gkrjbbh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__gkrjbbh * SOAP_FMAC2 soap_instantiate___ns1__gkrjbbh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__gkrjbbh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__gkrjbbh, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__gkrjbbh);
		if (size)
			*size = sizeof(struct __ns1__gkrjbbh);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__gkrjbbh, n);
		if (size)
			*size = n * sizeof(struct __ns1__gkrjbbh);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__gkrjbbh*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__gkrjbbh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__gkrjbbh %p -> %p\n", q, p));
	*(struct __ns1__gkrjbbh*)p = *(struct __ns1__gkrjbbh*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAccessToken(struct soap *soap, struct __ns1__getAccessToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAccessToken_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAccessToken(struct soap *soap, const struct __ns1__getAccessToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__getAccessToken(soap, &a->ns1__getAccessToken_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAccessToken(struct soap *soap, const char *tag, int id, const struct __ns1__getAccessToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__getAccessToken(soap, "ns1:getAccessToken", -1, &a->ns1__getAccessToken_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccessToken * SOAP_FMAC4 soap_in___ns1__getAccessToken(struct soap *soap, const char *tag, struct __ns1__getAccessToken *a, const char *type)
{
	size_t soap_flag_ns1__getAccessToken_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getAccessToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAccessToken, sizeof(struct __ns1__getAccessToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAccessToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAccessToken_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getAccessToken(soap, "ns1:getAccessToken", &a->ns1__getAccessToken_, "ns1:getAccessToken"))
				{	soap_flag_ns1__getAccessToken_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAccessToken(struct soap *soap, const struct __ns1__getAccessToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAccessToken(soap, tag?tag:"-ns1:getAccessToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccessToken * SOAP_FMAC4 soap_get___ns1__getAccessToken(struct soap *soap, struct __ns1__getAccessToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAccessToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAccessToken * SOAP_FMAC2 soap_instantiate___ns1__getAccessToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAccessToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAccessToken, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAccessToken);
		if (size)
			*size = sizeof(struct __ns1__getAccessToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getAccessToken, n);
		if (size)
			*size = n * sizeof(struct __ns1__getAccessToken);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getAccessToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAccessToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAccessToken %p -> %p\n", q, p));
	*(struct __ns1__getAccessToken*)p = *(struct __ns1__getAccessToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sdsGcsj(struct soap *soap, struct __ns1__sdsGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sdsGcsj_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sdsGcsj(struct soap *soap, const struct __ns1__sdsGcsj *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__sdsGcsj(soap, &a->ns1__sdsGcsj_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sdsGcsj(struct soap *soap, const char *tag, int id, const struct __ns1__sdsGcsj *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__sdsGcsj(soap, "ns1:sdsGcsj", -1, &a->ns1__sdsGcsj_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sdsGcsj * SOAP_FMAC4 soap_in___ns1__sdsGcsj(struct soap *soap, const char *tag, struct __ns1__sdsGcsj *a, const char *type)
{
	size_t soap_flag_ns1__sdsGcsj_ = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__sdsGcsj *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sdsGcsj, sizeof(struct __ns1__sdsGcsj), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sdsGcsj(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sdsGcsj_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sdsGcsj(soap, "ns1:sdsGcsj", &a->ns1__sdsGcsj_, "ns1:sdsGcsj"))
				{	soap_flag_ns1__sdsGcsj_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sdsGcsj(struct soap *soap, const struct __ns1__sdsGcsj *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sdsGcsj(soap, tag?tag:"-ns1:sdsGcsj", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sdsGcsj * SOAP_FMAC4 soap_get___ns1__sdsGcsj(struct soap *soap, struct __ns1__sdsGcsj *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sdsGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sdsGcsj * SOAP_FMAC2 soap_instantiate___ns1__sdsGcsj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sdsGcsj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sdsGcsj, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sdsGcsj);
		if (size)
			*size = sizeof(struct __ns1__sdsGcsj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__sdsGcsj, n);
		if (size)
			*size = n * sizeof(struct __ns1__sdsGcsj);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__sdsGcsj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sdsGcsj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sdsGcsj %p -> %p\n", q, p));
	*(struct __ns1__sdsGcsj*)p = *(struct __ns1__sdsGcsj*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__qycObdIupr(struct soap *soap, ns1__qycObdIupr *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__qycObdIupr))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__qycObdIupr(struct soap *soap, const char *tag, int id, ns1__qycObdIupr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__qycObdIupr);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__qycObdIupr ** SOAP_FMAC4 soap_in_PointerTons1__qycObdIupr(struct soap *soap, const char *tag, ns1__qycObdIupr **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__qycObdIupr **)soap_malloc(soap, sizeof(ns1__qycObdIupr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__qycObdIupr *)soap_instantiate_ns1__qycObdIupr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__qycObdIupr ** p = (ns1__qycObdIupr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__qycObdIupr, sizeof(ns1__qycObdIupr), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__qycObdIupr(struct soap *soap, ns1__qycObdIupr *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__qycObdIupr);
	if (soap_out_PointerTons1__qycObdIupr(soap, tag?tag:"ns1:qycObdIupr", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__qycObdIupr ** SOAP_FMAC4 soap_get_PointerTons1__qycObdIupr(struct soap *soap, ns1__qycObdIupr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__qycObdIupr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sdsJgsj(struct soap *soap, ns1__sdsJgsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sdsJgsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sdsJgsj(struct soap *soap, const char *tag, int id, ns1__sdsJgsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sdsJgsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sdsJgsj ** SOAP_FMAC4 soap_in_PointerTons1__sdsJgsj(struct soap *soap, const char *tag, ns1__sdsJgsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sdsJgsj **)soap_malloc(soap, sizeof(ns1__sdsJgsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sdsJgsj *)soap_instantiate_ns1__sdsJgsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sdsJgsj ** p = (ns1__sdsJgsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sdsJgsj, sizeof(ns1__sdsJgsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sdsJgsj(struct soap *soap, ns1__sdsJgsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__sdsJgsj);
	if (soap_out_PointerTons1__sdsJgsj(soap, tag?tag:"ns1:sdsJgsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sdsJgsj ** SOAP_FMAC4 soap_get_PointerTons1__sdsJgsj(struct soap *soap, ns1__sdsJgsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sdsJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cycObdIupr(struct soap *soap, ns1__cycObdIupr *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cycObdIupr))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cycObdIupr(struct soap *soap, const char *tag, int id, ns1__cycObdIupr *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cycObdIupr);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cycObdIupr ** SOAP_FMAC4 soap_in_PointerTons1__cycObdIupr(struct soap *soap, const char *tag, ns1__cycObdIupr **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cycObdIupr **)soap_malloc(soap, sizeof(ns1__cycObdIupr *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cycObdIupr *)soap_instantiate_ns1__cycObdIupr(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cycObdIupr ** p = (ns1__cycObdIupr **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cycObdIupr, sizeof(ns1__cycObdIupr), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cycObdIupr(struct soap *soap, ns1__cycObdIupr *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__cycObdIupr);
	if (soap_out_PointerTons1__cycObdIupr(soap, tag?tag:"ns1:cycObdIupr", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cycObdIupr ** SOAP_FMAC4 soap_get_PointerTons1__cycObdIupr(struct soap *soap, ns1__cycObdIupr **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cycObdIupr(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wqfxyzj(struct soap *soap, ns1__wqfxyzj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wqfxyzj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wqfxyzj(struct soap *soap, const char *tag, int id, ns1__wqfxyzj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wqfxyzj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wqfxyzj ** SOAP_FMAC4 soap_in_PointerTons1__wqfxyzj(struct soap *soap, const char *tag, ns1__wqfxyzj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wqfxyzj **)soap_malloc(soap, sizeof(ns1__wqfxyzj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wqfxyzj *)soap_instantiate_ns1__wqfxyzj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wqfxyzj ** p = (ns1__wqfxyzj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wqfxyzj, sizeof(ns1__wqfxyzj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wqfxyzj(struct soap *soap, ns1__wqfxyzj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__wqfxyzj);
	if (soap_out_PointerTons1__wqfxyzj(soap, tag?tag:"ns1:wqfxyzj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wqfxyzj ** SOAP_FMAC4 soap_get_PointerTons1__wqfxyzj(struct soap *soap, ns1__wqfxyzj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wqfxyzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__jzjsGcsj(struct soap *soap, ns1__jzjsGcsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__jzjsGcsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__jzjsGcsj(struct soap *soap, const char *tag, int id, ns1__jzjsGcsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__jzjsGcsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__jzjsGcsj ** SOAP_FMAC4 soap_in_PointerTons1__jzjsGcsj(struct soap *soap, const char *tag, ns1__jzjsGcsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__jzjsGcsj **)soap_malloc(soap, sizeof(ns1__jzjsGcsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__jzjsGcsj *)soap_instantiate_ns1__jzjsGcsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__jzjsGcsj ** p = (ns1__jzjsGcsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__jzjsGcsj, sizeof(ns1__jzjsGcsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__jzjsGcsj(struct soap *soap, ns1__jzjsGcsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__jzjsGcsj);
	if (soap_out_PointerTons1__jzjsGcsj(soap, tag?tag:"ns1:jzjsGcsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__jzjsGcsj ** SOAP_FMAC4 soap_get_PointerTons1__jzjsGcsj(struct soap *soap, ns1__jzjsGcsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__jzjsGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__jystGcsj(struct soap *soap, ns1__jystGcsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__jystGcsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__jystGcsj(struct soap *soap, const char *tag, int id, ns1__jystGcsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__jystGcsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__jystGcsj ** SOAP_FMAC4 soap_in_PointerTons1__jystGcsj(struct soap *soap, const char *tag, ns1__jystGcsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__jystGcsj **)soap_malloc(soap, sizeof(ns1__jystGcsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__jystGcsj *)soap_instantiate_ns1__jystGcsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__jystGcsj ** p = (ns1__jystGcsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__jystGcsj, sizeof(ns1__jystGcsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__jystGcsj(struct soap *soap, ns1__jystGcsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__jystGcsj);
	if (soap_out_PointerTons1__jystGcsj(soap, tag?tag:"ns1:jystGcsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__jystGcsj ** SOAP_FMAC4 soap_get_PointerTons1__jystGcsj(struct soap *soap, ns1__jystGcsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__jystGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lgmhdJgsj(struct soap *soap, ns1__lgmhdJgsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__lgmhdJgsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lgmhdJgsj(struct soap *soap, const char *tag, int id, ns1__lgmhdJgsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__lgmhdJgsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lgmhdJgsj ** SOAP_FMAC4 soap_in_PointerTons1__lgmhdJgsj(struct soap *soap, const char *tag, ns1__lgmhdJgsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__lgmhdJgsj **)soap_malloc(soap, sizeof(ns1__lgmhdJgsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__lgmhdJgsj *)soap_instantiate_ns1__lgmhdJgsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__lgmhdJgsj ** p = (ns1__lgmhdJgsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__lgmhdJgsj, sizeof(ns1__lgmhdJgsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lgmhdJgsj(struct soap *soap, ns1__lgmhdJgsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__lgmhdJgsj);
	if (soap_out_PointerTons1__lgmhdJgsj(soap, tag?tag:"ns1:lgmhdJgsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lgmhdJgsj ** SOAP_FMAC4 soap_get_PointerTons1__lgmhdJgsj(struct soap *soap, ns1__lgmhdJgsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__lgmhdJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__jczrylb(struct soap *soap, ns1__jczrylb *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__jczrylb))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__jczrylb(struct soap *soap, const char *tag, int id, ns1__jczrylb *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__jczrylb);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__jczrylb ** SOAP_FMAC4 soap_in_PointerTons1__jczrylb(struct soap *soap, const char *tag, ns1__jczrylb **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__jczrylb **)soap_malloc(soap, sizeof(ns1__jczrylb *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__jczrylb *)soap_instantiate_ns1__jczrylb(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__jczrylb ** p = (ns1__jczrylb **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__jczrylb, sizeof(ns1__jczrylb), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__jczrylb(struct soap *soap, ns1__jczrylb *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__jczrylb);
	if (soap_out_PointerTons1__jczrylb(soap, tag?tag:"ns1:jczrylb", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__jczrylb ** SOAP_FMAC4 soap_get_PointerTons1__jczrylb(struct soap *soap, ns1__jczrylb **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__jczrylb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__hjcsyzj(struct soap *soap, ns1__hjcsyzj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__hjcsyzj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__hjcsyzj(struct soap *soap, const char *tag, int id, ns1__hjcsyzj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__hjcsyzj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__hjcsyzj ** SOAP_FMAC4 soap_in_PointerTons1__hjcsyzj(struct soap *soap, const char *tag, ns1__hjcsyzj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__hjcsyzj **)soap_malloc(soap, sizeof(ns1__hjcsyzj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__hjcsyzj *)soap_instantiate_ns1__hjcsyzj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__hjcsyzj ** p = (ns1__hjcsyzj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__hjcsyzj, sizeof(ns1__hjcsyzj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__hjcsyzj(struct soap *soap, ns1__hjcsyzj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__hjcsyzj);
	if (soap_out_PointerTons1__hjcsyzj(soap, tag?tag:"ns1:hjcsyzj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__hjcsyzj ** SOAP_FMAC4 soap_get_PointerTons1__hjcsyzj(struct soap *soap, ns1__hjcsyzj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__hjcsyzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__btgJgsj(struct soap *soap, ns1__btgJgsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__btgJgsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__btgJgsj(struct soap *soap, const char *tag, int id, ns1__btgJgsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__btgJgsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__btgJgsj ** SOAP_FMAC4 soap_in_PointerTons1__btgJgsj(struct soap *soap, const char *tag, ns1__btgJgsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__btgJgsj **)soap_malloc(soap, sizeof(ns1__btgJgsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__btgJgsj *)soap_instantiate_ns1__btgJgsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__btgJgsj ** p = (ns1__btgJgsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__btgJgsj, sizeof(ns1__btgJgsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__btgJgsj(struct soap *soap, ns1__btgJgsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__btgJgsj);
	if (soap_out_PointerTons1__btgJgsj(soap, tag?tag:"ns1:btgJgsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__btgJgsj ** SOAP_FMAC4 soap_get_PointerTons1__btgJgsj(struct soap *soap, ns1__btgJgsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__btgJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__xxtz(struct soap *soap, ns1__xxtz *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__xxtz))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__xxtz(struct soap *soap, const char *tag, int id, ns1__xxtz *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__xxtz);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__xxtz ** SOAP_FMAC4 soap_in_PointerTons1__xxtz(struct soap *soap, const char *tag, ns1__xxtz **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__xxtz **)soap_malloc(soap, sizeof(ns1__xxtz *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__xxtz *)soap_instantiate_ns1__xxtz(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__xxtz ** p = (ns1__xxtz **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__xxtz, sizeof(ns1__xxtz), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__xxtz(struct soap *soap, ns1__xxtz *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__xxtz);
	if (soap_out_PointerTons1__xxtz(soap, tag?tag:"ns1:xxtz", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__xxtz ** SOAP_FMAC4 soap_get_PointerTons1__xxtz(struct soap *soap, ns1__xxtz **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__xxtz(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDjzt(struct soap *soap, ns1__getDjzt *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDjzt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDjzt(struct soap *soap, const char *tag, int id, ns1__getDjzt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDjzt);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDjzt ** SOAP_FMAC4 soap_in_PointerTons1__getDjzt(struct soap *soap, const char *tag, ns1__getDjzt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDjzt **)soap_malloc(soap, sizeof(ns1__getDjzt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDjzt *)soap_instantiate_ns1__getDjzt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDjzt ** p = (ns1__getDjzt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDjzt, sizeof(ns1__getDjzt), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDjzt(struct soap *soap, ns1__getDjzt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__getDjzt);
	if (soap_out_PointerTons1__getDjzt(soap, tag?tag:"ns1:getDjzt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDjzt ** SOAP_FMAC4 soap_get_PointerTons1__getDjzt(struct soap *soap, ns1__getDjzt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDjzt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cgjzj(struct soap *soap, ns1__cgjzj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cgjzj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cgjzj(struct soap *soap, const char *tag, int id, ns1__cgjzj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cgjzj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cgjzj ** SOAP_FMAC4 soap_in_PointerTons1__cgjzj(struct soap *soap, const char *tag, ns1__cgjzj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cgjzj **)soap_malloc(soap, sizeof(ns1__cgjzj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cgjzj *)soap_instantiate_ns1__cgjzj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cgjzj ** p = (ns1__cgjzj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cgjzj, sizeof(ns1__cgjzj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cgjzj(struct soap *soap, ns1__cgjzj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__cgjzj);
	if (soap_out_PointerTons1__cgjzj(soap, tag?tag:"ns1:cgjzj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cgjzj ** SOAP_FMAC4 soap_get_PointerTons1__cgjzj(struct soap *soap, ns1__cgjzj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cgjzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wtJgsj(struct soap *soap, ns1__wtJgsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wtJgsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wtJgsj(struct soap *soap, const char *tag, int id, ns1__wtJgsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wtJgsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wtJgsj ** SOAP_FMAC4 soap_in_PointerTons1__wtJgsj(struct soap *soap, const char *tag, ns1__wtJgsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wtJgsj **)soap_malloc(soap, sizeof(ns1__wtJgsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wtJgsj *)soap_instantiate_ns1__wtJgsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wtJgsj ** p = (ns1__wtJgsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wtJgsj, sizeof(ns1__wtJgsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wtJgsj(struct soap *soap, ns1__wtJgsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__wtJgsj);
	if (soap_out_PointerTons1__wtJgsj(soap, tag?tag:"ns1:wtJgsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wtJgsj ** SOAP_FMAC4 soap_get_PointerTons1__wtJgsj(struct soap *soap, ns1__wtJgsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wtJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__obdGcsj(struct soap *soap, ns1__obdGcsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__obdGcsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__obdGcsj(struct soap *soap, const char *tag, int id, ns1__obdGcsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__obdGcsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__obdGcsj ** SOAP_FMAC4 soap_in_PointerTons1__obdGcsj(struct soap *soap, const char *tag, ns1__obdGcsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__obdGcsj **)soap_malloc(soap, sizeof(ns1__obdGcsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__obdGcsj *)soap_instantiate_ns1__obdGcsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__obdGcsj ** p = (ns1__obdGcsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__obdGcsj, sizeof(ns1__obdGcsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__obdGcsj(struct soap *soap, ns1__obdGcsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__obdGcsj);
	if (soap_out_PointerTons1__obdGcsj(soap, tag?tag:"ns1:obdGcsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__obdGcsj ** SOAP_FMAC4 soap_get_PointerTons1__obdGcsj(struct soap *soap, ns1__obdGcsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__obdGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wtGcsj(struct soap *soap, ns1__wtGcsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wtGcsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wtGcsj(struct soap *soap, const char *tag, int id, ns1__wtGcsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wtGcsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wtGcsj ** SOAP_FMAC4 soap_in_PointerTons1__wtGcsj(struct soap *soap, const char *tag, ns1__wtGcsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wtGcsj **)soap_malloc(soap, sizeof(ns1__wtGcsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wtGcsj *)soap_instantiate_ns1__wtGcsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wtGcsj ** p = (ns1__wtGcsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wtGcsj, sizeof(ns1__wtGcsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wtGcsj(struct soap *soap, ns1__wtGcsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__wtGcsj);
	if (soap_out_PointerTons1__wtGcsj(soap, tag?tag:"ns1:wtGcsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wtGcsj ** SOAP_FMAC4 soap_get_PointerTons1__wtGcsj(struct soap *soap, ns1__wtGcsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wtGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__jzjsJgsj(struct soap *soap, ns1__jzjsJgsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__jzjsJgsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__jzjsJgsj(struct soap *soap, const char *tag, int id, ns1__jzjsJgsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__jzjsJgsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__jzjsJgsj ** SOAP_FMAC4 soap_in_PointerTons1__jzjsJgsj(struct soap *soap, const char *tag, ns1__jzjsJgsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__jzjsJgsj **)soap_malloc(soap, sizeof(ns1__jzjsJgsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__jzjsJgsj *)soap_instantiate_ns1__jzjsJgsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__jzjsJgsj ** p = (ns1__jzjsJgsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__jzjsJgsj, sizeof(ns1__jzjsJgsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__jzjsJgsj(struct soap *soap, ns1__jzjsJgsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__jzjsJgsj);
	if (soap_out_PointerTons1__jzjsJgsj(soap, tag?tag:"ns1:jzjsJgsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__jzjsJgsj ** SOAP_FMAC4 soap_get_PointerTons1__jzjsJgsj(struct soap *soap, ns1__jzjsJgsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__jzjsJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDjclxx(struct soap *soap, ns1__getDjclxx *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDjclxx))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDjclxx(struct soap *soap, const char *tag, int id, ns1__getDjclxx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDjclxx);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDjclxx ** SOAP_FMAC4 soap_in_PointerTons1__getDjclxx(struct soap *soap, const char *tag, ns1__getDjclxx **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDjclxx **)soap_malloc(soap, sizeof(ns1__getDjclxx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDjclxx *)soap_instantiate_ns1__getDjclxx(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDjclxx ** p = (ns1__getDjclxx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDjclxx, sizeof(ns1__getDjclxx), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDjclxx(struct soap *soap, ns1__getDjclxx *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__getDjclxx);
	if (soap_out_PointerTons1__getDjclxx(soap, tag?tag:"ns1:getDjclxx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDjclxx ** SOAP_FMAC4 soap_get_PointerTons1__getDjclxx(struct soap *soap, ns1__getDjclxx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDjclxx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lgmhdGcsj(struct soap *soap, ns1__lgmhdGcsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__lgmhdGcsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lgmhdGcsj(struct soap *soap, const char *tag, int id, ns1__lgmhdGcsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__lgmhdGcsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lgmhdGcsj ** SOAP_FMAC4 soap_in_PointerTons1__lgmhdGcsj(struct soap *soap, const char *tag, ns1__lgmhdGcsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__lgmhdGcsj **)soap_malloc(soap, sizeof(ns1__lgmhdGcsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__lgmhdGcsj *)soap_instantiate_ns1__lgmhdGcsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__lgmhdGcsj ** p = (ns1__lgmhdGcsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__lgmhdGcsj, sizeof(ns1__lgmhdGcsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lgmhdGcsj(struct soap *soap, ns1__lgmhdGcsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__lgmhdGcsj);
	if (soap_out_PointerTons1__lgmhdGcsj(soap, tag?tag:"ns1:lgmhdGcsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lgmhdGcsj ** SOAP_FMAC4 soap_get_PointerTons1__lgmhdGcsj(struct soap *soap, ns1__lgmhdGcsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__lgmhdGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__obdDjlb(struct soap *soap, ns1__obdDjlb *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__obdDjlb))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__obdDjlb(struct soap *soap, const char *tag, int id, ns1__obdDjlb *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__obdDjlb);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__obdDjlb ** SOAP_FMAC4 soap_in_PointerTons1__obdDjlb(struct soap *soap, const char *tag, ns1__obdDjlb **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__obdDjlb **)soap_malloc(soap, sizeof(ns1__obdDjlb *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__obdDjlb *)soap_instantiate_ns1__obdDjlb(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__obdDjlb ** p = (ns1__obdDjlb **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__obdDjlb, sizeof(ns1__obdDjlb), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__obdDjlb(struct soap *soap, ns1__obdDjlb *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__obdDjlb);
	if (soap_out_PointerTons1__obdDjlb(soap, tag?tag:"ns1:obdDjlb", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__obdDjlb ** SOAP_FMAC4 soap_get_PointerTons1__obdDjlb(struct soap *soap, ns1__obdDjlb **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__obdDjlb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fwqsjtb(struct soap *soap, ns1__fwqsjtb *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fwqsjtb))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fwqsjtb(struct soap *soap, const char *tag, int id, ns1__fwqsjtb *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fwqsjtb);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__fwqsjtb ** SOAP_FMAC4 soap_in_PointerTons1__fwqsjtb(struct soap *soap, const char *tag, ns1__fwqsjtb **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fwqsjtb **)soap_malloc(soap, sizeof(ns1__fwqsjtb *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__fwqsjtb *)soap_instantiate_ns1__fwqsjtb(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__fwqsjtb ** p = (ns1__fwqsjtb **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fwqsjtb, sizeof(ns1__fwqsjtb), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fwqsjtb(struct soap *soap, ns1__fwqsjtb *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__fwqsjtb);
	if (soap_out_PointerTons1__fwqsjtb(soap, tag?tag:"ns1:fwqsjtb", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fwqsjtb ** SOAP_FMAC4 soap_get_PointerTons1__fwqsjtb(struct soap *soap, ns1__fwqsjtb **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fwqsjtb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lljzj(struct soap *soap, ns1__lljzj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__lljzj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lljzj(struct soap *soap, const char *tag, int id, ns1__lljzj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__lljzj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lljzj ** SOAP_FMAC4 soap_in_PointerTons1__lljzj(struct soap *soap, const char *tag, ns1__lljzj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__lljzj **)soap_malloc(soap, sizeof(ns1__lljzj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__lljzj *)soap_instantiate_ns1__lljzj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__lljzj ** p = (ns1__lljzj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__lljzj, sizeof(ns1__lljzj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lljzj(struct soap *soap, ns1__lljzj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__lljzj);
	if (soap_out_PointerTons1__lljzj(soap, tag?tag:"ns1:lljzj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lljzj ** SOAP_FMAC4 soap_get_PointerTons1__lljzj(struct soap *soap, ns1__lljzj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__lljzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__btgGcsj(struct soap *soap, ns1__btgGcsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__btgGcsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__btgGcsj(struct soap *soap, const char *tag, int id, ns1__btgGcsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__btgGcsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__btgGcsj ** SOAP_FMAC4 soap_in_PointerTons1__btgGcsj(struct soap *soap, const char *tag, ns1__btgGcsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__btgGcsj **)soap_malloc(soap, sizeof(ns1__btgGcsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__btgGcsj *)soap_instantiate_ns1__btgGcsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__btgGcsj ** p = (ns1__btgGcsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__btgGcsj, sizeof(ns1__btgGcsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__btgGcsj(struct soap *soap, ns1__btgGcsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__btgGcsj);
	if (soap_out_PointerTons1__btgGcsj(soap, tag?tag:"ns1:btgGcsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__btgGcsj ** SOAP_FMAC4 soap_get_PointerTons1__btgGcsj(struct soap *soap, ns1__btgGcsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__btgGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ryzfJysj(struct soap *soap, ns1__ryzfJysj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ryzfJysj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ryzfJysj(struct soap *soap, const char *tag, int id, ns1__ryzfJysj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ryzfJysj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ryzfJysj ** SOAP_FMAC4 soap_in_PointerTons1__ryzfJysj(struct soap *soap, const char *tag, ns1__ryzfJysj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ryzfJysj **)soap_malloc(soap, sizeof(ns1__ryzfJysj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ryzfJysj *)soap_instantiate_ns1__ryzfJysj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ryzfJysj ** p = (ns1__ryzfJysj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ryzfJysj, sizeof(ns1__ryzfJysj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ryzfJysj(struct soap *soap, ns1__ryzfJysj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__ryzfJysj);
	if (soap_out_PointerTons1__ryzfJysj(soap, tag?tag:"ns1:ryzfJysj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ryzfJysj ** SOAP_FMAC4 soap_get_PointerTons1__ryzfJysj(struct soap *soap, ns1__ryzfJysj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ryzfJysj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wgjcJgsj(struct soap *soap, ns1__wgjcJgsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wgjcJgsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wgjcJgsj(struct soap *soap, const char *tag, int id, ns1__wgjcJgsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wgjcJgsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wgjcJgsj ** SOAP_FMAC4 soap_in_PointerTons1__wgjcJgsj(struct soap *soap, const char *tag, ns1__wgjcJgsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wgjcJgsj **)soap_malloc(soap, sizeof(ns1__wgjcJgsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wgjcJgsj *)soap_instantiate_ns1__wgjcJgsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wgjcJgsj ** p = (ns1__wgjcJgsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wgjcJgsj, sizeof(ns1__wgjcJgsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wgjcJgsj(struct soap *soap, ns1__wgjcJgsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__wgjcJgsj);
	if (soap_out_PointerTons1__wgjcJgsj(soap, tag?tag:"ns1:wgjcJgsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wgjcJgsj ** SOAP_FMAC4 soap_get_PointerTons1__wgjcJgsj(struct soap *soap, ns1__wgjcJgsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wgjcJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__jystJgsj(struct soap *soap, ns1__jystJgsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__jystJgsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__jystJgsj(struct soap *soap, const char *tag, int id, ns1__jystJgsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__jystJgsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__jystJgsj ** SOAP_FMAC4 soap_in_PointerTons1__jystJgsj(struct soap *soap, const char *tag, ns1__jystJgsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__jystJgsj **)soap_malloc(soap, sizeof(ns1__jystJgsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__jystJgsj *)soap_instantiate_ns1__jystJgsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__jystJgsj ** p = (ns1__jystJgsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__jystJgsj, sizeof(ns1__jystJgsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__jystJgsj(struct soap *soap, ns1__jystJgsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__jystJgsj);
	if (soap_out_PointerTons1__jystJgsj(soap, tag?tag:"ns1:jystJgsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__jystJgsj ** SOAP_FMAC4 soap_get_PointerTons1__jystJgsj(struct soap *soap, ns1__jystJgsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__jystJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wqfxybd(struct soap *soap, ns1__wqfxybd *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wqfxybd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wqfxybd(struct soap *soap, const char *tag, int id, ns1__wqfxybd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wqfxybd);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wqfxybd ** SOAP_FMAC4 soap_in_PointerTons1__wqfxybd(struct soap *soap, const char *tag, ns1__wqfxybd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wqfxybd **)soap_malloc(soap, sizeof(ns1__wqfxybd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wqfxybd *)soap_instantiate_ns1__wqfxybd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wqfxybd ** p = (ns1__wqfxybd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wqfxybd, sizeof(ns1__wqfxybd), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wqfxybd(struct soap *soap, ns1__wqfxybd *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__wqfxybd);
	if (soap_out_PointerTons1__wqfxybd(soap, tag?tag:"ns1:wqfxybd", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wqfxybd ** SOAP_FMAC4 soap_get_PointerTons1__wqfxybd(struct soap *soap, ns1__wqfxybd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wqfxybd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ydjzj(struct soap *soap, ns1__ydjzj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ydjzj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ydjzj(struct soap *soap, const char *tag, int id, ns1__ydjzj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ydjzj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ydjzj ** SOAP_FMAC4 soap_in_PointerTons1__ydjzj(struct soap *soap, const char *tag, ns1__ydjzj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ydjzj **)soap_malloc(soap, sizeof(ns1__ydjzj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ydjzj *)soap_instantiate_ns1__ydjzj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ydjzj ** p = (ns1__ydjzj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ydjzj, sizeof(ns1__ydjzj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ydjzj(struct soap *soap, ns1__ydjzj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__ydjzj);
	if (soap_out_PointerTons1__ydjzj(soap, tag?tag:"ns1:ydjzj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ydjzj ** SOAP_FMAC4 soap_get_PointerTons1__ydjzj(struct soap *soap, ns1__ydjzj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ydjzj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__obdJgsj(struct soap *soap, ns1__obdJgsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__obdJgsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__obdJgsj(struct soap *soap, const char *tag, int id, ns1__obdJgsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__obdJgsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__obdJgsj ** SOAP_FMAC4 soap_in_PointerTons1__obdJgsj(struct soap *soap, const char *tag, ns1__obdJgsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__obdJgsj **)soap_malloc(soap, sizeof(ns1__obdJgsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__obdJgsj *)soap_instantiate_ns1__obdJgsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__obdJgsj ** p = (ns1__obdJgsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__obdJgsj, sizeof(ns1__obdJgsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__obdJgsj(struct soap *soap, ns1__obdJgsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__obdJgsj);
	if (soap_out_PointerTons1__obdJgsj(soap, tag?tag:"ns1:obdJgsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__obdJgsj ** SOAP_FMAC4 soap_get_PointerTons1__obdJgsj(struct soap *soap, ns1__obdJgsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__obdJgsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gkrjbbh(struct soap *soap, ns1__gkrjbbh *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gkrjbbh))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gkrjbbh(struct soap *soap, const char *tag, int id, ns1__gkrjbbh *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gkrjbbh);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gkrjbbh ** SOAP_FMAC4 soap_in_PointerTons1__gkrjbbh(struct soap *soap, const char *tag, ns1__gkrjbbh **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gkrjbbh **)soap_malloc(soap, sizeof(ns1__gkrjbbh *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gkrjbbh *)soap_instantiate_ns1__gkrjbbh(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gkrjbbh ** p = (ns1__gkrjbbh **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gkrjbbh, sizeof(ns1__gkrjbbh), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gkrjbbh(struct soap *soap, ns1__gkrjbbh *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__gkrjbbh);
	if (soap_out_PointerTons1__gkrjbbh(soap, tag?tag:"ns1:gkrjbbh", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__gkrjbbh ** SOAP_FMAC4 soap_get_PointerTons1__gkrjbbh(struct soap *soap, ns1__gkrjbbh **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gkrjbbh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getAccessToken(struct soap *soap, ns1__getAccessToken *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getAccessToken))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getAccessToken(struct soap *soap, const char *tag, int id, ns1__getAccessToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getAccessToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getAccessToken ** SOAP_FMAC4 soap_in_PointerTons1__getAccessToken(struct soap *soap, const char *tag, ns1__getAccessToken **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getAccessToken **)soap_malloc(soap, sizeof(ns1__getAccessToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getAccessToken *)soap_instantiate_ns1__getAccessToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getAccessToken ** p = (ns1__getAccessToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAccessToken, sizeof(ns1__getAccessToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getAccessToken(struct soap *soap, ns1__getAccessToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__getAccessToken);
	if (soap_out_PointerTons1__getAccessToken(soap, tag?tag:"ns1:getAccessToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getAccessToken ** SOAP_FMAC4 soap_get_PointerTons1__getAccessToken(struct soap *soap, ns1__getAccessToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getAccessToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sdsGcsj(struct soap *soap, ns1__sdsGcsj *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sdsGcsj))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sdsGcsj(struct soap *soap, const char *tag, int id, ns1__sdsGcsj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sdsGcsj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sdsGcsj ** SOAP_FMAC4 soap_in_PointerTons1__sdsGcsj(struct soap *soap, const char *tag, ns1__sdsGcsj **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sdsGcsj **)soap_malloc(soap, sizeof(ns1__sdsGcsj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sdsGcsj *)soap_instantiate_ns1__sdsGcsj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sdsGcsj ** p = (ns1__sdsGcsj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sdsGcsj, sizeof(ns1__sdsGcsj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sdsGcsj(struct soap *soap, ns1__sdsGcsj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__sdsGcsj);
	if (soap_out_PointerTons1__sdsGcsj(soap, tag?tag:"ns1:sdsGcsj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sdsGcsj ** SOAP_FMAC4 soap_get_PointerTons1__sdsGcsj(struct soap *soap, ns1__sdsGcsj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sdsGcsj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__wstring(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__wstring))
		soap_serialize_std__wstring(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__wstring(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__wstring);
	if (id < 0)
		return soap->error;
	return soap_out_std__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTostd__wstring(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__wstring(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTostd__wstring);
	if (soap_out_PointerTostd__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTostd__wstring(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
