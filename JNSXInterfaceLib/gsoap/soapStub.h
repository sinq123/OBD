/* soapStub.h
   Generated by gSOAP 2.8.21 from service[1].h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://www.gc8848.com/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20821
# error "GSOAP VERSION 20821 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__RetValue
#define SOAP_TYPE_ns1__RetValue (8)
/* ns1:RetValue */
class SOAP_CMAC ns1__RetValue
{
public:
	int ErrNum;	/* required element of type xsd:int */
	std::wstring *ErrMsg;	/* optional element of type xsd:string */
	int InternalErrNum;	/* required element of type xsd:int */
	std::wstring *InternalErrMsg;	/* optional element of type xsd:string */
	std::wstring *Value;	/* optional element of type xsd:string */
	std::wstring *TipMessage;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique type id SOAP_TYPE_ns1__RetValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetValue() { ns1__RetValue::soap_default(NULL); }
	virtual ~ns1__RetValue() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Sync
#define SOAP_TYPE__ns1__Sync (9)
/* ns1:Sync */
class SOAP_CMAC _ns1__Sync
{
public:
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique type id SOAP_TYPE__ns1__Sync */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Sync() { _ns1__Sync::soap_default(NULL); }
	virtual ~_ns1__Sync() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SyncResponse
#define SOAP_TYPE__ns1__SyncResponse (10)
/* ns1:SyncResponse */
class SOAP_CMAC _ns1__SyncResponse
{
public:
	ns1__RetValue *SyncResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique type id SOAP_TYPE__ns1__SyncResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SyncResponse() { _ns1__SyncResponse::soap_default(NULL); }
	virtual ~_ns1__SyncResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetInspectQueueByDate
#define SOAP_TYPE__ns1__GetInspectQueueByDate (11)
/* ns1:GetInspectQueueByDate */
class SOAP_CMAC _ns1__GetInspectQueueByDate
{
public:
	std::wstring *FromDate;	/* optional element of type xsd:string */
	std::wstring *ToDate;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique type id SOAP_TYPE__ns1__GetInspectQueueByDate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetInspectQueueByDate() { _ns1__GetInspectQueueByDate::soap_default(NULL); }
	virtual ~_ns1__GetInspectQueueByDate() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetInspectQueueByDateResponse
#define SOAP_TYPE__ns1__GetInspectQueueByDateResponse (12)
/* ns1:GetInspectQueueByDateResponse */
class SOAP_CMAC _ns1__GetInspectQueueByDateResponse
{
public:
	ns1__RetValue *GetInspectQueueByDateResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique type id SOAP_TYPE__ns1__GetInspectQueueByDateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetInspectQueueByDateResponse() { _ns1__GetInspectQueueByDateResponse::soap_default(NULL); }
	virtual ~_ns1__GetInspectQueueByDateResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetInspectQueueByPlateID
#define SOAP_TYPE__ns1__GetInspectQueueByPlateID (13)
/* ns1:GetInspectQueueByPlateID */
class SOAP_CMAC _ns1__GetInspectQueueByPlateID
{
public:
	std::wstring *PlateID;	/* optional element of type xsd:string */
	int PlateType;	/* required element of type xsd:int */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique type id SOAP_TYPE__ns1__GetInspectQueueByPlateID */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetInspectQueueByPlateID() { _ns1__GetInspectQueueByPlateID::soap_default(NULL); }
	virtual ~_ns1__GetInspectQueueByPlateID() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse
#define SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse (14)
/* ns1:GetInspectQueueByPlateIDResponse */
class SOAP_CMAC _ns1__GetInspectQueueByPlateIDResponse
{
public:
	ns1__RetValue *GetInspectQueueByPlateIDResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique type id SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetInspectQueueByPlateIDResponse() { _ns1__GetInspectQueueByPlateIDResponse::soap_default(NULL); }
	virtual ~_ns1__GetInspectQueueByPlateIDResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AbortInspect
#define SOAP_TYPE__ns1__AbortInspect (15)
/* ns1:AbortInspect */
class SOAP_CMAC _ns1__AbortInspect
{
public:
	std::wstring *InspectID;	/* optional element of type xsd:string */
	int Reason;	/* required element of type xsd:int */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique type id SOAP_TYPE__ns1__AbortInspect */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AbortInspect() { _ns1__AbortInspect::soap_default(NULL); }
	virtual ~_ns1__AbortInspect() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AbortInspectResponse
#define SOAP_TYPE__ns1__AbortInspectResponse (16)
/* ns1:AbortInspectResponse */
class SOAP_CMAC _ns1__AbortInspectResponse
{
public:
	ns1__RetValue *AbortInspectResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique type id SOAP_TYPE__ns1__AbortInspectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AbortInspectResponse() { _ns1__AbortInspectResponse::soap_default(NULL); }
	virtual ~_ns1__AbortInspectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BeginRecord
#define SOAP_TYPE__ns1__BeginRecord (17)
/* ns1:BeginRecord */
class SOAP_CMAC _ns1__BeginRecord
{
public:
	LONG64 LineID;	/* required element of type xsd:long */
	std::wstring *InspectID;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique type id SOAP_TYPE__ns1__BeginRecord */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BeginRecord() { _ns1__BeginRecord::soap_default(NULL); }
	virtual ~_ns1__BeginRecord() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BeginRecordResponse
#define SOAP_TYPE__ns1__BeginRecordResponse (18)
/* ns1:BeginRecordResponse */
class SOAP_CMAC _ns1__BeginRecordResponse
{
public:
	ns1__RetValue *BeginRecordResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique type id SOAP_TYPE__ns1__BeginRecordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BeginRecordResponse() { _ns1__BeginRecordResponse::soap_default(NULL); }
	virtual ~_ns1__BeginRecordResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__EndRecord
#define SOAP_TYPE__ns1__EndRecord (19)
/* ns1:EndRecord */
class SOAP_CMAC _ns1__EndRecord
{
public:
	std::wstring *InspectID;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique type id SOAP_TYPE__ns1__EndRecord */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__EndRecord() { _ns1__EndRecord::soap_default(NULL); }
	virtual ~_ns1__EndRecord() { }
};
#endif

#ifndef SOAP_TYPE__ns1__EndRecordResponse
#define SOAP_TYPE__ns1__EndRecordResponse (20)
/* ns1:EndRecordResponse */
class SOAP_CMAC _ns1__EndRecordResponse
{
public:
	ns1__RetValue *EndRecordResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique type id SOAP_TYPE__ns1__EndRecordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__EndRecordResponse() { _ns1__EndRecordResponse::soap_default(NULL); }
	virtual ~_ns1__EndRecordResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BeginInspect
#define SOAP_TYPE__ns1__BeginInspect (21)
/* ns1:BeginInspect */
class SOAP_CMAC _ns1__BeginInspect
{
public:
	LONG64 LineID;	/* required element of type xsd:long */
	std::wstring *InspectID;	/* optional element of type xsd:string */
	LONG64 DriverID;	/* required element of type xsd:long */
	LONG64 OperatorID;	/* required element of type xsd:long */
	std::wstring *InspectParam;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique type id SOAP_TYPE__ns1__BeginInspect */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BeginInspect() { _ns1__BeginInspect::soap_default(NULL); }
	virtual ~_ns1__BeginInspect() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BeginInspectResponse
#define SOAP_TYPE__ns1__BeginInspectResponse (22)
/* ns1:BeginInspectResponse */
class SOAP_CMAC _ns1__BeginInspectResponse
{
public:
	ns1__RetValue *BeginInspectResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique type id SOAP_TYPE__ns1__BeginInspectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BeginInspectResponse() { _ns1__BeginInspectResponse::soap_default(NULL); }
	virtual ~_ns1__BeginInspectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetLimit
#define SOAP_TYPE__ns1__GetLimit (23)
/* ns1:GetLimit */
class SOAP_CMAC _ns1__GetLimit
{
public:
	std::wstring *InspectID;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique type id SOAP_TYPE__ns1__GetLimit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetLimit() { _ns1__GetLimit::soap_default(NULL); }
	virtual ~_ns1__GetLimit() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetLimitResponse
#define SOAP_TYPE__ns1__GetLimitResponse (24)
/* ns1:GetLimitResponse */
class SOAP_CMAC _ns1__GetLimitResponse
{
public:
	ns1__RetValue *GetLimitResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique type id SOAP_TYPE__ns1__GetLimitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetLimitResponse() { _ns1__GetLimitResponse::soap_default(NULL); }
	virtual ~_ns1__GetLimitResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__TakePhoto
#define SOAP_TYPE__ns1__TakePhoto (25)
/* ns1:TakePhoto */
class SOAP_CMAC _ns1__TakePhoto
{
public:
	LONG64 LineID;	/* required element of type xsd:long */
	std::wstring *InspectID;	/* optional element of type xsd:string */
	int PicCode;	/* required element of type xsd:int */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique type id SOAP_TYPE__ns1__TakePhoto */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__TakePhoto() { _ns1__TakePhoto::soap_default(NULL); }
	virtual ~_ns1__TakePhoto() { }
};
#endif

#ifndef SOAP_TYPE__ns1__TakePhotoResponse
#define SOAP_TYPE__ns1__TakePhotoResponse (26)
/* ns1:TakePhotoResponse */
class SOAP_CMAC _ns1__TakePhotoResponse
{
public:
	ns1__RetValue *TakePhotoResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique type id SOAP_TYPE__ns1__TakePhotoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__TakePhotoResponse() { _ns1__TakePhotoResponse::soap_default(NULL); }
	virtual ~_ns1__TakePhotoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__WJTakePhoto
#define SOAP_TYPE__ns1__WJTakePhoto (27)
/* ns1:WJTakePhoto */
class SOAP_CMAC _ns1__WJTakePhoto
{
public:
	LONG64 ChannelID;	/* required element of type xsd:long */
	std::wstring *InspectID;	/* optional element of type xsd:string */
	int PicCode;	/* required element of type xsd:int */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique type id SOAP_TYPE__ns1__WJTakePhoto */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__WJTakePhoto() { _ns1__WJTakePhoto::soap_default(NULL); }
	virtual ~_ns1__WJTakePhoto() { }
};
#endif

#ifndef SOAP_TYPE__ns1__WJTakePhotoResponse
#define SOAP_TYPE__ns1__WJTakePhotoResponse (28)
/* ns1:WJTakePhotoResponse */
class SOAP_CMAC _ns1__WJTakePhotoResponse
{
public:
	ns1__RetValue *WJTakePhotoResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique type id SOAP_TYPE__ns1__WJTakePhotoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__WJTakePhotoResponse() { _ns1__WJTakePhotoResponse::soap_default(NULL); }
	virtual ~_ns1__WJTakePhotoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopInspect
#define SOAP_TYPE__ns1__StopInspect (29)
/* ns1:StopInspect */
class SOAP_CMAC _ns1__StopInspect
{
public:
	std::wstring *InspectID;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique type id SOAP_TYPE__ns1__StopInspect */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopInspect() { _ns1__StopInspect::soap_default(NULL); }
	virtual ~_ns1__StopInspect() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopInspectResponse
#define SOAP_TYPE__ns1__StopInspectResponse (30)
/* ns1:StopInspectResponse */
class SOAP_CMAC _ns1__StopInspectResponse
{
public:
	ns1__RetValue *StopInspectResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE__ns1__StopInspectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopInspectResponse() { _ns1__StopInspectResponse::soap_default(NULL); }
	virtual ~_ns1__StopInspectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__EndInspect
#define SOAP_TYPE__ns1__EndInspect (31)
/* ns1:EndInspect */
class SOAP_CMAC _ns1__EndInspect
{
public:
	std::wstring *InspectID;	/* optional element of type xsd:string */
	std::wstring *Result;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique type id SOAP_TYPE__ns1__EndInspect */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__EndInspect() { _ns1__EndInspect::soap_default(NULL); }
	virtual ~_ns1__EndInspect() { }
};
#endif

#ifndef SOAP_TYPE__ns1__EndInspectResponse
#define SOAP_TYPE__ns1__EndInspectResponse (32)
/* ns1:EndInspectResponse */
class SOAP_CMAC _ns1__EndInspectResponse
{
public:
	ns1__RetValue *EndInspectResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique type id SOAP_TYPE__ns1__EndInspectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__EndInspectResponse() { _ns1__EndInspectResponse::soap_default(NULL); }
	virtual ~_ns1__EndInspectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadSelfTestData
#define SOAP_TYPE__ns1__UploadSelfTestData (33)
/* ns1:UploadSelfTestData */
class SOAP_CMAC _ns1__UploadSelfTestData
{
public:
	LONG64 LineID;	/* required element of type xsd:long */
	std::wstring *ResultData;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique type id SOAP_TYPE__ns1__UploadSelfTestData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UploadSelfTestData() { _ns1__UploadSelfTestData::soap_default(NULL); }
	virtual ~_ns1__UploadSelfTestData() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadSelfTestDataResponse
#define SOAP_TYPE__ns1__UploadSelfTestDataResponse (34)
/* ns1:UploadSelfTestDataResponse */
class SOAP_CMAC _ns1__UploadSelfTestDataResponse
{
public:
	ns1__RetValue *UploadSelfTestDataResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique type id SOAP_TYPE__ns1__UploadSelfTestDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UploadSelfTestDataResponse() { _ns1__UploadSelfTestDataResponse::soap_default(NULL); }
	virtual ~_ns1__UploadSelfTestDataResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadRealtimeData
#define SOAP_TYPE__ns1__UploadRealtimeData (35)
/* ns1:UploadRealtimeData */
class SOAP_CMAC _ns1__UploadRealtimeData
{
public:
	std::wstring *InspectID;	/* optional element of type xsd:string */
	std::wstring *RealtimeData;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique type id SOAP_TYPE__ns1__UploadRealtimeData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UploadRealtimeData() { _ns1__UploadRealtimeData::soap_default(NULL); }
	virtual ~_ns1__UploadRealtimeData() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadRealtimeDataResponse
#define SOAP_TYPE__ns1__UploadRealtimeDataResponse (36)
/* ns1:UploadRealtimeDataResponse */
class SOAP_CMAC _ns1__UploadRealtimeDataResponse
{
public:
	ns1__RetValue *UploadRealtimeDataResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique type id SOAP_TYPE__ns1__UploadRealtimeDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UploadRealtimeDataResponse() { _ns1__UploadRealtimeDataResponse::soap_default(NULL); }
	virtual ~_ns1__UploadRealtimeDataResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetInspectionInfo
#define SOAP_TYPE__ns1__GetInspectionInfo (37)
/* ns1:GetInspectionInfo */
class SOAP_CMAC _ns1__GetInspectionInfo
{
public:
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique type id SOAP_TYPE__ns1__GetInspectionInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetInspectionInfo() { _ns1__GetInspectionInfo::soap_default(NULL); }
	virtual ~_ns1__GetInspectionInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetInspectionInfoResponse
#define SOAP_TYPE__ns1__GetInspectionInfoResponse (38)
/* ns1:GetInspectionInfoResponse */
class SOAP_CMAC _ns1__GetInspectionInfoResponse
{
public:
	ns1__RetValue *GetInspectionInfoResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique type id SOAP_TYPE__ns1__GetInspectionInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetInspectionInfoResponse() { _ns1__GetInspectionInfoResponse::soap_default(NULL); }
	virtual ~_ns1__GetInspectionInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BeginCalibrate
#define SOAP_TYPE__ns1__BeginCalibrate (39)
/* ns1:BeginCalibrate */
class SOAP_CMAC _ns1__BeginCalibrate
{
public:
	LONG64 LineID;	/* required element of type xsd:long */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique type id SOAP_TYPE__ns1__BeginCalibrate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BeginCalibrate() { _ns1__BeginCalibrate::soap_default(NULL); }
	virtual ~_ns1__BeginCalibrate() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BeginCalibrateResponse
#define SOAP_TYPE__ns1__BeginCalibrateResponse (40)
/* ns1:BeginCalibrateResponse */
class SOAP_CMAC _ns1__BeginCalibrateResponse
{
public:
	ns1__RetValue *BeginCalibrateResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique type id SOAP_TYPE__ns1__BeginCalibrateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BeginCalibrateResponse() { _ns1__BeginCalibrateResponse::soap_default(NULL); }
	virtual ~_ns1__BeginCalibrateResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadCalibrateData
#define SOAP_TYPE__ns1__UploadCalibrateData (41)
/* ns1:UploadCalibrateData */
class SOAP_CMAC _ns1__UploadCalibrateData
{
public:
	LONG64 LineID;	/* required element of type xsd:long */
	std::wstring *ResultData;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique type id SOAP_TYPE__ns1__UploadCalibrateData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UploadCalibrateData() { _ns1__UploadCalibrateData::soap_default(NULL); }
	virtual ~_ns1__UploadCalibrateData() { }
};
#endif

#ifndef SOAP_TYPE__ns1__UploadCalibrateDataResponse
#define SOAP_TYPE__ns1__UploadCalibrateDataResponse (42)
/* ns1:UploadCalibrateDataResponse */
class SOAP_CMAC _ns1__UploadCalibrateDataResponse
{
public:
	ns1__RetValue *UploadCalibrateDataResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique type id SOAP_TYPE__ns1__UploadCalibrateDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__UploadCalibrateDataResponse() { _ns1__UploadCalibrateDataResponse::soap_default(NULL); }
	virtual ~_ns1__UploadCalibrateDataResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__EndCalibrate
#define SOAP_TYPE__ns1__EndCalibrate (43)
/* ns1:EndCalibrate */
class SOAP_CMAC _ns1__EndCalibrate
{
public:
	LONG64 LineID;	/* required element of type xsd:long */
	std::wstring *Result;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique type id SOAP_TYPE__ns1__EndCalibrate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__EndCalibrate() { _ns1__EndCalibrate::soap_default(NULL); }
	virtual ~_ns1__EndCalibrate() { }
};
#endif

#ifndef SOAP_TYPE__ns1__EndCalibrateResponse
#define SOAP_TYPE__ns1__EndCalibrateResponse (44)
/* ns1:EndCalibrateResponse */
class SOAP_CMAC _ns1__EndCalibrateResponse
{
public:
	ns1__RetValue *EndCalibrateResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique type id SOAP_TYPE__ns1__EndCalibrateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__EndCalibrateResponse() { _ns1__EndCalibrateResponse::soap_default(NULL); }
	virtual ~_ns1__EndCalibrateResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__TestPhoto
#define SOAP_TYPE__ns1__TestPhoto (45)
/* ns1:TestPhoto */
class SOAP_CMAC _ns1__TestPhoto
{
public:
	LONG64 LineID;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique type id SOAP_TYPE__ns1__TestPhoto */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__TestPhoto() { _ns1__TestPhoto::soap_default(NULL); }
	virtual ~_ns1__TestPhoto() { }
};
#endif

#ifndef SOAP_TYPE__ns1__TestPhotoResponse
#define SOAP_TYPE__ns1__TestPhotoResponse (46)
/* ns1:TestPhotoResponse */
class SOAP_CMAC _ns1__TestPhotoResponse
{
public:
	ns1__RetValue *TestPhotoResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique type id SOAP_TYPE__ns1__TestPhotoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__TestPhotoResponse() { _ns1__TestPhotoResponse::soap_default(NULL); }
	virtual ~_ns1__TestPhotoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__FuelEvaporationInspect
#define SOAP_TYPE__ns1__FuelEvaporationInspect (47)
/* ns1:FuelEvaporationInspect */
class SOAP_CMAC _ns1__FuelEvaporationInspect
{
public:
	LONG64 ChannelID;	/* required element of type xsd:long */
	std::wstring *InspectID;	/* optional element of type xsd:string */
	std::wstring *RYZFData;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique type id SOAP_TYPE__ns1__FuelEvaporationInspect */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__FuelEvaporationInspect() { _ns1__FuelEvaporationInspect::soap_default(NULL); }
	virtual ~_ns1__FuelEvaporationInspect() { }
};
#endif

#ifndef SOAP_TYPE__ns1__FuelEvaporationInspectResponse
#define SOAP_TYPE__ns1__FuelEvaporationInspectResponse (48)
/* ns1:FuelEvaporationInspectResponse */
class SOAP_CMAC _ns1__FuelEvaporationInspectResponse
{
public:
	ns1__RetValue *FuelEvaporationInspectResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique type id SOAP_TYPE__ns1__FuelEvaporationInspectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__FuelEvaporationInspectResponse() { _ns1__FuelEvaporationInspectResponse::soap_default(NULL); }
	virtual ~_ns1__FuelEvaporationInspectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetInspectParams
#define SOAP_TYPE__ns1__GetInspectParams (49)
/* ns1:GetInspectParams */
class SOAP_CMAC _ns1__GetInspectParams
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique type id SOAP_TYPE__ns1__GetInspectParams */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetInspectParams() { _ns1__GetInspectParams::soap_default(NULL); }
	virtual ~_ns1__GetInspectParams() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetInspectParamsResponse
#define SOAP_TYPE__ns1__GetInspectParamsResponse (50)
/* ns1:GetInspectParamsResponse */
class SOAP_CMAC _ns1__GetInspectParamsResponse
{
public:
	ns1__RetValue *GetInspectParamsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique type id SOAP_TYPE__ns1__GetInspectParamsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetInspectParamsResponse() { _ns1__GetInspectParamsResponse::soap_default(NULL); }
	virtual ~_ns1__GetInspectParamsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID
#define SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID (51)
/* ns1:GetOtherInspectQueueByPlateID */
class SOAP_CMAC _ns1__GetOtherInspectQueueByPlateID
{
public:
	std::wstring *PlateID;	/* optional element of type xsd:string */
	int PlateType;	/* required element of type xsd:int */
	std::wstring *QueueType;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique type id SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOtherInspectQueueByPlateID() { _ns1__GetOtherInspectQueueByPlateID::soap_default(NULL); }
	virtual ~_ns1__GetOtherInspectQueueByPlateID() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse
#define SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse (52)
/* ns1:GetOtherInspectQueueByPlateIDResponse */
class SOAP_CMAC _ns1__GetOtherInspectQueueByPlateIDResponse
{
public:
	ns1__RetValue *GetOtherInspectQueueByPlateIDResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique type id SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOtherInspectQueueByPlateIDResponse() { _ns1__GetOtherInspectQueueByPlateIDResponse::soap_default(NULL); }
	virtual ~_ns1__GetOtherInspectQueueByPlateIDResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOtherInspectQueueByDate
#define SOAP_TYPE__ns1__GetOtherInspectQueueByDate (53)
/* ns1:GetOtherInspectQueueByDate */
class SOAP_CMAC _ns1__GetOtherInspectQueueByDate
{
public:
	std::wstring *FromDate;	/* optional element of type xsd:string */
	std::wstring *ToDate;	/* optional element of type xsd:string */
	std::wstring *QueueType;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique type id SOAP_TYPE__ns1__GetOtherInspectQueueByDate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOtherInspectQueueByDate() { _ns1__GetOtherInspectQueueByDate::soap_default(NULL); }
	virtual ~_ns1__GetOtherInspectQueueByDate() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse
#define SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse (54)
/* ns1:GetOtherInspectQueueByDateResponse */
class SOAP_CMAC _ns1__GetOtherInspectQueueByDateResponse
{
public:
	ns1__RetValue *GetOtherInspectQueueByDateResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique type id SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOtherInspectQueueByDateResponse() { _ns1__GetOtherInspectQueueByDateResponse::soap_default(NULL); }
	virtual ~_ns1__GetOtherInspectQueueByDateResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__OBDInspect
#define SOAP_TYPE__ns1__OBDInspect (55)
/* ns1:OBDInspect */
class SOAP_CMAC _ns1__OBDInspect
{
public:
	LONG64 LineID;	/* required element of type xsd:long */
	std::wstring *InspectID;	/* optional element of type xsd:string */
	std::wstring *sOBDData;	/* optional element of type xsd:string */
	std::wstring *Memo;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique type id SOAP_TYPE__ns1__OBDInspect */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__OBDInspect() { _ns1__OBDInspect::soap_default(NULL); }
	virtual ~_ns1__OBDInspect() { }
};
#endif

#ifndef SOAP_TYPE__ns1__OBDInspectResponse
#define SOAP_TYPE__ns1__OBDInspectResponse (56)
/* ns1:OBDInspectResponse */
class SOAP_CMAC _ns1__OBDInspectResponse
{
public:
	ns1__RetValue *OBDInspectResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique type id SOAP_TYPE__ns1__OBDInspectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__OBDInspectResponse() { _ns1__OBDInspectResponse::soap_default(NULL); }
	virtual ~_ns1__OBDInspectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__OBDTXCheck
#define SOAP_TYPE__ns1__OBDTXCheck (57)
/* ns1:OBDTXCheck */
class SOAP_CMAC _ns1__OBDTXCheck
{
public:
	std::wstring *VIN;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique type id SOAP_TYPE__ns1__OBDTXCheck */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__OBDTXCheck() { _ns1__OBDTXCheck::soap_default(NULL); }
	virtual ~_ns1__OBDTXCheck() { }
};
#endif

#ifndef SOAP_TYPE__ns1__OBDTXCheckResponse
#define SOAP_TYPE__ns1__OBDTXCheckResponse (58)
/* ns1:OBDTXCheckResponse */
class SOAP_CMAC _ns1__OBDTXCheckResponse
{
public:
	ns1__RetValue *OBDTXCheckResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:RetValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique type id SOAP_TYPE__ns1__OBDTXCheckResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__OBDTXCheckResponse() { _ns1__OBDTXCheckResponse::soap_default(NULL); }
	virtual ~_ns1__OBDTXCheckResponse() { }
};
#endif

#ifndef SOAP_TYPE___ns1__Sync
#define SOAP_TYPE___ns1__Sync (67)
/* Operation wrapper: */
struct __ns1__Sync
{
public:
	_ns1__Sync *ns1__Sync;	/* optional element of type ns1:Sync */
public:
	int soap_type() const { return 67; } /* = unique type id SOAP_TYPE___ns1__Sync */
};
#endif

#ifndef SOAP_TYPE___ns1__GetInspectQueueByDate
#define SOAP_TYPE___ns1__GetInspectQueueByDate (71)
/* Operation wrapper: */
struct __ns1__GetInspectQueueByDate
{
public:
	_ns1__GetInspectQueueByDate *ns1__GetInspectQueueByDate;	/* optional element of type ns1:GetInspectQueueByDate */
public:
	int soap_type() const { return 71; } /* = unique type id SOAP_TYPE___ns1__GetInspectQueueByDate */
};
#endif

#ifndef SOAP_TYPE___ns1__GetInspectQueueByPlateID
#define SOAP_TYPE___ns1__GetInspectQueueByPlateID (75)
/* Operation wrapper: */
struct __ns1__GetInspectQueueByPlateID
{
public:
	_ns1__GetInspectQueueByPlateID *ns1__GetInspectQueueByPlateID;	/* optional element of type ns1:GetInspectQueueByPlateID */
public:
	int soap_type() const { return 75; } /* = unique type id SOAP_TYPE___ns1__GetInspectQueueByPlateID */
};
#endif

#ifndef SOAP_TYPE___ns1__AbortInspect
#define SOAP_TYPE___ns1__AbortInspect (79)
/* Operation wrapper: */
struct __ns1__AbortInspect
{
public:
	_ns1__AbortInspect *ns1__AbortInspect;	/* optional element of type ns1:AbortInspect */
public:
	int soap_type() const { return 79; } /* = unique type id SOAP_TYPE___ns1__AbortInspect */
};
#endif

#ifndef SOAP_TYPE___ns1__BeginRecord
#define SOAP_TYPE___ns1__BeginRecord (83)
/* Operation wrapper: */
struct __ns1__BeginRecord
{
public:
	_ns1__BeginRecord *ns1__BeginRecord;	/* optional element of type ns1:BeginRecord */
public:
	int soap_type() const { return 83; } /* = unique type id SOAP_TYPE___ns1__BeginRecord */
};
#endif

#ifndef SOAP_TYPE___ns1__EndRecord
#define SOAP_TYPE___ns1__EndRecord (87)
/* Operation wrapper: */
struct __ns1__EndRecord
{
public:
	_ns1__EndRecord *ns1__EndRecord;	/* optional element of type ns1:EndRecord */
public:
	int soap_type() const { return 87; } /* = unique type id SOAP_TYPE___ns1__EndRecord */
};
#endif

#ifndef SOAP_TYPE___ns1__BeginInspect
#define SOAP_TYPE___ns1__BeginInspect (91)
/* Operation wrapper: */
struct __ns1__BeginInspect
{
public:
	_ns1__BeginInspect *ns1__BeginInspect;	/* optional element of type ns1:BeginInspect */
public:
	int soap_type() const { return 91; } /* = unique type id SOAP_TYPE___ns1__BeginInspect */
};
#endif

#ifndef SOAP_TYPE___ns1__GetLimit
#define SOAP_TYPE___ns1__GetLimit (95)
/* Operation wrapper: */
struct __ns1__GetLimit
{
public:
	_ns1__GetLimit *ns1__GetLimit;	/* optional element of type ns1:GetLimit */
public:
	int soap_type() const { return 95; } /* = unique type id SOAP_TYPE___ns1__GetLimit */
};
#endif

#ifndef SOAP_TYPE___ns1__TakePhoto
#define SOAP_TYPE___ns1__TakePhoto (99)
/* Operation wrapper: */
struct __ns1__TakePhoto
{
public:
	_ns1__TakePhoto *ns1__TakePhoto;	/* optional element of type ns1:TakePhoto */
public:
	int soap_type() const { return 99; } /* = unique type id SOAP_TYPE___ns1__TakePhoto */
};
#endif

#ifndef SOAP_TYPE___ns1__WJTakePhoto
#define SOAP_TYPE___ns1__WJTakePhoto (103)
/* Operation wrapper: */
struct __ns1__WJTakePhoto
{
public:
	_ns1__WJTakePhoto *ns1__WJTakePhoto;	/* optional element of type ns1:WJTakePhoto */
public:
	int soap_type() const { return 103; } /* = unique type id SOAP_TYPE___ns1__WJTakePhoto */
};
#endif

#ifndef SOAP_TYPE___ns1__StopInspect
#define SOAP_TYPE___ns1__StopInspect (107)
/* Operation wrapper: */
struct __ns1__StopInspect
{
public:
	_ns1__StopInspect *ns1__StopInspect;	/* optional element of type ns1:StopInspect */
public:
	int soap_type() const { return 107; } /* = unique type id SOAP_TYPE___ns1__StopInspect */
};
#endif

#ifndef SOAP_TYPE___ns1__EndInspect
#define SOAP_TYPE___ns1__EndInspect (111)
/* Operation wrapper: */
struct __ns1__EndInspect
{
public:
	_ns1__EndInspect *ns1__EndInspect;	/* optional element of type ns1:EndInspect */
public:
	int soap_type() const { return 111; } /* = unique type id SOAP_TYPE___ns1__EndInspect */
};
#endif

#ifndef SOAP_TYPE___ns1__UploadSelfTestData
#define SOAP_TYPE___ns1__UploadSelfTestData (115)
/* Operation wrapper: */
struct __ns1__UploadSelfTestData
{
public:
	_ns1__UploadSelfTestData *ns1__UploadSelfTestData;	/* optional element of type ns1:UploadSelfTestData */
public:
	int soap_type() const { return 115; } /* = unique type id SOAP_TYPE___ns1__UploadSelfTestData */
};
#endif

#ifndef SOAP_TYPE___ns1__UploadRealtimeData
#define SOAP_TYPE___ns1__UploadRealtimeData (119)
/* Operation wrapper: */
struct __ns1__UploadRealtimeData
{
public:
	_ns1__UploadRealtimeData *ns1__UploadRealtimeData;	/* optional element of type ns1:UploadRealtimeData */
public:
	int soap_type() const { return 119; } /* = unique type id SOAP_TYPE___ns1__UploadRealtimeData */
};
#endif

#ifndef SOAP_TYPE___ns1__GetInspectionInfo
#define SOAP_TYPE___ns1__GetInspectionInfo (123)
/* Operation wrapper: */
struct __ns1__GetInspectionInfo
{
public:
	_ns1__GetInspectionInfo *ns1__GetInspectionInfo;	/* optional element of type ns1:GetInspectionInfo */
public:
	int soap_type() const { return 123; } /* = unique type id SOAP_TYPE___ns1__GetInspectionInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__BeginCalibrate
#define SOAP_TYPE___ns1__BeginCalibrate (127)
/* Operation wrapper: */
struct __ns1__BeginCalibrate
{
public:
	_ns1__BeginCalibrate *ns1__BeginCalibrate;	/* optional element of type ns1:BeginCalibrate */
public:
	int soap_type() const { return 127; } /* = unique type id SOAP_TYPE___ns1__BeginCalibrate */
};
#endif

#ifndef SOAP_TYPE___ns1__UploadCalibrateData
#define SOAP_TYPE___ns1__UploadCalibrateData (131)
/* Operation wrapper: */
struct __ns1__UploadCalibrateData
{
public:
	_ns1__UploadCalibrateData *ns1__UploadCalibrateData;	/* optional element of type ns1:UploadCalibrateData */
public:
	int soap_type() const { return 131; } /* = unique type id SOAP_TYPE___ns1__UploadCalibrateData */
};
#endif

#ifndef SOAP_TYPE___ns1__EndCalibrate
#define SOAP_TYPE___ns1__EndCalibrate (135)
/* Operation wrapper: */
struct __ns1__EndCalibrate
{
public:
	_ns1__EndCalibrate *ns1__EndCalibrate;	/* optional element of type ns1:EndCalibrate */
public:
	int soap_type() const { return 135; } /* = unique type id SOAP_TYPE___ns1__EndCalibrate */
};
#endif

#ifndef SOAP_TYPE___ns1__TestPhoto
#define SOAP_TYPE___ns1__TestPhoto (139)
/* Operation wrapper: */
struct __ns1__TestPhoto
{
public:
	_ns1__TestPhoto *ns1__TestPhoto;	/* optional element of type ns1:TestPhoto */
public:
	int soap_type() const { return 139; } /* = unique type id SOAP_TYPE___ns1__TestPhoto */
};
#endif

#ifndef SOAP_TYPE___ns1__FuelEvaporationInspect
#define SOAP_TYPE___ns1__FuelEvaporationInspect (143)
/* Operation wrapper: */
struct __ns1__FuelEvaporationInspect
{
public:
	_ns1__FuelEvaporationInspect *ns1__FuelEvaporationInspect;	/* optional element of type ns1:FuelEvaporationInspect */
public:
	int soap_type() const { return 143; } /* = unique type id SOAP_TYPE___ns1__FuelEvaporationInspect */
};
#endif

#ifndef SOAP_TYPE___ns1__GetInspectParams
#define SOAP_TYPE___ns1__GetInspectParams (147)
/* Operation wrapper: */
struct __ns1__GetInspectParams
{
public:
	_ns1__GetInspectParams *ns1__GetInspectParams;	/* optional element of type ns1:GetInspectParams */
public:
	int soap_type() const { return 147; } /* = unique type id SOAP_TYPE___ns1__GetInspectParams */
};
#endif

#ifndef SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID
#define SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID (151)
/* Operation wrapper: */
struct __ns1__GetOtherInspectQueueByPlateID
{
public:
	_ns1__GetOtherInspectQueueByPlateID *ns1__GetOtherInspectQueueByPlateID;	/* optional element of type ns1:GetOtherInspectQueueByPlateID */
public:
	int soap_type() const { return 151; } /* = unique type id SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID */
};
#endif

#ifndef SOAP_TYPE___ns1__GetOtherInspectQueueByDate
#define SOAP_TYPE___ns1__GetOtherInspectQueueByDate (155)
/* Operation wrapper: */
struct __ns1__GetOtherInspectQueueByDate
{
public:
	_ns1__GetOtherInspectQueueByDate *ns1__GetOtherInspectQueueByDate;	/* optional element of type ns1:GetOtherInspectQueueByDate */
public:
	int soap_type() const { return 155; } /* = unique type id SOAP_TYPE___ns1__GetOtherInspectQueueByDate */
};
#endif

#ifndef SOAP_TYPE___ns1__OBDInspect
#define SOAP_TYPE___ns1__OBDInspect (159)
/* Operation wrapper: */
struct __ns1__OBDInspect
{
public:
	_ns1__OBDInspect *ns1__OBDInspect;	/* optional element of type ns1:OBDInspect */
public:
	int soap_type() const { return 159; } /* = unique type id SOAP_TYPE___ns1__OBDInspect */
};
#endif

#ifndef SOAP_TYPE___ns1__OBDTXCheck
#define SOAP_TYPE___ns1__OBDTXCheck (163)
/* Operation wrapper: */
struct __ns1__OBDTXCheck
{
public:
	_ns1__OBDTXCheck *ns1__OBDTXCheck;	/* optional element of type ns1:OBDTXCheck */
public:
	int soap_type() const { return 163; } /* = unique type id SOAP_TYPE___ns1__OBDTXCheck */
};
#endif

#ifndef SOAP_TYPE___ns1__Sync_
#define SOAP_TYPE___ns1__Sync_ (165)
/* Operation wrapper: */
struct __ns1__Sync_
{
public:
	_ns1__Sync *ns1__Sync;	/* optional element of type ns1:Sync */
public:
	int soap_type() const { return 165; } /* = unique type id SOAP_TYPE___ns1__Sync_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetInspectQueueByDate_
#define SOAP_TYPE___ns1__GetInspectQueueByDate_ (167)
/* Operation wrapper: */
struct __ns1__GetInspectQueueByDate_
{
public:
	_ns1__GetInspectQueueByDate *ns1__GetInspectQueueByDate;	/* optional element of type ns1:GetInspectQueueByDate */
public:
	int soap_type() const { return 167; } /* = unique type id SOAP_TYPE___ns1__GetInspectQueueByDate_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetInspectQueueByPlateID_
#define SOAP_TYPE___ns1__GetInspectQueueByPlateID_ (169)
/* Operation wrapper: */
struct __ns1__GetInspectQueueByPlateID_
{
public:
	_ns1__GetInspectQueueByPlateID *ns1__GetInspectQueueByPlateID;	/* optional element of type ns1:GetInspectQueueByPlateID */
public:
	int soap_type() const { return 169; } /* = unique type id SOAP_TYPE___ns1__GetInspectQueueByPlateID_ */
};
#endif

#ifndef SOAP_TYPE___ns1__AbortInspect_
#define SOAP_TYPE___ns1__AbortInspect_ (171)
/* Operation wrapper: */
struct __ns1__AbortInspect_
{
public:
	_ns1__AbortInspect *ns1__AbortInspect;	/* optional element of type ns1:AbortInspect */
public:
	int soap_type() const { return 171; } /* = unique type id SOAP_TYPE___ns1__AbortInspect_ */
};
#endif

#ifndef SOAP_TYPE___ns1__BeginRecord_
#define SOAP_TYPE___ns1__BeginRecord_ (173)
/* Operation wrapper: */
struct __ns1__BeginRecord_
{
public:
	_ns1__BeginRecord *ns1__BeginRecord;	/* optional element of type ns1:BeginRecord */
public:
	int soap_type() const { return 173; } /* = unique type id SOAP_TYPE___ns1__BeginRecord_ */
};
#endif

#ifndef SOAP_TYPE___ns1__EndRecord_
#define SOAP_TYPE___ns1__EndRecord_ (175)
/* Operation wrapper: */
struct __ns1__EndRecord_
{
public:
	_ns1__EndRecord *ns1__EndRecord;	/* optional element of type ns1:EndRecord */
public:
	int soap_type() const { return 175; } /* = unique type id SOAP_TYPE___ns1__EndRecord_ */
};
#endif

#ifndef SOAP_TYPE___ns1__BeginInspect_
#define SOAP_TYPE___ns1__BeginInspect_ (177)
/* Operation wrapper: */
struct __ns1__BeginInspect_
{
public:
	_ns1__BeginInspect *ns1__BeginInspect;	/* optional element of type ns1:BeginInspect */
public:
	int soap_type() const { return 177; } /* = unique type id SOAP_TYPE___ns1__BeginInspect_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetLimit_
#define SOAP_TYPE___ns1__GetLimit_ (179)
/* Operation wrapper: */
struct __ns1__GetLimit_
{
public:
	_ns1__GetLimit *ns1__GetLimit;	/* optional element of type ns1:GetLimit */
public:
	int soap_type() const { return 179; } /* = unique type id SOAP_TYPE___ns1__GetLimit_ */
};
#endif

#ifndef SOAP_TYPE___ns1__TakePhoto_
#define SOAP_TYPE___ns1__TakePhoto_ (181)
/* Operation wrapper: */
struct __ns1__TakePhoto_
{
public:
	_ns1__TakePhoto *ns1__TakePhoto;	/* optional element of type ns1:TakePhoto */
public:
	int soap_type() const { return 181; } /* = unique type id SOAP_TYPE___ns1__TakePhoto_ */
};
#endif

#ifndef SOAP_TYPE___ns1__WJTakePhoto_
#define SOAP_TYPE___ns1__WJTakePhoto_ (183)
/* Operation wrapper: */
struct __ns1__WJTakePhoto_
{
public:
	_ns1__WJTakePhoto *ns1__WJTakePhoto;	/* optional element of type ns1:WJTakePhoto */
public:
	int soap_type() const { return 183; } /* = unique type id SOAP_TYPE___ns1__WJTakePhoto_ */
};
#endif

#ifndef SOAP_TYPE___ns1__StopInspect_
#define SOAP_TYPE___ns1__StopInspect_ (185)
/* Operation wrapper: */
struct __ns1__StopInspect_
{
public:
	_ns1__StopInspect *ns1__StopInspect;	/* optional element of type ns1:StopInspect */
public:
	int soap_type() const { return 185; } /* = unique type id SOAP_TYPE___ns1__StopInspect_ */
};
#endif

#ifndef SOAP_TYPE___ns1__EndInspect_
#define SOAP_TYPE___ns1__EndInspect_ (187)
/* Operation wrapper: */
struct __ns1__EndInspect_
{
public:
	_ns1__EndInspect *ns1__EndInspect;	/* optional element of type ns1:EndInspect */
public:
	int soap_type() const { return 187; } /* = unique type id SOAP_TYPE___ns1__EndInspect_ */
};
#endif

#ifndef SOAP_TYPE___ns1__UploadSelfTestData_
#define SOAP_TYPE___ns1__UploadSelfTestData_ (189)
/* Operation wrapper: */
struct __ns1__UploadSelfTestData_
{
public:
	_ns1__UploadSelfTestData *ns1__UploadSelfTestData;	/* optional element of type ns1:UploadSelfTestData */
public:
	int soap_type() const { return 189; } /* = unique type id SOAP_TYPE___ns1__UploadSelfTestData_ */
};
#endif

#ifndef SOAP_TYPE___ns1__UploadRealtimeData_
#define SOAP_TYPE___ns1__UploadRealtimeData_ (191)
/* Operation wrapper: */
struct __ns1__UploadRealtimeData_
{
public:
	_ns1__UploadRealtimeData *ns1__UploadRealtimeData;	/* optional element of type ns1:UploadRealtimeData */
public:
	int soap_type() const { return 191; } /* = unique type id SOAP_TYPE___ns1__UploadRealtimeData_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetInspectionInfo_
#define SOAP_TYPE___ns1__GetInspectionInfo_ (193)
/* Operation wrapper: */
struct __ns1__GetInspectionInfo_
{
public:
	_ns1__GetInspectionInfo *ns1__GetInspectionInfo;	/* optional element of type ns1:GetInspectionInfo */
public:
	int soap_type() const { return 193; } /* = unique type id SOAP_TYPE___ns1__GetInspectionInfo_ */
};
#endif

#ifndef SOAP_TYPE___ns1__BeginCalibrate_
#define SOAP_TYPE___ns1__BeginCalibrate_ (195)
/* Operation wrapper: */
struct __ns1__BeginCalibrate_
{
public:
	_ns1__BeginCalibrate *ns1__BeginCalibrate;	/* optional element of type ns1:BeginCalibrate */
public:
	int soap_type() const { return 195; } /* = unique type id SOAP_TYPE___ns1__BeginCalibrate_ */
};
#endif

#ifndef SOAP_TYPE___ns1__UploadCalibrateData_
#define SOAP_TYPE___ns1__UploadCalibrateData_ (197)
/* Operation wrapper: */
struct __ns1__UploadCalibrateData_
{
public:
	_ns1__UploadCalibrateData *ns1__UploadCalibrateData;	/* optional element of type ns1:UploadCalibrateData */
public:
	int soap_type() const { return 197; } /* = unique type id SOAP_TYPE___ns1__UploadCalibrateData_ */
};
#endif

#ifndef SOAP_TYPE___ns1__EndCalibrate_
#define SOAP_TYPE___ns1__EndCalibrate_ (199)
/* Operation wrapper: */
struct __ns1__EndCalibrate_
{
public:
	_ns1__EndCalibrate *ns1__EndCalibrate;	/* optional element of type ns1:EndCalibrate */
public:
	int soap_type() const { return 199; } /* = unique type id SOAP_TYPE___ns1__EndCalibrate_ */
};
#endif

#ifndef SOAP_TYPE___ns1__TestPhoto_
#define SOAP_TYPE___ns1__TestPhoto_ (201)
/* Operation wrapper: */
struct __ns1__TestPhoto_
{
public:
	_ns1__TestPhoto *ns1__TestPhoto;	/* optional element of type ns1:TestPhoto */
public:
	int soap_type() const { return 201; } /* = unique type id SOAP_TYPE___ns1__TestPhoto_ */
};
#endif

#ifndef SOAP_TYPE___ns1__FuelEvaporationInspect_
#define SOAP_TYPE___ns1__FuelEvaporationInspect_ (203)
/* Operation wrapper: */
struct __ns1__FuelEvaporationInspect_
{
public:
	_ns1__FuelEvaporationInspect *ns1__FuelEvaporationInspect;	/* optional element of type ns1:FuelEvaporationInspect */
public:
	int soap_type() const { return 203; } /* = unique type id SOAP_TYPE___ns1__FuelEvaporationInspect_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetInspectParams_
#define SOAP_TYPE___ns1__GetInspectParams_ (205)
/* Operation wrapper: */
struct __ns1__GetInspectParams_
{
public:
	_ns1__GetInspectParams *ns1__GetInspectParams;	/* optional element of type ns1:GetInspectParams */
public:
	int soap_type() const { return 205; } /* = unique type id SOAP_TYPE___ns1__GetInspectParams_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID_
#define SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID_ (207)
/* Operation wrapper: */
struct __ns1__GetOtherInspectQueueByPlateID_
{
public:
	_ns1__GetOtherInspectQueueByPlateID *ns1__GetOtherInspectQueueByPlateID;	/* optional element of type ns1:GetOtherInspectQueueByPlateID */
public:
	int soap_type() const { return 207; } /* = unique type id SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetOtherInspectQueueByDate_
#define SOAP_TYPE___ns1__GetOtherInspectQueueByDate_ (209)
/* Operation wrapper: */
struct __ns1__GetOtherInspectQueueByDate_
{
public:
	_ns1__GetOtherInspectQueueByDate *ns1__GetOtherInspectQueueByDate;	/* optional element of type ns1:GetOtherInspectQueueByDate */
public:
	int soap_type() const { return 209; } /* = unique type id SOAP_TYPE___ns1__GetOtherInspectQueueByDate_ */
};
#endif

#ifndef SOAP_TYPE___ns1__OBDInspect_
#define SOAP_TYPE___ns1__OBDInspect_ (211)
/* Operation wrapper: */
struct __ns1__OBDInspect_
{
public:
	_ns1__OBDInspect *ns1__OBDInspect;	/* optional element of type ns1:OBDInspect */
public:
	int soap_type() const { return 211; } /* = unique type id SOAP_TYPE___ns1__OBDInspect_ */
};
#endif

#ifndef SOAP_TYPE___ns1__OBDTXCheck_
#define SOAP_TYPE___ns1__OBDTXCheck_ (213)
/* Operation wrapper: */
struct __ns1__OBDTXCheck_
{
public:
	_ns1__OBDTXCheck *ns1__OBDTXCheck;	/* optional element of type ns1:OBDTXCheck */
public:
	int soap_type() const { return 213; } /* = unique type id SOAP_TYPE___ns1__OBDTXCheck_ */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (214)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 214; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (215)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 215; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (217)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 217; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (220)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 220; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (221)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 221; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
