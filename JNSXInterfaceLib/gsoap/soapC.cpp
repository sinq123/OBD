/* soapC.cpp
   Generated by gSOAP 2.8.21 from service[1].h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.21 2019-11-16 05:46:10 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__RetValue:
		return soap_in_ns1__RetValue(soap, NULL, NULL, "ns1:RetValue");
	case SOAP_TYPE_PointerTo_ns1__OBDTXCheck:
		return soap_in_PointerTo_ns1__OBDTXCheck(soap, NULL, NULL, "ns1:OBDTXCheck");
	case SOAP_TYPE_PointerTo_ns1__OBDInspect:
		return soap_in_PointerTo_ns1__OBDInspect(soap, NULL, NULL, "ns1:OBDInspect");
	case SOAP_TYPE_PointerTo_ns1__GetOtherInspectQueueByDate:
		return soap_in_PointerTo_ns1__GetOtherInspectQueueByDate(soap, NULL, NULL, "ns1:GetOtherInspectQueueByDate");
	case SOAP_TYPE_PointerTo_ns1__GetOtherInspectQueueByPlateID:
		return soap_in_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, NULL, NULL, "ns1:GetOtherInspectQueueByPlateID");
	case SOAP_TYPE_PointerTo_ns1__GetInspectParams:
		return soap_in_PointerTo_ns1__GetInspectParams(soap, NULL, NULL, "ns1:GetInspectParams");
	case SOAP_TYPE_PointerTo_ns1__FuelEvaporationInspect:
		return soap_in_PointerTo_ns1__FuelEvaporationInspect(soap, NULL, NULL, "ns1:FuelEvaporationInspect");
	case SOAP_TYPE_PointerTo_ns1__TestPhoto:
		return soap_in_PointerTo_ns1__TestPhoto(soap, NULL, NULL, "ns1:TestPhoto");
	case SOAP_TYPE_PointerTo_ns1__EndCalibrate:
		return soap_in_PointerTo_ns1__EndCalibrate(soap, NULL, NULL, "ns1:EndCalibrate");
	case SOAP_TYPE_PointerTo_ns1__UploadCalibrateData:
		return soap_in_PointerTo_ns1__UploadCalibrateData(soap, NULL, NULL, "ns1:UploadCalibrateData");
	case SOAP_TYPE_PointerTo_ns1__BeginCalibrate:
		return soap_in_PointerTo_ns1__BeginCalibrate(soap, NULL, NULL, "ns1:BeginCalibrate");
	case SOAP_TYPE_PointerTo_ns1__GetInspectionInfo:
		return soap_in_PointerTo_ns1__GetInspectionInfo(soap, NULL, NULL, "ns1:GetInspectionInfo");
	case SOAP_TYPE_PointerTo_ns1__UploadRealtimeData:
		return soap_in_PointerTo_ns1__UploadRealtimeData(soap, NULL, NULL, "ns1:UploadRealtimeData");
	case SOAP_TYPE_PointerTo_ns1__UploadSelfTestData:
		return soap_in_PointerTo_ns1__UploadSelfTestData(soap, NULL, NULL, "ns1:UploadSelfTestData");
	case SOAP_TYPE_PointerTo_ns1__EndInspect:
		return soap_in_PointerTo_ns1__EndInspect(soap, NULL, NULL, "ns1:EndInspect");
	case SOAP_TYPE_PointerTo_ns1__StopInspect:
		return soap_in_PointerTo_ns1__StopInspect(soap, NULL, NULL, "ns1:StopInspect");
	case SOAP_TYPE_PointerTo_ns1__WJTakePhoto:
		return soap_in_PointerTo_ns1__WJTakePhoto(soap, NULL, NULL, "ns1:WJTakePhoto");
	case SOAP_TYPE_PointerTo_ns1__TakePhoto:
		return soap_in_PointerTo_ns1__TakePhoto(soap, NULL, NULL, "ns1:TakePhoto");
	case SOAP_TYPE_PointerTo_ns1__GetLimit:
		return soap_in_PointerTo_ns1__GetLimit(soap, NULL, NULL, "ns1:GetLimit");
	case SOAP_TYPE_PointerTo_ns1__BeginInspect:
		return soap_in_PointerTo_ns1__BeginInspect(soap, NULL, NULL, "ns1:BeginInspect");
	case SOAP_TYPE_PointerTo_ns1__EndRecord:
		return soap_in_PointerTo_ns1__EndRecord(soap, NULL, NULL, "ns1:EndRecord");
	case SOAP_TYPE_PointerTo_ns1__BeginRecord:
		return soap_in_PointerTo_ns1__BeginRecord(soap, NULL, NULL, "ns1:BeginRecord");
	case SOAP_TYPE_PointerTo_ns1__AbortInspect:
		return soap_in_PointerTo_ns1__AbortInspect(soap, NULL, NULL, "ns1:AbortInspect");
	case SOAP_TYPE_PointerTo_ns1__GetInspectQueueByPlateID:
		return soap_in_PointerTo_ns1__GetInspectQueueByPlateID(soap, NULL, NULL, "ns1:GetInspectQueueByPlateID");
	case SOAP_TYPE_PointerTo_ns1__GetInspectQueueByDate:
		return soap_in_PointerTo_ns1__GetInspectQueueByDate(soap, NULL, NULL, "ns1:GetInspectQueueByDate");
	case SOAP_TYPE_PointerTo_ns1__Sync:
		return soap_in_PointerTo_ns1__Sync(soap, NULL, NULL, "ns1:Sync");
	case SOAP_TYPE_PointerTons1__RetValue:
		return soap_in_PointerTons1__RetValue(soap, NULL, NULL, "ns1:RetValue");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_in_PointerTostd__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RetValue"))
		{	*type = SOAP_TYPE_ns1__RetValue;
			return soap_in_ns1__RetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:OBDTXCheckResponse"))
		{	*type = SOAP_TYPE__ns1__OBDTXCheckResponse;
			return soap_in__ns1__OBDTXCheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OBDTXCheck"))
		{	*type = SOAP_TYPE__ns1__OBDTXCheck;
			return soap_in__ns1__OBDTXCheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OBDInspectResponse"))
		{	*type = SOAP_TYPE__ns1__OBDInspectResponse;
			return soap_in__ns1__OBDInspectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OBDInspect"))
		{	*type = SOAP_TYPE__ns1__OBDInspect;
			return soap_in__ns1__OBDInspect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOtherInspectQueueByDateResponse"))
		{	*type = SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse;
			return soap_in__ns1__GetOtherInspectQueueByDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOtherInspectQueueByDate"))
		{	*type = SOAP_TYPE__ns1__GetOtherInspectQueueByDate;
			return soap_in__ns1__GetOtherInspectQueueByDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOtherInspectQueueByPlateIDResponse"))
		{	*type = SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse;
			return soap_in__ns1__GetOtherInspectQueueByPlateIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOtherInspectQueueByPlateID"))
		{	*type = SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID;
			return soap_in__ns1__GetOtherInspectQueueByPlateID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInspectParamsResponse"))
		{	*type = SOAP_TYPE__ns1__GetInspectParamsResponse;
			return soap_in__ns1__GetInspectParamsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInspectParams"))
		{	*type = SOAP_TYPE__ns1__GetInspectParams;
			return soap_in__ns1__GetInspectParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FuelEvaporationInspectResponse"))
		{	*type = SOAP_TYPE__ns1__FuelEvaporationInspectResponse;
			return soap_in__ns1__FuelEvaporationInspectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FuelEvaporationInspect"))
		{	*type = SOAP_TYPE__ns1__FuelEvaporationInspect;
			return soap_in__ns1__FuelEvaporationInspect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TestPhotoResponse"))
		{	*type = SOAP_TYPE__ns1__TestPhotoResponse;
			return soap_in__ns1__TestPhotoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TestPhoto"))
		{	*type = SOAP_TYPE__ns1__TestPhoto;
			return soap_in__ns1__TestPhoto(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndCalibrateResponse"))
		{	*type = SOAP_TYPE__ns1__EndCalibrateResponse;
			return soap_in__ns1__EndCalibrateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndCalibrate"))
		{	*type = SOAP_TYPE__ns1__EndCalibrate;
			return soap_in__ns1__EndCalibrate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadCalibrateDataResponse"))
		{	*type = SOAP_TYPE__ns1__UploadCalibrateDataResponse;
			return soap_in__ns1__UploadCalibrateDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadCalibrateData"))
		{	*type = SOAP_TYPE__ns1__UploadCalibrateData;
			return soap_in__ns1__UploadCalibrateData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BeginCalibrateResponse"))
		{	*type = SOAP_TYPE__ns1__BeginCalibrateResponse;
			return soap_in__ns1__BeginCalibrateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BeginCalibrate"))
		{	*type = SOAP_TYPE__ns1__BeginCalibrate;
			return soap_in__ns1__BeginCalibrate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInspectionInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetInspectionInfoResponse;
			return soap_in__ns1__GetInspectionInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInspectionInfo"))
		{	*type = SOAP_TYPE__ns1__GetInspectionInfo;
			return soap_in__ns1__GetInspectionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadRealtimeDataResponse"))
		{	*type = SOAP_TYPE__ns1__UploadRealtimeDataResponse;
			return soap_in__ns1__UploadRealtimeDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadRealtimeData"))
		{	*type = SOAP_TYPE__ns1__UploadRealtimeData;
			return soap_in__ns1__UploadRealtimeData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadSelfTestDataResponse"))
		{	*type = SOAP_TYPE__ns1__UploadSelfTestDataResponse;
			return soap_in__ns1__UploadSelfTestDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadSelfTestData"))
		{	*type = SOAP_TYPE__ns1__UploadSelfTestData;
			return soap_in__ns1__UploadSelfTestData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndInspectResponse"))
		{	*type = SOAP_TYPE__ns1__EndInspectResponse;
			return soap_in__ns1__EndInspectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndInspect"))
		{	*type = SOAP_TYPE__ns1__EndInspect;
			return soap_in__ns1__EndInspect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopInspectResponse"))
		{	*type = SOAP_TYPE__ns1__StopInspectResponse;
			return soap_in__ns1__StopInspectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopInspect"))
		{	*type = SOAP_TYPE__ns1__StopInspect;
			return soap_in__ns1__StopInspect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WJTakePhotoResponse"))
		{	*type = SOAP_TYPE__ns1__WJTakePhotoResponse;
			return soap_in__ns1__WJTakePhotoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WJTakePhoto"))
		{	*type = SOAP_TYPE__ns1__WJTakePhoto;
			return soap_in__ns1__WJTakePhoto(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TakePhotoResponse"))
		{	*type = SOAP_TYPE__ns1__TakePhotoResponse;
			return soap_in__ns1__TakePhotoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TakePhoto"))
		{	*type = SOAP_TYPE__ns1__TakePhoto;
			return soap_in__ns1__TakePhoto(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLimitResponse"))
		{	*type = SOAP_TYPE__ns1__GetLimitResponse;
			return soap_in__ns1__GetLimitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLimit"))
		{	*type = SOAP_TYPE__ns1__GetLimit;
			return soap_in__ns1__GetLimit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BeginInspectResponse"))
		{	*type = SOAP_TYPE__ns1__BeginInspectResponse;
			return soap_in__ns1__BeginInspectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BeginInspect"))
		{	*type = SOAP_TYPE__ns1__BeginInspect;
			return soap_in__ns1__BeginInspect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndRecordResponse"))
		{	*type = SOAP_TYPE__ns1__EndRecordResponse;
			return soap_in__ns1__EndRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndRecord"))
		{	*type = SOAP_TYPE__ns1__EndRecord;
			return soap_in__ns1__EndRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BeginRecordResponse"))
		{	*type = SOAP_TYPE__ns1__BeginRecordResponse;
			return soap_in__ns1__BeginRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BeginRecord"))
		{	*type = SOAP_TYPE__ns1__BeginRecord;
			return soap_in__ns1__BeginRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AbortInspectResponse"))
		{	*type = SOAP_TYPE__ns1__AbortInspectResponse;
			return soap_in__ns1__AbortInspectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AbortInspect"))
		{	*type = SOAP_TYPE__ns1__AbortInspect;
			return soap_in__ns1__AbortInspect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInspectQueueByPlateIDResponse"))
		{	*type = SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse;
			return soap_in__ns1__GetInspectQueueByPlateIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInspectQueueByPlateID"))
		{	*type = SOAP_TYPE__ns1__GetInspectQueueByPlateID;
			return soap_in__ns1__GetInspectQueueByPlateID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInspectQueueByDateResponse"))
		{	*type = SOAP_TYPE__ns1__GetInspectQueueByDateResponse;
			return soap_in__ns1__GetInspectQueueByDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInspectQueueByDate"))
		{	*type = SOAP_TYPE__ns1__GetInspectQueueByDate;
			return soap_in__ns1__GetInspectQueueByDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncResponse"))
		{	*type = SOAP_TYPE__ns1__SyncResponse;
			return soap_in__ns1__SyncResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Sync"))
		{	*type = SOAP_TYPE__ns1__Sync;
			return soap_in__ns1__Sync(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE__ns1__OBDTXCheckResponse:
		return ((_ns1__OBDTXCheckResponse *)ptr)->soap_out(soap, "ns1:OBDTXCheckResponse", id, NULL);
	case SOAP_TYPE__ns1__OBDTXCheck:
		return ((_ns1__OBDTXCheck *)ptr)->soap_out(soap, "ns1:OBDTXCheck", id, NULL);
	case SOAP_TYPE__ns1__OBDInspectResponse:
		return ((_ns1__OBDInspectResponse *)ptr)->soap_out(soap, "ns1:OBDInspectResponse", id, NULL);
	case SOAP_TYPE__ns1__OBDInspect:
		return ((_ns1__OBDInspect *)ptr)->soap_out(soap, "ns1:OBDInspect", id, NULL);
	case SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse:
		return ((_ns1__GetOtherInspectQueueByDateResponse *)ptr)->soap_out(soap, "ns1:GetOtherInspectQueueByDateResponse", id, NULL);
	case SOAP_TYPE__ns1__GetOtherInspectQueueByDate:
		return ((_ns1__GetOtherInspectQueueByDate *)ptr)->soap_out(soap, "ns1:GetOtherInspectQueueByDate", id, NULL);
	case SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse:
		return ((_ns1__GetOtherInspectQueueByPlateIDResponse *)ptr)->soap_out(soap, "ns1:GetOtherInspectQueueByPlateIDResponse", id, NULL);
	case SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID:
		return ((_ns1__GetOtherInspectQueueByPlateID *)ptr)->soap_out(soap, "ns1:GetOtherInspectQueueByPlateID", id, NULL);
	case SOAP_TYPE__ns1__GetInspectParamsResponse:
		return ((_ns1__GetInspectParamsResponse *)ptr)->soap_out(soap, "ns1:GetInspectParamsResponse", id, NULL);
	case SOAP_TYPE__ns1__GetInspectParams:
		return ((_ns1__GetInspectParams *)ptr)->soap_out(soap, "ns1:GetInspectParams", id, NULL);
	case SOAP_TYPE__ns1__FuelEvaporationInspectResponse:
		return ((_ns1__FuelEvaporationInspectResponse *)ptr)->soap_out(soap, "ns1:FuelEvaporationInspectResponse", id, NULL);
	case SOAP_TYPE__ns1__FuelEvaporationInspect:
		return ((_ns1__FuelEvaporationInspect *)ptr)->soap_out(soap, "ns1:FuelEvaporationInspect", id, NULL);
	case SOAP_TYPE__ns1__TestPhotoResponse:
		return ((_ns1__TestPhotoResponse *)ptr)->soap_out(soap, "ns1:TestPhotoResponse", id, NULL);
	case SOAP_TYPE__ns1__TestPhoto:
		return ((_ns1__TestPhoto *)ptr)->soap_out(soap, "ns1:TestPhoto", id, NULL);
	case SOAP_TYPE__ns1__EndCalibrateResponse:
		return ((_ns1__EndCalibrateResponse *)ptr)->soap_out(soap, "ns1:EndCalibrateResponse", id, NULL);
	case SOAP_TYPE__ns1__EndCalibrate:
		return ((_ns1__EndCalibrate *)ptr)->soap_out(soap, "ns1:EndCalibrate", id, NULL);
	case SOAP_TYPE__ns1__UploadCalibrateDataResponse:
		return ((_ns1__UploadCalibrateDataResponse *)ptr)->soap_out(soap, "ns1:UploadCalibrateDataResponse", id, NULL);
	case SOAP_TYPE__ns1__UploadCalibrateData:
		return ((_ns1__UploadCalibrateData *)ptr)->soap_out(soap, "ns1:UploadCalibrateData", id, NULL);
	case SOAP_TYPE__ns1__BeginCalibrateResponse:
		return ((_ns1__BeginCalibrateResponse *)ptr)->soap_out(soap, "ns1:BeginCalibrateResponse", id, NULL);
	case SOAP_TYPE__ns1__BeginCalibrate:
		return ((_ns1__BeginCalibrate *)ptr)->soap_out(soap, "ns1:BeginCalibrate", id, NULL);
	case SOAP_TYPE__ns1__GetInspectionInfoResponse:
		return ((_ns1__GetInspectionInfoResponse *)ptr)->soap_out(soap, "ns1:GetInspectionInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetInspectionInfo:
		return ((_ns1__GetInspectionInfo *)ptr)->soap_out(soap, "ns1:GetInspectionInfo", id, NULL);
	case SOAP_TYPE__ns1__UploadRealtimeDataResponse:
		return ((_ns1__UploadRealtimeDataResponse *)ptr)->soap_out(soap, "ns1:UploadRealtimeDataResponse", id, NULL);
	case SOAP_TYPE__ns1__UploadRealtimeData:
		return ((_ns1__UploadRealtimeData *)ptr)->soap_out(soap, "ns1:UploadRealtimeData", id, NULL);
	case SOAP_TYPE__ns1__UploadSelfTestDataResponse:
		return ((_ns1__UploadSelfTestDataResponse *)ptr)->soap_out(soap, "ns1:UploadSelfTestDataResponse", id, NULL);
	case SOAP_TYPE__ns1__UploadSelfTestData:
		return ((_ns1__UploadSelfTestData *)ptr)->soap_out(soap, "ns1:UploadSelfTestData", id, NULL);
	case SOAP_TYPE__ns1__EndInspectResponse:
		return ((_ns1__EndInspectResponse *)ptr)->soap_out(soap, "ns1:EndInspectResponse", id, NULL);
	case SOAP_TYPE__ns1__EndInspect:
		return ((_ns1__EndInspect *)ptr)->soap_out(soap, "ns1:EndInspect", id, NULL);
	case SOAP_TYPE__ns1__StopInspectResponse:
		return ((_ns1__StopInspectResponse *)ptr)->soap_out(soap, "ns1:StopInspectResponse", id, NULL);
	case SOAP_TYPE__ns1__StopInspect:
		return ((_ns1__StopInspect *)ptr)->soap_out(soap, "ns1:StopInspect", id, NULL);
	case SOAP_TYPE__ns1__WJTakePhotoResponse:
		return ((_ns1__WJTakePhotoResponse *)ptr)->soap_out(soap, "ns1:WJTakePhotoResponse", id, NULL);
	case SOAP_TYPE__ns1__WJTakePhoto:
		return ((_ns1__WJTakePhoto *)ptr)->soap_out(soap, "ns1:WJTakePhoto", id, NULL);
	case SOAP_TYPE__ns1__TakePhotoResponse:
		return ((_ns1__TakePhotoResponse *)ptr)->soap_out(soap, "ns1:TakePhotoResponse", id, NULL);
	case SOAP_TYPE__ns1__TakePhoto:
		return ((_ns1__TakePhoto *)ptr)->soap_out(soap, "ns1:TakePhoto", id, NULL);
	case SOAP_TYPE__ns1__GetLimitResponse:
		return ((_ns1__GetLimitResponse *)ptr)->soap_out(soap, "ns1:GetLimitResponse", id, NULL);
	case SOAP_TYPE__ns1__GetLimit:
		return ((_ns1__GetLimit *)ptr)->soap_out(soap, "ns1:GetLimit", id, NULL);
	case SOAP_TYPE__ns1__BeginInspectResponse:
		return ((_ns1__BeginInspectResponse *)ptr)->soap_out(soap, "ns1:BeginInspectResponse", id, NULL);
	case SOAP_TYPE__ns1__BeginInspect:
		return ((_ns1__BeginInspect *)ptr)->soap_out(soap, "ns1:BeginInspect", id, NULL);
	case SOAP_TYPE__ns1__EndRecordResponse:
		return ((_ns1__EndRecordResponse *)ptr)->soap_out(soap, "ns1:EndRecordResponse", id, NULL);
	case SOAP_TYPE__ns1__EndRecord:
		return ((_ns1__EndRecord *)ptr)->soap_out(soap, "ns1:EndRecord", id, NULL);
	case SOAP_TYPE__ns1__BeginRecordResponse:
		return ((_ns1__BeginRecordResponse *)ptr)->soap_out(soap, "ns1:BeginRecordResponse", id, NULL);
	case SOAP_TYPE__ns1__BeginRecord:
		return ((_ns1__BeginRecord *)ptr)->soap_out(soap, "ns1:BeginRecord", id, NULL);
	case SOAP_TYPE__ns1__AbortInspectResponse:
		return ((_ns1__AbortInspectResponse *)ptr)->soap_out(soap, "ns1:AbortInspectResponse", id, NULL);
	case SOAP_TYPE__ns1__AbortInspect:
		return ((_ns1__AbortInspect *)ptr)->soap_out(soap, "ns1:AbortInspect", id, NULL);
	case SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse:
		return ((_ns1__GetInspectQueueByPlateIDResponse *)ptr)->soap_out(soap, "ns1:GetInspectQueueByPlateIDResponse", id, NULL);
	case SOAP_TYPE__ns1__GetInspectQueueByPlateID:
		return ((_ns1__GetInspectQueueByPlateID *)ptr)->soap_out(soap, "ns1:GetInspectQueueByPlateID", id, NULL);
	case SOAP_TYPE__ns1__GetInspectQueueByDateResponse:
		return ((_ns1__GetInspectQueueByDateResponse *)ptr)->soap_out(soap, "ns1:GetInspectQueueByDateResponse", id, NULL);
	case SOAP_TYPE__ns1__GetInspectQueueByDate:
		return ((_ns1__GetInspectQueueByDate *)ptr)->soap_out(soap, "ns1:GetInspectQueueByDate", id, NULL);
	case SOAP_TYPE__ns1__SyncResponse:
		return ((_ns1__SyncResponse *)ptr)->soap_out(soap, "ns1:SyncResponse", id, NULL);
	case SOAP_TYPE__ns1__Sync:
		return ((_ns1__Sync *)ptr)->soap_out(soap, "ns1:Sync", id, NULL);
	case SOAP_TYPE_ns1__RetValue:
		return ((ns1__RetValue *)ptr)->soap_out(soap, tag, id, "ns1:RetValue");
	case SOAP_TYPE_PointerTo_ns1__OBDTXCheck:
		return soap_out_PointerTo_ns1__OBDTXCheck(soap, tag, id, (_ns1__OBDTXCheck *const*)ptr, "ns1:OBDTXCheck");
	case SOAP_TYPE_PointerTo_ns1__OBDInspect:
		return soap_out_PointerTo_ns1__OBDInspect(soap, tag, id, (_ns1__OBDInspect *const*)ptr, "ns1:OBDInspect");
	case SOAP_TYPE_PointerTo_ns1__GetOtherInspectQueueByDate:
		return soap_out_PointerTo_ns1__GetOtherInspectQueueByDate(soap, tag, id, (_ns1__GetOtherInspectQueueByDate *const*)ptr, "ns1:GetOtherInspectQueueByDate");
	case SOAP_TYPE_PointerTo_ns1__GetOtherInspectQueueByPlateID:
		return soap_out_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, tag, id, (_ns1__GetOtherInspectQueueByPlateID *const*)ptr, "ns1:GetOtherInspectQueueByPlateID");
	case SOAP_TYPE_PointerTo_ns1__GetInspectParams:
		return soap_out_PointerTo_ns1__GetInspectParams(soap, tag, id, (_ns1__GetInspectParams *const*)ptr, "ns1:GetInspectParams");
	case SOAP_TYPE_PointerTo_ns1__FuelEvaporationInspect:
		return soap_out_PointerTo_ns1__FuelEvaporationInspect(soap, tag, id, (_ns1__FuelEvaporationInspect *const*)ptr, "ns1:FuelEvaporationInspect");
	case SOAP_TYPE_PointerTo_ns1__TestPhoto:
		return soap_out_PointerTo_ns1__TestPhoto(soap, tag, id, (_ns1__TestPhoto *const*)ptr, "ns1:TestPhoto");
	case SOAP_TYPE_PointerTo_ns1__EndCalibrate:
		return soap_out_PointerTo_ns1__EndCalibrate(soap, tag, id, (_ns1__EndCalibrate *const*)ptr, "ns1:EndCalibrate");
	case SOAP_TYPE_PointerTo_ns1__UploadCalibrateData:
		return soap_out_PointerTo_ns1__UploadCalibrateData(soap, tag, id, (_ns1__UploadCalibrateData *const*)ptr, "ns1:UploadCalibrateData");
	case SOAP_TYPE_PointerTo_ns1__BeginCalibrate:
		return soap_out_PointerTo_ns1__BeginCalibrate(soap, tag, id, (_ns1__BeginCalibrate *const*)ptr, "ns1:BeginCalibrate");
	case SOAP_TYPE_PointerTo_ns1__GetInspectionInfo:
		return soap_out_PointerTo_ns1__GetInspectionInfo(soap, tag, id, (_ns1__GetInspectionInfo *const*)ptr, "ns1:GetInspectionInfo");
	case SOAP_TYPE_PointerTo_ns1__UploadRealtimeData:
		return soap_out_PointerTo_ns1__UploadRealtimeData(soap, tag, id, (_ns1__UploadRealtimeData *const*)ptr, "ns1:UploadRealtimeData");
	case SOAP_TYPE_PointerTo_ns1__UploadSelfTestData:
		return soap_out_PointerTo_ns1__UploadSelfTestData(soap, tag, id, (_ns1__UploadSelfTestData *const*)ptr, "ns1:UploadSelfTestData");
	case SOAP_TYPE_PointerTo_ns1__EndInspect:
		return soap_out_PointerTo_ns1__EndInspect(soap, tag, id, (_ns1__EndInspect *const*)ptr, "ns1:EndInspect");
	case SOAP_TYPE_PointerTo_ns1__StopInspect:
		return soap_out_PointerTo_ns1__StopInspect(soap, tag, id, (_ns1__StopInspect *const*)ptr, "ns1:StopInspect");
	case SOAP_TYPE_PointerTo_ns1__WJTakePhoto:
		return soap_out_PointerTo_ns1__WJTakePhoto(soap, tag, id, (_ns1__WJTakePhoto *const*)ptr, "ns1:WJTakePhoto");
	case SOAP_TYPE_PointerTo_ns1__TakePhoto:
		return soap_out_PointerTo_ns1__TakePhoto(soap, tag, id, (_ns1__TakePhoto *const*)ptr, "ns1:TakePhoto");
	case SOAP_TYPE_PointerTo_ns1__GetLimit:
		return soap_out_PointerTo_ns1__GetLimit(soap, tag, id, (_ns1__GetLimit *const*)ptr, "ns1:GetLimit");
	case SOAP_TYPE_PointerTo_ns1__BeginInspect:
		return soap_out_PointerTo_ns1__BeginInspect(soap, tag, id, (_ns1__BeginInspect *const*)ptr, "ns1:BeginInspect");
	case SOAP_TYPE_PointerTo_ns1__EndRecord:
		return soap_out_PointerTo_ns1__EndRecord(soap, tag, id, (_ns1__EndRecord *const*)ptr, "ns1:EndRecord");
	case SOAP_TYPE_PointerTo_ns1__BeginRecord:
		return soap_out_PointerTo_ns1__BeginRecord(soap, tag, id, (_ns1__BeginRecord *const*)ptr, "ns1:BeginRecord");
	case SOAP_TYPE_PointerTo_ns1__AbortInspect:
		return soap_out_PointerTo_ns1__AbortInspect(soap, tag, id, (_ns1__AbortInspect *const*)ptr, "ns1:AbortInspect");
	case SOAP_TYPE_PointerTo_ns1__GetInspectQueueByPlateID:
		return soap_out_PointerTo_ns1__GetInspectQueueByPlateID(soap, tag, id, (_ns1__GetInspectQueueByPlateID *const*)ptr, "ns1:GetInspectQueueByPlateID");
	case SOAP_TYPE_PointerTo_ns1__GetInspectQueueByDate:
		return soap_out_PointerTo_ns1__GetInspectQueueByDate(soap, tag, id, (_ns1__GetInspectQueueByDate *const*)ptr, "ns1:GetInspectQueueByDate");
	case SOAP_TYPE_PointerTo_ns1__Sync:
		return soap_out_PointerTo_ns1__Sync(soap, tag, id, (_ns1__Sync *const*)ptr, "ns1:Sync");
	case SOAP_TYPE_PointerTons1__RetValue:
		return soap_out_PointerTons1__RetValue(soap, tag, id, (ns1__RetValue *const*)ptr, "ns1:RetValue");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_out_PointerTostd__wstring(soap, tag, id, (std::wstring *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE__ns1__OBDTXCheckResponse:
		((_ns1__OBDTXCheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OBDTXCheck:
		((_ns1__OBDTXCheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OBDInspectResponse:
		((_ns1__OBDInspectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OBDInspect:
		((_ns1__OBDInspect *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse:
		((_ns1__GetOtherInspectQueueByDateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOtherInspectQueueByDate:
		((_ns1__GetOtherInspectQueueByDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse:
		((_ns1__GetOtherInspectQueueByPlateIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID:
		((_ns1__GetOtherInspectQueueByPlateID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInspectParamsResponse:
		((_ns1__GetInspectParamsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInspectParams:
		((_ns1__GetInspectParams *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FuelEvaporationInspectResponse:
		((_ns1__FuelEvaporationInspectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FuelEvaporationInspect:
		((_ns1__FuelEvaporationInspect *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__TestPhotoResponse:
		((_ns1__TestPhotoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__TestPhoto:
		((_ns1__TestPhoto *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EndCalibrateResponse:
		((_ns1__EndCalibrateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EndCalibrate:
		((_ns1__EndCalibrate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadCalibrateDataResponse:
		((_ns1__UploadCalibrateDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadCalibrateData:
		((_ns1__UploadCalibrateData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BeginCalibrateResponse:
		((_ns1__BeginCalibrateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BeginCalibrate:
		((_ns1__BeginCalibrate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInspectionInfoResponse:
		((_ns1__GetInspectionInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInspectionInfo:
		((_ns1__GetInspectionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadRealtimeDataResponse:
		((_ns1__UploadRealtimeDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadRealtimeData:
		((_ns1__UploadRealtimeData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadSelfTestDataResponse:
		((_ns1__UploadSelfTestDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadSelfTestData:
		((_ns1__UploadSelfTestData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EndInspectResponse:
		((_ns1__EndInspectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EndInspect:
		((_ns1__EndInspect *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopInspectResponse:
		((_ns1__StopInspectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopInspect:
		((_ns1__StopInspect *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WJTakePhotoResponse:
		((_ns1__WJTakePhotoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WJTakePhoto:
		((_ns1__WJTakePhoto *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__TakePhotoResponse:
		((_ns1__TakePhotoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__TakePhoto:
		((_ns1__TakePhoto *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLimitResponse:
		((_ns1__GetLimitResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLimit:
		((_ns1__GetLimit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BeginInspectResponse:
		((_ns1__BeginInspectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BeginInspect:
		((_ns1__BeginInspect *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EndRecordResponse:
		((_ns1__EndRecordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EndRecord:
		((_ns1__EndRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BeginRecordResponse:
		((_ns1__BeginRecordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BeginRecord:
		((_ns1__BeginRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AbortInspectResponse:
		((_ns1__AbortInspectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AbortInspect:
		((_ns1__AbortInspect *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse:
		((_ns1__GetInspectQueueByPlateIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInspectQueueByPlateID:
		((_ns1__GetInspectQueueByPlateID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInspectQueueByDateResponse:
		((_ns1__GetInspectQueueByDateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInspectQueueByDate:
		((_ns1__GetInspectQueueByDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SyncResponse:
		((_ns1__SyncResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Sync:
		((_ns1__Sync *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RetValue:
		((ns1__RetValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__OBDTXCheck_:
		soap_serialize___ns1__OBDTXCheck_(soap, (const struct __ns1__OBDTXCheck_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OBDInspect_:
		soap_serialize___ns1__OBDInspect_(soap, (const struct __ns1__OBDInspect_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetOtherInspectQueueByDate_:
		soap_serialize___ns1__GetOtherInspectQueueByDate_(soap, (const struct __ns1__GetOtherInspectQueueByDate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID_:
		soap_serialize___ns1__GetOtherInspectQueueByPlateID_(soap, (const struct __ns1__GetOtherInspectQueueByPlateID_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectParams_:
		soap_serialize___ns1__GetInspectParams_(soap, (const struct __ns1__GetInspectParams_ *)ptr);
		break;
	case SOAP_TYPE___ns1__FuelEvaporationInspect_:
		soap_serialize___ns1__FuelEvaporationInspect_(soap, (const struct __ns1__FuelEvaporationInspect_ *)ptr);
		break;
	case SOAP_TYPE___ns1__TestPhoto_:
		soap_serialize___ns1__TestPhoto_(soap, (const struct __ns1__TestPhoto_ *)ptr);
		break;
	case SOAP_TYPE___ns1__EndCalibrate_:
		soap_serialize___ns1__EndCalibrate_(soap, (const struct __ns1__EndCalibrate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadCalibrateData_:
		soap_serialize___ns1__UploadCalibrateData_(soap, (const struct __ns1__UploadCalibrateData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__BeginCalibrate_:
		soap_serialize___ns1__BeginCalibrate_(soap, (const struct __ns1__BeginCalibrate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectionInfo_:
		soap_serialize___ns1__GetInspectionInfo_(soap, (const struct __ns1__GetInspectionInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadRealtimeData_:
		soap_serialize___ns1__UploadRealtimeData_(soap, (const struct __ns1__UploadRealtimeData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadSelfTestData_:
		soap_serialize___ns1__UploadSelfTestData_(soap, (const struct __ns1__UploadSelfTestData_ *)ptr);
		break;
	case SOAP_TYPE___ns1__EndInspect_:
		soap_serialize___ns1__EndInspect_(soap, (const struct __ns1__EndInspect_ *)ptr);
		break;
	case SOAP_TYPE___ns1__StopInspect_:
		soap_serialize___ns1__StopInspect_(soap, (const struct __ns1__StopInspect_ *)ptr);
		break;
	case SOAP_TYPE___ns1__WJTakePhoto_:
		soap_serialize___ns1__WJTakePhoto_(soap, (const struct __ns1__WJTakePhoto_ *)ptr);
		break;
	case SOAP_TYPE___ns1__TakePhoto_:
		soap_serialize___ns1__TakePhoto_(soap, (const struct __ns1__TakePhoto_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLimit_:
		soap_serialize___ns1__GetLimit_(soap, (const struct __ns1__GetLimit_ *)ptr);
		break;
	case SOAP_TYPE___ns1__BeginInspect_:
		soap_serialize___ns1__BeginInspect_(soap, (const struct __ns1__BeginInspect_ *)ptr);
		break;
	case SOAP_TYPE___ns1__EndRecord_:
		soap_serialize___ns1__EndRecord_(soap, (const struct __ns1__EndRecord_ *)ptr);
		break;
	case SOAP_TYPE___ns1__BeginRecord_:
		soap_serialize___ns1__BeginRecord_(soap, (const struct __ns1__BeginRecord_ *)ptr);
		break;
	case SOAP_TYPE___ns1__AbortInspect_:
		soap_serialize___ns1__AbortInspect_(soap, (const struct __ns1__AbortInspect_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectQueueByPlateID_:
		soap_serialize___ns1__GetInspectQueueByPlateID_(soap, (const struct __ns1__GetInspectQueueByPlateID_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectQueueByDate_:
		soap_serialize___ns1__GetInspectQueueByDate_(soap, (const struct __ns1__GetInspectQueueByDate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Sync_:
		soap_serialize___ns1__Sync_(soap, (const struct __ns1__Sync_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OBDTXCheck:
		soap_serialize___ns1__OBDTXCheck(soap, (const struct __ns1__OBDTXCheck *)ptr);
		break;
	case SOAP_TYPE___ns1__OBDInspect:
		soap_serialize___ns1__OBDInspect(soap, (const struct __ns1__OBDInspect *)ptr);
		break;
	case SOAP_TYPE___ns1__GetOtherInspectQueueByDate:
		soap_serialize___ns1__GetOtherInspectQueueByDate(soap, (const struct __ns1__GetOtherInspectQueueByDate *)ptr);
		break;
	case SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID:
		soap_serialize___ns1__GetOtherInspectQueueByPlateID(soap, (const struct __ns1__GetOtherInspectQueueByPlateID *)ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectParams:
		soap_serialize___ns1__GetInspectParams(soap, (const struct __ns1__GetInspectParams *)ptr);
		break;
	case SOAP_TYPE___ns1__FuelEvaporationInspect:
		soap_serialize___ns1__FuelEvaporationInspect(soap, (const struct __ns1__FuelEvaporationInspect *)ptr);
		break;
	case SOAP_TYPE___ns1__TestPhoto:
		soap_serialize___ns1__TestPhoto(soap, (const struct __ns1__TestPhoto *)ptr);
		break;
	case SOAP_TYPE___ns1__EndCalibrate:
		soap_serialize___ns1__EndCalibrate(soap, (const struct __ns1__EndCalibrate *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadCalibrateData:
		soap_serialize___ns1__UploadCalibrateData(soap, (const struct __ns1__UploadCalibrateData *)ptr);
		break;
	case SOAP_TYPE___ns1__BeginCalibrate:
		soap_serialize___ns1__BeginCalibrate(soap, (const struct __ns1__BeginCalibrate *)ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectionInfo:
		soap_serialize___ns1__GetInspectionInfo(soap, (const struct __ns1__GetInspectionInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadRealtimeData:
		soap_serialize___ns1__UploadRealtimeData(soap, (const struct __ns1__UploadRealtimeData *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadSelfTestData:
		soap_serialize___ns1__UploadSelfTestData(soap, (const struct __ns1__UploadSelfTestData *)ptr);
		break;
	case SOAP_TYPE___ns1__EndInspect:
		soap_serialize___ns1__EndInspect(soap, (const struct __ns1__EndInspect *)ptr);
		break;
	case SOAP_TYPE___ns1__StopInspect:
		soap_serialize___ns1__StopInspect(soap, (const struct __ns1__StopInspect *)ptr);
		break;
	case SOAP_TYPE___ns1__WJTakePhoto:
		soap_serialize___ns1__WJTakePhoto(soap, (const struct __ns1__WJTakePhoto *)ptr);
		break;
	case SOAP_TYPE___ns1__TakePhoto:
		soap_serialize___ns1__TakePhoto(soap, (const struct __ns1__TakePhoto *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLimit:
		soap_serialize___ns1__GetLimit(soap, (const struct __ns1__GetLimit *)ptr);
		break;
	case SOAP_TYPE___ns1__BeginInspect:
		soap_serialize___ns1__BeginInspect(soap, (const struct __ns1__BeginInspect *)ptr);
		break;
	case SOAP_TYPE___ns1__EndRecord:
		soap_serialize___ns1__EndRecord(soap, (const struct __ns1__EndRecord *)ptr);
		break;
	case SOAP_TYPE___ns1__BeginRecord:
		soap_serialize___ns1__BeginRecord(soap, (const struct __ns1__BeginRecord *)ptr);
		break;
	case SOAP_TYPE___ns1__AbortInspect:
		soap_serialize___ns1__AbortInspect(soap, (const struct __ns1__AbortInspect *)ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectQueueByPlateID:
		soap_serialize___ns1__GetInspectQueueByPlateID(soap, (const struct __ns1__GetInspectQueueByPlateID *)ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectQueueByDate:
		soap_serialize___ns1__GetInspectQueueByDate(soap, (const struct __ns1__GetInspectQueueByDate *)ptr);
		break;
	case SOAP_TYPE___ns1__Sync:
		soap_serialize___ns1__Sync(soap, (const struct __ns1__Sync *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OBDTXCheck:
		soap_serialize_PointerTo_ns1__OBDTXCheck(soap, (_ns1__OBDTXCheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OBDInspect:
		soap_serialize_PointerTo_ns1__OBDInspect(soap, (_ns1__OBDInspect *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetOtherInspectQueueByDate:
		soap_serialize_PointerTo_ns1__GetOtherInspectQueueByDate(soap, (_ns1__GetOtherInspectQueueByDate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetOtherInspectQueueByPlateID:
		soap_serialize_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, (_ns1__GetOtherInspectQueueByPlateID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetInspectParams:
		soap_serialize_PointerTo_ns1__GetInspectParams(soap, (_ns1__GetInspectParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__FuelEvaporationInspect:
		soap_serialize_PointerTo_ns1__FuelEvaporationInspect(soap, (_ns1__FuelEvaporationInspect *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TestPhoto:
		soap_serialize_PointerTo_ns1__TestPhoto(soap, (_ns1__TestPhoto *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__EndCalibrate:
		soap_serialize_PointerTo_ns1__EndCalibrate(soap, (_ns1__EndCalibrate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UploadCalibrateData:
		soap_serialize_PointerTo_ns1__UploadCalibrateData(soap, (_ns1__UploadCalibrateData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BeginCalibrate:
		soap_serialize_PointerTo_ns1__BeginCalibrate(soap, (_ns1__BeginCalibrate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetInspectionInfo:
		soap_serialize_PointerTo_ns1__GetInspectionInfo(soap, (_ns1__GetInspectionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UploadRealtimeData:
		soap_serialize_PointerTo_ns1__UploadRealtimeData(soap, (_ns1__UploadRealtimeData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UploadSelfTestData:
		soap_serialize_PointerTo_ns1__UploadSelfTestData(soap, (_ns1__UploadSelfTestData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__EndInspect:
		soap_serialize_PointerTo_ns1__EndInspect(soap, (_ns1__EndInspect *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopInspect:
		soap_serialize_PointerTo_ns1__StopInspect(soap, (_ns1__StopInspect *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__WJTakePhoto:
		soap_serialize_PointerTo_ns1__WJTakePhoto(soap, (_ns1__WJTakePhoto *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__TakePhoto:
		soap_serialize_PointerTo_ns1__TakePhoto(soap, (_ns1__TakePhoto *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLimit:
		soap_serialize_PointerTo_ns1__GetLimit(soap, (_ns1__GetLimit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BeginInspect:
		soap_serialize_PointerTo_ns1__BeginInspect(soap, (_ns1__BeginInspect *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__EndRecord:
		soap_serialize_PointerTo_ns1__EndRecord(soap, (_ns1__EndRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BeginRecord:
		soap_serialize_PointerTo_ns1__BeginRecord(soap, (_ns1__BeginRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AbortInspect:
		soap_serialize_PointerTo_ns1__AbortInspect(soap, (_ns1__AbortInspect *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetInspectQueueByPlateID:
		soap_serialize_PointerTo_ns1__GetInspectQueueByPlateID(soap, (_ns1__GetInspectQueueByPlateID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetInspectQueueByDate:
		soap_serialize_PointerTo_ns1__GetInspectQueueByDate(soap, (_ns1__GetInspectQueueByDate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Sync:
		soap_serialize_PointerTo_ns1__Sync(soap, (_ns1__Sync *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RetValue:
		soap_serialize_PointerTons1__RetValue(soap, (ns1__RetValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__wstring:
		soap_serialize_PointerTostd__wstring(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RetValue:
		return (void*)soap_instantiate_ns1__RetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Sync:
		return (void*)soap_instantiate__ns1__Sync(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SyncResponse:
		return (void*)soap_instantiate__ns1__SyncResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInspectQueueByDate:
		return (void*)soap_instantiate__ns1__GetInspectQueueByDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInspectQueueByDateResponse:
		return (void*)soap_instantiate__ns1__GetInspectQueueByDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInspectQueueByPlateID:
		return (void*)soap_instantiate__ns1__GetInspectQueueByPlateID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse:
		return (void*)soap_instantiate__ns1__GetInspectQueueByPlateIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AbortInspect:
		return (void*)soap_instantiate__ns1__AbortInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AbortInspectResponse:
		return (void*)soap_instantiate__ns1__AbortInspectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BeginRecord:
		return (void*)soap_instantiate__ns1__BeginRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BeginRecordResponse:
		return (void*)soap_instantiate__ns1__BeginRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EndRecord:
		return (void*)soap_instantiate__ns1__EndRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EndRecordResponse:
		return (void*)soap_instantiate__ns1__EndRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BeginInspect:
		return (void*)soap_instantiate__ns1__BeginInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BeginInspectResponse:
		return (void*)soap_instantiate__ns1__BeginInspectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLimit:
		return (void*)soap_instantiate__ns1__GetLimit(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLimitResponse:
		return (void*)soap_instantiate__ns1__GetLimitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__TakePhoto:
		return (void*)soap_instantiate__ns1__TakePhoto(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__TakePhotoResponse:
		return (void*)soap_instantiate__ns1__TakePhotoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__WJTakePhoto:
		return (void*)soap_instantiate__ns1__WJTakePhoto(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__WJTakePhotoResponse:
		return (void*)soap_instantiate__ns1__WJTakePhotoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopInspect:
		return (void*)soap_instantiate__ns1__StopInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopInspectResponse:
		return (void*)soap_instantiate__ns1__StopInspectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EndInspect:
		return (void*)soap_instantiate__ns1__EndInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EndInspectResponse:
		return (void*)soap_instantiate__ns1__EndInspectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadSelfTestData:
		return (void*)soap_instantiate__ns1__UploadSelfTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadSelfTestDataResponse:
		return (void*)soap_instantiate__ns1__UploadSelfTestDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadRealtimeData:
		return (void*)soap_instantiate__ns1__UploadRealtimeData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadRealtimeDataResponse:
		return (void*)soap_instantiate__ns1__UploadRealtimeDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInspectionInfo:
		return (void*)soap_instantiate__ns1__GetInspectionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInspectionInfoResponse:
		return (void*)soap_instantiate__ns1__GetInspectionInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BeginCalibrate:
		return (void*)soap_instantiate__ns1__BeginCalibrate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BeginCalibrateResponse:
		return (void*)soap_instantiate__ns1__BeginCalibrateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadCalibrateData:
		return (void*)soap_instantiate__ns1__UploadCalibrateData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadCalibrateDataResponse:
		return (void*)soap_instantiate__ns1__UploadCalibrateDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EndCalibrate:
		return (void*)soap_instantiate__ns1__EndCalibrate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EndCalibrateResponse:
		return (void*)soap_instantiate__ns1__EndCalibrateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__TestPhoto:
		return (void*)soap_instantiate__ns1__TestPhoto(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__TestPhotoResponse:
		return (void*)soap_instantiate__ns1__TestPhotoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FuelEvaporationInspect:
		return (void*)soap_instantiate__ns1__FuelEvaporationInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FuelEvaporationInspectResponse:
		return (void*)soap_instantiate__ns1__FuelEvaporationInspectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInspectParams:
		return (void*)soap_instantiate__ns1__GetInspectParams(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInspectParamsResponse:
		return (void*)soap_instantiate__ns1__GetInspectParamsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID:
		return (void*)soap_instantiate__ns1__GetOtherInspectQueueByPlateID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse:
		return (void*)soap_instantiate__ns1__GetOtherInspectQueueByPlateIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOtherInspectQueueByDate:
		return (void*)soap_instantiate__ns1__GetOtherInspectQueueByDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse:
		return (void*)soap_instantiate__ns1__GetOtherInspectQueueByDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OBDInspect:
		return (void*)soap_instantiate__ns1__OBDInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OBDInspectResponse:
		return (void*)soap_instantiate__ns1__OBDInspectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OBDTXCheck:
		return (void*)soap_instantiate__ns1__OBDTXCheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OBDTXCheckResponse:
		return (void*)soap_instantiate__ns1__OBDTXCheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Sync:
		return (void*)soap_instantiate___ns1__Sync(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetInspectQueueByDate:
		return (void*)soap_instantiate___ns1__GetInspectQueueByDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetInspectQueueByPlateID:
		return (void*)soap_instantiate___ns1__GetInspectQueueByPlateID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AbortInspect:
		return (void*)soap_instantiate___ns1__AbortInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BeginRecord:
		return (void*)soap_instantiate___ns1__BeginRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EndRecord:
		return (void*)soap_instantiate___ns1__EndRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BeginInspect:
		return (void*)soap_instantiate___ns1__BeginInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLimit:
		return (void*)soap_instantiate___ns1__GetLimit(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__TakePhoto:
		return (void*)soap_instantiate___ns1__TakePhoto(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__WJTakePhoto:
		return (void*)soap_instantiate___ns1__WJTakePhoto(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__StopInspect:
		return (void*)soap_instantiate___ns1__StopInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EndInspect:
		return (void*)soap_instantiate___ns1__EndInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadSelfTestData:
		return (void*)soap_instantiate___ns1__UploadSelfTestData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadRealtimeData:
		return (void*)soap_instantiate___ns1__UploadRealtimeData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetInspectionInfo:
		return (void*)soap_instantiate___ns1__GetInspectionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BeginCalibrate:
		return (void*)soap_instantiate___ns1__BeginCalibrate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadCalibrateData:
		return (void*)soap_instantiate___ns1__UploadCalibrateData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EndCalibrate:
		return (void*)soap_instantiate___ns1__EndCalibrate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__TestPhoto:
		return (void*)soap_instantiate___ns1__TestPhoto(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__FuelEvaporationInspect:
		return (void*)soap_instantiate___ns1__FuelEvaporationInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetInspectParams:
		return (void*)soap_instantiate___ns1__GetInspectParams(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID:
		return (void*)soap_instantiate___ns1__GetOtherInspectQueueByPlateID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetOtherInspectQueueByDate:
		return (void*)soap_instantiate___ns1__GetOtherInspectQueueByDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OBDInspect:
		return (void*)soap_instantiate___ns1__OBDInspect(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OBDTXCheck:
		return (void*)soap_instantiate___ns1__OBDTXCheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Sync_:
		return (void*)soap_instantiate___ns1__Sync_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetInspectQueueByDate_:
		return (void*)soap_instantiate___ns1__GetInspectQueueByDate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetInspectQueueByPlateID_:
		return (void*)soap_instantiate___ns1__GetInspectQueueByPlateID_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AbortInspect_:
		return (void*)soap_instantiate___ns1__AbortInspect_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BeginRecord_:
		return (void*)soap_instantiate___ns1__BeginRecord_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EndRecord_:
		return (void*)soap_instantiate___ns1__EndRecord_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BeginInspect_:
		return (void*)soap_instantiate___ns1__BeginInspect_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLimit_:
		return (void*)soap_instantiate___ns1__GetLimit_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__TakePhoto_:
		return (void*)soap_instantiate___ns1__TakePhoto_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__WJTakePhoto_:
		return (void*)soap_instantiate___ns1__WJTakePhoto_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__StopInspect_:
		return (void*)soap_instantiate___ns1__StopInspect_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EndInspect_:
		return (void*)soap_instantiate___ns1__EndInspect_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadSelfTestData_:
		return (void*)soap_instantiate___ns1__UploadSelfTestData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadRealtimeData_:
		return (void*)soap_instantiate___ns1__UploadRealtimeData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetInspectionInfo_:
		return (void*)soap_instantiate___ns1__GetInspectionInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BeginCalibrate_:
		return (void*)soap_instantiate___ns1__BeginCalibrate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadCalibrateData_:
		return (void*)soap_instantiate___ns1__UploadCalibrateData_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__EndCalibrate_:
		return (void*)soap_instantiate___ns1__EndCalibrate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__TestPhoto_:
		return (void*)soap_instantiate___ns1__TestPhoto_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__FuelEvaporationInspect_:
		return (void*)soap_instantiate___ns1__FuelEvaporationInspect_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetInspectParams_:
		return (void*)soap_instantiate___ns1__GetInspectParams_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID_:
		return (void*)soap_instantiate___ns1__GetOtherInspectQueueByPlateID_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetOtherInspectQueueByDate_:
		return (void*)soap_instantiate___ns1__GetOtherInspectQueueByDate_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OBDInspect_:
		return (void*)soap_instantiate___ns1__OBDInspect_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OBDTXCheck_:
		return (void*)soap_instantiate___ns1__OBDTXCheck_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_ns1__RetValue:
		if (p->size < 0)
			SOAP_DELETE((ns1__RetValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__RetValue*)p->ptr);
		break;
	case SOAP_TYPE__ns1__Sync:
		if (p->size < 0)
			SOAP_DELETE((_ns1__Sync*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__Sync*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SyncResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SyncResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SyncResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetInspectQueueByDate:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetInspectQueueByDate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetInspectQueueByDate*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetInspectQueueByDateResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetInspectQueueByDateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetInspectQueueByDateResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetInspectQueueByPlateID:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetInspectQueueByPlateID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetInspectQueueByPlateID*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetInspectQueueByPlateIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetInspectQueueByPlateIDResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AbortInspect:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AbortInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AbortInspect*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AbortInspectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AbortInspectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AbortInspectResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__BeginRecord:
		if (p->size < 0)
			SOAP_DELETE((_ns1__BeginRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__BeginRecord*)p->ptr);
		break;
	case SOAP_TYPE__ns1__BeginRecordResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__BeginRecordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__BeginRecordResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__EndRecord:
		if (p->size < 0)
			SOAP_DELETE((_ns1__EndRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__EndRecord*)p->ptr);
		break;
	case SOAP_TYPE__ns1__EndRecordResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__EndRecordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__EndRecordResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__BeginInspect:
		if (p->size < 0)
			SOAP_DELETE((_ns1__BeginInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__BeginInspect*)p->ptr);
		break;
	case SOAP_TYPE__ns1__BeginInspectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__BeginInspectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__BeginInspectResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLimit:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLimit*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLimit*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLimitResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLimitResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLimitResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__TakePhoto:
		if (p->size < 0)
			SOAP_DELETE((_ns1__TakePhoto*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__TakePhoto*)p->ptr);
		break;
	case SOAP_TYPE__ns1__TakePhotoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__TakePhotoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__TakePhotoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__WJTakePhoto:
		if (p->size < 0)
			SOAP_DELETE((_ns1__WJTakePhoto*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__WJTakePhoto*)p->ptr);
		break;
	case SOAP_TYPE__ns1__WJTakePhotoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__WJTakePhotoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__WJTakePhotoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__StopInspect:
		if (p->size < 0)
			SOAP_DELETE((_ns1__StopInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__StopInspect*)p->ptr);
		break;
	case SOAP_TYPE__ns1__StopInspectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__StopInspectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__StopInspectResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__EndInspect:
		if (p->size < 0)
			SOAP_DELETE((_ns1__EndInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__EndInspect*)p->ptr);
		break;
	case SOAP_TYPE__ns1__EndInspectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__EndInspectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__EndInspectResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UploadSelfTestData:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UploadSelfTestData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UploadSelfTestData*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UploadSelfTestDataResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UploadSelfTestDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UploadSelfTestDataResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UploadRealtimeData:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UploadRealtimeData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UploadRealtimeData*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UploadRealtimeDataResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UploadRealtimeDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UploadRealtimeDataResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetInspectionInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetInspectionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetInspectionInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetInspectionInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetInspectionInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetInspectionInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__BeginCalibrate:
		if (p->size < 0)
			SOAP_DELETE((_ns1__BeginCalibrate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__BeginCalibrate*)p->ptr);
		break;
	case SOAP_TYPE__ns1__BeginCalibrateResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__BeginCalibrateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__BeginCalibrateResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UploadCalibrateData:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UploadCalibrateData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UploadCalibrateData*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UploadCalibrateDataResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UploadCalibrateDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UploadCalibrateDataResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__EndCalibrate:
		if (p->size < 0)
			SOAP_DELETE((_ns1__EndCalibrate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__EndCalibrate*)p->ptr);
		break;
	case SOAP_TYPE__ns1__EndCalibrateResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__EndCalibrateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__EndCalibrateResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__TestPhoto:
		if (p->size < 0)
			SOAP_DELETE((_ns1__TestPhoto*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__TestPhoto*)p->ptr);
		break;
	case SOAP_TYPE__ns1__TestPhotoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__TestPhotoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__TestPhotoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__FuelEvaporationInspect:
		if (p->size < 0)
			SOAP_DELETE((_ns1__FuelEvaporationInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__FuelEvaporationInspect*)p->ptr);
		break;
	case SOAP_TYPE__ns1__FuelEvaporationInspectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__FuelEvaporationInspectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__FuelEvaporationInspectResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetInspectParams:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetInspectParams*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetInspectParams*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetInspectParamsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetInspectParamsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetInspectParamsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetOtherInspectQueueByPlateID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetOtherInspectQueueByPlateID*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetOtherInspectQueueByPlateIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetOtherInspectQueueByPlateIDResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetOtherInspectQueueByDate:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetOtherInspectQueueByDate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetOtherInspectQueueByDate*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetOtherInspectQueueByDateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetOtherInspectQueueByDateResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__OBDInspect:
		if (p->size < 0)
			SOAP_DELETE((_ns1__OBDInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__OBDInspect*)p->ptr);
		break;
	case SOAP_TYPE__ns1__OBDInspectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__OBDInspectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__OBDInspectResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__OBDTXCheck:
		if (p->size < 0)
			SOAP_DELETE((_ns1__OBDTXCheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__OBDTXCheck*)p->ptr);
		break;
	case SOAP_TYPE__ns1__OBDTXCheckResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__OBDTXCheckResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__OBDTXCheckResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__Sync:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__Sync*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__Sync*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectQueueByDate:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetInspectQueueByDate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetInspectQueueByDate*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectQueueByPlateID:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetInspectQueueByPlateID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetInspectQueueByPlateID*)p->ptr);
		break;
	case SOAP_TYPE___ns1__AbortInspect:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__AbortInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__AbortInspect*)p->ptr);
		break;
	case SOAP_TYPE___ns1__BeginRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__BeginRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__BeginRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns1__EndRecord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__EndRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__EndRecord*)p->ptr);
		break;
	case SOAP_TYPE___ns1__BeginInspect:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__BeginInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__BeginInspect*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetLimit:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetLimit*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetLimit*)p->ptr);
		break;
	case SOAP_TYPE___ns1__TakePhoto:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__TakePhoto*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__TakePhoto*)p->ptr);
		break;
	case SOAP_TYPE___ns1__WJTakePhoto:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__WJTakePhoto*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__WJTakePhoto*)p->ptr);
		break;
	case SOAP_TYPE___ns1__StopInspect:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__StopInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__StopInspect*)p->ptr);
		break;
	case SOAP_TYPE___ns1__EndInspect:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__EndInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__EndInspect*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UploadSelfTestData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UploadSelfTestData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UploadSelfTestData*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UploadRealtimeData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UploadRealtimeData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UploadRealtimeData*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectionInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetInspectionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetInspectionInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__BeginCalibrate:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__BeginCalibrate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__BeginCalibrate*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UploadCalibrateData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UploadCalibrateData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UploadCalibrateData*)p->ptr);
		break;
	case SOAP_TYPE___ns1__EndCalibrate:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__EndCalibrate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__EndCalibrate*)p->ptr);
		break;
	case SOAP_TYPE___ns1__TestPhoto:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__TestPhoto*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__TestPhoto*)p->ptr);
		break;
	case SOAP_TYPE___ns1__FuelEvaporationInspect:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__FuelEvaporationInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__FuelEvaporationInspect*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectParams:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetInspectParams*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetInspectParams*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetOtherInspectQueueByPlateID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetOtherInspectQueueByPlateID*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetOtherInspectQueueByDate:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetOtherInspectQueueByDate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetOtherInspectQueueByDate*)p->ptr);
		break;
	case SOAP_TYPE___ns1__OBDInspect:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__OBDInspect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__OBDInspect*)p->ptr);
		break;
	case SOAP_TYPE___ns1__OBDTXCheck:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__OBDTXCheck*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__OBDTXCheck*)p->ptr);
		break;
	case SOAP_TYPE___ns1__Sync_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__Sync_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__Sync_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectQueueByDate_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetInspectQueueByDate_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetInspectQueueByDate_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectQueueByPlateID_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetInspectQueueByPlateID_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetInspectQueueByPlateID_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__AbortInspect_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__AbortInspect_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__AbortInspect_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__BeginRecord_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__BeginRecord_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__BeginRecord_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__EndRecord_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__EndRecord_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__EndRecord_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__BeginInspect_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__BeginInspect_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__BeginInspect_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetLimit_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetLimit_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetLimit_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__TakePhoto_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__TakePhoto_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__TakePhoto_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__WJTakePhoto_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__WJTakePhoto_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__WJTakePhoto_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__StopInspect_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__StopInspect_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__StopInspect_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__EndInspect_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__EndInspect_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__EndInspect_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UploadSelfTestData_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UploadSelfTestData_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UploadSelfTestData_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UploadRealtimeData_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UploadRealtimeData_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UploadRealtimeData_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectionInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetInspectionInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetInspectionInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__BeginCalibrate_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__BeginCalibrate_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__BeginCalibrate_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UploadCalibrateData_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UploadCalibrateData_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UploadCalibrateData_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__EndCalibrate_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__EndCalibrate_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__EndCalibrate_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__TestPhoto_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__TestPhoto_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__TestPhoto_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__FuelEvaporationInspect_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__FuelEvaporationInspect_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__FuelEvaporationInspect_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetInspectParams_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetInspectParams_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetInspectParams_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetOtherInspectQueueByPlateID_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetOtherInspectQueueByPlateID_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetOtherInspectQueueByDate_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetOtherInspectQueueByDate_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetOtherInspectQueueByDate_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__OBDInspect_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__OBDInspect_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__OBDInspect_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__OBDTXCheck_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__OBDTXCheck_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__OBDTXCheck_*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_std__wstring, 0, sizeof(std::wstring), 0, soap_copy_std__wstring);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_std__wstring);
	if (soap_out_std__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__wstring, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::wstring);
		if (size)
			*size = sizeof(std::wstring);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::wstring, n);
		if (size)
			*size = n * sizeof(std::wstring);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::wstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::wstring %p -> %p\n", q, p));
	*(std::wstring*)p = *(std::wstring*)q;
}

void _ns1__OBDTXCheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OBDTXCheckResponse::OBDTXCheckResult = NULL;
	/* transient soap skipped */
}

void _ns1__OBDTXCheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__OBDTXCheckResponse::OBDTXCheckResult);
	/* transient soap skipped */
#endif
}

int _ns1__OBDTXCheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OBDTXCheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OBDTXCheckResponse(struct soap *soap, const char *tag, int id, const _ns1__OBDTXCheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OBDTXCheckResponse), type))
		return soap->error;
	if (a->OBDTXCheckResult)
		soap_element_result(soap, "ns1:OBDTXCheckResult");
	if (a->_ns1__OBDTXCheckResponse::OBDTXCheckResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:OBDTXCheckResult", -1, &a->_ns1__OBDTXCheckResponse::OBDTXCheckResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:OBDTXCheckResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__OBDTXCheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OBDTXCheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OBDTXCheckResponse * SOAP_FMAC4 soap_in__ns1__OBDTXCheckResponse(struct soap *soap, const char *tag, _ns1__OBDTXCheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OBDTXCheckResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OBDTXCheckResponse, sizeof(_ns1__OBDTXCheckResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__OBDTXCheckResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__OBDTXCheckResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OBDTXCheckResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OBDTXCheckResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:OBDTXCheckResult", &(a->_ns1__OBDTXCheckResponse::OBDTXCheckResult), "ns1:RetValue"))
				{	soap_flag_OBDTXCheckResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:OBDTXCheckResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OBDTXCheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OBDTXCheckResponse, 0, sizeof(_ns1__OBDTXCheckResponse), 0, soap_copy__ns1__OBDTXCheckResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OBDTXCheckResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__OBDTXCheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__OBDTXCheckResponse);
	if (this->soap_out(soap, tag?tag:"ns1:OBDTXCheckResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OBDTXCheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OBDTXCheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OBDTXCheckResponse * SOAP_FMAC4 soap_get__ns1__OBDTXCheckResponse(struct soap *soap, _ns1__OBDTXCheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OBDTXCheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__OBDTXCheckResponse * SOAP_FMAC2 soap_instantiate__ns1__OBDTXCheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OBDTXCheckResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__OBDTXCheckResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__OBDTXCheckResponse);
		if (size)
			*size = sizeof(_ns1__OBDTXCheckResponse);
		((_ns1__OBDTXCheckResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__OBDTXCheckResponse, n);
		if (size)
			*size = n * sizeof(_ns1__OBDTXCheckResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__OBDTXCheckResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__OBDTXCheckResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__OBDTXCheckResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__OBDTXCheckResponse %p -> %p\n", q, p));
	*(_ns1__OBDTXCheckResponse*)p = *(_ns1__OBDTXCheckResponse*)q;
}

void _ns1__OBDTXCheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OBDTXCheck::VIN = NULL;
	/* transient soap skipped */
}

void _ns1__OBDTXCheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__OBDTXCheck::VIN);
	/* transient soap skipped */
#endif
}

int _ns1__OBDTXCheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OBDTXCheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OBDTXCheck(struct soap *soap, const char *tag, int id, const _ns1__OBDTXCheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OBDTXCheck), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:VIN", -1, &(a->_ns1__OBDTXCheck::VIN), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__OBDTXCheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OBDTXCheck(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OBDTXCheck * SOAP_FMAC4 soap_in__ns1__OBDTXCheck(struct soap *soap, const char *tag, _ns1__OBDTXCheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OBDTXCheck *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OBDTXCheck, sizeof(_ns1__OBDTXCheck), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__OBDTXCheck)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__OBDTXCheck *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_VIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:VIN", &(a->_ns1__OBDTXCheck::VIN), "xsd:string"))
				{	soap_flag_VIN1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OBDTXCheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OBDTXCheck, 0, sizeof(_ns1__OBDTXCheck), 0, soap_copy__ns1__OBDTXCheck);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__OBDTXCheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__OBDTXCheck);
	if (this->soap_out(soap, tag?tag:"ns1:OBDTXCheck", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OBDTXCheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OBDTXCheck(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OBDTXCheck * SOAP_FMAC4 soap_get__ns1__OBDTXCheck(struct soap *soap, _ns1__OBDTXCheck *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OBDTXCheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__OBDTXCheck * SOAP_FMAC2 soap_instantiate__ns1__OBDTXCheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OBDTXCheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__OBDTXCheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__OBDTXCheck);
		if (size)
			*size = sizeof(_ns1__OBDTXCheck);
		((_ns1__OBDTXCheck*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__OBDTXCheck, n);
		if (size)
			*size = n * sizeof(_ns1__OBDTXCheck);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__OBDTXCheck*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__OBDTXCheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__OBDTXCheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__OBDTXCheck %p -> %p\n", q, p));
	*(_ns1__OBDTXCheck*)p = *(_ns1__OBDTXCheck*)q;
}

void _ns1__OBDInspectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OBDInspectResponse::OBDInspectResult = NULL;
	/* transient soap skipped */
}

void _ns1__OBDInspectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__OBDInspectResponse::OBDInspectResult);
	/* transient soap skipped */
#endif
}

int _ns1__OBDInspectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OBDInspectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OBDInspectResponse(struct soap *soap, const char *tag, int id, const _ns1__OBDInspectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OBDInspectResponse), type))
		return soap->error;
	if (a->OBDInspectResult)
		soap_element_result(soap, "ns1:OBDInspectResult");
	if (a->_ns1__OBDInspectResponse::OBDInspectResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:OBDInspectResult", -1, &a->_ns1__OBDInspectResponse::OBDInspectResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:OBDInspectResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__OBDInspectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OBDInspectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OBDInspectResponse * SOAP_FMAC4 soap_in__ns1__OBDInspectResponse(struct soap *soap, const char *tag, _ns1__OBDInspectResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OBDInspectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OBDInspectResponse, sizeof(_ns1__OBDInspectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__OBDInspectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__OBDInspectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OBDInspectResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OBDInspectResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:OBDInspectResult", &(a->_ns1__OBDInspectResponse::OBDInspectResult), "ns1:RetValue"))
				{	soap_flag_OBDInspectResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:OBDInspectResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OBDInspectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OBDInspectResponse, 0, sizeof(_ns1__OBDInspectResponse), 0, soap_copy__ns1__OBDInspectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OBDInspectResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__OBDInspectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__OBDInspectResponse);
	if (this->soap_out(soap, tag?tag:"ns1:OBDInspectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OBDInspectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OBDInspectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OBDInspectResponse * SOAP_FMAC4 soap_get__ns1__OBDInspectResponse(struct soap *soap, _ns1__OBDInspectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OBDInspectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__OBDInspectResponse * SOAP_FMAC2 soap_instantiate__ns1__OBDInspectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OBDInspectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__OBDInspectResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__OBDInspectResponse);
		if (size)
			*size = sizeof(_ns1__OBDInspectResponse);
		((_ns1__OBDInspectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__OBDInspectResponse, n);
		if (size)
			*size = n * sizeof(_ns1__OBDInspectResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__OBDInspectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__OBDInspectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__OBDInspectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__OBDInspectResponse %p -> %p\n", q, p));
	*(_ns1__OBDInspectResponse*)p = *(_ns1__OBDInspectResponse*)q;
}

void _ns1__OBDInspect::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__OBDInspect::LineID);
	this->_ns1__OBDInspect::InspectID = NULL;
	this->_ns1__OBDInspect::sOBDData = NULL;
	this->_ns1__OBDInspect::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__OBDInspect::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__OBDInspect::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__OBDInspect::sOBDData);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__OBDInspect::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__OBDInspect::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OBDInspect(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OBDInspect(struct soap *soap, const char *tag, int id, const _ns1__OBDInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OBDInspect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:LineID", -1, &(a->_ns1__OBDInspect::LineID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__OBDInspect::InspectID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:sOBDData", -1, &(a->_ns1__OBDInspect::sOBDData), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__OBDInspect::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__OBDInspect::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OBDInspect(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OBDInspect * SOAP_FMAC4 soap_in__ns1__OBDInspect(struct soap *soap, const char *tag, _ns1__OBDInspect *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OBDInspect *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OBDInspect, sizeof(_ns1__OBDInspect), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__OBDInspect)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__OBDInspect *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LineID1 = 1;
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_sOBDData1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:LineID", &(a->_ns1__OBDInspect::LineID), "xsd:long"))
				{	soap_flag_LineID1--;
					continue;
				}
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__OBDInspect::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_sOBDData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:sOBDData", &(a->_ns1__OBDInspect::sOBDData), "xsd:string"))
				{	soap_flag_sOBDData1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__OBDInspect::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OBDInspect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OBDInspect, 0, sizeof(_ns1__OBDInspect), 0, soap_copy__ns1__OBDInspect);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LineID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__OBDInspect::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__OBDInspect);
	if (this->soap_out(soap, tag?tag:"ns1:OBDInspect", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OBDInspect::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OBDInspect(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OBDInspect * SOAP_FMAC4 soap_get__ns1__OBDInspect(struct soap *soap, _ns1__OBDInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OBDInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__OBDInspect * SOAP_FMAC2 soap_instantiate__ns1__OBDInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OBDInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__OBDInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__OBDInspect);
		if (size)
			*size = sizeof(_ns1__OBDInspect);
		((_ns1__OBDInspect*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__OBDInspect, n);
		if (size)
			*size = n * sizeof(_ns1__OBDInspect);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__OBDInspect*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__OBDInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__OBDInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__OBDInspect %p -> %p\n", q, p));
	*(_ns1__OBDInspect*)p = *(_ns1__OBDInspect*)q;
}

void _ns1__GetOtherInspectQueueByDateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetOtherInspectQueueByDateResponse::GetOtherInspectQueueByDateResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetOtherInspectQueueByDateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__GetOtherInspectQueueByDateResponse::GetOtherInspectQueueByDateResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetOtherInspectQueueByDateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOtherInspectQueueByDateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOtherInspectQueueByDateResponse(struct soap *soap, const char *tag, int id, const _ns1__GetOtherInspectQueueByDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse), type))
		return soap->error;
	if (a->GetOtherInspectQueueByDateResult)
		soap_element_result(soap, "ns1:GetOtherInspectQueueByDateResult");
	if (a->_ns1__GetOtherInspectQueueByDateResponse::GetOtherInspectQueueByDateResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:GetOtherInspectQueueByDateResult", -1, &a->_ns1__GetOtherInspectQueueByDateResponse::GetOtherInspectQueueByDateResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetOtherInspectQueueByDateResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOtherInspectQueueByDateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOtherInspectQueueByDateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByDateResponse * SOAP_FMAC4 soap_in__ns1__GetOtherInspectQueueByDateResponse(struct soap *soap, const char *tag, _ns1__GetOtherInspectQueueByDateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOtherInspectQueueByDateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse, sizeof(_ns1__GetOtherInspectQueueByDateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetOtherInspectQueueByDateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetOtherInspectQueueByDateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetOtherInspectQueueByDateResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:GetOtherInspectQueueByDateResult", &(a->_ns1__GetOtherInspectQueueByDateResponse::GetOtherInspectQueueByDateResult), "ns1:RetValue"))
				{	soap_flag_GetOtherInspectQueueByDateResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetOtherInspectQueueByDateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOtherInspectQueueByDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse, 0, sizeof(_ns1__GetOtherInspectQueueByDateResponse), 0, soap_copy__ns1__GetOtherInspectQueueByDateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetOtherInspectQueueByDateResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetOtherInspectQueueByDateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetOtherInspectQueueByDateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOtherInspectQueueByDateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOtherInspectQueueByDateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByDateResponse * SOAP_FMAC4 soap_get__ns1__GetOtherInspectQueueByDateResponse(struct soap *soap, _ns1__GetOtherInspectQueueByDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOtherInspectQueueByDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetOtherInspectQueueByDateResponse * SOAP_FMAC2 soap_instantiate__ns1__GetOtherInspectQueueByDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOtherInspectQueueByDateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetOtherInspectQueueByDateResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetOtherInspectQueueByDateResponse);
		if (size)
			*size = sizeof(_ns1__GetOtherInspectQueueByDateResponse);
		((_ns1__GetOtherInspectQueueByDateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetOtherInspectQueueByDateResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetOtherInspectQueueByDateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetOtherInspectQueueByDateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetOtherInspectQueueByDateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetOtherInspectQueueByDateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetOtherInspectQueueByDateResponse %p -> %p\n", q, p));
	*(_ns1__GetOtherInspectQueueByDateResponse*)p = *(_ns1__GetOtherInspectQueueByDateResponse*)q;
}

void _ns1__GetOtherInspectQueueByDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetOtherInspectQueueByDate::FromDate = NULL;
	this->_ns1__GetOtherInspectQueueByDate::ToDate = NULL;
	this->_ns1__GetOtherInspectQueueByDate::QueueType = NULL;
	this->_ns1__GetOtherInspectQueueByDate::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__GetOtherInspectQueueByDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetOtherInspectQueueByDate::FromDate);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetOtherInspectQueueByDate::ToDate);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetOtherInspectQueueByDate::QueueType);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetOtherInspectQueueByDate::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__GetOtherInspectQueueByDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOtherInspectQueueByDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOtherInspectQueueByDate(struct soap *soap, const char *tag, int id, const _ns1__GetOtherInspectQueueByDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOtherInspectQueueByDate), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:FromDate", -1, &(a->_ns1__GetOtherInspectQueueByDate::FromDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:ToDate", -1, &(a->_ns1__GetOtherInspectQueueByDate::ToDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:QueueType", -1, &(a->_ns1__GetOtherInspectQueueByDate::QueueType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__GetOtherInspectQueueByDate::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOtherInspectQueueByDate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOtherInspectQueueByDate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByDate * SOAP_FMAC4 soap_in__ns1__GetOtherInspectQueueByDate(struct soap *soap, const char *tag, _ns1__GetOtherInspectQueueByDate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOtherInspectQueueByDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOtherInspectQueueByDate, sizeof(_ns1__GetOtherInspectQueueByDate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetOtherInspectQueueByDate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetOtherInspectQueueByDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FromDate1 = 1;
	size_t soap_flag_ToDate1 = 1;
	size_t soap_flag_QueueType1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:FromDate", &(a->_ns1__GetOtherInspectQueueByDate::FromDate), "xsd:string"))
				{	soap_flag_FromDate1--;
					continue;
				}
			if (soap_flag_ToDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:ToDate", &(a->_ns1__GetOtherInspectQueueByDate::ToDate), "xsd:string"))
				{	soap_flag_ToDate1--;
					continue;
				}
			if (soap_flag_QueueType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:QueueType", &(a->_ns1__GetOtherInspectQueueByDate::QueueType), "xsd:string"))
				{	soap_flag_QueueType1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__GetOtherInspectQueueByDate::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOtherInspectQueueByDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOtherInspectQueueByDate, 0, sizeof(_ns1__GetOtherInspectQueueByDate), 0, soap_copy__ns1__GetOtherInspectQueueByDate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetOtherInspectQueueByDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetOtherInspectQueueByDate);
	if (this->soap_out(soap, tag?tag:"ns1:GetOtherInspectQueueByDate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOtherInspectQueueByDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOtherInspectQueueByDate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByDate * SOAP_FMAC4 soap_get__ns1__GetOtherInspectQueueByDate(struct soap *soap, _ns1__GetOtherInspectQueueByDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOtherInspectQueueByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetOtherInspectQueueByDate * SOAP_FMAC2 soap_instantiate__ns1__GetOtherInspectQueueByDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOtherInspectQueueByDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetOtherInspectQueueByDate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetOtherInspectQueueByDate);
		if (size)
			*size = sizeof(_ns1__GetOtherInspectQueueByDate);
		((_ns1__GetOtherInspectQueueByDate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetOtherInspectQueueByDate, n);
		if (size)
			*size = n * sizeof(_ns1__GetOtherInspectQueueByDate);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetOtherInspectQueueByDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetOtherInspectQueueByDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetOtherInspectQueueByDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetOtherInspectQueueByDate %p -> %p\n", q, p));
	*(_ns1__GetOtherInspectQueueByDate*)p = *(_ns1__GetOtherInspectQueueByDate*)q;
}

void _ns1__GetOtherInspectQueueByPlateIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetOtherInspectQueueByPlateIDResponse::GetOtherInspectQueueByPlateIDResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetOtherInspectQueueByPlateIDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__GetOtherInspectQueueByPlateIDResponse::GetOtherInspectQueueByPlateIDResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetOtherInspectQueueByPlateIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOtherInspectQueueByPlateIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOtherInspectQueueByPlateIDResponse(struct soap *soap, const char *tag, int id, const _ns1__GetOtherInspectQueueByPlateIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse), type))
		return soap->error;
	if (a->GetOtherInspectQueueByPlateIDResult)
		soap_element_result(soap, "ns1:GetOtherInspectQueueByPlateIDResult");
	if (a->_ns1__GetOtherInspectQueueByPlateIDResponse::GetOtherInspectQueueByPlateIDResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:GetOtherInspectQueueByPlateIDResult", -1, &a->_ns1__GetOtherInspectQueueByPlateIDResponse::GetOtherInspectQueueByPlateIDResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetOtherInspectQueueByPlateIDResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOtherInspectQueueByPlateIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOtherInspectQueueByPlateIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByPlateIDResponse * SOAP_FMAC4 soap_in__ns1__GetOtherInspectQueueByPlateIDResponse(struct soap *soap, const char *tag, _ns1__GetOtherInspectQueueByPlateIDResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOtherInspectQueueByPlateIDResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse, sizeof(_ns1__GetOtherInspectQueueByPlateIDResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetOtherInspectQueueByPlateIDResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetOtherInspectQueueByPlateIDResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetOtherInspectQueueByPlateIDResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:GetOtherInspectQueueByPlateIDResult", &(a->_ns1__GetOtherInspectQueueByPlateIDResponse::GetOtherInspectQueueByPlateIDResult), "ns1:RetValue"))
				{	soap_flag_GetOtherInspectQueueByPlateIDResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetOtherInspectQueueByPlateIDResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOtherInspectQueueByPlateIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse, 0, sizeof(_ns1__GetOtherInspectQueueByPlateIDResponse), 0, soap_copy__ns1__GetOtherInspectQueueByPlateIDResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetOtherInspectQueueByPlateIDResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetOtherInspectQueueByPlateIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetOtherInspectQueueByPlateIDResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOtherInspectQueueByPlateIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOtherInspectQueueByPlateIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByPlateIDResponse * SOAP_FMAC4 soap_get__ns1__GetOtherInspectQueueByPlateIDResponse(struct soap *soap, _ns1__GetOtherInspectQueueByPlateIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOtherInspectQueueByPlateIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetOtherInspectQueueByPlateIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetOtherInspectQueueByPlateIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOtherInspectQueueByPlateIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateIDResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetOtherInspectQueueByPlateIDResponse);
		if (size)
			*size = sizeof(_ns1__GetOtherInspectQueueByPlateIDResponse);
		((_ns1__GetOtherInspectQueueByPlateIDResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetOtherInspectQueueByPlateIDResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetOtherInspectQueueByPlateIDResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetOtherInspectQueueByPlateIDResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetOtherInspectQueueByPlateIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetOtherInspectQueueByPlateIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetOtherInspectQueueByPlateIDResponse %p -> %p\n", q, p));
	*(_ns1__GetOtherInspectQueueByPlateIDResponse*)p = *(_ns1__GetOtherInspectQueueByPlateIDResponse*)q;
}

void _ns1__GetOtherInspectQueueByPlateID::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetOtherInspectQueueByPlateID::PlateID = NULL;
	soap_default_int(soap, &this->_ns1__GetOtherInspectQueueByPlateID::PlateType);
	this->_ns1__GetOtherInspectQueueByPlateID::QueueType = NULL;
	this->_ns1__GetOtherInspectQueueByPlateID::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__GetOtherInspectQueueByPlateID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetOtherInspectQueueByPlateID::PlateID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetOtherInspectQueueByPlateID::QueueType);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetOtherInspectQueueByPlateID::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__GetOtherInspectQueueByPlateID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOtherInspectQueueByPlateID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOtherInspectQueueByPlateID(struct soap *soap, const char *tag, int id, const _ns1__GetOtherInspectQueueByPlateID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:PlateID", -1, &(a->_ns1__GetOtherInspectQueueByPlateID::PlateID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PlateType", -1, &(a->_ns1__GetOtherInspectQueueByPlateID::PlateType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:QueueType", -1, &(a->_ns1__GetOtherInspectQueueByPlateID::QueueType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__GetOtherInspectQueueByPlateID::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOtherInspectQueueByPlateID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOtherInspectQueueByPlateID(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByPlateID * SOAP_FMAC4 soap_in__ns1__GetOtherInspectQueueByPlateID(struct soap *soap, const char *tag, _ns1__GetOtherInspectQueueByPlateID *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOtherInspectQueueByPlateID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID, sizeof(_ns1__GetOtherInspectQueueByPlateID), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetOtherInspectQueueByPlateID *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PlateID1 = 1;
	size_t soap_flag_PlateType1 = 1;
	size_t soap_flag_QueueType1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PlateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:PlateID", &(a->_ns1__GetOtherInspectQueueByPlateID::PlateID), "xsd:string"))
				{	soap_flag_PlateID1--;
					continue;
				}
			if (soap_flag_PlateType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PlateType", &(a->_ns1__GetOtherInspectQueueByPlateID::PlateType), "xsd:int"))
				{	soap_flag_PlateType1--;
					continue;
				}
			if (soap_flag_QueueType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:QueueType", &(a->_ns1__GetOtherInspectQueueByPlateID::QueueType), "xsd:string"))
				{	soap_flag_QueueType1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__GetOtherInspectQueueByPlateID::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOtherInspectQueueByPlateID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID, 0, sizeof(_ns1__GetOtherInspectQueueByPlateID), 0, soap_copy__ns1__GetOtherInspectQueueByPlateID);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PlateType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetOtherInspectQueueByPlateID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID);
	if (this->soap_out(soap, tag?tag:"ns1:GetOtherInspectQueueByPlateID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOtherInspectQueueByPlateID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOtherInspectQueueByPlateID(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByPlateID * SOAP_FMAC4 soap_get__ns1__GetOtherInspectQueueByPlateID(struct soap *soap, _ns1__GetOtherInspectQueueByPlateID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOtherInspectQueueByPlateID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetOtherInspectQueueByPlateID * SOAP_FMAC2 soap_instantiate__ns1__GetOtherInspectQueueByPlateID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOtherInspectQueueByPlateID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetOtherInspectQueueByPlateID);
		if (size)
			*size = sizeof(_ns1__GetOtherInspectQueueByPlateID);
		((_ns1__GetOtherInspectQueueByPlateID*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetOtherInspectQueueByPlateID, n);
		if (size)
			*size = n * sizeof(_ns1__GetOtherInspectQueueByPlateID);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetOtherInspectQueueByPlateID*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetOtherInspectQueueByPlateID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetOtherInspectQueueByPlateID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetOtherInspectQueueByPlateID %p -> %p\n", q, p));
	*(_ns1__GetOtherInspectQueueByPlateID*)p = *(_ns1__GetOtherInspectQueueByPlateID*)q;
}

void _ns1__GetInspectParamsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetInspectParamsResponse::GetInspectParamsResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetInspectParamsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__GetInspectParamsResponse::GetInspectParamsResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetInspectParamsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInspectParamsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInspectParamsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetInspectParamsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInspectParamsResponse), type))
		return soap->error;
	if (a->GetInspectParamsResult)
		soap_element_result(soap, "ns1:GetInspectParamsResult");
	if (a->_ns1__GetInspectParamsResponse::GetInspectParamsResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:GetInspectParamsResult", -1, &a->_ns1__GetInspectParamsResponse::GetInspectParamsResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetInspectParamsResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInspectParamsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInspectParamsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInspectParamsResponse * SOAP_FMAC4 soap_in__ns1__GetInspectParamsResponse(struct soap *soap, const char *tag, _ns1__GetInspectParamsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInspectParamsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInspectParamsResponse, sizeof(_ns1__GetInspectParamsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetInspectParamsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetInspectParamsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetInspectParamsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetInspectParamsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:GetInspectParamsResult", &(a->_ns1__GetInspectParamsResponse::GetInspectParamsResult), "ns1:RetValue"))
				{	soap_flag_GetInspectParamsResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetInspectParamsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInspectParamsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInspectParamsResponse, 0, sizeof(_ns1__GetInspectParamsResponse), 0, soap_copy__ns1__GetInspectParamsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetInspectParamsResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetInspectParamsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetInspectParamsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetInspectParamsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInspectParamsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInspectParamsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInspectParamsResponse * SOAP_FMAC4 soap_get__ns1__GetInspectParamsResponse(struct soap *soap, _ns1__GetInspectParamsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInspectParamsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetInspectParamsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetInspectParamsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInspectParamsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetInspectParamsResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetInspectParamsResponse);
		if (size)
			*size = sizeof(_ns1__GetInspectParamsResponse);
		((_ns1__GetInspectParamsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetInspectParamsResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetInspectParamsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetInspectParamsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetInspectParamsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetInspectParamsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetInspectParamsResponse %p -> %p\n", q, p));
	*(_ns1__GetInspectParamsResponse*)p = *(_ns1__GetInspectParamsResponse*)q;
}

void _ns1__GetInspectParams::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetInspectParams::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns1__GetInspectParams::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInspectParams(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInspectParams(struct soap *soap, const char *tag, int id, const _ns1__GetInspectParams *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInspectParams), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInspectParams::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInspectParams(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInspectParams * SOAP_FMAC4 soap_in__ns1__GetInspectParams(struct soap *soap, const char *tag, _ns1__GetInspectParams *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInspectParams *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInspectParams, sizeof(_ns1__GetInspectParams), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetInspectParams)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetInspectParams *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInspectParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInspectParams, 0, sizeof(_ns1__GetInspectParams), 0, soap_copy__ns1__GetInspectParams);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetInspectParams::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetInspectParams);
	if (this->soap_out(soap, tag?tag:"ns1:GetInspectParams", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInspectParams::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInspectParams(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInspectParams * SOAP_FMAC4 soap_get__ns1__GetInspectParams(struct soap *soap, _ns1__GetInspectParams *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInspectParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetInspectParams * SOAP_FMAC2 soap_instantiate__ns1__GetInspectParams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInspectParams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetInspectParams, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetInspectParams);
		if (size)
			*size = sizeof(_ns1__GetInspectParams);
		((_ns1__GetInspectParams*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetInspectParams, n);
		if (size)
			*size = n * sizeof(_ns1__GetInspectParams);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetInspectParams*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetInspectParams*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetInspectParams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetInspectParams %p -> %p\n", q, p));
	*(_ns1__GetInspectParams*)p = *(_ns1__GetInspectParams*)q;
}

void _ns1__FuelEvaporationInspectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__FuelEvaporationInspectResponse::FuelEvaporationInspectResult = NULL;
	/* transient soap skipped */
}

void _ns1__FuelEvaporationInspectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__FuelEvaporationInspectResponse::FuelEvaporationInspectResult);
	/* transient soap skipped */
#endif
}

int _ns1__FuelEvaporationInspectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FuelEvaporationInspectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FuelEvaporationInspectResponse(struct soap *soap, const char *tag, int id, const _ns1__FuelEvaporationInspectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FuelEvaporationInspectResponse), type))
		return soap->error;
	if (a->FuelEvaporationInspectResult)
		soap_element_result(soap, "ns1:FuelEvaporationInspectResult");
	if (a->_ns1__FuelEvaporationInspectResponse::FuelEvaporationInspectResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:FuelEvaporationInspectResult", -1, &a->_ns1__FuelEvaporationInspectResponse::FuelEvaporationInspectResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:FuelEvaporationInspectResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__FuelEvaporationInspectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__FuelEvaporationInspectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FuelEvaporationInspectResponse * SOAP_FMAC4 soap_in__ns1__FuelEvaporationInspectResponse(struct soap *soap, const char *tag, _ns1__FuelEvaporationInspectResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FuelEvaporationInspectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FuelEvaporationInspectResponse, sizeof(_ns1__FuelEvaporationInspectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__FuelEvaporationInspectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__FuelEvaporationInspectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FuelEvaporationInspectResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FuelEvaporationInspectResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:FuelEvaporationInspectResult", &(a->_ns1__FuelEvaporationInspectResponse::FuelEvaporationInspectResult), "ns1:RetValue"))
				{	soap_flag_FuelEvaporationInspectResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:FuelEvaporationInspectResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FuelEvaporationInspectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FuelEvaporationInspectResponse, 0, sizeof(_ns1__FuelEvaporationInspectResponse), 0, soap_copy__ns1__FuelEvaporationInspectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FuelEvaporationInspectResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__FuelEvaporationInspectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__FuelEvaporationInspectResponse);
	if (this->soap_out(soap, tag?tag:"ns1:FuelEvaporationInspectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FuelEvaporationInspectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FuelEvaporationInspectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FuelEvaporationInspectResponse * SOAP_FMAC4 soap_get__ns1__FuelEvaporationInspectResponse(struct soap *soap, _ns1__FuelEvaporationInspectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FuelEvaporationInspectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__FuelEvaporationInspectResponse * SOAP_FMAC2 soap_instantiate__ns1__FuelEvaporationInspectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FuelEvaporationInspectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__FuelEvaporationInspectResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__FuelEvaporationInspectResponse);
		if (size)
			*size = sizeof(_ns1__FuelEvaporationInspectResponse);
		((_ns1__FuelEvaporationInspectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__FuelEvaporationInspectResponse, n);
		if (size)
			*size = n * sizeof(_ns1__FuelEvaporationInspectResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__FuelEvaporationInspectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__FuelEvaporationInspectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__FuelEvaporationInspectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__FuelEvaporationInspectResponse %p -> %p\n", q, p));
	*(_ns1__FuelEvaporationInspectResponse*)p = *(_ns1__FuelEvaporationInspectResponse*)q;
}

void _ns1__FuelEvaporationInspect::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__FuelEvaporationInspect::ChannelID);
	this->_ns1__FuelEvaporationInspect::InspectID = NULL;
	this->_ns1__FuelEvaporationInspect::RYZFData = NULL;
	this->_ns1__FuelEvaporationInspect::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__FuelEvaporationInspect::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__FuelEvaporationInspect::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__FuelEvaporationInspect::RYZFData);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__FuelEvaporationInspect::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__FuelEvaporationInspect::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FuelEvaporationInspect(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FuelEvaporationInspect(struct soap *soap, const char *tag, int id, const _ns1__FuelEvaporationInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FuelEvaporationInspect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:ChannelID", -1, &(a->_ns1__FuelEvaporationInspect::ChannelID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__FuelEvaporationInspect::InspectID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:RYZFData", -1, &(a->_ns1__FuelEvaporationInspect::RYZFData), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__FuelEvaporationInspect::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__FuelEvaporationInspect::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__FuelEvaporationInspect(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FuelEvaporationInspect * SOAP_FMAC4 soap_in__ns1__FuelEvaporationInspect(struct soap *soap, const char *tag, _ns1__FuelEvaporationInspect *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FuelEvaporationInspect *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FuelEvaporationInspect, sizeof(_ns1__FuelEvaporationInspect), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__FuelEvaporationInspect)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__FuelEvaporationInspect *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ChannelID1 = 1;
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_RYZFData1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChannelID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:ChannelID", &(a->_ns1__FuelEvaporationInspect::ChannelID), "xsd:long"))
				{	soap_flag_ChannelID1--;
					continue;
				}
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__FuelEvaporationInspect::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_RYZFData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:RYZFData", &(a->_ns1__FuelEvaporationInspect::RYZFData), "xsd:string"))
				{	soap_flag_RYZFData1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__FuelEvaporationInspect::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__FuelEvaporationInspect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FuelEvaporationInspect, 0, sizeof(_ns1__FuelEvaporationInspect), 0, soap_copy__ns1__FuelEvaporationInspect);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__FuelEvaporationInspect::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__FuelEvaporationInspect);
	if (this->soap_out(soap, tag?tag:"ns1:FuelEvaporationInspect", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FuelEvaporationInspect::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FuelEvaporationInspect(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FuelEvaporationInspect * SOAP_FMAC4 soap_get__ns1__FuelEvaporationInspect(struct soap *soap, _ns1__FuelEvaporationInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FuelEvaporationInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__FuelEvaporationInspect * SOAP_FMAC2 soap_instantiate__ns1__FuelEvaporationInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FuelEvaporationInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__FuelEvaporationInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__FuelEvaporationInspect);
		if (size)
			*size = sizeof(_ns1__FuelEvaporationInspect);
		((_ns1__FuelEvaporationInspect*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__FuelEvaporationInspect, n);
		if (size)
			*size = n * sizeof(_ns1__FuelEvaporationInspect);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__FuelEvaporationInspect*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__FuelEvaporationInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__FuelEvaporationInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__FuelEvaporationInspect %p -> %p\n", q, p));
	*(_ns1__FuelEvaporationInspect*)p = *(_ns1__FuelEvaporationInspect*)q;
}

void _ns1__TestPhotoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__TestPhotoResponse::TestPhotoResult = NULL;
	/* transient soap skipped */
}

void _ns1__TestPhotoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__TestPhotoResponse::TestPhotoResult);
	/* transient soap skipped */
#endif
}

int _ns1__TestPhotoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TestPhotoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TestPhotoResponse(struct soap *soap, const char *tag, int id, const _ns1__TestPhotoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TestPhotoResponse), type))
		return soap->error;
	if (a->TestPhotoResult)
		soap_element_result(soap, "ns1:TestPhotoResult");
	if (a->_ns1__TestPhotoResponse::TestPhotoResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:TestPhotoResult", -1, &a->_ns1__TestPhotoResponse::TestPhotoResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:TestPhotoResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__TestPhotoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TestPhotoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TestPhotoResponse * SOAP_FMAC4 soap_in__ns1__TestPhotoResponse(struct soap *soap, const char *tag, _ns1__TestPhotoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TestPhotoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TestPhotoResponse, sizeof(_ns1__TestPhotoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__TestPhotoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__TestPhotoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TestPhotoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TestPhotoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:TestPhotoResult", &(a->_ns1__TestPhotoResponse::TestPhotoResult), "ns1:RetValue"))
				{	soap_flag_TestPhotoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:TestPhotoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TestPhotoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TestPhotoResponse, 0, sizeof(_ns1__TestPhotoResponse), 0, soap_copy__ns1__TestPhotoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TestPhotoResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__TestPhotoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__TestPhotoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:TestPhotoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TestPhotoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TestPhotoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TestPhotoResponse * SOAP_FMAC4 soap_get__ns1__TestPhotoResponse(struct soap *soap, _ns1__TestPhotoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TestPhotoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__TestPhotoResponse * SOAP_FMAC2 soap_instantiate__ns1__TestPhotoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TestPhotoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__TestPhotoResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__TestPhotoResponse);
		if (size)
			*size = sizeof(_ns1__TestPhotoResponse);
		((_ns1__TestPhotoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__TestPhotoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__TestPhotoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__TestPhotoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__TestPhotoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__TestPhotoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__TestPhotoResponse %p -> %p\n", q, p));
	*(_ns1__TestPhotoResponse*)p = *(_ns1__TestPhotoResponse*)q;
}

void _ns1__TestPhoto::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__TestPhoto::LineID);
	/* transient soap skipped */
}

void _ns1__TestPhoto::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns1__TestPhoto::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TestPhoto(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TestPhoto(struct soap *soap, const char *tag, int id, const _ns1__TestPhoto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TestPhoto), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:LineID", -1, &(a->_ns1__TestPhoto::LineID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__TestPhoto::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TestPhoto(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TestPhoto * SOAP_FMAC4 soap_in__ns1__TestPhoto(struct soap *soap, const char *tag, _ns1__TestPhoto *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TestPhoto *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TestPhoto, sizeof(_ns1__TestPhoto), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__TestPhoto)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__TestPhoto *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LineID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:LineID", &(a->_ns1__TestPhoto::LineID), "xsd:long"))
				{	soap_flag_LineID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TestPhoto *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TestPhoto, 0, sizeof(_ns1__TestPhoto), 0, soap_copy__ns1__TestPhoto);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LineID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__TestPhoto::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__TestPhoto);
	if (this->soap_out(soap, tag?tag:"ns1:TestPhoto", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TestPhoto::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TestPhoto(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TestPhoto * SOAP_FMAC4 soap_get__ns1__TestPhoto(struct soap *soap, _ns1__TestPhoto *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TestPhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__TestPhoto * SOAP_FMAC2 soap_instantiate__ns1__TestPhoto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TestPhoto(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__TestPhoto, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__TestPhoto);
		if (size)
			*size = sizeof(_ns1__TestPhoto);
		((_ns1__TestPhoto*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__TestPhoto, n);
		if (size)
			*size = n * sizeof(_ns1__TestPhoto);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__TestPhoto*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__TestPhoto*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__TestPhoto(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__TestPhoto %p -> %p\n", q, p));
	*(_ns1__TestPhoto*)p = *(_ns1__TestPhoto*)q;
}

void _ns1__EndCalibrateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EndCalibrateResponse::EndCalibrateResult = NULL;
	/* transient soap skipped */
}

void _ns1__EndCalibrateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__EndCalibrateResponse::EndCalibrateResult);
	/* transient soap skipped */
#endif
}

int _ns1__EndCalibrateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EndCalibrateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EndCalibrateResponse(struct soap *soap, const char *tag, int id, const _ns1__EndCalibrateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EndCalibrateResponse), type))
		return soap->error;
	if (a->EndCalibrateResult)
		soap_element_result(soap, "ns1:EndCalibrateResult");
	if (a->_ns1__EndCalibrateResponse::EndCalibrateResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:EndCalibrateResult", -1, &a->_ns1__EndCalibrateResponse::EndCalibrateResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:EndCalibrateResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__EndCalibrateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__EndCalibrateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EndCalibrateResponse * SOAP_FMAC4 soap_in__ns1__EndCalibrateResponse(struct soap *soap, const char *tag, _ns1__EndCalibrateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EndCalibrateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EndCalibrateResponse, sizeof(_ns1__EndCalibrateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__EndCalibrateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__EndCalibrateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EndCalibrateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EndCalibrateResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:EndCalibrateResult", &(a->_ns1__EndCalibrateResponse::EndCalibrateResult), "ns1:RetValue"))
				{	soap_flag_EndCalibrateResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:EndCalibrateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EndCalibrateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EndCalibrateResponse, 0, sizeof(_ns1__EndCalibrateResponse), 0, soap_copy__ns1__EndCalibrateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EndCalibrateResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__EndCalibrateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__EndCalibrateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:EndCalibrateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EndCalibrateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EndCalibrateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EndCalibrateResponse * SOAP_FMAC4 soap_get__ns1__EndCalibrateResponse(struct soap *soap, _ns1__EndCalibrateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EndCalibrateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__EndCalibrateResponse * SOAP_FMAC2 soap_instantiate__ns1__EndCalibrateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EndCalibrateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__EndCalibrateResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__EndCalibrateResponse);
		if (size)
			*size = sizeof(_ns1__EndCalibrateResponse);
		((_ns1__EndCalibrateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__EndCalibrateResponse, n);
		if (size)
			*size = n * sizeof(_ns1__EndCalibrateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__EndCalibrateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__EndCalibrateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__EndCalibrateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__EndCalibrateResponse %p -> %p\n", q, p));
	*(_ns1__EndCalibrateResponse*)p = *(_ns1__EndCalibrateResponse*)q;
}

void _ns1__EndCalibrate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__EndCalibrate::LineID);
	this->_ns1__EndCalibrate::Result = NULL;
	this->_ns1__EndCalibrate::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__EndCalibrate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__EndCalibrate::Result);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__EndCalibrate::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__EndCalibrate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EndCalibrate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EndCalibrate(struct soap *soap, const char *tag, int id, const _ns1__EndCalibrate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EndCalibrate), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:LineID", -1, &(a->_ns1__EndCalibrate::LineID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Result", -1, &(a->_ns1__EndCalibrate::Result), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__EndCalibrate::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__EndCalibrate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__EndCalibrate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EndCalibrate * SOAP_FMAC4 soap_in__ns1__EndCalibrate(struct soap *soap, const char *tag, _ns1__EndCalibrate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EndCalibrate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EndCalibrate, sizeof(_ns1__EndCalibrate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__EndCalibrate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__EndCalibrate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LineID1 = 1;
	size_t soap_flag_Result1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:LineID", &(a->_ns1__EndCalibrate::LineID), "xsd:long"))
				{	soap_flag_LineID1--;
					continue;
				}
			if (soap_flag_Result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Result", &(a->_ns1__EndCalibrate::Result), "xsd:string"))
				{	soap_flag_Result1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__EndCalibrate::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EndCalibrate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EndCalibrate, 0, sizeof(_ns1__EndCalibrate), 0, soap_copy__ns1__EndCalibrate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LineID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__EndCalibrate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__EndCalibrate);
	if (this->soap_out(soap, tag?tag:"ns1:EndCalibrate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EndCalibrate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EndCalibrate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EndCalibrate * SOAP_FMAC4 soap_get__ns1__EndCalibrate(struct soap *soap, _ns1__EndCalibrate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EndCalibrate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__EndCalibrate * SOAP_FMAC2 soap_instantiate__ns1__EndCalibrate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EndCalibrate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__EndCalibrate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__EndCalibrate);
		if (size)
			*size = sizeof(_ns1__EndCalibrate);
		((_ns1__EndCalibrate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__EndCalibrate, n);
		if (size)
			*size = n * sizeof(_ns1__EndCalibrate);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__EndCalibrate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__EndCalibrate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__EndCalibrate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__EndCalibrate %p -> %p\n", q, p));
	*(_ns1__EndCalibrate*)p = *(_ns1__EndCalibrate*)q;
}

void _ns1__UploadCalibrateDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UploadCalibrateDataResponse::UploadCalibrateDataResult = NULL;
	/* transient soap skipped */
}

void _ns1__UploadCalibrateDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__UploadCalibrateDataResponse::UploadCalibrateDataResult);
	/* transient soap skipped */
#endif
}

int _ns1__UploadCalibrateDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadCalibrateDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadCalibrateDataResponse(struct soap *soap, const char *tag, int id, const _ns1__UploadCalibrateDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadCalibrateDataResponse), type))
		return soap->error;
	if (a->UploadCalibrateDataResult)
		soap_element_result(soap, "ns1:UploadCalibrateDataResult");
	if (a->_ns1__UploadCalibrateDataResponse::UploadCalibrateDataResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:UploadCalibrateDataResult", -1, &a->_ns1__UploadCalibrateDataResponse::UploadCalibrateDataResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:UploadCalibrateDataResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadCalibrateDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadCalibrateDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadCalibrateDataResponse * SOAP_FMAC4 soap_in__ns1__UploadCalibrateDataResponse(struct soap *soap, const char *tag, _ns1__UploadCalibrateDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadCalibrateDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadCalibrateDataResponse, sizeof(_ns1__UploadCalibrateDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UploadCalibrateDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UploadCalibrateDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UploadCalibrateDataResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadCalibrateDataResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:UploadCalibrateDataResult", &(a->_ns1__UploadCalibrateDataResponse::UploadCalibrateDataResult), "ns1:RetValue"))
				{	soap_flag_UploadCalibrateDataResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UploadCalibrateDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadCalibrateDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadCalibrateDataResponse, 0, sizeof(_ns1__UploadCalibrateDataResponse), 0, soap_copy__ns1__UploadCalibrateDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadCalibrateDataResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__UploadCalibrateDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UploadCalibrateDataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UploadCalibrateDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadCalibrateDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadCalibrateDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadCalibrateDataResponse * SOAP_FMAC4 soap_get__ns1__UploadCalibrateDataResponse(struct soap *soap, _ns1__UploadCalibrateDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadCalibrateDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UploadCalibrateDataResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadCalibrateDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadCalibrateDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadCalibrateDataResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UploadCalibrateDataResponse);
		if (size)
			*size = sizeof(_ns1__UploadCalibrateDataResponse);
		((_ns1__UploadCalibrateDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UploadCalibrateDataResponse, n);
		if (size)
			*size = n * sizeof(_ns1__UploadCalibrateDataResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UploadCalibrateDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UploadCalibrateDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadCalibrateDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadCalibrateDataResponse %p -> %p\n", q, p));
	*(_ns1__UploadCalibrateDataResponse*)p = *(_ns1__UploadCalibrateDataResponse*)q;
}

void _ns1__UploadCalibrateData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__UploadCalibrateData::LineID);
	this->_ns1__UploadCalibrateData::ResultData = NULL;
	this->_ns1__UploadCalibrateData::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__UploadCalibrateData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__UploadCalibrateData::ResultData);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__UploadCalibrateData::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__UploadCalibrateData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadCalibrateData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadCalibrateData(struct soap *soap, const char *tag, int id, const _ns1__UploadCalibrateData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadCalibrateData), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:LineID", -1, &(a->_ns1__UploadCalibrateData::LineID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:ResultData", -1, &(a->_ns1__UploadCalibrateData::ResultData), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__UploadCalibrateData::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadCalibrateData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadCalibrateData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadCalibrateData * SOAP_FMAC4 soap_in__ns1__UploadCalibrateData(struct soap *soap, const char *tag, _ns1__UploadCalibrateData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadCalibrateData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadCalibrateData, sizeof(_ns1__UploadCalibrateData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UploadCalibrateData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UploadCalibrateData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LineID1 = 1;
	size_t soap_flag_ResultData1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:LineID", &(a->_ns1__UploadCalibrateData::LineID), "xsd:long"))
				{	soap_flag_LineID1--;
					continue;
				}
			if (soap_flag_ResultData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:ResultData", &(a->_ns1__UploadCalibrateData::ResultData), "xsd:string"))
				{	soap_flag_ResultData1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__UploadCalibrateData::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadCalibrateData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadCalibrateData, 0, sizeof(_ns1__UploadCalibrateData), 0, soap_copy__ns1__UploadCalibrateData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LineID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__UploadCalibrateData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UploadCalibrateData);
	if (this->soap_out(soap, tag?tag:"ns1:UploadCalibrateData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadCalibrateData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadCalibrateData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadCalibrateData * SOAP_FMAC4 soap_get__ns1__UploadCalibrateData(struct soap *soap, _ns1__UploadCalibrateData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadCalibrateData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UploadCalibrateData * SOAP_FMAC2 soap_instantiate__ns1__UploadCalibrateData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadCalibrateData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadCalibrateData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UploadCalibrateData);
		if (size)
			*size = sizeof(_ns1__UploadCalibrateData);
		((_ns1__UploadCalibrateData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UploadCalibrateData, n);
		if (size)
			*size = n * sizeof(_ns1__UploadCalibrateData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UploadCalibrateData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UploadCalibrateData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadCalibrateData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadCalibrateData %p -> %p\n", q, p));
	*(_ns1__UploadCalibrateData*)p = *(_ns1__UploadCalibrateData*)q;
}

void _ns1__BeginCalibrateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BeginCalibrateResponse::BeginCalibrateResult = NULL;
	/* transient soap skipped */
}

void _ns1__BeginCalibrateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__BeginCalibrateResponse::BeginCalibrateResult);
	/* transient soap skipped */
#endif
}

int _ns1__BeginCalibrateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BeginCalibrateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BeginCalibrateResponse(struct soap *soap, const char *tag, int id, const _ns1__BeginCalibrateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BeginCalibrateResponse), type))
		return soap->error;
	if (a->BeginCalibrateResult)
		soap_element_result(soap, "ns1:BeginCalibrateResult");
	if (a->_ns1__BeginCalibrateResponse::BeginCalibrateResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:BeginCalibrateResult", -1, &a->_ns1__BeginCalibrateResponse::BeginCalibrateResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:BeginCalibrateResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__BeginCalibrateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BeginCalibrateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BeginCalibrateResponse * SOAP_FMAC4 soap_in__ns1__BeginCalibrateResponse(struct soap *soap, const char *tag, _ns1__BeginCalibrateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BeginCalibrateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BeginCalibrateResponse, sizeof(_ns1__BeginCalibrateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__BeginCalibrateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__BeginCalibrateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_BeginCalibrateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BeginCalibrateResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:BeginCalibrateResult", &(a->_ns1__BeginCalibrateResponse::BeginCalibrateResult), "ns1:RetValue"))
				{	soap_flag_BeginCalibrateResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:BeginCalibrateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BeginCalibrateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BeginCalibrateResponse, 0, sizeof(_ns1__BeginCalibrateResponse), 0, soap_copy__ns1__BeginCalibrateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BeginCalibrateResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__BeginCalibrateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__BeginCalibrateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:BeginCalibrateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BeginCalibrateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BeginCalibrateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BeginCalibrateResponse * SOAP_FMAC4 soap_get__ns1__BeginCalibrateResponse(struct soap *soap, _ns1__BeginCalibrateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BeginCalibrateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__BeginCalibrateResponse * SOAP_FMAC2 soap_instantiate__ns1__BeginCalibrateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BeginCalibrateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__BeginCalibrateResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__BeginCalibrateResponse);
		if (size)
			*size = sizeof(_ns1__BeginCalibrateResponse);
		((_ns1__BeginCalibrateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__BeginCalibrateResponse, n);
		if (size)
			*size = n * sizeof(_ns1__BeginCalibrateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__BeginCalibrateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__BeginCalibrateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__BeginCalibrateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__BeginCalibrateResponse %p -> %p\n", q, p));
	*(_ns1__BeginCalibrateResponse*)p = *(_ns1__BeginCalibrateResponse*)q;
}

void _ns1__BeginCalibrate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__BeginCalibrate::LineID);
	this->_ns1__BeginCalibrate::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__BeginCalibrate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__BeginCalibrate::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__BeginCalibrate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BeginCalibrate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BeginCalibrate(struct soap *soap, const char *tag, int id, const _ns1__BeginCalibrate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BeginCalibrate), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:LineID", -1, &(a->_ns1__BeginCalibrate::LineID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__BeginCalibrate::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__BeginCalibrate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BeginCalibrate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BeginCalibrate * SOAP_FMAC4 soap_in__ns1__BeginCalibrate(struct soap *soap, const char *tag, _ns1__BeginCalibrate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BeginCalibrate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BeginCalibrate, sizeof(_ns1__BeginCalibrate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__BeginCalibrate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__BeginCalibrate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LineID1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:LineID", &(a->_ns1__BeginCalibrate::LineID), "xsd:long"))
				{	soap_flag_LineID1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__BeginCalibrate::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BeginCalibrate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BeginCalibrate, 0, sizeof(_ns1__BeginCalibrate), 0, soap_copy__ns1__BeginCalibrate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LineID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__BeginCalibrate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__BeginCalibrate);
	if (this->soap_out(soap, tag?tag:"ns1:BeginCalibrate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BeginCalibrate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BeginCalibrate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BeginCalibrate * SOAP_FMAC4 soap_get__ns1__BeginCalibrate(struct soap *soap, _ns1__BeginCalibrate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BeginCalibrate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__BeginCalibrate * SOAP_FMAC2 soap_instantiate__ns1__BeginCalibrate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BeginCalibrate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__BeginCalibrate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__BeginCalibrate);
		if (size)
			*size = sizeof(_ns1__BeginCalibrate);
		((_ns1__BeginCalibrate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__BeginCalibrate, n);
		if (size)
			*size = n * sizeof(_ns1__BeginCalibrate);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__BeginCalibrate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__BeginCalibrate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__BeginCalibrate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__BeginCalibrate %p -> %p\n", q, p));
	*(_ns1__BeginCalibrate*)p = *(_ns1__BeginCalibrate*)q;
}

void _ns1__GetInspectionInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetInspectionInfoResponse::GetInspectionInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetInspectionInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__GetInspectionInfoResponse::GetInspectionInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetInspectionInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInspectionInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInspectionInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetInspectionInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInspectionInfoResponse), type))
		return soap->error;
	if (a->GetInspectionInfoResult)
		soap_element_result(soap, "ns1:GetInspectionInfoResult");
	if (a->_ns1__GetInspectionInfoResponse::GetInspectionInfoResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:GetInspectionInfoResult", -1, &a->_ns1__GetInspectionInfoResponse::GetInspectionInfoResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetInspectionInfoResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInspectionInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInspectionInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInspectionInfoResponse * SOAP_FMAC4 soap_in__ns1__GetInspectionInfoResponse(struct soap *soap, const char *tag, _ns1__GetInspectionInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInspectionInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInspectionInfoResponse, sizeof(_ns1__GetInspectionInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetInspectionInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetInspectionInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetInspectionInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetInspectionInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:GetInspectionInfoResult", &(a->_ns1__GetInspectionInfoResponse::GetInspectionInfoResult), "ns1:RetValue"))
				{	soap_flag_GetInspectionInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetInspectionInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInspectionInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInspectionInfoResponse, 0, sizeof(_ns1__GetInspectionInfoResponse), 0, soap_copy__ns1__GetInspectionInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetInspectionInfoResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetInspectionInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetInspectionInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetInspectionInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInspectionInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInspectionInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInspectionInfoResponse * SOAP_FMAC4 soap_get__ns1__GetInspectionInfoResponse(struct soap *soap, _ns1__GetInspectionInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInspectionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetInspectionInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetInspectionInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInspectionInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetInspectionInfoResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetInspectionInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetInspectionInfoResponse);
		((_ns1__GetInspectionInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetInspectionInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetInspectionInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetInspectionInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetInspectionInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetInspectionInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetInspectionInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetInspectionInfoResponse*)p = *(_ns1__GetInspectionInfoResponse*)q;
}

void _ns1__GetInspectionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetInspectionInfo::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__GetInspectionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetInspectionInfo::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__GetInspectionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInspectionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInspectionInfo(struct soap *soap, const char *tag, int id, const _ns1__GetInspectionInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInspectionInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__GetInspectionInfo::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInspectionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInspectionInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInspectionInfo * SOAP_FMAC4 soap_in__ns1__GetInspectionInfo(struct soap *soap, const char *tag, _ns1__GetInspectionInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInspectionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInspectionInfo, sizeof(_ns1__GetInspectionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetInspectionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetInspectionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__GetInspectionInfo::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInspectionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInspectionInfo, 0, sizeof(_ns1__GetInspectionInfo), 0, soap_copy__ns1__GetInspectionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetInspectionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetInspectionInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetInspectionInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInspectionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInspectionInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInspectionInfo * SOAP_FMAC4 soap_get__ns1__GetInspectionInfo(struct soap *soap, _ns1__GetInspectionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInspectionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetInspectionInfo * SOAP_FMAC2 soap_instantiate__ns1__GetInspectionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInspectionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetInspectionInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetInspectionInfo);
		if (size)
			*size = sizeof(_ns1__GetInspectionInfo);
		((_ns1__GetInspectionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetInspectionInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetInspectionInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetInspectionInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetInspectionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetInspectionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetInspectionInfo %p -> %p\n", q, p));
	*(_ns1__GetInspectionInfo*)p = *(_ns1__GetInspectionInfo*)q;
}

void _ns1__UploadRealtimeDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UploadRealtimeDataResponse::UploadRealtimeDataResult = NULL;
	/* transient soap skipped */
}

void _ns1__UploadRealtimeDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__UploadRealtimeDataResponse::UploadRealtimeDataResult);
	/* transient soap skipped */
#endif
}

int _ns1__UploadRealtimeDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadRealtimeDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadRealtimeDataResponse(struct soap *soap, const char *tag, int id, const _ns1__UploadRealtimeDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadRealtimeDataResponse), type))
		return soap->error;
	if (a->UploadRealtimeDataResult)
		soap_element_result(soap, "ns1:UploadRealtimeDataResult");
	if (a->_ns1__UploadRealtimeDataResponse::UploadRealtimeDataResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:UploadRealtimeDataResult", -1, &a->_ns1__UploadRealtimeDataResponse::UploadRealtimeDataResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:UploadRealtimeDataResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadRealtimeDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadRealtimeDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadRealtimeDataResponse * SOAP_FMAC4 soap_in__ns1__UploadRealtimeDataResponse(struct soap *soap, const char *tag, _ns1__UploadRealtimeDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadRealtimeDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadRealtimeDataResponse, sizeof(_ns1__UploadRealtimeDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UploadRealtimeDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UploadRealtimeDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UploadRealtimeDataResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadRealtimeDataResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:UploadRealtimeDataResult", &(a->_ns1__UploadRealtimeDataResponse::UploadRealtimeDataResult), "ns1:RetValue"))
				{	soap_flag_UploadRealtimeDataResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UploadRealtimeDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadRealtimeDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadRealtimeDataResponse, 0, sizeof(_ns1__UploadRealtimeDataResponse), 0, soap_copy__ns1__UploadRealtimeDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadRealtimeDataResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__UploadRealtimeDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UploadRealtimeDataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UploadRealtimeDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadRealtimeDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadRealtimeDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadRealtimeDataResponse * SOAP_FMAC4 soap_get__ns1__UploadRealtimeDataResponse(struct soap *soap, _ns1__UploadRealtimeDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadRealtimeDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UploadRealtimeDataResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadRealtimeDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadRealtimeDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadRealtimeDataResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UploadRealtimeDataResponse);
		if (size)
			*size = sizeof(_ns1__UploadRealtimeDataResponse);
		((_ns1__UploadRealtimeDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UploadRealtimeDataResponse, n);
		if (size)
			*size = n * sizeof(_ns1__UploadRealtimeDataResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UploadRealtimeDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UploadRealtimeDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadRealtimeDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadRealtimeDataResponse %p -> %p\n", q, p));
	*(_ns1__UploadRealtimeDataResponse*)p = *(_ns1__UploadRealtimeDataResponse*)q;
}

void _ns1__UploadRealtimeData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UploadRealtimeData::InspectID = NULL;
	this->_ns1__UploadRealtimeData::RealtimeData = NULL;
	this->_ns1__UploadRealtimeData::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__UploadRealtimeData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__UploadRealtimeData::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__UploadRealtimeData::RealtimeData);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__UploadRealtimeData::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__UploadRealtimeData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadRealtimeData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadRealtimeData(struct soap *soap, const char *tag, int id, const _ns1__UploadRealtimeData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadRealtimeData), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__UploadRealtimeData::InspectID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:RealtimeData", -1, &(a->_ns1__UploadRealtimeData::RealtimeData), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__UploadRealtimeData::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadRealtimeData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadRealtimeData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadRealtimeData * SOAP_FMAC4 soap_in__ns1__UploadRealtimeData(struct soap *soap, const char *tag, _ns1__UploadRealtimeData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadRealtimeData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadRealtimeData, sizeof(_ns1__UploadRealtimeData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UploadRealtimeData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UploadRealtimeData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_RealtimeData1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__UploadRealtimeData::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_RealtimeData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:RealtimeData", &(a->_ns1__UploadRealtimeData::RealtimeData), "xsd:string"))
				{	soap_flag_RealtimeData1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__UploadRealtimeData::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadRealtimeData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadRealtimeData, 0, sizeof(_ns1__UploadRealtimeData), 0, soap_copy__ns1__UploadRealtimeData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UploadRealtimeData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UploadRealtimeData);
	if (this->soap_out(soap, tag?tag:"ns1:UploadRealtimeData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadRealtimeData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadRealtimeData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadRealtimeData * SOAP_FMAC4 soap_get__ns1__UploadRealtimeData(struct soap *soap, _ns1__UploadRealtimeData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadRealtimeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UploadRealtimeData * SOAP_FMAC2 soap_instantiate__ns1__UploadRealtimeData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadRealtimeData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadRealtimeData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UploadRealtimeData);
		if (size)
			*size = sizeof(_ns1__UploadRealtimeData);
		((_ns1__UploadRealtimeData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UploadRealtimeData, n);
		if (size)
			*size = n * sizeof(_ns1__UploadRealtimeData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UploadRealtimeData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UploadRealtimeData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadRealtimeData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadRealtimeData %p -> %p\n", q, p));
	*(_ns1__UploadRealtimeData*)p = *(_ns1__UploadRealtimeData*)q;
}

void _ns1__UploadSelfTestDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UploadSelfTestDataResponse::UploadSelfTestDataResult = NULL;
	/* transient soap skipped */
}

void _ns1__UploadSelfTestDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__UploadSelfTestDataResponse::UploadSelfTestDataResult);
	/* transient soap skipped */
#endif
}

int _ns1__UploadSelfTestDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadSelfTestDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadSelfTestDataResponse(struct soap *soap, const char *tag, int id, const _ns1__UploadSelfTestDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadSelfTestDataResponse), type))
		return soap->error;
	if (a->UploadSelfTestDataResult)
		soap_element_result(soap, "ns1:UploadSelfTestDataResult");
	if (a->_ns1__UploadSelfTestDataResponse::UploadSelfTestDataResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:UploadSelfTestDataResult", -1, &a->_ns1__UploadSelfTestDataResponse::UploadSelfTestDataResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:UploadSelfTestDataResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadSelfTestDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadSelfTestDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadSelfTestDataResponse * SOAP_FMAC4 soap_in__ns1__UploadSelfTestDataResponse(struct soap *soap, const char *tag, _ns1__UploadSelfTestDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadSelfTestDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadSelfTestDataResponse, sizeof(_ns1__UploadSelfTestDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UploadSelfTestDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UploadSelfTestDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UploadSelfTestDataResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadSelfTestDataResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:UploadSelfTestDataResult", &(a->_ns1__UploadSelfTestDataResponse::UploadSelfTestDataResult), "ns1:RetValue"))
				{	soap_flag_UploadSelfTestDataResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UploadSelfTestDataResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadSelfTestDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadSelfTestDataResponse, 0, sizeof(_ns1__UploadSelfTestDataResponse), 0, soap_copy__ns1__UploadSelfTestDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadSelfTestDataResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__UploadSelfTestDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UploadSelfTestDataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UploadSelfTestDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadSelfTestDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadSelfTestDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadSelfTestDataResponse * SOAP_FMAC4 soap_get__ns1__UploadSelfTestDataResponse(struct soap *soap, _ns1__UploadSelfTestDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadSelfTestDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UploadSelfTestDataResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadSelfTestDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadSelfTestDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadSelfTestDataResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UploadSelfTestDataResponse);
		if (size)
			*size = sizeof(_ns1__UploadSelfTestDataResponse);
		((_ns1__UploadSelfTestDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UploadSelfTestDataResponse, n);
		if (size)
			*size = n * sizeof(_ns1__UploadSelfTestDataResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UploadSelfTestDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UploadSelfTestDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadSelfTestDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadSelfTestDataResponse %p -> %p\n", q, p));
	*(_ns1__UploadSelfTestDataResponse*)p = *(_ns1__UploadSelfTestDataResponse*)q;
}

void _ns1__UploadSelfTestData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__UploadSelfTestData::LineID);
	this->_ns1__UploadSelfTestData::ResultData = NULL;
	this->_ns1__UploadSelfTestData::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__UploadSelfTestData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__UploadSelfTestData::ResultData);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__UploadSelfTestData::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__UploadSelfTestData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadSelfTestData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadSelfTestData(struct soap *soap, const char *tag, int id, const _ns1__UploadSelfTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadSelfTestData), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:LineID", -1, &(a->_ns1__UploadSelfTestData::LineID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:ResultData", -1, &(a->_ns1__UploadSelfTestData::ResultData), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__UploadSelfTestData::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadSelfTestData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadSelfTestData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadSelfTestData * SOAP_FMAC4 soap_in__ns1__UploadSelfTestData(struct soap *soap, const char *tag, _ns1__UploadSelfTestData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadSelfTestData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadSelfTestData, sizeof(_ns1__UploadSelfTestData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UploadSelfTestData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UploadSelfTestData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LineID1 = 1;
	size_t soap_flag_ResultData1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:LineID", &(a->_ns1__UploadSelfTestData::LineID), "xsd:long"))
				{	soap_flag_LineID1--;
					continue;
				}
			if (soap_flag_ResultData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:ResultData", &(a->_ns1__UploadSelfTestData::ResultData), "xsd:string"))
				{	soap_flag_ResultData1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__UploadSelfTestData::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadSelfTestData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadSelfTestData, 0, sizeof(_ns1__UploadSelfTestData), 0, soap_copy__ns1__UploadSelfTestData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LineID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__UploadSelfTestData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UploadSelfTestData);
	if (this->soap_out(soap, tag?tag:"ns1:UploadSelfTestData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadSelfTestData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadSelfTestData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadSelfTestData * SOAP_FMAC4 soap_get__ns1__UploadSelfTestData(struct soap *soap, _ns1__UploadSelfTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadSelfTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UploadSelfTestData * SOAP_FMAC2 soap_instantiate__ns1__UploadSelfTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadSelfTestData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadSelfTestData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UploadSelfTestData);
		if (size)
			*size = sizeof(_ns1__UploadSelfTestData);
		((_ns1__UploadSelfTestData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UploadSelfTestData, n);
		if (size)
			*size = n * sizeof(_ns1__UploadSelfTestData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UploadSelfTestData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UploadSelfTestData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadSelfTestData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadSelfTestData %p -> %p\n", q, p));
	*(_ns1__UploadSelfTestData*)p = *(_ns1__UploadSelfTestData*)q;
}

void _ns1__EndInspectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EndInspectResponse::EndInspectResult = NULL;
	/* transient soap skipped */
}

void _ns1__EndInspectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__EndInspectResponse::EndInspectResult);
	/* transient soap skipped */
#endif
}

int _ns1__EndInspectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EndInspectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EndInspectResponse(struct soap *soap, const char *tag, int id, const _ns1__EndInspectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EndInspectResponse), type))
		return soap->error;
	if (a->EndInspectResult)
		soap_element_result(soap, "ns1:EndInspectResult");
	if (a->_ns1__EndInspectResponse::EndInspectResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:EndInspectResult", -1, &a->_ns1__EndInspectResponse::EndInspectResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:EndInspectResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__EndInspectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__EndInspectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EndInspectResponse * SOAP_FMAC4 soap_in__ns1__EndInspectResponse(struct soap *soap, const char *tag, _ns1__EndInspectResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EndInspectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EndInspectResponse, sizeof(_ns1__EndInspectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__EndInspectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__EndInspectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EndInspectResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EndInspectResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:EndInspectResult", &(a->_ns1__EndInspectResponse::EndInspectResult), "ns1:RetValue"))
				{	soap_flag_EndInspectResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:EndInspectResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EndInspectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EndInspectResponse, 0, sizeof(_ns1__EndInspectResponse), 0, soap_copy__ns1__EndInspectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EndInspectResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__EndInspectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__EndInspectResponse);
	if (this->soap_out(soap, tag?tag:"ns1:EndInspectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EndInspectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EndInspectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EndInspectResponse * SOAP_FMAC4 soap_get__ns1__EndInspectResponse(struct soap *soap, _ns1__EndInspectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EndInspectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__EndInspectResponse * SOAP_FMAC2 soap_instantiate__ns1__EndInspectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EndInspectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__EndInspectResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__EndInspectResponse);
		if (size)
			*size = sizeof(_ns1__EndInspectResponse);
		((_ns1__EndInspectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__EndInspectResponse, n);
		if (size)
			*size = n * sizeof(_ns1__EndInspectResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__EndInspectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__EndInspectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__EndInspectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__EndInspectResponse %p -> %p\n", q, p));
	*(_ns1__EndInspectResponse*)p = *(_ns1__EndInspectResponse*)q;
}

void _ns1__EndInspect::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EndInspect::InspectID = NULL;
	this->_ns1__EndInspect::Result = NULL;
	this->_ns1__EndInspect::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__EndInspect::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__EndInspect::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__EndInspect::Result);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__EndInspect::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__EndInspect::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EndInspect(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EndInspect(struct soap *soap, const char *tag, int id, const _ns1__EndInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EndInspect), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__EndInspect::InspectID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Result", -1, &(a->_ns1__EndInspect::Result), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__EndInspect::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__EndInspect::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__EndInspect(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EndInspect * SOAP_FMAC4 soap_in__ns1__EndInspect(struct soap *soap, const char *tag, _ns1__EndInspect *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EndInspect *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EndInspect, sizeof(_ns1__EndInspect), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__EndInspect)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__EndInspect *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_Result1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__EndInspect::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_Result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Result", &(a->_ns1__EndInspect::Result), "xsd:string"))
				{	soap_flag_Result1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__EndInspect::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EndInspect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EndInspect, 0, sizeof(_ns1__EndInspect), 0, soap_copy__ns1__EndInspect);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__EndInspect::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__EndInspect);
	if (this->soap_out(soap, tag?tag:"ns1:EndInspect", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EndInspect::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EndInspect(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EndInspect * SOAP_FMAC4 soap_get__ns1__EndInspect(struct soap *soap, _ns1__EndInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EndInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__EndInspect * SOAP_FMAC2 soap_instantiate__ns1__EndInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EndInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__EndInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__EndInspect);
		if (size)
			*size = sizeof(_ns1__EndInspect);
		((_ns1__EndInspect*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__EndInspect, n);
		if (size)
			*size = n * sizeof(_ns1__EndInspect);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__EndInspect*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__EndInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__EndInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__EndInspect %p -> %p\n", q, p));
	*(_ns1__EndInspect*)p = *(_ns1__EndInspect*)q;
}

void _ns1__StopInspectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__StopInspectResponse::StopInspectResult = NULL;
	/* transient soap skipped */
}

void _ns1__StopInspectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__StopInspectResponse::StopInspectResult);
	/* transient soap skipped */
#endif
}

int _ns1__StopInspectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopInspectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopInspectResponse(struct soap *soap, const char *tag, int id, const _ns1__StopInspectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopInspectResponse), type))
		return soap->error;
	if (a->StopInspectResult)
		soap_element_result(soap, "ns1:StopInspectResult");
	if (a->_ns1__StopInspectResponse::StopInspectResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:StopInspectResult", -1, &a->_ns1__StopInspectResponse::StopInspectResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:StopInspectResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopInspectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopInspectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopInspectResponse * SOAP_FMAC4 soap_in__ns1__StopInspectResponse(struct soap *soap, const char *tag, _ns1__StopInspectResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopInspectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopInspectResponse, sizeof(_ns1__StopInspectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopInspectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopInspectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_StopInspectResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StopInspectResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:StopInspectResult", &(a->_ns1__StopInspectResponse::StopInspectResult), "ns1:RetValue"))
				{	soap_flag_StopInspectResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:StopInspectResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopInspectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopInspectResponse, 0, sizeof(_ns1__StopInspectResponse), 0, soap_copy__ns1__StopInspectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StopInspectResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__StopInspectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__StopInspectResponse);
	if (this->soap_out(soap, tag?tag:"ns1:StopInspectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StopInspectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopInspectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopInspectResponse * SOAP_FMAC4 soap_get__ns1__StopInspectResponse(struct soap *soap, _ns1__StopInspectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopInspectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__StopInspectResponse * SOAP_FMAC2 soap_instantiate__ns1__StopInspectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopInspectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopInspectResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__StopInspectResponse);
		if (size)
			*size = sizeof(_ns1__StopInspectResponse);
		((_ns1__StopInspectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__StopInspectResponse, n);
		if (size)
			*size = n * sizeof(_ns1__StopInspectResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__StopInspectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__StopInspectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopInspectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopInspectResponse %p -> %p\n", q, p));
	*(_ns1__StopInspectResponse*)p = *(_ns1__StopInspectResponse*)q;
}

void _ns1__StopInspect::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__StopInspect::InspectID = NULL;
	this->_ns1__StopInspect::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__StopInspect::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__StopInspect::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__StopInspect::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__StopInspect::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopInspect(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopInspect(struct soap *soap, const char *tag, int id, const _ns1__StopInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopInspect), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__StopInspect::InspectID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__StopInspect::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopInspect::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopInspect(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopInspect * SOAP_FMAC4 soap_in__ns1__StopInspect(struct soap *soap, const char *tag, _ns1__StopInspect *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopInspect *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopInspect, sizeof(_ns1__StopInspect), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__StopInspect)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__StopInspect *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__StopInspect::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__StopInspect::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__StopInspect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopInspect, 0, sizeof(_ns1__StopInspect), 0, soap_copy__ns1__StopInspect);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__StopInspect::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__StopInspect);
	if (this->soap_out(soap, tag?tag:"ns1:StopInspect", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StopInspect::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopInspect(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopInspect * SOAP_FMAC4 soap_get__ns1__StopInspect(struct soap *soap, _ns1__StopInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__StopInspect * SOAP_FMAC2 soap_instantiate__ns1__StopInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__StopInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__StopInspect);
		if (size)
			*size = sizeof(_ns1__StopInspect);
		((_ns1__StopInspect*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__StopInspect, n);
		if (size)
			*size = n * sizeof(_ns1__StopInspect);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__StopInspect*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__StopInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__StopInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__StopInspect %p -> %p\n", q, p));
	*(_ns1__StopInspect*)p = *(_ns1__StopInspect*)q;
}

void _ns1__WJTakePhotoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__WJTakePhotoResponse::WJTakePhotoResult = NULL;
	/* transient soap skipped */
}

void _ns1__WJTakePhotoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__WJTakePhotoResponse::WJTakePhotoResult);
	/* transient soap skipped */
#endif
}

int _ns1__WJTakePhotoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WJTakePhotoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WJTakePhotoResponse(struct soap *soap, const char *tag, int id, const _ns1__WJTakePhotoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WJTakePhotoResponse), type))
		return soap->error;
	if (a->WJTakePhotoResult)
		soap_element_result(soap, "ns1:WJTakePhotoResult");
	if (a->_ns1__WJTakePhotoResponse::WJTakePhotoResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:WJTakePhotoResult", -1, &a->_ns1__WJTakePhotoResponse::WJTakePhotoResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:WJTakePhotoResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__WJTakePhotoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WJTakePhotoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WJTakePhotoResponse * SOAP_FMAC4 soap_in__ns1__WJTakePhotoResponse(struct soap *soap, const char *tag, _ns1__WJTakePhotoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WJTakePhotoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WJTakePhotoResponse, sizeof(_ns1__WJTakePhotoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__WJTakePhotoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__WJTakePhotoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_WJTakePhotoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WJTakePhotoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:WJTakePhotoResult", &(a->_ns1__WJTakePhotoResponse::WJTakePhotoResult), "ns1:RetValue"))
				{	soap_flag_WJTakePhotoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:WJTakePhotoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__WJTakePhotoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WJTakePhotoResponse, 0, sizeof(_ns1__WJTakePhotoResponse), 0, soap_copy__ns1__WJTakePhotoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_WJTakePhotoResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__WJTakePhotoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__WJTakePhotoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:WJTakePhotoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__WJTakePhotoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WJTakePhotoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WJTakePhotoResponse * SOAP_FMAC4 soap_get__ns1__WJTakePhotoResponse(struct soap *soap, _ns1__WJTakePhotoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WJTakePhotoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__WJTakePhotoResponse * SOAP_FMAC2 soap_instantiate__ns1__WJTakePhotoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WJTakePhotoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__WJTakePhotoResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__WJTakePhotoResponse);
		if (size)
			*size = sizeof(_ns1__WJTakePhotoResponse);
		((_ns1__WJTakePhotoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__WJTakePhotoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__WJTakePhotoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__WJTakePhotoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__WJTakePhotoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__WJTakePhotoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__WJTakePhotoResponse %p -> %p\n", q, p));
	*(_ns1__WJTakePhotoResponse*)p = *(_ns1__WJTakePhotoResponse*)q;
}

void _ns1__WJTakePhoto::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__WJTakePhoto::ChannelID);
	this->_ns1__WJTakePhoto::InspectID = NULL;
	soap_default_int(soap, &this->_ns1__WJTakePhoto::PicCode);
	this->_ns1__WJTakePhoto::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__WJTakePhoto::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__WJTakePhoto::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__WJTakePhoto::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__WJTakePhoto::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WJTakePhoto(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WJTakePhoto(struct soap *soap, const char *tag, int id, const _ns1__WJTakePhoto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WJTakePhoto), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:ChannelID", -1, &(a->_ns1__WJTakePhoto::ChannelID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__WJTakePhoto::InspectID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PicCode", -1, &(a->_ns1__WJTakePhoto::PicCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__WJTakePhoto::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__WJTakePhoto::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WJTakePhoto(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WJTakePhoto * SOAP_FMAC4 soap_in__ns1__WJTakePhoto(struct soap *soap, const char *tag, _ns1__WJTakePhoto *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WJTakePhoto *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WJTakePhoto, sizeof(_ns1__WJTakePhoto), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__WJTakePhoto)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__WJTakePhoto *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ChannelID1 = 1;
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_PicCode1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChannelID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:ChannelID", &(a->_ns1__WJTakePhoto::ChannelID), "xsd:long"))
				{	soap_flag_ChannelID1--;
					continue;
				}
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__WJTakePhoto::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_PicCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PicCode", &(a->_ns1__WJTakePhoto::PicCode), "xsd:int"))
				{	soap_flag_PicCode1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__WJTakePhoto::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__WJTakePhoto *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WJTakePhoto, 0, sizeof(_ns1__WJTakePhoto), 0, soap_copy__ns1__WJTakePhoto);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelID1 > 0 || soap_flag_PicCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__WJTakePhoto::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__WJTakePhoto);
	if (this->soap_out(soap, tag?tag:"ns1:WJTakePhoto", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__WJTakePhoto::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WJTakePhoto(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WJTakePhoto * SOAP_FMAC4 soap_get__ns1__WJTakePhoto(struct soap *soap, _ns1__WJTakePhoto *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WJTakePhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__WJTakePhoto * SOAP_FMAC2 soap_instantiate__ns1__WJTakePhoto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WJTakePhoto(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__WJTakePhoto, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__WJTakePhoto);
		if (size)
			*size = sizeof(_ns1__WJTakePhoto);
		((_ns1__WJTakePhoto*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__WJTakePhoto, n);
		if (size)
			*size = n * sizeof(_ns1__WJTakePhoto);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__WJTakePhoto*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__WJTakePhoto*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__WJTakePhoto(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__WJTakePhoto %p -> %p\n", q, p));
	*(_ns1__WJTakePhoto*)p = *(_ns1__WJTakePhoto*)q;
}

void _ns1__TakePhotoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__TakePhotoResponse::TakePhotoResult = NULL;
	/* transient soap skipped */
}

void _ns1__TakePhotoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__TakePhotoResponse::TakePhotoResult);
	/* transient soap skipped */
#endif
}

int _ns1__TakePhotoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TakePhotoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TakePhotoResponse(struct soap *soap, const char *tag, int id, const _ns1__TakePhotoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TakePhotoResponse), type))
		return soap->error;
	if (a->TakePhotoResult)
		soap_element_result(soap, "ns1:TakePhotoResult");
	if (a->_ns1__TakePhotoResponse::TakePhotoResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:TakePhotoResult", -1, &a->_ns1__TakePhotoResponse::TakePhotoResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:TakePhotoResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__TakePhotoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TakePhotoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TakePhotoResponse * SOAP_FMAC4 soap_in__ns1__TakePhotoResponse(struct soap *soap, const char *tag, _ns1__TakePhotoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TakePhotoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TakePhotoResponse, sizeof(_ns1__TakePhotoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__TakePhotoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__TakePhotoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TakePhotoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TakePhotoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:TakePhotoResult", &(a->_ns1__TakePhotoResponse::TakePhotoResult), "ns1:RetValue"))
				{	soap_flag_TakePhotoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:TakePhotoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TakePhotoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TakePhotoResponse, 0, sizeof(_ns1__TakePhotoResponse), 0, soap_copy__ns1__TakePhotoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TakePhotoResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__TakePhotoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__TakePhotoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:TakePhotoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TakePhotoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TakePhotoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TakePhotoResponse * SOAP_FMAC4 soap_get__ns1__TakePhotoResponse(struct soap *soap, _ns1__TakePhotoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TakePhotoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__TakePhotoResponse * SOAP_FMAC2 soap_instantiate__ns1__TakePhotoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TakePhotoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__TakePhotoResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__TakePhotoResponse);
		if (size)
			*size = sizeof(_ns1__TakePhotoResponse);
		((_ns1__TakePhotoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__TakePhotoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__TakePhotoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__TakePhotoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__TakePhotoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__TakePhotoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__TakePhotoResponse %p -> %p\n", q, p));
	*(_ns1__TakePhotoResponse*)p = *(_ns1__TakePhotoResponse*)q;
}

void _ns1__TakePhoto::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__TakePhoto::LineID);
	this->_ns1__TakePhoto::InspectID = NULL;
	soap_default_int(soap, &this->_ns1__TakePhoto::PicCode);
	this->_ns1__TakePhoto::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__TakePhoto::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__TakePhoto::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__TakePhoto::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__TakePhoto::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__TakePhoto(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__TakePhoto(struct soap *soap, const char *tag, int id, const _ns1__TakePhoto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__TakePhoto), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:LineID", -1, &(a->_ns1__TakePhoto::LineID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__TakePhoto::InspectID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PicCode", -1, &(a->_ns1__TakePhoto::PicCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__TakePhoto::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__TakePhoto::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__TakePhoto(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__TakePhoto * SOAP_FMAC4 soap_in__ns1__TakePhoto(struct soap *soap, const char *tag, _ns1__TakePhoto *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__TakePhoto *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__TakePhoto, sizeof(_ns1__TakePhoto), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__TakePhoto)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__TakePhoto *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LineID1 = 1;
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_PicCode1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:LineID", &(a->_ns1__TakePhoto::LineID), "xsd:long"))
				{	soap_flag_LineID1--;
					continue;
				}
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__TakePhoto::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_PicCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PicCode", &(a->_ns1__TakePhoto::PicCode), "xsd:int"))
				{	soap_flag_PicCode1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__TakePhoto::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__TakePhoto *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__TakePhoto, 0, sizeof(_ns1__TakePhoto), 0, soap_copy__ns1__TakePhoto);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LineID1 > 0 || soap_flag_PicCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__TakePhoto::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__TakePhoto);
	if (this->soap_out(soap, tag?tag:"ns1:TakePhoto", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__TakePhoto::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__TakePhoto(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__TakePhoto * SOAP_FMAC4 soap_get__ns1__TakePhoto(struct soap *soap, _ns1__TakePhoto *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__TakePhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__TakePhoto * SOAP_FMAC2 soap_instantiate__ns1__TakePhoto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__TakePhoto(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__TakePhoto, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__TakePhoto);
		if (size)
			*size = sizeof(_ns1__TakePhoto);
		((_ns1__TakePhoto*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__TakePhoto, n);
		if (size)
			*size = n * sizeof(_ns1__TakePhoto);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__TakePhoto*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__TakePhoto*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__TakePhoto(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__TakePhoto %p -> %p\n", q, p));
	*(_ns1__TakePhoto*)p = *(_ns1__TakePhoto*)q;
}

void _ns1__GetLimitResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLimitResponse::GetLimitResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetLimitResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__GetLimitResponse::GetLimitResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetLimitResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLimitResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLimitResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLimitResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLimitResponse), type))
		return soap->error;
	if (a->GetLimitResult)
		soap_element_result(soap, "ns1:GetLimitResult");
	if (a->_ns1__GetLimitResponse::GetLimitResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:GetLimitResult", -1, &a->_ns1__GetLimitResponse::GetLimitResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetLimitResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLimitResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLimitResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLimitResponse * SOAP_FMAC4 soap_in__ns1__GetLimitResponse(struct soap *soap, const char *tag, _ns1__GetLimitResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLimitResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLimitResponse, sizeof(_ns1__GetLimitResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLimitResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLimitResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetLimitResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLimitResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:GetLimitResult", &(a->_ns1__GetLimitResponse::GetLimitResult), "ns1:RetValue"))
				{	soap_flag_GetLimitResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetLimitResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLimitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLimitResponse, 0, sizeof(_ns1__GetLimitResponse), 0, soap_copy__ns1__GetLimitResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetLimitResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetLimitResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetLimitResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetLimitResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLimitResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLimitResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLimitResponse * SOAP_FMAC4 soap_get__ns1__GetLimitResponse(struct soap *soap, _ns1__GetLimitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLimitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLimitResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLimitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLimitResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLimitResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLimitResponse);
		if (size)
			*size = sizeof(_ns1__GetLimitResponse);
		((_ns1__GetLimitResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLimitResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetLimitResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetLimitResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLimitResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLimitResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLimitResponse %p -> %p\n", q, p));
	*(_ns1__GetLimitResponse*)p = *(_ns1__GetLimitResponse*)q;
}

void _ns1__GetLimit::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLimit::InspectID = NULL;
	this->_ns1__GetLimit::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__GetLimit::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetLimit::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetLimit::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__GetLimit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLimit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLimit(struct soap *soap, const char *tag, int id, const _ns1__GetLimit *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLimit), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__GetLimit::InspectID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__GetLimit::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLimit::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLimit(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLimit * SOAP_FMAC4 soap_in__ns1__GetLimit(struct soap *soap, const char *tag, _ns1__GetLimit *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLimit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLimit, sizeof(_ns1__GetLimit), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLimit)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLimit *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__GetLimit::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__GetLimit::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLimit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLimit, 0, sizeof(_ns1__GetLimit), 0, soap_copy__ns1__GetLimit);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetLimit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetLimit);
	if (this->soap_out(soap, tag?tag:"ns1:GetLimit", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLimit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLimit(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLimit * SOAP_FMAC4 soap_get__ns1__GetLimit(struct soap *soap, _ns1__GetLimit *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLimit * SOAP_FMAC2 soap_instantiate__ns1__GetLimit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLimit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLimit, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLimit);
		if (size)
			*size = sizeof(_ns1__GetLimit);
		((_ns1__GetLimit*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLimit, n);
		if (size)
			*size = n * sizeof(_ns1__GetLimit);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetLimit*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLimit*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLimit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLimit %p -> %p\n", q, p));
	*(_ns1__GetLimit*)p = *(_ns1__GetLimit*)q;
}

void _ns1__BeginInspectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BeginInspectResponse::BeginInspectResult = NULL;
	/* transient soap skipped */
}

void _ns1__BeginInspectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__BeginInspectResponse::BeginInspectResult);
	/* transient soap skipped */
#endif
}

int _ns1__BeginInspectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BeginInspectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BeginInspectResponse(struct soap *soap, const char *tag, int id, const _ns1__BeginInspectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BeginInspectResponse), type))
		return soap->error;
	if (a->BeginInspectResult)
		soap_element_result(soap, "ns1:BeginInspectResult");
	if (a->_ns1__BeginInspectResponse::BeginInspectResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:BeginInspectResult", -1, &a->_ns1__BeginInspectResponse::BeginInspectResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:BeginInspectResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__BeginInspectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BeginInspectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BeginInspectResponse * SOAP_FMAC4 soap_in__ns1__BeginInspectResponse(struct soap *soap, const char *tag, _ns1__BeginInspectResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BeginInspectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BeginInspectResponse, sizeof(_ns1__BeginInspectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__BeginInspectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__BeginInspectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_BeginInspectResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BeginInspectResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:BeginInspectResult", &(a->_ns1__BeginInspectResponse::BeginInspectResult), "ns1:RetValue"))
				{	soap_flag_BeginInspectResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:BeginInspectResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BeginInspectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BeginInspectResponse, 0, sizeof(_ns1__BeginInspectResponse), 0, soap_copy__ns1__BeginInspectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BeginInspectResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__BeginInspectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__BeginInspectResponse);
	if (this->soap_out(soap, tag?tag:"ns1:BeginInspectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BeginInspectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BeginInspectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BeginInspectResponse * SOAP_FMAC4 soap_get__ns1__BeginInspectResponse(struct soap *soap, _ns1__BeginInspectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BeginInspectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__BeginInspectResponse * SOAP_FMAC2 soap_instantiate__ns1__BeginInspectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BeginInspectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__BeginInspectResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__BeginInspectResponse);
		if (size)
			*size = sizeof(_ns1__BeginInspectResponse);
		((_ns1__BeginInspectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__BeginInspectResponse, n);
		if (size)
			*size = n * sizeof(_ns1__BeginInspectResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__BeginInspectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__BeginInspectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__BeginInspectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__BeginInspectResponse %p -> %p\n", q, p));
	*(_ns1__BeginInspectResponse*)p = *(_ns1__BeginInspectResponse*)q;
}

void _ns1__BeginInspect::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__BeginInspect::LineID);
	this->_ns1__BeginInspect::InspectID = NULL;
	soap_default_LONG64(soap, &this->_ns1__BeginInspect::DriverID);
	soap_default_LONG64(soap, &this->_ns1__BeginInspect::OperatorID);
	this->_ns1__BeginInspect::InspectParam = NULL;
	this->_ns1__BeginInspect::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__BeginInspect::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__BeginInspect::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__BeginInspect::InspectParam);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__BeginInspect::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__BeginInspect::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BeginInspect(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BeginInspect(struct soap *soap, const char *tag, int id, const _ns1__BeginInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BeginInspect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:LineID", -1, &(a->_ns1__BeginInspect::LineID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__BeginInspect::InspectID), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:DriverID", -1, &(a->_ns1__BeginInspect::DriverID), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:OperatorID", -1, &(a->_ns1__BeginInspect::OperatorID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectParam", -1, &(a->_ns1__BeginInspect::InspectParam), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__BeginInspect::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__BeginInspect::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BeginInspect(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BeginInspect * SOAP_FMAC4 soap_in__ns1__BeginInspect(struct soap *soap, const char *tag, _ns1__BeginInspect *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BeginInspect *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BeginInspect, sizeof(_ns1__BeginInspect), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__BeginInspect)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__BeginInspect *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LineID1 = 1;
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_DriverID1 = 1;
	size_t soap_flag_OperatorID1 = 1;
	size_t soap_flag_InspectParam1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:LineID", &(a->_ns1__BeginInspect::LineID), "xsd:long"))
				{	soap_flag_LineID1--;
					continue;
				}
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__BeginInspect::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_DriverID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:DriverID", &(a->_ns1__BeginInspect::DriverID), "xsd:long"))
				{	soap_flag_DriverID1--;
					continue;
				}
			if (soap_flag_OperatorID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:OperatorID", &(a->_ns1__BeginInspect::OperatorID), "xsd:long"))
				{	soap_flag_OperatorID1--;
					continue;
				}
			if (soap_flag_InspectParam1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectParam", &(a->_ns1__BeginInspect::InspectParam), "xsd:string"))
				{	soap_flag_InspectParam1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__BeginInspect::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BeginInspect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BeginInspect, 0, sizeof(_ns1__BeginInspect), 0, soap_copy__ns1__BeginInspect);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LineID1 > 0 || soap_flag_DriverID1 > 0 || soap_flag_OperatorID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__BeginInspect::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__BeginInspect);
	if (this->soap_out(soap, tag?tag:"ns1:BeginInspect", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BeginInspect::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BeginInspect(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BeginInspect * SOAP_FMAC4 soap_get__ns1__BeginInspect(struct soap *soap, _ns1__BeginInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BeginInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__BeginInspect * SOAP_FMAC2 soap_instantiate__ns1__BeginInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BeginInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__BeginInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__BeginInspect);
		if (size)
			*size = sizeof(_ns1__BeginInspect);
		((_ns1__BeginInspect*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__BeginInspect, n);
		if (size)
			*size = n * sizeof(_ns1__BeginInspect);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__BeginInspect*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__BeginInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__BeginInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__BeginInspect %p -> %p\n", q, p));
	*(_ns1__BeginInspect*)p = *(_ns1__BeginInspect*)q;
}

void _ns1__EndRecordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EndRecordResponse::EndRecordResult = NULL;
	/* transient soap skipped */
}

void _ns1__EndRecordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__EndRecordResponse::EndRecordResult);
	/* transient soap skipped */
#endif
}

int _ns1__EndRecordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EndRecordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EndRecordResponse(struct soap *soap, const char *tag, int id, const _ns1__EndRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EndRecordResponse), type))
		return soap->error;
	if (a->EndRecordResult)
		soap_element_result(soap, "ns1:EndRecordResult");
	if (a->_ns1__EndRecordResponse::EndRecordResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:EndRecordResult", -1, &a->_ns1__EndRecordResponse::EndRecordResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:EndRecordResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__EndRecordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__EndRecordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EndRecordResponse * SOAP_FMAC4 soap_in__ns1__EndRecordResponse(struct soap *soap, const char *tag, _ns1__EndRecordResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EndRecordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EndRecordResponse, sizeof(_ns1__EndRecordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__EndRecordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__EndRecordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EndRecordResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EndRecordResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:EndRecordResult", &(a->_ns1__EndRecordResponse::EndRecordResult), "ns1:RetValue"))
				{	soap_flag_EndRecordResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:EndRecordResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EndRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EndRecordResponse, 0, sizeof(_ns1__EndRecordResponse), 0, soap_copy__ns1__EndRecordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EndRecordResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__EndRecordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__EndRecordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:EndRecordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EndRecordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EndRecordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EndRecordResponse * SOAP_FMAC4 soap_get__ns1__EndRecordResponse(struct soap *soap, _ns1__EndRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EndRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__EndRecordResponse * SOAP_FMAC2 soap_instantiate__ns1__EndRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EndRecordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__EndRecordResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__EndRecordResponse);
		if (size)
			*size = sizeof(_ns1__EndRecordResponse);
		((_ns1__EndRecordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__EndRecordResponse, n);
		if (size)
			*size = n * sizeof(_ns1__EndRecordResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__EndRecordResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__EndRecordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__EndRecordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__EndRecordResponse %p -> %p\n", q, p));
	*(_ns1__EndRecordResponse*)p = *(_ns1__EndRecordResponse*)q;
}

void _ns1__EndRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__EndRecord::InspectID = NULL;
	this->_ns1__EndRecord::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__EndRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__EndRecord::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__EndRecord::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__EndRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EndRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EndRecord(struct soap *soap, const char *tag, int id, const _ns1__EndRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EndRecord), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__EndRecord::InspectID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__EndRecord::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__EndRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__EndRecord(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EndRecord * SOAP_FMAC4 soap_in__ns1__EndRecord(struct soap *soap, const char *tag, _ns1__EndRecord *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EndRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EndRecord, sizeof(_ns1__EndRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__EndRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__EndRecord *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__EndRecord::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__EndRecord::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__EndRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EndRecord, 0, sizeof(_ns1__EndRecord), 0, soap_copy__ns1__EndRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__EndRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__EndRecord);
	if (this->soap_out(soap, tag?tag:"ns1:EndRecord", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EndRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EndRecord(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EndRecord * SOAP_FMAC4 soap_get__ns1__EndRecord(struct soap *soap, _ns1__EndRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EndRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__EndRecord * SOAP_FMAC2 soap_instantiate__ns1__EndRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EndRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__EndRecord, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__EndRecord);
		if (size)
			*size = sizeof(_ns1__EndRecord);
		((_ns1__EndRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__EndRecord, n);
		if (size)
			*size = n * sizeof(_ns1__EndRecord);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__EndRecord*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__EndRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__EndRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__EndRecord %p -> %p\n", q, p));
	*(_ns1__EndRecord*)p = *(_ns1__EndRecord*)q;
}

void _ns1__BeginRecordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BeginRecordResponse::BeginRecordResult = NULL;
	/* transient soap skipped */
}

void _ns1__BeginRecordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__BeginRecordResponse::BeginRecordResult);
	/* transient soap skipped */
#endif
}

int _ns1__BeginRecordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BeginRecordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BeginRecordResponse(struct soap *soap, const char *tag, int id, const _ns1__BeginRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BeginRecordResponse), type))
		return soap->error;
	if (a->BeginRecordResult)
		soap_element_result(soap, "ns1:BeginRecordResult");
	if (a->_ns1__BeginRecordResponse::BeginRecordResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:BeginRecordResult", -1, &a->_ns1__BeginRecordResponse::BeginRecordResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:BeginRecordResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__BeginRecordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BeginRecordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BeginRecordResponse * SOAP_FMAC4 soap_in__ns1__BeginRecordResponse(struct soap *soap, const char *tag, _ns1__BeginRecordResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BeginRecordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BeginRecordResponse, sizeof(_ns1__BeginRecordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__BeginRecordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__BeginRecordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_BeginRecordResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BeginRecordResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:BeginRecordResult", &(a->_ns1__BeginRecordResponse::BeginRecordResult), "ns1:RetValue"))
				{	soap_flag_BeginRecordResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:BeginRecordResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BeginRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BeginRecordResponse, 0, sizeof(_ns1__BeginRecordResponse), 0, soap_copy__ns1__BeginRecordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BeginRecordResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__BeginRecordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__BeginRecordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:BeginRecordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BeginRecordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BeginRecordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BeginRecordResponse * SOAP_FMAC4 soap_get__ns1__BeginRecordResponse(struct soap *soap, _ns1__BeginRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BeginRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__BeginRecordResponse * SOAP_FMAC2 soap_instantiate__ns1__BeginRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BeginRecordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__BeginRecordResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__BeginRecordResponse);
		if (size)
			*size = sizeof(_ns1__BeginRecordResponse);
		((_ns1__BeginRecordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__BeginRecordResponse, n);
		if (size)
			*size = n * sizeof(_ns1__BeginRecordResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__BeginRecordResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__BeginRecordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__BeginRecordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__BeginRecordResponse %p -> %p\n", q, p));
	*(_ns1__BeginRecordResponse*)p = *(_ns1__BeginRecordResponse*)q;
}

void _ns1__BeginRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->_ns1__BeginRecord::LineID);
	this->_ns1__BeginRecord::InspectID = NULL;
	this->_ns1__BeginRecord::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__BeginRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__BeginRecord::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__BeginRecord::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__BeginRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BeginRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BeginRecord(struct soap *soap, const char *tag, int id, const _ns1__BeginRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BeginRecord), type))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:LineID", -1, &(a->_ns1__BeginRecord::LineID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__BeginRecord::InspectID), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__BeginRecord::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__BeginRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BeginRecord(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BeginRecord * SOAP_FMAC4 soap_in__ns1__BeginRecord(struct soap *soap, const char *tag, _ns1__BeginRecord *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BeginRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BeginRecord, sizeof(_ns1__BeginRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__BeginRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__BeginRecord *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LineID1 = 1;
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LineID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:LineID", &(a->_ns1__BeginRecord::LineID), "xsd:long"))
				{	soap_flag_LineID1--;
					continue;
				}
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__BeginRecord::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__BeginRecord::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BeginRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BeginRecord, 0, sizeof(_ns1__BeginRecord), 0, soap_copy__ns1__BeginRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LineID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__BeginRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__BeginRecord);
	if (this->soap_out(soap, tag?tag:"ns1:BeginRecord", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BeginRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BeginRecord(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BeginRecord * SOAP_FMAC4 soap_get__ns1__BeginRecord(struct soap *soap, _ns1__BeginRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BeginRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__BeginRecord * SOAP_FMAC2 soap_instantiate__ns1__BeginRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BeginRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__BeginRecord, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__BeginRecord);
		if (size)
			*size = sizeof(_ns1__BeginRecord);
		((_ns1__BeginRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__BeginRecord, n);
		if (size)
			*size = n * sizeof(_ns1__BeginRecord);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__BeginRecord*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__BeginRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__BeginRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__BeginRecord %p -> %p\n", q, p));
	*(_ns1__BeginRecord*)p = *(_ns1__BeginRecord*)q;
}

void _ns1__AbortInspectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__AbortInspectResponse::AbortInspectResult = NULL;
	/* transient soap skipped */
}

void _ns1__AbortInspectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__AbortInspectResponse::AbortInspectResult);
	/* transient soap skipped */
#endif
}

int _ns1__AbortInspectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AbortInspectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AbortInspectResponse(struct soap *soap, const char *tag, int id, const _ns1__AbortInspectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AbortInspectResponse), type))
		return soap->error;
	if (a->AbortInspectResult)
		soap_element_result(soap, "ns1:AbortInspectResult");
	if (a->_ns1__AbortInspectResponse::AbortInspectResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:AbortInspectResult", -1, &a->_ns1__AbortInspectResponse::AbortInspectResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:AbortInspectResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AbortInspectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AbortInspectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AbortInspectResponse * SOAP_FMAC4 soap_in__ns1__AbortInspectResponse(struct soap *soap, const char *tag, _ns1__AbortInspectResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AbortInspectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AbortInspectResponse, sizeof(_ns1__AbortInspectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AbortInspectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AbortInspectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AbortInspectResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AbortInspectResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:AbortInspectResult", &(a->_ns1__AbortInspectResponse::AbortInspectResult), "ns1:RetValue"))
				{	soap_flag_AbortInspectResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AbortInspectResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AbortInspectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AbortInspectResponse, 0, sizeof(_ns1__AbortInspectResponse), 0, soap_copy__ns1__AbortInspectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AbortInspectResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__AbortInspectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__AbortInspectResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AbortInspectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AbortInspectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AbortInspectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AbortInspectResponse * SOAP_FMAC4 soap_get__ns1__AbortInspectResponse(struct soap *soap, _ns1__AbortInspectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AbortInspectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AbortInspectResponse * SOAP_FMAC2 soap_instantiate__ns1__AbortInspectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AbortInspectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AbortInspectResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AbortInspectResponse);
		if (size)
			*size = sizeof(_ns1__AbortInspectResponse);
		((_ns1__AbortInspectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__AbortInspectResponse, n);
		if (size)
			*size = n * sizeof(_ns1__AbortInspectResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__AbortInspectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__AbortInspectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AbortInspectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AbortInspectResponse %p -> %p\n", q, p));
	*(_ns1__AbortInspectResponse*)p = *(_ns1__AbortInspectResponse*)q;
}

void _ns1__AbortInspect::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__AbortInspect::InspectID = NULL;
	soap_default_int(soap, &this->_ns1__AbortInspect::Reason);
	this->_ns1__AbortInspect::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__AbortInspect::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__AbortInspect::InspectID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__AbortInspect::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__AbortInspect::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AbortInspect(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AbortInspect(struct soap *soap, const char *tag, int id, const _ns1__AbortInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AbortInspect), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InspectID", -1, &(a->_ns1__AbortInspect::InspectID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Reason", -1, &(a->_ns1__AbortInspect::Reason), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__AbortInspect::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AbortInspect::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AbortInspect(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AbortInspect * SOAP_FMAC4 soap_in__ns1__AbortInspect(struct soap *soap, const char *tag, _ns1__AbortInspect *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AbortInspect *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AbortInspect, sizeof(_ns1__AbortInspect), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AbortInspect)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AbortInspect *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InspectID1 = 1;
	size_t soap_flag_Reason1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InspectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InspectID", &(a->_ns1__AbortInspect::InspectID), "xsd:string"))
				{	soap_flag_InspectID1--;
					continue;
				}
			if (soap_flag_Reason1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Reason", &(a->_ns1__AbortInspect::Reason), "xsd:int"))
				{	soap_flag_Reason1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__AbortInspect::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AbortInspect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AbortInspect, 0, sizeof(_ns1__AbortInspect), 0, soap_copy__ns1__AbortInspect);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Reason1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__AbortInspect::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__AbortInspect);
	if (this->soap_out(soap, tag?tag:"ns1:AbortInspect", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AbortInspect::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AbortInspect(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AbortInspect * SOAP_FMAC4 soap_get__ns1__AbortInspect(struct soap *soap, _ns1__AbortInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AbortInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AbortInspect * SOAP_FMAC2 soap_instantiate__ns1__AbortInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AbortInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AbortInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AbortInspect);
		if (size)
			*size = sizeof(_ns1__AbortInspect);
		((_ns1__AbortInspect*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__AbortInspect, n);
		if (size)
			*size = n * sizeof(_ns1__AbortInspect);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__AbortInspect*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__AbortInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AbortInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AbortInspect %p -> %p\n", q, p));
	*(_ns1__AbortInspect*)p = *(_ns1__AbortInspect*)q;
}

void _ns1__GetInspectQueueByPlateIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetInspectQueueByPlateIDResponse::GetInspectQueueByPlateIDResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetInspectQueueByPlateIDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__GetInspectQueueByPlateIDResponse::GetInspectQueueByPlateIDResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetInspectQueueByPlateIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInspectQueueByPlateIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInspectQueueByPlateIDResponse(struct soap *soap, const char *tag, int id, const _ns1__GetInspectQueueByPlateIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse), type))
		return soap->error;
	if (a->GetInspectQueueByPlateIDResult)
		soap_element_result(soap, "ns1:GetInspectQueueByPlateIDResult");
	if (a->_ns1__GetInspectQueueByPlateIDResponse::GetInspectQueueByPlateIDResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:GetInspectQueueByPlateIDResult", -1, &a->_ns1__GetInspectQueueByPlateIDResponse::GetInspectQueueByPlateIDResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetInspectQueueByPlateIDResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInspectQueueByPlateIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInspectQueueByPlateIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInspectQueueByPlateIDResponse * SOAP_FMAC4 soap_in__ns1__GetInspectQueueByPlateIDResponse(struct soap *soap, const char *tag, _ns1__GetInspectQueueByPlateIDResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInspectQueueByPlateIDResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse, sizeof(_ns1__GetInspectQueueByPlateIDResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetInspectQueueByPlateIDResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetInspectQueueByPlateIDResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetInspectQueueByPlateIDResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:GetInspectQueueByPlateIDResult", &(a->_ns1__GetInspectQueueByPlateIDResponse::GetInspectQueueByPlateIDResult), "ns1:RetValue"))
				{	soap_flag_GetInspectQueueByPlateIDResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetInspectQueueByPlateIDResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInspectQueueByPlateIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse, 0, sizeof(_ns1__GetInspectQueueByPlateIDResponse), 0, soap_copy__ns1__GetInspectQueueByPlateIDResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetInspectQueueByPlateIDResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetInspectQueueByPlateIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetInspectQueueByPlateIDResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInspectQueueByPlateIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInspectQueueByPlateIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInspectQueueByPlateIDResponse * SOAP_FMAC4 soap_get__ns1__GetInspectQueueByPlateIDResponse(struct soap *soap, _ns1__GetInspectQueueByPlateIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInspectQueueByPlateIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetInspectQueueByPlateIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetInspectQueueByPlateIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInspectQueueByPlateIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetInspectQueueByPlateIDResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetInspectQueueByPlateIDResponse);
		if (size)
			*size = sizeof(_ns1__GetInspectQueueByPlateIDResponse);
		((_ns1__GetInspectQueueByPlateIDResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetInspectQueueByPlateIDResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetInspectQueueByPlateIDResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetInspectQueueByPlateIDResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetInspectQueueByPlateIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetInspectQueueByPlateIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetInspectQueueByPlateIDResponse %p -> %p\n", q, p));
	*(_ns1__GetInspectQueueByPlateIDResponse*)p = *(_ns1__GetInspectQueueByPlateIDResponse*)q;
}

void _ns1__GetInspectQueueByPlateID::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetInspectQueueByPlateID::PlateID = NULL;
	soap_default_int(soap, &this->_ns1__GetInspectQueueByPlateID::PlateType);
	this->_ns1__GetInspectQueueByPlateID::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__GetInspectQueueByPlateID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetInspectQueueByPlateID::PlateID);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetInspectQueueByPlateID::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__GetInspectQueueByPlateID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInspectQueueByPlateID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInspectQueueByPlateID(struct soap *soap, const char *tag, int id, const _ns1__GetInspectQueueByPlateID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInspectQueueByPlateID), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:PlateID", -1, &(a->_ns1__GetInspectQueueByPlateID::PlateID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PlateType", -1, &(a->_ns1__GetInspectQueueByPlateID::PlateType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__GetInspectQueueByPlateID::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInspectQueueByPlateID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInspectQueueByPlateID(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInspectQueueByPlateID * SOAP_FMAC4 soap_in__ns1__GetInspectQueueByPlateID(struct soap *soap, const char *tag, _ns1__GetInspectQueueByPlateID *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInspectQueueByPlateID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInspectQueueByPlateID, sizeof(_ns1__GetInspectQueueByPlateID), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetInspectQueueByPlateID)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetInspectQueueByPlateID *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PlateID1 = 1;
	size_t soap_flag_PlateType1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PlateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:PlateID", &(a->_ns1__GetInspectQueueByPlateID::PlateID), "xsd:string"))
				{	soap_flag_PlateID1--;
					continue;
				}
			if (soap_flag_PlateType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PlateType", &(a->_ns1__GetInspectQueueByPlateID::PlateType), "xsd:int"))
				{	soap_flag_PlateType1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__GetInspectQueueByPlateID::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInspectQueueByPlateID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInspectQueueByPlateID, 0, sizeof(_ns1__GetInspectQueueByPlateID), 0, soap_copy__ns1__GetInspectQueueByPlateID);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PlateType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetInspectQueueByPlateID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetInspectQueueByPlateID);
	if (this->soap_out(soap, tag?tag:"ns1:GetInspectQueueByPlateID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInspectQueueByPlateID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInspectQueueByPlateID(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInspectQueueByPlateID * SOAP_FMAC4 soap_get__ns1__GetInspectQueueByPlateID(struct soap *soap, _ns1__GetInspectQueueByPlateID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInspectQueueByPlateID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetInspectQueueByPlateID * SOAP_FMAC2 soap_instantiate__ns1__GetInspectQueueByPlateID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInspectQueueByPlateID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetInspectQueueByPlateID, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetInspectQueueByPlateID);
		if (size)
			*size = sizeof(_ns1__GetInspectQueueByPlateID);
		((_ns1__GetInspectQueueByPlateID*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetInspectQueueByPlateID, n);
		if (size)
			*size = n * sizeof(_ns1__GetInspectQueueByPlateID);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetInspectQueueByPlateID*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetInspectQueueByPlateID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetInspectQueueByPlateID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetInspectQueueByPlateID %p -> %p\n", q, p));
	*(_ns1__GetInspectQueueByPlateID*)p = *(_ns1__GetInspectQueueByPlateID*)q;
}

void _ns1__GetInspectQueueByDateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetInspectQueueByDateResponse::GetInspectQueueByDateResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetInspectQueueByDateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__GetInspectQueueByDateResponse::GetInspectQueueByDateResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetInspectQueueByDateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInspectQueueByDateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInspectQueueByDateResponse(struct soap *soap, const char *tag, int id, const _ns1__GetInspectQueueByDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInspectQueueByDateResponse), type))
		return soap->error;
	if (a->GetInspectQueueByDateResult)
		soap_element_result(soap, "ns1:GetInspectQueueByDateResult");
	if (a->_ns1__GetInspectQueueByDateResponse::GetInspectQueueByDateResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:GetInspectQueueByDateResult", -1, &a->_ns1__GetInspectQueueByDateResponse::GetInspectQueueByDateResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetInspectQueueByDateResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInspectQueueByDateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInspectQueueByDateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInspectQueueByDateResponse * SOAP_FMAC4 soap_in__ns1__GetInspectQueueByDateResponse(struct soap *soap, const char *tag, _ns1__GetInspectQueueByDateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInspectQueueByDateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInspectQueueByDateResponse, sizeof(_ns1__GetInspectQueueByDateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetInspectQueueByDateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetInspectQueueByDateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetInspectQueueByDateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetInspectQueueByDateResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:GetInspectQueueByDateResult", &(a->_ns1__GetInspectQueueByDateResponse::GetInspectQueueByDateResult), "ns1:RetValue"))
				{	soap_flag_GetInspectQueueByDateResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetInspectQueueByDateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInspectQueueByDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInspectQueueByDateResponse, 0, sizeof(_ns1__GetInspectQueueByDateResponse), 0, soap_copy__ns1__GetInspectQueueByDateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetInspectQueueByDateResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetInspectQueueByDateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetInspectQueueByDateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetInspectQueueByDateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInspectQueueByDateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInspectQueueByDateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInspectQueueByDateResponse * SOAP_FMAC4 soap_get__ns1__GetInspectQueueByDateResponse(struct soap *soap, _ns1__GetInspectQueueByDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInspectQueueByDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetInspectQueueByDateResponse * SOAP_FMAC2 soap_instantiate__ns1__GetInspectQueueByDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInspectQueueByDateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetInspectQueueByDateResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetInspectQueueByDateResponse);
		if (size)
			*size = sizeof(_ns1__GetInspectQueueByDateResponse);
		((_ns1__GetInspectQueueByDateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetInspectQueueByDateResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetInspectQueueByDateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetInspectQueueByDateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetInspectQueueByDateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetInspectQueueByDateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetInspectQueueByDateResponse %p -> %p\n", q, p));
	*(_ns1__GetInspectQueueByDateResponse*)p = *(_ns1__GetInspectQueueByDateResponse*)q;
}

void _ns1__GetInspectQueueByDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetInspectQueueByDate::FromDate = NULL;
	this->_ns1__GetInspectQueueByDate::ToDate = NULL;
	this->_ns1__GetInspectQueueByDate::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__GetInspectQueueByDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetInspectQueueByDate::FromDate);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetInspectQueueByDate::ToDate);
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__GetInspectQueueByDate::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__GetInspectQueueByDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInspectQueueByDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInspectQueueByDate(struct soap *soap, const char *tag, int id, const _ns1__GetInspectQueueByDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInspectQueueByDate), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:FromDate", -1, &(a->_ns1__GetInspectQueueByDate::FromDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:ToDate", -1, &(a->_ns1__GetInspectQueueByDate::ToDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__GetInspectQueueByDate::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInspectQueueByDate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInspectQueueByDate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInspectQueueByDate * SOAP_FMAC4 soap_in__ns1__GetInspectQueueByDate(struct soap *soap, const char *tag, _ns1__GetInspectQueueByDate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInspectQueueByDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInspectQueueByDate, sizeof(_ns1__GetInspectQueueByDate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetInspectQueueByDate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetInspectQueueByDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FromDate1 = 1;
	size_t soap_flag_ToDate1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:FromDate", &(a->_ns1__GetInspectQueueByDate::FromDate), "xsd:string"))
				{	soap_flag_FromDate1--;
					continue;
				}
			if (soap_flag_ToDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:ToDate", &(a->_ns1__GetInspectQueueByDate::ToDate), "xsd:string"))
				{	soap_flag_ToDate1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__GetInspectQueueByDate::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInspectQueueByDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInspectQueueByDate, 0, sizeof(_ns1__GetInspectQueueByDate), 0, soap_copy__ns1__GetInspectQueueByDate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetInspectQueueByDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetInspectQueueByDate);
	if (this->soap_out(soap, tag?tag:"ns1:GetInspectQueueByDate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInspectQueueByDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInspectQueueByDate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInspectQueueByDate * SOAP_FMAC4 soap_get__ns1__GetInspectQueueByDate(struct soap *soap, _ns1__GetInspectQueueByDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInspectQueueByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetInspectQueueByDate * SOAP_FMAC2 soap_instantiate__ns1__GetInspectQueueByDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInspectQueueByDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetInspectQueueByDate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetInspectQueueByDate);
		if (size)
			*size = sizeof(_ns1__GetInspectQueueByDate);
		((_ns1__GetInspectQueueByDate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetInspectQueueByDate, n);
		if (size)
			*size = n * sizeof(_ns1__GetInspectQueueByDate);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetInspectQueueByDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetInspectQueueByDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetInspectQueueByDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetInspectQueueByDate %p -> %p\n", q, p));
	*(_ns1__GetInspectQueueByDate*)p = *(_ns1__GetInspectQueueByDate*)q;
}

void _ns1__SyncResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SyncResponse::SyncResult = NULL;
	/* transient soap skipped */
}

void _ns1__SyncResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RetValue(soap, &this->_ns1__SyncResponse::SyncResult);
	/* transient soap skipped */
#endif
}

int _ns1__SyncResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SyncResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SyncResponse(struct soap *soap, const char *tag, int id, const _ns1__SyncResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SyncResponse), type))
		return soap->error;
	if (a->SyncResult)
		soap_element_result(soap, "ns1:SyncResult");
	if (a->_ns1__SyncResponse::SyncResult)
	{	if (soap_out_PointerTons1__RetValue(soap, "ns1:SyncResult", -1, &a->_ns1__SyncResponse::SyncResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:SyncResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SyncResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SyncResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SyncResponse * SOAP_FMAC4 soap_in__ns1__SyncResponse(struct soap *soap, const char *tag, _ns1__SyncResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SyncResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SyncResponse, sizeof(_ns1__SyncResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SyncResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SyncResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SyncResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SyncResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RetValue(soap, "ns1:SyncResult", &(a->_ns1__SyncResponse::SyncResult), "ns1:RetValue"))
				{	soap_flag_SyncResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SyncResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SyncResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SyncResponse, 0, sizeof(_ns1__SyncResponse), 0, soap_copy__ns1__SyncResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SyncResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__SyncResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__SyncResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SyncResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SyncResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SyncResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SyncResponse * SOAP_FMAC4 soap_get__ns1__SyncResponse(struct soap *soap, _ns1__SyncResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SyncResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SyncResponse * SOAP_FMAC2 soap_instantiate__ns1__SyncResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SyncResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SyncResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SyncResponse);
		if (size)
			*size = sizeof(_ns1__SyncResponse);
		((_ns1__SyncResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__SyncResponse, n);
		if (size)
			*size = n * sizeof(_ns1__SyncResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SyncResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SyncResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SyncResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SyncResponse %p -> %p\n", q, p));
	*(_ns1__SyncResponse*)p = *(_ns1__SyncResponse*)q;
}

void _ns1__Sync::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Sync::Memo = NULL;
	/* transient soap skipped */
}

void _ns1__Sync::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->_ns1__Sync::Memo);
	/* transient soap skipped */
#endif
}

int _ns1__Sync::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Sync(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Sync(struct soap *soap, const char *tag, int id, const _ns1__Sync *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Sync), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->_ns1__Sync::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__Sync::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Sync(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Sync * SOAP_FMAC4 soap_in__ns1__Sync(struct soap *soap, const char *tag, _ns1__Sync *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Sync *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Sync, sizeof(_ns1__Sync), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__Sync)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__Sync *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->_ns1__Sync::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Sync *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Sync, 0, sizeof(_ns1__Sync), 0, soap_copy__ns1__Sync);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__Sync::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__Sync);
	if (this->soap_out(soap, tag?tag:"ns1:Sync", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Sync::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Sync(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Sync * SOAP_FMAC4 soap_get__ns1__Sync(struct soap *soap, _ns1__Sync *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Sync(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__Sync * SOAP_FMAC2 soap_instantiate__ns1__Sync(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Sync(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Sync, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__Sync);
		if (size)
			*size = sizeof(_ns1__Sync);
		((_ns1__Sync*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__Sync, n);
		if (size)
			*size = n * sizeof(_ns1__Sync);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__Sync*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__Sync*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Sync(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Sync %p -> %p\n", q, p));
	*(_ns1__Sync*)p = *(_ns1__Sync*)q;
}

void ns1__RetValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__RetValue::ErrNum);
	this->ns1__RetValue::ErrMsg = NULL;
	soap_default_int(soap, &this->ns1__RetValue::InternalErrNum);
	this->ns1__RetValue::InternalErrMsg = NULL;
	this->ns1__RetValue::Value = NULL;
	this->ns1__RetValue::TipMessage = NULL;
	this->ns1__RetValue::Memo = NULL;
	/* transient soap skipped */
}

void ns1__RetValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__RetValue::ErrMsg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__RetValue::InternalErrMsg);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__RetValue::Value);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__RetValue::TipMessage);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__RetValue::Memo);
	/* transient soap skipped */
#endif
}

int ns1__RetValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RetValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RetValue(struct soap *soap, const char *tag, int id, const ns1__RetValue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RetValue), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:ErrNum", -1, &(a->ns1__RetValue::ErrNum), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:ErrMsg", -1, &(a->ns1__RetValue::ErrMsg), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:InternalErrNum", -1, &(a->ns1__RetValue::InternalErrNum), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:InternalErrMsg", -1, &(a->ns1__RetValue::InternalErrMsg), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Value", -1, &(a->ns1__RetValue::Value), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:TipMessage", -1, &(a->ns1__RetValue::TipMessage), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "ns1:Memo", -1, &(a->ns1__RetValue::Memo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__RetValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RetValue(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RetValue * SOAP_FMAC4 soap_in_ns1__RetValue(struct soap *soap, const char *tag, ns1__RetValue *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RetValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RetValue, sizeof(ns1__RetValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__RetValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__RetValue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ErrNum1 = 1;
	size_t soap_flag_ErrMsg1 = 1;
	size_t soap_flag_InternalErrNum1 = 1;
	size_t soap_flag_InternalErrMsg1 = 1;
	size_t soap_flag_Value1 = 1;
	size_t soap_flag_TipMessage1 = 1;
	size_t soap_flag_Memo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrNum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ErrNum", &(a->ns1__RetValue::ErrNum), "xsd:int"))
				{	soap_flag_ErrNum1--;
					continue;
				}
			if (soap_flag_ErrMsg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:ErrMsg", &(a->ns1__RetValue::ErrMsg), "xsd:string"))
				{	soap_flag_ErrMsg1--;
					continue;
				}
			if (soap_flag_InternalErrNum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:InternalErrNum", &(a->ns1__RetValue::InternalErrNum), "xsd:int"))
				{	soap_flag_InternalErrNum1--;
					continue;
				}
			if (soap_flag_InternalErrMsg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:InternalErrMsg", &(a->ns1__RetValue::InternalErrMsg), "xsd:string"))
				{	soap_flag_InternalErrMsg1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Value", &(a->ns1__RetValue::Value), "xsd:string"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap_flag_TipMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:TipMessage", &(a->ns1__RetValue::TipMessage), "xsd:string"))
				{	soap_flag_TipMessage1--;
					continue;
				}
			if (soap_flag_Memo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "ns1:Memo", &(a->ns1__RetValue::Memo), "xsd:string"))
				{	soap_flag_Memo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RetValue, 0, sizeof(ns1__RetValue), 0, soap_copy_ns1__RetValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrNum1 > 0 || soap_flag_InternalErrNum1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__RetValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__RetValue);
	if (this->soap_out(soap, tag?tag:"ns1:RetValue", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RetValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RetValue(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RetValue * SOAP_FMAC4 soap_get_ns1__RetValue(struct soap *soap, ns1__RetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__RetValue * SOAP_FMAC2 soap_instantiate_ns1__RetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RetValue, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__RetValue);
		if (size)
			*size = sizeof(ns1__RetValue);
		((ns1__RetValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__RetValue, n);
		if (size)
			*size = n * sizeof(ns1__RetValue);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__RetValue*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__RetValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__RetValue %p -> %p\n", q, p));
	*(ns1__RetValue*)p = *(ns1__RetValue*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OBDTXCheck_(struct soap *soap, struct __ns1__OBDTXCheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OBDTXCheck = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OBDTXCheck_(struct soap *soap, const struct __ns1__OBDTXCheck_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OBDTXCheck(soap, &a->ns1__OBDTXCheck);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OBDTXCheck_(struct soap *soap, const char *tag, int id, const struct __ns1__OBDTXCheck_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OBDTXCheck(soap, "ns1:OBDTXCheck", -1, &a->ns1__OBDTXCheck, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OBDTXCheck_ * SOAP_FMAC4 soap_in___ns1__OBDTXCheck_(struct soap *soap, const char *tag, struct __ns1__OBDTXCheck_ *a, const char *type)
{
	size_t soap_flag_ns1__OBDTXCheck = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OBDTXCheck_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OBDTXCheck_, sizeof(struct __ns1__OBDTXCheck_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OBDTXCheck_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OBDTXCheck && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OBDTXCheck(soap, "ns1:OBDTXCheck", &a->ns1__OBDTXCheck, ""))
				{	soap_flag_ns1__OBDTXCheck--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OBDTXCheck_(struct soap *soap, const struct __ns1__OBDTXCheck_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__OBDTXCheck_(soap, tag?tag:"-ns1:OBDTXCheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OBDTXCheck_ * SOAP_FMAC4 soap_get___ns1__OBDTXCheck_(struct soap *soap, struct __ns1__OBDTXCheck_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OBDTXCheck_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__OBDTXCheck_ * SOAP_FMAC2 soap_instantiate___ns1__OBDTXCheck_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OBDTXCheck_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__OBDTXCheck_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__OBDTXCheck_);
		if (size)
			*size = sizeof(struct __ns1__OBDTXCheck_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__OBDTXCheck_, n);
		if (size)
			*size = n * sizeof(struct __ns1__OBDTXCheck_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__OBDTXCheck_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__OBDTXCheck_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__OBDTXCheck_ %p -> %p\n", q, p));
	*(struct __ns1__OBDTXCheck_*)p = *(struct __ns1__OBDTXCheck_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OBDInspect_(struct soap *soap, struct __ns1__OBDInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OBDInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OBDInspect_(struct soap *soap, const struct __ns1__OBDInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OBDInspect(soap, &a->ns1__OBDInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OBDInspect_(struct soap *soap, const char *tag, int id, const struct __ns1__OBDInspect_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OBDInspect(soap, "ns1:OBDInspect", -1, &a->ns1__OBDInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OBDInspect_ * SOAP_FMAC4 soap_in___ns1__OBDInspect_(struct soap *soap, const char *tag, struct __ns1__OBDInspect_ *a, const char *type)
{
	size_t soap_flag_ns1__OBDInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OBDInspect_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OBDInspect_, sizeof(struct __ns1__OBDInspect_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OBDInspect_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OBDInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OBDInspect(soap, "ns1:OBDInspect", &a->ns1__OBDInspect, ""))
				{	soap_flag_ns1__OBDInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OBDInspect_(struct soap *soap, const struct __ns1__OBDInspect_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__OBDInspect_(soap, tag?tag:"-ns1:OBDInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OBDInspect_ * SOAP_FMAC4 soap_get___ns1__OBDInspect_(struct soap *soap, struct __ns1__OBDInspect_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OBDInspect_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__OBDInspect_ * SOAP_FMAC2 soap_instantiate___ns1__OBDInspect_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OBDInspect_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__OBDInspect_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__OBDInspect_);
		if (size)
			*size = sizeof(struct __ns1__OBDInspect_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__OBDInspect_, n);
		if (size)
			*size = n * sizeof(struct __ns1__OBDInspect_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__OBDInspect_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__OBDInspect_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__OBDInspect_ %p -> %p\n", q, p));
	*(struct __ns1__OBDInspect_*)p = *(struct __ns1__OBDInspect_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetOtherInspectQueueByDate_(struct soap *soap, struct __ns1__GetOtherInspectQueueByDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOtherInspectQueueByDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetOtherInspectQueueByDate_(struct soap *soap, const struct __ns1__GetOtherInspectQueueByDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetOtherInspectQueueByDate(soap, &a->ns1__GetOtherInspectQueueByDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetOtherInspectQueueByDate_(struct soap *soap, const char *tag, int id, const struct __ns1__GetOtherInspectQueueByDate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetOtherInspectQueueByDate(soap, "ns1:GetOtherInspectQueueByDate", -1, &a->ns1__GetOtherInspectQueueByDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOtherInspectQueueByDate_ * SOAP_FMAC4 soap_in___ns1__GetOtherInspectQueueByDate_(struct soap *soap, const char *tag, struct __ns1__GetOtherInspectQueueByDate_ *a, const char *type)
{
	size_t soap_flag_ns1__GetOtherInspectQueueByDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetOtherInspectQueueByDate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetOtherInspectQueueByDate_, sizeof(struct __ns1__GetOtherInspectQueueByDate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetOtherInspectQueueByDate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOtherInspectQueueByDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetOtherInspectQueueByDate(soap, "ns1:GetOtherInspectQueueByDate", &a->ns1__GetOtherInspectQueueByDate, ""))
				{	soap_flag_ns1__GetOtherInspectQueueByDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetOtherInspectQueueByDate_(struct soap *soap, const struct __ns1__GetOtherInspectQueueByDate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetOtherInspectQueueByDate_(soap, tag?tag:"-ns1:GetOtherInspectQueueByDate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOtherInspectQueueByDate_ * SOAP_FMAC4 soap_get___ns1__GetOtherInspectQueueByDate_(struct soap *soap, struct __ns1__GetOtherInspectQueueByDate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetOtherInspectQueueByDate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetOtherInspectQueueByDate_ * SOAP_FMAC2 soap_instantiate___ns1__GetOtherInspectQueueByDate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetOtherInspectQueueByDate_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetOtherInspectQueueByDate_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetOtherInspectQueueByDate_);
		if (size)
			*size = sizeof(struct __ns1__GetOtherInspectQueueByDate_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetOtherInspectQueueByDate_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetOtherInspectQueueByDate_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetOtherInspectQueueByDate_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetOtherInspectQueueByDate_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetOtherInspectQueueByDate_ %p -> %p\n", q, p));
	*(struct __ns1__GetOtherInspectQueueByDate_*)p = *(struct __ns1__GetOtherInspectQueueByDate_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetOtherInspectQueueByPlateID_(struct soap *soap, struct __ns1__GetOtherInspectQueueByPlateID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOtherInspectQueueByPlateID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetOtherInspectQueueByPlateID_(struct soap *soap, const struct __ns1__GetOtherInspectQueueByPlateID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, &a->ns1__GetOtherInspectQueueByPlateID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetOtherInspectQueueByPlateID_(struct soap *soap, const char *tag, int id, const struct __ns1__GetOtherInspectQueueByPlateID_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, "ns1:GetOtherInspectQueueByPlateID", -1, &a->ns1__GetOtherInspectQueueByPlateID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOtherInspectQueueByPlateID_ * SOAP_FMAC4 soap_in___ns1__GetOtherInspectQueueByPlateID_(struct soap *soap, const char *tag, struct __ns1__GetOtherInspectQueueByPlateID_ *a, const char *type)
{
	size_t soap_flag_ns1__GetOtherInspectQueueByPlateID = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetOtherInspectQueueByPlateID_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID_, sizeof(struct __ns1__GetOtherInspectQueueByPlateID_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetOtherInspectQueueByPlateID_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOtherInspectQueueByPlateID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, "ns1:GetOtherInspectQueueByPlateID", &a->ns1__GetOtherInspectQueueByPlateID, ""))
				{	soap_flag_ns1__GetOtherInspectQueueByPlateID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetOtherInspectQueueByPlateID_(struct soap *soap, const struct __ns1__GetOtherInspectQueueByPlateID_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetOtherInspectQueueByPlateID_(soap, tag?tag:"-ns1:GetOtherInspectQueueByPlateID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOtherInspectQueueByPlateID_ * SOAP_FMAC4 soap_get___ns1__GetOtherInspectQueueByPlateID_(struct soap *soap, struct __ns1__GetOtherInspectQueueByPlateID_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetOtherInspectQueueByPlateID_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetOtherInspectQueueByPlateID_ * SOAP_FMAC2 soap_instantiate___ns1__GetOtherInspectQueueByPlateID_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetOtherInspectQueueByPlateID_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetOtherInspectQueueByPlateID_);
		if (size)
			*size = sizeof(struct __ns1__GetOtherInspectQueueByPlateID_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetOtherInspectQueueByPlateID_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetOtherInspectQueueByPlateID_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetOtherInspectQueueByPlateID_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetOtherInspectQueueByPlateID_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetOtherInspectQueueByPlateID_ %p -> %p\n", q, p));
	*(struct __ns1__GetOtherInspectQueueByPlateID_*)p = *(struct __ns1__GetOtherInspectQueueByPlateID_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetInspectParams_(struct soap *soap, struct __ns1__GetInspectParams_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInspectParams = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetInspectParams_(struct soap *soap, const struct __ns1__GetInspectParams_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetInspectParams(soap, &a->ns1__GetInspectParams);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetInspectParams_(struct soap *soap, const char *tag, int id, const struct __ns1__GetInspectParams_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetInspectParams(soap, "ns1:GetInspectParams", -1, &a->ns1__GetInspectParams, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectParams_ * SOAP_FMAC4 soap_in___ns1__GetInspectParams_(struct soap *soap, const char *tag, struct __ns1__GetInspectParams_ *a, const char *type)
{
	size_t soap_flag_ns1__GetInspectParams = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetInspectParams_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetInspectParams_, sizeof(struct __ns1__GetInspectParams_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetInspectParams_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInspectParams && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInspectParams(soap, "ns1:GetInspectParams", &a->ns1__GetInspectParams, ""))
				{	soap_flag_ns1__GetInspectParams--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetInspectParams_(struct soap *soap, const struct __ns1__GetInspectParams_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetInspectParams_(soap, tag?tag:"-ns1:GetInspectParams", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectParams_ * SOAP_FMAC4 soap_get___ns1__GetInspectParams_(struct soap *soap, struct __ns1__GetInspectParams_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetInspectParams_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetInspectParams_ * SOAP_FMAC2 soap_instantiate___ns1__GetInspectParams_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetInspectParams_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetInspectParams_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetInspectParams_);
		if (size)
			*size = sizeof(struct __ns1__GetInspectParams_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetInspectParams_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetInspectParams_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetInspectParams_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetInspectParams_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetInspectParams_ %p -> %p\n", q, p));
	*(struct __ns1__GetInspectParams_*)p = *(struct __ns1__GetInspectParams_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FuelEvaporationInspect_(struct soap *soap, struct __ns1__FuelEvaporationInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FuelEvaporationInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FuelEvaporationInspect_(struct soap *soap, const struct __ns1__FuelEvaporationInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__FuelEvaporationInspect(soap, &a->ns1__FuelEvaporationInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FuelEvaporationInspect_(struct soap *soap, const char *tag, int id, const struct __ns1__FuelEvaporationInspect_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__FuelEvaporationInspect(soap, "ns1:FuelEvaporationInspect", -1, &a->ns1__FuelEvaporationInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FuelEvaporationInspect_ * SOAP_FMAC4 soap_in___ns1__FuelEvaporationInspect_(struct soap *soap, const char *tag, struct __ns1__FuelEvaporationInspect_ *a, const char *type)
{
	size_t soap_flag_ns1__FuelEvaporationInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FuelEvaporationInspect_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__FuelEvaporationInspect_, sizeof(struct __ns1__FuelEvaporationInspect_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FuelEvaporationInspect_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FuelEvaporationInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__FuelEvaporationInspect(soap, "ns1:FuelEvaporationInspect", &a->ns1__FuelEvaporationInspect, ""))
				{	soap_flag_ns1__FuelEvaporationInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FuelEvaporationInspect_(struct soap *soap, const struct __ns1__FuelEvaporationInspect_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__FuelEvaporationInspect_(soap, tag?tag:"-ns1:FuelEvaporationInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FuelEvaporationInspect_ * SOAP_FMAC4 soap_get___ns1__FuelEvaporationInspect_(struct soap *soap, struct __ns1__FuelEvaporationInspect_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FuelEvaporationInspect_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__FuelEvaporationInspect_ * SOAP_FMAC2 soap_instantiate___ns1__FuelEvaporationInspect_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FuelEvaporationInspect_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__FuelEvaporationInspect_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__FuelEvaporationInspect_);
		if (size)
			*size = sizeof(struct __ns1__FuelEvaporationInspect_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__FuelEvaporationInspect_, n);
		if (size)
			*size = n * sizeof(struct __ns1__FuelEvaporationInspect_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__FuelEvaporationInspect_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__FuelEvaporationInspect_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__FuelEvaporationInspect_ %p -> %p\n", q, p));
	*(struct __ns1__FuelEvaporationInspect_*)p = *(struct __ns1__FuelEvaporationInspect_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TestPhoto_(struct soap *soap, struct __ns1__TestPhoto_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TestPhoto = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TestPhoto_(struct soap *soap, const struct __ns1__TestPhoto_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__TestPhoto(soap, &a->ns1__TestPhoto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TestPhoto_(struct soap *soap, const char *tag, int id, const struct __ns1__TestPhoto_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__TestPhoto(soap, "ns1:TestPhoto", -1, &a->ns1__TestPhoto, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TestPhoto_ * SOAP_FMAC4 soap_in___ns1__TestPhoto_(struct soap *soap, const char *tag, struct __ns1__TestPhoto_ *a, const char *type)
{
	size_t soap_flag_ns1__TestPhoto = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TestPhoto_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TestPhoto_, sizeof(struct __ns1__TestPhoto_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TestPhoto_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TestPhoto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TestPhoto(soap, "ns1:TestPhoto", &a->ns1__TestPhoto, ""))
				{	soap_flag_ns1__TestPhoto--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TestPhoto_(struct soap *soap, const struct __ns1__TestPhoto_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__TestPhoto_(soap, tag?tag:"-ns1:TestPhoto", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TestPhoto_ * SOAP_FMAC4 soap_get___ns1__TestPhoto_(struct soap *soap, struct __ns1__TestPhoto_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TestPhoto_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__TestPhoto_ * SOAP_FMAC2 soap_instantiate___ns1__TestPhoto_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TestPhoto_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__TestPhoto_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__TestPhoto_);
		if (size)
			*size = sizeof(struct __ns1__TestPhoto_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__TestPhoto_, n);
		if (size)
			*size = n * sizeof(struct __ns1__TestPhoto_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__TestPhoto_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__TestPhoto_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__TestPhoto_ %p -> %p\n", q, p));
	*(struct __ns1__TestPhoto_*)p = *(struct __ns1__TestPhoto_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EndCalibrate_(struct soap *soap, struct __ns1__EndCalibrate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EndCalibrate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EndCalibrate_(struct soap *soap, const struct __ns1__EndCalibrate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EndCalibrate(soap, &a->ns1__EndCalibrate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EndCalibrate_(struct soap *soap, const char *tag, int id, const struct __ns1__EndCalibrate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EndCalibrate(soap, "ns1:EndCalibrate", -1, &a->ns1__EndCalibrate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndCalibrate_ * SOAP_FMAC4 soap_in___ns1__EndCalibrate_(struct soap *soap, const char *tag, struct __ns1__EndCalibrate_ *a, const char *type)
{
	size_t soap_flag_ns1__EndCalibrate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EndCalibrate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EndCalibrate_, sizeof(struct __ns1__EndCalibrate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EndCalibrate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EndCalibrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__EndCalibrate(soap, "ns1:EndCalibrate", &a->ns1__EndCalibrate, ""))
				{	soap_flag_ns1__EndCalibrate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EndCalibrate_(struct soap *soap, const struct __ns1__EndCalibrate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__EndCalibrate_(soap, tag?tag:"-ns1:EndCalibrate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndCalibrate_ * SOAP_FMAC4 soap_get___ns1__EndCalibrate_(struct soap *soap, struct __ns1__EndCalibrate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EndCalibrate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__EndCalibrate_ * SOAP_FMAC2 soap_instantiate___ns1__EndCalibrate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EndCalibrate_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__EndCalibrate_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__EndCalibrate_);
		if (size)
			*size = sizeof(struct __ns1__EndCalibrate_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__EndCalibrate_, n);
		if (size)
			*size = n * sizeof(struct __ns1__EndCalibrate_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__EndCalibrate_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__EndCalibrate_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__EndCalibrate_ %p -> %p\n", q, p));
	*(struct __ns1__EndCalibrate_*)p = *(struct __ns1__EndCalibrate_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadCalibrateData_(struct soap *soap, struct __ns1__UploadCalibrateData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadCalibrateData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadCalibrateData_(struct soap *soap, const struct __ns1__UploadCalibrateData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadCalibrateData(soap, &a->ns1__UploadCalibrateData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadCalibrateData_(struct soap *soap, const char *tag, int id, const struct __ns1__UploadCalibrateData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadCalibrateData(soap, "ns1:UploadCalibrateData", -1, &a->ns1__UploadCalibrateData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadCalibrateData_ * SOAP_FMAC4 soap_in___ns1__UploadCalibrateData_(struct soap *soap, const char *tag, struct __ns1__UploadCalibrateData_ *a, const char *type)
{
	size_t soap_flag_ns1__UploadCalibrateData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadCalibrateData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadCalibrateData_, sizeof(struct __ns1__UploadCalibrateData_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadCalibrateData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadCalibrateData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UploadCalibrateData(soap, "ns1:UploadCalibrateData", &a->ns1__UploadCalibrateData, ""))
				{	soap_flag_ns1__UploadCalibrateData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadCalibrateData_(struct soap *soap, const struct __ns1__UploadCalibrateData_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadCalibrateData_(soap, tag?tag:"-ns1:UploadCalibrateData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadCalibrateData_ * SOAP_FMAC4 soap_get___ns1__UploadCalibrateData_(struct soap *soap, struct __ns1__UploadCalibrateData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadCalibrateData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UploadCalibrateData_ * SOAP_FMAC2 soap_instantiate___ns1__UploadCalibrateData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadCalibrateData_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadCalibrateData_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UploadCalibrateData_);
		if (size)
			*size = sizeof(struct __ns1__UploadCalibrateData_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UploadCalibrateData_, n);
		if (size)
			*size = n * sizeof(struct __ns1__UploadCalibrateData_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UploadCalibrateData_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadCalibrateData_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadCalibrateData_ %p -> %p\n", q, p));
	*(struct __ns1__UploadCalibrateData_*)p = *(struct __ns1__UploadCalibrateData_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BeginCalibrate_(struct soap *soap, struct __ns1__BeginCalibrate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BeginCalibrate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BeginCalibrate_(struct soap *soap, const struct __ns1__BeginCalibrate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BeginCalibrate(soap, &a->ns1__BeginCalibrate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BeginCalibrate_(struct soap *soap, const char *tag, int id, const struct __ns1__BeginCalibrate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BeginCalibrate(soap, "ns1:BeginCalibrate", -1, &a->ns1__BeginCalibrate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginCalibrate_ * SOAP_FMAC4 soap_in___ns1__BeginCalibrate_(struct soap *soap, const char *tag, struct __ns1__BeginCalibrate_ *a, const char *type)
{
	size_t soap_flag_ns1__BeginCalibrate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BeginCalibrate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BeginCalibrate_, sizeof(struct __ns1__BeginCalibrate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BeginCalibrate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BeginCalibrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BeginCalibrate(soap, "ns1:BeginCalibrate", &a->ns1__BeginCalibrate, ""))
				{	soap_flag_ns1__BeginCalibrate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BeginCalibrate_(struct soap *soap, const struct __ns1__BeginCalibrate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__BeginCalibrate_(soap, tag?tag:"-ns1:BeginCalibrate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginCalibrate_ * SOAP_FMAC4 soap_get___ns1__BeginCalibrate_(struct soap *soap, struct __ns1__BeginCalibrate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BeginCalibrate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__BeginCalibrate_ * SOAP_FMAC2 soap_instantiate___ns1__BeginCalibrate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BeginCalibrate_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__BeginCalibrate_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__BeginCalibrate_);
		if (size)
			*size = sizeof(struct __ns1__BeginCalibrate_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__BeginCalibrate_, n);
		if (size)
			*size = n * sizeof(struct __ns1__BeginCalibrate_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__BeginCalibrate_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__BeginCalibrate_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__BeginCalibrate_ %p -> %p\n", q, p));
	*(struct __ns1__BeginCalibrate_*)p = *(struct __ns1__BeginCalibrate_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetInspectionInfo_(struct soap *soap, struct __ns1__GetInspectionInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInspectionInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetInspectionInfo_(struct soap *soap, const struct __ns1__GetInspectionInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetInspectionInfo(soap, &a->ns1__GetInspectionInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetInspectionInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetInspectionInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetInspectionInfo(soap, "ns1:GetInspectionInfo", -1, &a->ns1__GetInspectionInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectionInfo_ * SOAP_FMAC4 soap_in___ns1__GetInspectionInfo_(struct soap *soap, const char *tag, struct __ns1__GetInspectionInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetInspectionInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetInspectionInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetInspectionInfo_, sizeof(struct __ns1__GetInspectionInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetInspectionInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInspectionInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInspectionInfo(soap, "ns1:GetInspectionInfo", &a->ns1__GetInspectionInfo, ""))
				{	soap_flag_ns1__GetInspectionInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetInspectionInfo_(struct soap *soap, const struct __ns1__GetInspectionInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetInspectionInfo_(soap, tag?tag:"-ns1:GetInspectionInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectionInfo_ * SOAP_FMAC4 soap_get___ns1__GetInspectionInfo_(struct soap *soap, struct __ns1__GetInspectionInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetInspectionInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetInspectionInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetInspectionInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetInspectionInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetInspectionInfo_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetInspectionInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetInspectionInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetInspectionInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetInspectionInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetInspectionInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetInspectionInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetInspectionInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetInspectionInfo_*)p = *(struct __ns1__GetInspectionInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadRealtimeData_(struct soap *soap, struct __ns1__UploadRealtimeData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadRealtimeData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadRealtimeData_(struct soap *soap, const struct __ns1__UploadRealtimeData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadRealtimeData(soap, &a->ns1__UploadRealtimeData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadRealtimeData_(struct soap *soap, const char *tag, int id, const struct __ns1__UploadRealtimeData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadRealtimeData(soap, "ns1:UploadRealtimeData", -1, &a->ns1__UploadRealtimeData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadRealtimeData_ * SOAP_FMAC4 soap_in___ns1__UploadRealtimeData_(struct soap *soap, const char *tag, struct __ns1__UploadRealtimeData_ *a, const char *type)
{
	size_t soap_flag_ns1__UploadRealtimeData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadRealtimeData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadRealtimeData_, sizeof(struct __ns1__UploadRealtimeData_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadRealtimeData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadRealtimeData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UploadRealtimeData(soap, "ns1:UploadRealtimeData", &a->ns1__UploadRealtimeData, ""))
				{	soap_flag_ns1__UploadRealtimeData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadRealtimeData_(struct soap *soap, const struct __ns1__UploadRealtimeData_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadRealtimeData_(soap, tag?tag:"-ns1:UploadRealtimeData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadRealtimeData_ * SOAP_FMAC4 soap_get___ns1__UploadRealtimeData_(struct soap *soap, struct __ns1__UploadRealtimeData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadRealtimeData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UploadRealtimeData_ * SOAP_FMAC2 soap_instantiate___ns1__UploadRealtimeData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadRealtimeData_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadRealtimeData_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UploadRealtimeData_);
		if (size)
			*size = sizeof(struct __ns1__UploadRealtimeData_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UploadRealtimeData_, n);
		if (size)
			*size = n * sizeof(struct __ns1__UploadRealtimeData_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UploadRealtimeData_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadRealtimeData_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadRealtimeData_ %p -> %p\n", q, p));
	*(struct __ns1__UploadRealtimeData_*)p = *(struct __ns1__UploadRealtimeData_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadSelfTestData_(struct soap *soap, struct __ns1__UploadSelfTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadSelfTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadSelfTestData_(struct soap *soap, const struct __ns1__UploadSelfTestData_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadSelfTestData(soap, &a->ns1__UploadSelfTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadSelfTestData_(struct soap *soap, const char *tag, int id, const struct __ns1__UploadSelfTestData_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadSelfTestData(soap, "ns1:UploadSelfTestData", -1, &a->ns1__UploadSelfTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadSelfTestData_ * SOAP_FMAC4 soap_in___ns1__UploadSelfTestData_(struct soap *soap, const char *tag, struct __ns1__UploadSelfTestData_ *a, const char *type)
{
	size_t soap_flag_ns1__UploadSelfTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadSelfTestData_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadSelfTestData_, sizeof(struct __ns1__UploadSelfTestData_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadSelfTestData_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadSelfTestData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UploadSelfTestData(soap, "ns1:UploadSelfTestData", &a->ns1__UploadSelfTestData, ""))
				{	soap_flag_ns1__UploadSelfTestData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadSelfTestData_(struct soap *soap, const struct __ns1__UploadSelfTestData_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadSelfTestData_(soap, tag?tag:"-ns1:UploadSelfTestData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadSelfTestData_ * SOAP_FMAC4 soap_get___ns1__UploadSelfTestData_(struct soap *soap, struct __ns1__UploadSelfTestData_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadSelfTestData_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UploadSelfTestData_ * SOAP_FMAC2 soap_instantiate___ns1__UploadSelfTestData_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadSelfTestData_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadSelfTestData_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UploadSelfTestData_);
		if (size)
			*size = sizeof(struct __ns1__UploadSelfTestData_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UploadSelfTestData_, n);
		if (size)
			*size = n * sizeof(struct __ns1__UploadSelfTestData_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UploadSelfTestData_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadSelfTestData_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadSelfTestData_ %p -> %p\n", q, p));
	*(struct __ns1__UploadSelfTestData_*)p = *(struct __ns1__UploadSelfTestData_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EndInspect_(struct soap *soap, struct __ns1__EndInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EndInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EndInspect_(struct soap *soap, const struct __ns1__EndInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EndInspect(soap, &a->ns1__EndInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EndInspect_(struct soap *soap, const char *tag, int id, const struct __ns1__EndInspect_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EndInspect(soap, "ns1:EndInspect", -1, &a->ns1__EndInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndInspect_ * SOAP_FMAC4 soap_in___ns1__EndInspect_(struct soap *soap, const char *tag, struct __ns1__EndInspect_ *a, const char *type)
{
	size_t soap_flag_ns1__EndInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EndInspect_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EndInspect_, sizeof(struct __ns1__EndInspect_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EndInspect_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EndInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__EndInspect(soap, "ns1:EndInspect", &a->ns1__EndInspect, ""))
				{	soap_flag_ns1__EndInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EndInspect_(struct soap *soap, const struct __ns1__EndInspect_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__EndInspect_(soap, tag?tag:"-ns1:EndInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndInspect_ * SOAP_FMAC4 soap_get___ns1__EndInspect_(struct soap *soap, struct __ns1__EndInspect_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EndInspect_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__EndInspect_ * SOAP_FMAC2 soap_instantiate___ns1__EndInspect_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EndInspect_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__EndInspect_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__EndInspect_);
		if (size)
			*size = sizeof(struct __ns1__EndInspect_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__EndInspect_, n);
		if (size)
			*size = n * sizeof(struct __ns1__EndInspect_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__EndInspect_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__EndInspect_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__EndInspect_ %p -> %p\n", q, p));
	*(struct __ns1__EndInspect_*)p = *(struct __ns1__EndInspect_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__StopInspect_(struct soap *soap, struct __ns1__StopInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__StopInspect_(struct soap *soap, const struct __ns1__StopInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__StopInspect(soap, &a->ns1__StopInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__StopInspect_(struct soap *soap, const char *tag, int id, const struct __ns1__StopInspect_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__StopInspect(soap, "ns1:StopInspect", -1, &a->ns1__StopInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StopInspect_ * SOAP_FMAC4 soap_in___ns1__StopInspect_(struct soap *soap, const char *tag, struct __ns1__StopInspect_ *a, const char *type)
{
	size_t soap_flag_ns1__StopInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__StopInspect_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__StopInspect_, sizeof(struct __ns1__StopInspect_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__StopInspect_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopInspect(soap, "ns1:StopInspect", &a->ns1__StopInspect, ""))
				{	soap_flag_ns1__StopInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__StopInspect_(struct soap *soap, const struct __ns1__StopInspect_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__StopInspect_(soap, tag?tag:"-ns1:StopInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StopInspect_ * SOAP_FMAC4 soap_get___ns1__StopInspect_(struct soap *soap, struct __ns1__StopInspect_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__StopInspect_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__StopInspect_ * SOAP_FMAC2 soap_instantiate___ns1__StopInspect_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__StopInspect_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__StopInspect_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__StopInspect_);
		if (size)
			*size = sizeof(struct __ns1__StopInspect_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__StopInspect_, n);
		if (size)
			*size = n * sizeof(struct __ns1__StopInspect_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__StopInspect_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__StopInspect_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__StopInspect_ %p -> %p\n", q, p));
	*(struct __ns1__StopInspect_*)p = *(struct __ns1__StopInspect_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__WJTakePhoto_(struct soap *soap, struct __ns1__WJTakePhoto_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__WJTakePhoto = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__WJTakePhoto_(struct soap *soap, const struct __ns1__WJTakePhoto_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__WJTakePhoto(soap, &a->ns1__WJTakePhoto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__WJTakePhoto_(struct soap *soap, const char *tag, int id, const struct __ns1__WJTakePhoto_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__WJTakePhoto(soap, "ns1:WJTakePhoto", -1, &a->ns1__WJTakePhoto, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WJTakePhoto_ * SOAP_FMAC4 soap_in___ns1__WJTakePhoto_(struct soap *soap, const char *tag, struct __ns1__WJTakePhoto_ *a, const char *type)
{
	size_t soap_flag_ns1__WJTakePhoto = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__WJTakePhoto_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__WJTakePhoto_, sizeof(struct __ns1__WJTakePhoto_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__WJTakePhoto_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__WJTakePhoto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__WJTakePhoto(soap, "ns1:WJTakePhoto", &a->ns1__WJTakePhoto, ""))
				{	soap_flag_ns1__WJTakePhoto--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__WJTakePhoto_(struct soap *soap, const struct __ns1__WJTakePhoto_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__WJTakePhoto_(soap, tag?tag:"-ns1:WJTakePhoto", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WJTakePhoto_ * SOAP_FMAC4 soap_get___ns1__WJTakePhoto_(struct soap *soap, struct __ns1__WJTakePhoto_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__WJTakePhoto_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__WJTakePhoto_ * SOAP_FMAC2 soap_instantiate___ns1__WJTakePhoto_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__WJTakePhoto_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__WJTakePhoto_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__WJTakePhoto_);
		if (size)
			*size = sizeof(struct __ns1__WJTakePhoto_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__WJTakePhoto_, n);
		if (size)
			*size = n * sizeof(struct __ns1__WJTakePhoto_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__WJTakePhoto_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__WJTakePhoto_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__WJTakePhoto_ %p -> %p\n", q, p));
	*(struct __ns1__WJTakePhoto_*)p = *(struct __ns1__WJTakePhoto_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TakePhoto_(struct soap *soap, struct __ns1__TakePhoto_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TakePhoto = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TakePhoto_(struct soap *soap, const struct __ns1__TakePhoto_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__TakePhoto(soap, &a->ns1__TakePhoto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TakePhoto_(struct soap *soap, const char *tag, int id, const struct __ns1__TakePhoto_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__TakePhoto(soap, "ns1:TakePhoto", -1, &a->ns1__TakePhoto, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TakePhoto_ * SOAP_FMAC4 soap_in___ns1__TakePhoto_(struct soap *soap, const char *tag, struct __ns1__TakePhoto_ *a, const char *type)
{
	size_t soap_flag_ns1__TakePhoto = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TakePhoto_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TakePhoto_, sizeof(struct __ns1__TakePhoto_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TakePhoto_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TakePhoto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TakePhoto(soap, "ns1:TakePhoto", &a->ns1__TakePhoto, ""))
				{	soap_flag_ns1__TakePhoto--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TakePhoto_(struct soap *soap, const struct __ns1__TakePhoto_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__TakePhoto_(soap, tag?tag:"-ns1:TakePhoto", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TakePhoto_ * SOAP_FMAC4 soap_get___ns1__TakePhoto_(struct soap *soap, struct __ns1__TakePhoto_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TakePhoto_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__TakePhoto_ * SOAP_FMAC2 soap_instantiate___ns1__TakePhoto_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TakePhoto_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__TakePhoto_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__TakePhoto_);
		if (size)
			*size = sizeof(struct __ns1__TakePhoto_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__TakePhoto_, n);
		if (size)
			*size = n * sizeof(struct __ns1__TakePhoto_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__TakePhoto_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__TakePhoto_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__TakePhoto_ %p -> %p\n", q, p));
	*(struct __ns1__TakePhoto_*)p = *(struct __ns1__TakePhoto_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLimit_(struct soap *soap, struct __ns1__GetLimit_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLimit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLimit_(struct soap *soap, const struct __ns1__GetLimit_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLimit(soap, &a->ns1__GetLimit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLimit_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLimit_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLimit(soap, "ns1:GetLimit", -1, &a->ns1__GetLimit, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLimit_ * SOAP_FMAC4 soap_in___ns1__GetLimit_(struct soap *soap, const char *tag, struct __ns1__GetLimit_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLimit = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLimit_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLimit_, sizeof(struct __ns1__GetLimit_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLimit_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLimit(soap, "ns1:GetLimit", &a->ns1__GetLimit, ""))
				{	soap_flag_ns1__GetLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLimit_(struct soap *soap, const struct __ns1__GetLimit_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLimit_(soap, tag?tag:"-ns1:GetLimit", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLimit_ * SOAP_FMAC4 soap_get___ns1__GetLimit_(struct soap *soap, struct __ns1__GetLimit_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLimit_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetLimit_ * SOAP_FMAC2 soap_instantiate___ns1__GetLimit_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLimit_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLimit_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetLimit_);
		if (size)
			*size = sizeof(struct __ns1__GetLimit_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetLimit_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetLimit_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetLimit_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLimit_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLimit_ %p -> %p\n", q, p));
	*(struct __ns1__GetLimit_*)p = *(struct __ns1__GetLimit_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BeginInspect_(struct soap *soap, struct __ns1__BeginInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BeginInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BeginInspect_(struct soap *soap, const struct __ns1__BeginInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BeginInspect(soap, &a->ns1__BeginInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BeginInspect_(struct soap *soap, const char *tag, int id, const struct __ns1__BeginInspect_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BeginInspect(soap, "ns1:BeginInspect", -1, &a->ns1__BeginInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginInspect_ * SOAP_FMAC4 soap_in___ns1__BeginInspect_(struct soap *soap, const char *tag, struct __ns1__BeginInspect_ *a, const char *type)
{
	size_t soap_flag_ns1__BeginInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BeginInspect_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BeginInspect_, sizeof(struct __ns1__BeginInspect_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BeginInspect_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BeginInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BeginInspect(soap, "ns1:BeginInspect", &a->ns1__BeginInspect, ""))
				{	soap_flag_ns1__BeginInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BeginInspect_(struct soap *soap, const struct __ns1__BeginInspect_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__BeginInspect_(soap, tag?tag:"-ns1:BeginInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginInspect_ * SOAP_FMAC4 soap_get___ns1__BeginInspect_(struct soap *soap, struct __ns1__BeginInspect_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BeginInspect_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__BeginInspect_ * SOAP_FMAC2 soap_instantiate___ns1__BeginInspect_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BeginInspect_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__BeginInspect_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__BeginInspect_);
		if (size)
			*size = sizeof(struct __ns1__BeginInspect_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__BeginInspect_, n);
		if (size)
			*size = n * sizeof(struct __ns1__BeginInspect_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__BeginInspect_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__BeginInspect_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__BeginInspect_ %p -> %p\n", q, p));
	*(struct __ns1__BeginInspect_*)p = *(struct __ns1__BeginInspect_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EndRecord_(struct soap *soap, struct __ns1__EndRecord_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EndRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EndRecord_(struct soap *soap, const struct __ns1__EndRecord_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EndRecord(soap, &a->ns1__EndRecord);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EndRecord_(struct soap *soap, const char *tag, int id, const struct __ns1__EndRecord_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EndRecord(soap, "ns1:EndRecord", -1, &a->ns1__EndRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndRecord_ * SOAP_FMAC4 soap_in___ns1__EndRecord_(struct soap *soap, const char *tag, struct __ns1__EndRecord_ *a, const char *type)
{
	size_t soap_flag_ns1__EndRecord = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EndRecord_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EndRecord_, sizeof(struct __ns1__EndRecord_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EndRecord_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EndRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__EndRecord(soap, "ns1:EndRecord", &a->ns1__EndRecord, ""))
				{	soap_flag_ns1__EndRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EndRecord_(struct soap *soap, const struct __ns1__EndRecord_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__EndRecord_(soap, tag?tag:"-ns1:EndRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndRecord_ * SOAP_FMAC4 soap_get___ns1__EndRecord_(struct soap *soap, struct __ns1__EndRecord_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EndRecord_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__EndRecord_ * SOAP_FMAC2 soap_instantiate___ns1__EndRecord_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EndRecord_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__EndRecord_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__EndRecord_);
		if (size)
			*size = sizeof(struct __ns1__EndRecord_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__EndRecord_, n);
		if (size)
			*size = n * sizeof(struct __ns1__EndRecord_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__EndRecord_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__EndRecord_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__EndRecord_ %p -> %p\n", q, p));
	*(struct __ns1__EndRecord_*)p = *(struct __ns1__EndRecord_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BeginRecord_(struct soap *soap, struct __ns1__BeginRecord_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BeginRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BeginRecord_(struct soap *soap, const struct __ns1__BeginRecord_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BeginRecord(soap, &a->ns1__BeginRecord);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BeginRecord_(struct soap *soap, const char *tag, int id, const struct __ns1__BeginRecord_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BeginRecord(soap, "ns1:BeginRecord", -1, &a->ns1__BeginRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginRecord_ * SOAP_FMAC4 soap_in___ns1__BeginRecord_(struct soap *soap, const char *tag, struct __ns1__BeginRecord_ *a, const char *type)
{
	size_t soap_flag_ns1__BeginRecord = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BeginRecord_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BeginRecord_, sizeof(struct __ns1__BeginRecord_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BeginRecord_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BeginRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BeginRecord(soap, "ns1:BeginRecord", &a->ns1__BeginRecord, ""))
				{	soap_flag_ns1__BeginRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BeginRecord_(struct soap *soap, const struct __ns1__BeginRecord_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__BeginRecord_(soap, tag?tag:"-ns1:BeginRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginRecord_ * SOAP_FMAC4 soap_get___ns1__BeginRecord_(struct soap *soap, struct __ns1__BeginRecord_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BeginRecord_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__BeginRecord_ * SOAP_FMAC2 soap_instantiate___ns1__BeginRecord_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BeginRecord_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__BeginRecord_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__BeginRecord_);
		if (size)
			*size = sizeof(struct __ns1__BeginRecord_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__BeginRecord_, n);
		if (size)
			*size = n * sizeof(struct __ns1__BeginRecord_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__BeginRecord_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__BeginRecord_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__BeginRecord_ %p -> %p\n", q, p));
	*(struct __ns1__BeginRecord_*)p = *(struct __ns1__BeginRecord_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AbortInspect_(struct soap *soap, struct __ns1__AbortInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AbortInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AbortInspect_(struct soap *soap, const struct __ns1__AbortInspect_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AbortInspect(soap, &a->ns1__AbortInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AbortInspect_(struct soap *soap, const char *tag, int id, const struct __ns1__AbortInspect_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AbortInspect(soap, "ns1:AbortInspect", -1, &a->ns1__AbortInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AbortInspect_ * SOAP_FMAC4 soap_in___ns1__AbortInspect_(struct soap *soap, const char *tag, struct __ns1__AbortInspect_ *a, const char *type)
{
	size_t soap_flag_ns1__AbortInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AbortInspect_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AbortInspect_, sizeof(struct __ns1__AbortInspect_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AbortInspect_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AbortInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AbortInspect(soap, "ns1:AbortInspect", &a->ns1__AbortInspect, ""))
				{	soap_flag_ns1__AbortInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AbortInspect_(struct soap *soap, const struct __ns1__AbortInspect_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__AbortInspect_(soap, tag?tag:"-ns1:AbortInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AbortInspect_ * SOAP_FMAC4 soap_get___ns1__AbortInspect_(struct soap *soap, struct __ns1__AbortInspect_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AbortInspect_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__AbortInspect_ * SOAP_FMAC2 soap_instantiate___ns1__AbortInspect_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AbortInspect_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__AbortInspect_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__AbortInspect_);
		if (size)
			*size = sizeof(struct __ns1__AbortInspect_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__AbortInspect_, n);
		if (size)
			*size = n * sizeof(struct __ns1__AbortInspect_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__AbortInspect_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__AbortInspect_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__AbortInspect_ %p -> %p\n", q, p));
	*(struct __ns1__AbortInspect_*)p = *(struct __ns1__AbortInspect_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetInspectQueueByPlateID_(struct soap *soap, struct __ns1__GetInspectQueueByPlateID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInspectQueueByPlateID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetInspectQueueByPlateID_(struct soap *soap, const struct __ns1__GetInspectQueueByPlateID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetInspectQueueByPlateID(soap, &a->ns1__GetInspectQueueByPlateID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetInspectQueueByPlateID_(struct soap *soap, const char *tag, int id, const struct __ns1__GetInspectQueueByPlateID_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetInspectQueueByPlateID(soap, "ns1:GetInspectQueueByPlateID", -1, &a->ns1__GetInspectQueueByPlateID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectQueueByPlateID_ * SOAP_FMAC4 soap_in___ns1__GetInspectQueueByPlateID_(struct soap *soap, const char *tag, struct __ns1__GetInspectQueueByPlateID_ *a, const char *type)
{
	size_t soap_flag_ns1__GetInspectQueueByPlateID = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetInspectQueueByPlateID_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetInspectQueueByPlateID_, sizeof(struct __ns1__GetInspectQueueByPlateID_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetInspectQueueByPlateID_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInspectQueueByPlateID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInspectQueueByPlateID(soap, "ns1:GetInspectQueueByPlateID", &a->ns1__GetInspectQueueByPlateID, ""))
				{	soap_flag_ns1__GetInspectQueueByPlateID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetInspectQueueByPlateID_(struct soap *soap, const struct __ns1__GetInspectQueueByPlateID_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetInspectQueueByPlateID_(soap, tag?tag:"-ns1:GetInspectQueueByPlateID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectQueueByPlateID_ * SOAP_FMAC4 soap_get___ns1__GetInspectQueueByPlateID_(struct soap *soap, struct __ns1__GetInspectQueueByPlateID_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetInspectQueueByPlateID_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetInspectQueueByPlateID_ * SOAP_FMAC2 soap_instantiate___ns1__GetInspectQueueByPlateID_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetInspectQueueByPlateID_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetInspectQueueByPlateID_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetInspectQueueByPlateID_);
		if (size)
			*size = sizeof(struct __ns1__GetInspectQueueByPlateID_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetInspectQueueByPlateID_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetInspectQueueByPlateID_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetInspectQueueByPlateID_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetInspectQueueByPlateID_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetInspectQueueByPlateID_ %p -> %p\n", q, p));
	*(struct __ns1__GetInspectQueueByPlateID_*)p = *(struct __ns1__GetInspectQueueByPlateID_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetInspectQueueByDate_(struct soap *soap, struct __ns1__GetInspectQueueByDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInspectQueueByDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetInspectQueueByDate_(struct soap *soap, const struct __ns1__GetInspectQueueByDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetInspectQueueByDate(soap, &a->ns1__GetInspectQueueByDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetInspectQueueByDate_(struct soap *soap, const char *tag, int id, const struct __ns1__GetInspectQueueByDate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetInspectQueueByDate(soap, "ns1:GetInspectQueueByDate", -1, &a->ns1__GetInspectQueueByDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectQueueByDate_ * SOAP_FMAC4 soap_in___ns1__GetInspectQueueByDate_(struct soap *soap, const char *tag, struct __ns1__GetInspectQueueByDate_ *a, const char *type)
{
	size_t soap_flag_ns1__GetInspectQueueByDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetInspectQueueByDate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetInspectQueueByDate_, sizeof(struct __ns1__GetInspectQueueByDate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetInspectQueueByDate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInspectQueueByDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInspectQueueByDate(soap, "ns1:GetInspectQueueByDate", &a->ns1__GetInspectQueueByDate, ""))
				{	soap_flag_ns1__GetInspectQueueByDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetInspectQueueByDate_(struct soap *soap, const struct __ns1__GetInspectQueueByDate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetInspectQueueByDate_(soap, tag?tag:"-ns1:GetInspectQueueByDate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectQueueByDate_ * SOAP_FMAC4 soap_get___ns1__GetInspectQueueByDate_(struct soap *soap, struct __ns1__GetInspectQueueByDate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetInspectQueueByDate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetInspectQueueByDate_ * SOAP_FMAC2 soap_instantiate___ns1__GetInspectQueueByDate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetInspectQueueByDate_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetInspectQueueByDate_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetInspectQueueByDate_);
		if (size)
			*size = sizeof(struct __ns1__GetInspectQueueByDate_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetInspectQueueByDate_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetInspectQueueByDate_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetInspectQueueByDate_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetInspectQueueByDate_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetInspectQueueByDate_ %p -> %p\n", q, p));
	*(struct __ns1__GetInspectQueueByDate_*)p = *(struct __ns1__GetInspectQueueByDate_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Sync_(struct soap *soap, struct __ns1__Sync_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Sync = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Sync_(struct soap *soap, const struct __ns1__Sync_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Sync(soap, &a->ns1__Sync);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Sync_(struct soap *soap, const char *tag, int id, const struct __ns1__Sync_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Sync(soap, "ns1:Sync", -1, &a->ns1__Sync, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Sync_ * SOAP_FMAC4 soap_in___ns1__Sync_(struct soap *soap, const char *tag, struct __ns1__Sync_ *a, const char *type)
{
	size_t soap_flag_ns1__Sync = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Sync_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Sync_, sizeof(struct __ns1__Sync_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Sync_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Sync && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Sync(soap, "ns1:Sync", &a->ns1__Sync, ""))
				{	soap_flag_ns1__Sync--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Sync_(struct soap *soap, const struct __ns1__Sync_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Sync_(soap, tag?tag:"-ns1:Sync", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Sync_ * SOAP_FMAC4 soap_get___ns1__Sync_(struct soap *soap, struct __ns1__Sync_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Sync_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Sync_ * SOAP_FMAC2 soap_instantiate___ns1__Sync_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Sync_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Sync_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__Sync_);
		if (size)
			*size = sizeof(struct __ns1__Sync_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__Sync_, n);
		if (size)
			*size = n * sizeof(struct __ns1__Sync_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Sync_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Sync_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Sync_ %p -> %p\n", q, p));
	*(struct __ns1__Sync_*)p = *(struct __ns1__Sync_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OBDTXCheck(struct soap *soap, struct __ns1__OBDTXCheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OBDTXCheck = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OBDTXCheck(struct soap *soap, const struct __ns1__OBDTXCheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OBDTXCheck(soap, &a->ns1__OBDTXCheck);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OBDTXCheck(struct soap *soap, const char *tag, int id, const struct __ns1__OBDTXCheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OBDTXCheck(soap, "ns1:OBDTXCheck", -1, &a->ns1__OBDTXCheck, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OBDTXCheck * SOAP_FMAC4 soap_in___ns1__OBDTXCheck(struct soap *soap, const char *tag, struct __ns1__OBDTXCheck *a, const char *type)
{
	size_t soap_flag_ns1__OBDTXCheck = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OBDTXCheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OBDTXCheck, sizeof(struct __ns1__OBDTXCheck), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OBDTXCheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OBDTXCheck && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OBDTXCheck(soap, "ns1:OBDTXCheck", &a->ns1__OBDTXCheck, ""))
				{	soap_flag_ns1__OBDTXCheck--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OBDTXCheck(struct soap *soap, const struct __ns1__OBDTXCheck *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__OBDTXCheck(soap, tag?tag:"-ns1:OBDTXCheck", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OBDTXCheck * SOAP_FMAC4 soap_get___ns1__OBDTXCheck(struct soap *soap, struct __ns1__OBDTXCheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OBDTXCheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__OBDTXCheck * SOAP_FMAC2 soap_instantiate___ns1__OBDTXCheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OBDTXCheck(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__OBDTXCheck, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__OBDTXCheck);
		if (size)
			*size = sizeof(struct __ns1__OBDTXCheck);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__OBDTXCheck, n);
		if (size)
			*size = n * sizeof(struct __ns1__OBDTXCheck);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__OBDTXCheck*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__OBDTXCheck(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__OBDTXCheck %p -> %p\n", q, p));
	*(struct __ns1__OBDTXCheck*)p = *(struct __ns1__OBDTXCheck*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OBDInspect(struct soap *soap, struct __ns1__OBDInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OBDInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OBDInspect(struct soap *soap, const struct __ns1__OBDInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OBDInspect(soap, &a->ns1__OBDInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OBDInspect(struct soap *soap, const char *tag, int id, const struct __ns1__OBDInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OBDInspect(soap, "ns1:OBDInspect", -1, &a->ns1__OBDInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OBDInspect * SOAP_FMAC4 soap_in___ns1__OBDInspect(struct soap *soap, const char *tag, struct __ns1__OBDInspect *a, const char *type)
{
	size_t soap_flag_ns1__OBDInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OBDInspect *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OBDInspect, sizeof(struct __ns1__OBDInspect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OBDInspect(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OBDInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OBDInspect(soap, "ns1:OBDInspect", &a->ns1__OBDInspect, ""))
				{	soap_flag_ns1__OBDInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OBDInspect(struct soap *soap, const struct __ns1__OBDInspect *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__OBDInspect(soap, tag?tag:"-ns1:OBDInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OBDInspect * SOAP_FMAC4 soap_get___ns1__OBDInspect(struct soap *soap, struct __ns1__OBDInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OBDInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__OBDInspect * SOAP_FMAC2 soap_instantiate___ns1__OBDInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OBDInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__OBDInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__OBDInspect);
		if (size)
			*size = sizeof(struct __ns1__OBDInspect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__OBDInspect, n);
		if (size)
			*size = n * sizeof(struct __ns1__OBDInspect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__OBDInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__OBDInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__OBDInspect %p -> %p\n", q, p));
	*(struct __ns1__OBDInspect*)p = *(struct __ns1__OBDInspect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetOtherInspectQueueByDate(struct soap *soap, struct __ns1__GetOtherInspectQueueByDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOtherInspectQueueByDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetOtherInspectQueueByDate(struct soap *soap, const struct __ns1__GetOtherInspectQueueByDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetOtherInspectQueueByDate(soap, &a->ns1__GetOtherInspectQueueByDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetOtherInspectQueueByDate(struct soap *soap, const char *tag, int id, const struct __ns1__GetOtherInspectQueueByDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetOtherInspectQueueByDate(soap, "ns1:GetOtherInspectQueueByDate", -1, &a->ns1__GetOtherInspectQueueByDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOtherInspectQueueByDate * SOAP_FMAC4 soap_in___ns1__GetOtherInspectQueueByDate(struct soap *soap, const char *tag, struct __ns1__GetOtherInspectQueueByDate *a, const char *type)
{
	size_t soap_flag_ns1__GetOtherInspectQueueByDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetOtherInspectQueueByDate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetOtherInspectQueueByDate, sizeof(struct __ns1__GetOtherInspectQueueByDate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetOtherInspectQueueByDate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOtherInspectQueueByDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetOtherInspectQueueByDate(soap, "ns1:GetOtherInspectQueueByDate", &a->ns1__GetOtherInspectQueueByDate, ""))
				{	soap_flag_ns1__GetOtherInspectQueueByDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetOtherInspectQueueByDate(struct soap *soap, const struct __ns1__GetOtherInspectQueueByDate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetOtherInspectQueueByDate(soap, tag?tag:"-ns1:GetOtherInspectQueueByDate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOtherInspectQueueByDate * SOAP_FMAC4 soap_get___ns1__GetOtherInspectQueueByDate(struct soap *soap, struct __ns1__GetOtherInspectQueueByDate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetOtherInspectQueueByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetOtherInspectQueueByDate * SOAP_FMAC2 soap_instantiate___ns1__GetOtherInspectQueueByDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetOtherInspectQueueByDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetOtherInspectQueueByDate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetOtherInspectQueueByDate);
		if (size)
			*size = sizeof(struct __ns1__GetOtherInspectQueueByDate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetOtherInspectQueueByDate, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetOtherInspectQueueByDate);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetOtherInspectQueueByDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetOtherInspectQueueByDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetOtherInspectQueueByDate %p -> %p\n", q, p));
	*(struct __ns1__GetOtherInspectQueueByDate*)p = *(struct __ns1__GetOtherInspectQueueByDate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetOtherInspectQueueByPlateID(struct soap *soap, struct __ns1__GetOtherInspectQueueByPlateID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOtherInspectQueueByPlateID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetOtherInspectQueueByPlateID(struct soap *soap, const struct __ns1__GetOtherInspectQueueByPlateID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, &a->ns1__GetOtherInspectQueueByPlateID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetOtherInspectQueueByPlateID(struct soap *soap, const char *tag, int id, const struct __ns1__GetOtherInspectQueueByPlateID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, "ns1:GetOtherInspectQueueByPlateID", -1, &a->ns1__GetOtherInspectQueueByPlateID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOtherInspectQueueByPlateID * SOAP_FMAC4 soap_in___ns1__GetOtherInspectQueueByPlateID(struct soap *soap, const char *tag, struct __ns1__GetOtherInspectQueueByPlateID *a, const char *type)
{
	size_t soap_flag_ns1__GetOtherInspectQueueByPlateID = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetOtherInspectQueueByPlateID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID, sizeof(struct __ns1__GetOtherInspectQueueByPlateID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetOtherInspectQueueByPlateID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOtherInspectQueueByPlateID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, "ns1:GetOtherInspectQueueByPlateID", &a->ns1__GetOtherInspectQueueByPlateID, ""))
				{	soap_flag_ns1__GetOtherInspectQueueByPlateID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetOtherInspectQueueByPlateID(struct soap *soap, const struct __ns1__GetOtherInspectQueueByPlateID *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetOtherInspectQueueByPlateID(soap, tag?tag:"-ns1:GetOtherInspectQueueByPlateID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOtherInspectQueueByPlateID * SOAP_FMAC4 soap_get___ns1__GetOtherInspectQueueByPlateID(struct soap *soap, struct __ns1__GetOtherInspectQueueByPlateID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetOtherInspectQueueByPlateID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetOtherInspectQueueByPlateID * SOAP_FMAC2 soap_instantiate___ns1__GetOtherInspectQueueByPlateID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetOtherInspectQueueByPlateID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetOtherInspectQueueByPlateID, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetOtherInspectQueueByPlateID);
		if (size)
			*size = sizeof(struct __ns1__GetOtherInspectQueueByPlateID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetOtherInspectQueueByPlateID, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetOtherInspectQueueByPlateID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetOtherInspectQueueByPlateID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetOtherInspectQueueByPlateID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetOtherInspectQueueByPlateID %p -> %p\n", q, p));
	*(struct __ns1__GetOtherInspectQueueByPlateID*)p = *(struct __ns1__GetOtherInspectQueueByPlateID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetInspectParams(struct soap *soap, struct __ns1__GetInspectParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInspectParams = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetInspectParams(struct soap *soap, const struct __ns1__GetInspectParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetInspectParams(soap, &a->ns1__GetInspectParams);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetInspectParams(struct soap *soap, const char *tag, int id, const struct __ns1__GetInspectParams *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetInspectParams(soap, "ns1:GetInspectParams", -1, &a->ns1__GetInspectParams, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectParams * SOAP_FMAC4 soap_in___ns1__GetInspectParams(struct soap *soap, const char *tag, struct __ns1__GetInspectParams *a, const char *type)
{
	size_t soap_flag_ns1__GetInspectParams = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetInspectParams *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetInspectParams, sizeof(struct __ns1__GetInspectParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetInspectParams(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInspectParams && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInspectParams(soap, "ns1:GetInspectParams", &a->ns1__GetInspectParams, ""))
				{	soap_flag_ns1__GetInspectParams--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetInspectParams(struct soap *soap, const struct __ns1__GetInspectParams *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetInspectParams(soap, tag?tag:"-ns1:GetInspectParams", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectParams * SOAP_FMAC4 soap_get___ns1__GetInspectParams(struct soap *soap, struct __ns1__GetInspectParams *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetInspectParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetInspectParams * SOAP_FMAC2 soap_instantiate___ns1__GetInspectParams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetInspectParams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetInspectParams, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetInspectParams);
		if (size)
			*size = sizeof(struct __ns1__GetInspectParams);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetInspectParams, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetInspectParams);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetInspectParams*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetInspectParams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetInspectParams %p -> %p\n", q, p));
	*(struct __ns1__GetInspectParams*)p = *(struct __ns1__GetInspectParams*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__FuelEvaporationInspect(struct soap *soap, struct __ns1__FuelEvaporationInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__FuelEvaporationInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__FuelEvaporationInspect(struct soap *soap, const struct __ns1__FuelEvaporationInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__FuelEvaporationInspect(soap, &a->ns1__FuelEvaporationInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__FuelEvaporationInspect(struct soap *soap, const char *tag, int id, const struct __ns1__FuelEvaporationInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__FuelEvaporationInspect(soap, "ns1:FuelEvaporationInspect", -1, &a->ns1__FuelEvaporationInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FuelEvaporationInspect * SOAP_FMAC4 soap_in___ns1__FuelEvaporationInspect(struct soap *soap, const char *tag, struct __ns1__FuelEvaporationInspect *a, const char *type)
{
	size_t soap_flag_ns1__FuelEvaporationInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__FuelEvaporationInspect *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__FuelEvaporationInspect, sizeof(struct __ns1__FuelEvaporationInspect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__FuelEvaporationInspect(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__FuelEvaporationInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__FuelEvaporationInspect(soap, "ns1:FuelEvaporationInspect", &a->ns1__FuelEvaporationInspect, ""))
				{	soap_flag_ns1__FuelEvaporationInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__FuelEvaporationInspect(struct soap *soap, const struct __ns1__FuelEvaporationInspect *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__FuelEvaporationInspect(soap, tag?tag:"-ns1:FuelEvaporationInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__FuelEvaporationInspect * SOAP_FMAC4 soap_get___ns1__FuelEvaporationInspect(struct soap *soap, struct __ns1__FuelEvaporationInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__FuelEvaporationInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__FuelEvaporationInspect * SOAP_FMAC2 soap_instantiate___ns1__FuelEvaporationInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__FuelEvaporationInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__FuelEvaporationInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__FuelEvaporationInspect);
		if (size)
			*size = sizeof(struct __ns1__FuelEvaporationInspect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__FuelEvaporationInspect, n);
		if (size)
			*size = n * sizeof(struct __ns1__FuelEvaporationInspect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__FuelEvaporationInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__FuelEvaporationInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__FuelEvaporationInspect %p -> %p\n", q, p));
	*(struct __ns1__FuelEvaporationInspect*)p = *(struct __ns1__FuelEvaporationInspect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TestPhoto(struct soap *soap, struct __ns1__TestPhoto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TestPhoto = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TestPhoto(struct soap *soap, const struct __ns1__TestPhoto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__TestPhoto(soap, &a->ns1__TestPhoto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TestPhoto(struct soap *soap, const char *tag, int id, const struct __ns1__TestPhoto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__TestPhoto(soap, "ns1:TestPhoto", -1, &a->ns1__TestPhoto, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TestPhoto * SOAP_FMAC4 soap_in___ns1__TestPhoto(struct soap *soap, const char *tag, struct __ns1__TestPhoto *a, const char *type)
{
	size_t soap_flag_ns1__TestPhoto = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TestPhoto *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TestPhoto, sizeof(struct __ns1__TestPhoto), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TestPhoto(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TestPhoto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TestPhoto(soap, "ns1:TestPhoto", &a->ns1__TestPhoto, ""))
				{	soap_flag_ns1__TestPhoto--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TestPhoto(struct soap *soap, const struct __ns1__TestPhoto *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__TestPhoto(soap, tag?tag:"-ns1:TestPhoto", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TestPhoto * SOAP_FMAC4 soap_get___ns1__TestPhoto(struct soap *soap, struct __ns1__TestPhoto *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TestPhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__TestPhoto * SOAP_FMAC2 soap_instantiate___ns1__TestPhoto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TestPhoto(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__TestPhoto, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__TestPhoto);
		if (size)
			*size = sizeof(struct __ns1__TestPhoto);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__TestPhoto, n);
		if (size)
			*size = n * sizeof(struct __ns1__TestPhoto);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__TestPhoto*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__TestPhoto(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__TestPhoto %p -> %p\n", q, p));
	*(struct __ns1__TestPhoto*)p = *(struct __ns1__TestPhoto*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EndCalibrate(struct soap *soap, struct __ns1__EndCalibrate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EndCalibrate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EndCalibrate(struct soap *soap, const struct __ns1__EndCalibrate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EndCalibrate(soap, &a->ns1__EndCalibrate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EndCalibrate(struct soap *soap, const char *tag, int id, const struct __ns1__EndCalibrate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EndCalibrate(soap, "ns1:EndCalibrate", -1, &a->ns1__EndCalibrate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndCalibrate * SOAP_FMAC4 soap_in___ns1__EndCalibrate(struct soap *soap, const char *tag, struct __ns1__EndCalibrate *a, const char *type)
{
	size_t soap_flag_ns1__EndCalibrate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EndCalibrate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EndCalibrate, sizeof(struct __ns1__EndCalibrate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EndCalibrate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EndCalibrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__EndCalibrate(soap, "ns1:EndCalibrate", &a->ns1__EndCalibrate, ""))
				{	soap_flag_ns1__EndCalibrate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EndCalibrate(struct soap *soap, const struct __ns1__EndCalibrate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__EndCalibrate(soap, tag?tag:"-ns1:EndCalibrate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndCalibrate * SOAP_FMAC4 soap_get___ns1__EndCalibrate(struct soap *soap, struct __ns1__EndCalibrate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EndCalibrate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__EndCalibrate * SOAP_FMAC2 soap_instantiate___ns1__EndCalibrate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EndCalibrate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__EndCalibrate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__EndCalibrate);
		if (size)
			*size = sizeof(struct __ns1__EndCalibrate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__EndCalibrate, n);
		if (size)
			*size = n * sizeof(struct __ns1__EndCalibrate);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__EndCalibrate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__EndCalibrate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__EndCalibrate %p -> %p\n", q, p));
	*(struct __ns1__EndCalibrate*)p = *(struct __ns1__EndCalibrate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadCalibrateData(struct soap *soap, struct __ns1__UploadCalibrateData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadCalibrateData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadCalibrateData(struct soap *soap, const struct __ns1__UploadCalibrateData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadCalibrateData(soap, &a->ns1__UploadCalibrateData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadCalibrateData(struct soap *soap, const char *tag, int id, const struct __ns1__UploadCalibrateData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadCalibrateData(soap, "ns1:UploadCalibrateData", -1, &a->ns1__UploadCalibrateData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadCalibrateData * SOAP_FMAC4 soap_in___ns1__UploadCalibrateData(struct soap *soap, const char *tag, struct __ns1__UploadCalibrateData *a, const char *type)
{
	size_t soap_flag_ns1__UploadCalibrateData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadCalibrateData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadCalibrateData, sizeof(struct __ns1__UploadCalibrateData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadCalibrateData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadCalibrateData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UploadCalibrateData(soap, "ns1:UploadCalibrateData", &a->ns1__UploadCalibrateData, ""))
				{	soap_flag_ns1__UploadCalibrateData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadCalibrateData(struct soap *soap, const struct __ns1__UploadCalibrateData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadCalibrateData(soap, tag?tag:"-ns1:UploadCalibrateData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadCalibrateData * SOAP_FMAC4 soap_get___ns1__UploadCalibrateData(struct soap *soap, struct __ns1__UploadCalibrateData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadCalibrateData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UploadCalibrateData * SOAP_FMAC2 soap_instantiate___ns1__UploadCalibrateData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadCalibrateData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadCalibrateData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UploadCalibrateData);
		if (size)
			*size = sizeof(struct __ns1__UploadCalibrateData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UploadCalibrateData, n);
		if (size)
			*size = n * sizeof(struct __ns1__UploadCalibrateData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UploadCalibrateData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadCalibrateData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadCalibrateData %p -> %p\n", q, p));
	*(struct __ns1__UploadCalibrateData*)p = *(struct __ns1__UploadCalibrateData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BeginCalibrate(struct soap *soap, struct __ns1__BeginCalibrate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BeginCalibrate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BeginCalibrate(struct soap *soap, const struct __ns1__BeginCalibrate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BeginCalibrate(soap, &a->ns1__BeginCalibrate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BeginCalibrate(struct soap *soap, const char *tag, int id, const struct __ns1__BeginCalibrate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BeginCalibrate(soap, "ns1:BeginCalibrate", -1, &a->ns1__BeginCalibrate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginCalibrate * SOAP_FMAC4 soap_in___ns1__BeginCalibrate(struct soap *soap, const char *tag, struct __ns1__BeginCalibrate *a, const char *type)
{
	size_t soap_flag_ns1__BeginCalibrate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BeginCalibrate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BeginCalibrate, sizeof(struct __ns1__BeginCalibrate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BeginCalibrate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BeginCalibrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BeginCalibrate(soap, "ns1:BeginCalibrate", &a->ns1__BeginCalibrate, ""))
				{	soap_flag_ns1__BeginCalibrate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BeginCalibrate(struct soap *soap, const struct __ns1__BeginCalibrate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__BeginCalibrate(soap, tag?tag:"-ns1:BeginCalibrate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginCalibrate * SOAP_FMAC4 soap_get___ns1__BeginCalibrate(struct soap *soap, struct __ns1__BeginCalibrate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BeginCalibrate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__BeginCalibrate * SOAP_FMAC2 soap_instantiate___ns1__BeginCalibrate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BeginCalibrate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__BeginCalibrate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__BeginCalibrate);
		if (size)
			*size = sizeof(struct __ns1__BeginCalibrate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__BeginCalibrate, n);
		if (size)
			*size = n * sizeof(struct __ns1__BeginCalibrate);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__BeginCalibrate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__BeginCalibrate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__BeginCalibrate %p -> %p\n", q, p));
	*(struct __ns1__BeginCalibrate*)p = *(struct __ns1__BeginCalibrate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetInspectionInfo(struct soap *soap, struct __ns1__GetInspectionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInspectionInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetInspectionInfo(struct soap *soap, const struct __ns1__GetInspectionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetInspectionInfo(soap, &a->ns1__GetInspectionInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetInspectionInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetInspectionInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetInspectionInfo(soap, "ns1:GetInspectionInfo", -1, &a->ns1__GetInspectionInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectionInfo * SOAP_FMAC4 soap_in___ns1__GetInspectionInfo(struct soap *soap, const char *tag, struct __ns1__GetInspectionInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetInspectionInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetInspectionInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetInspectionInfo, sizeof(struct __ns1__GetInspectionInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetInspectionInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInspectionInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInspectionInfo(soap, "ns1:GetInspectionInfo", &a->ns1__GetInspectionInfo, ""))
				{	soap_flag_ns1__GetInspectionInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetInspectionInfo(struct soap *soap, const struct __ns1__GetInspectionInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetInspectionInfo(soap, tag?tag:"-ns1:GetInspectionInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectionInfo * SOAP_FMAC4 soap_get___ns1__GetInspectionInfo(struct soap *soap, struct __ns1__GetInspectionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetInspectionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetInspectionInfo * SOAP_FMAC2 soap_instantiate___ns1__GetInspectionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetInspectionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetInspectionInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetInspectionInfo);
		if (size)
			*size = sizeof(struct __ns1__GetInspectionInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetInspectionInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetInspectionInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetInspectionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetInspectionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetInspectionInfo %p -> %p\n", q, p));
	*(struct __ns1__GetInspectionInfo*)p = *(struct __ns1__GetInspectionInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadRealtimeData(struct soap *soap, struct __ns1__UploadRealtimeData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadRealtimeData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadRealtimeData(struct soap *soap, const struct __ns1__UploadRealtimeData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadRealtimeData(soap, &a->ns1__UploadRealtimeData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadRealtimeData(struct soap *soap, const char *tag, int id, const struct __ns1__UploadRealtimeData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadRealtimeData(soap, "ns1:UploadRealtimeData", -1, &a->ns1__UploadRealtimeData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadRealtimeData * SOAP_FMAC4 soap_in___ns1__UploadRealtimeData(struct soap *soap, const char *tag, struct __ns1__UploadRealtimeData *a, const char *type)
{
	size_t soap_flag_ns1__UploadRealtimeData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadRealtimeData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadRealtimeData, sizeof(struct __ns1__UploadRealtimeData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadRealtimeData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadRealtimeData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UploadRealtimeData(soap, "ns1:UploadRealtimeData", &a->ns1__UploadRealtimeData, ""))
				{	soap_flag_ns1__UploadRealtimeData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadRealtimeData(struct soap *soap, const struct __ns1__UploadRealtimeData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadRealtimeData(soap, tag?tag:"-ns1:UploadRealtimeData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadRealtimeData * SOAP_FMAC4 soap_get___ns1__UploadRealtimeData(struct soap *soap, struct __ns1__UploadRealtimeData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadRealtimeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UploadRealtimeData * SOAP_FMAC2 soap_instantiate___ns1__UploadRealtimeData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadRealtimeData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadRealtimeData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UploadRealtimeData);
		if (size)
			*size = sizeof(struct __ns1__UploadRealtimeData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UploadRealtimeData, n);
		if (size)
			*size = n * sizeof(struct __ns1__UploadRealtimeData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UploadRealtimeData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadRealtimeData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadRealtimeData %p -> %p\n", q, p));
	*(struct __ns1__UploadRealtimeData*)p = *(struct __ns1__UploadRealtimeData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadSelfTestData(struct soap *soap, struct __ns1__UploadSelfTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadSelfTestData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadSelfTestData(struct soap *soap, const struct __ns1__UploadSelfTestData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadSelfTestData(soap, &a->ns1__UploadSelfTestData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadSelfTestData(struct soap *soap, const char *tag, int id, const struct __ns1__UploadSelfTestData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadSelfTestData(soap, "ns1:UploadSelfTestData", -1, &a->ns1__UploadSelfTestData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadSelfTestData * SOAP_FMAC4 soap_in___ns1__UploadSelfTestData(struct soap *soap, const char *tag, struct __ns1__UploadSelfTestData *a, const char *type)
{
	size_t soap_flag_ns1__UploadSelfTestData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadSelfTestData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadSelfTestData, sizeof(struct __ns1__UploadSelfTestData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadSelfTestData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadSelfTestData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UploadSelfTestData(soap, "ns1:UploadSelfTestData", &a->ns1__UploadSelfTestData, ""))
				{	soap_flag_ns1__UploadSelfTestData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadSelfTestData(struct soap *soap, const struct __ns1__UploadSelfTestData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadSelfTestData(soap, tag?tag:"-ns1:UploadSelfTestData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadSelfTestData * SOAP_FMAC4 soap_get___ns1__UploadSelfTestData(struct soap *soap, struct __ns1__UploadSelfTestData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadSelfTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UploadSelfTestData * SOAP_FMAC2 soap_instantiate___ns1__UploadSelfTestData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadSelfTestData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadSelfTestData, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UploadSelfTestData);
		if (size)
			*size = sizeof(struct __ns1__UploadSelfTestData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UploadSelfTestData, n);
		if (size)
			*size = n * sizeof(struct __ns1__UploadSelfTestData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UploadSelfTestData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadSelfTestData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadSelfTestData %p -> %p\n", q, p));
	*(struct __ns1__UploadSelfTestData*)p = *(struct __ns1__UploadSelfTestData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EndInspect(struct soap *soap, struct __ns1__EndInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EndInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EndInspect(struct soap *soap, const struct __ns1__EndInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EndInspect(soap, &a->ns1__EndInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EndInspect(struct soap *soap, const char *tag, int id, const struct __ns1__EndInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EndInspect(soap, "ns1:EndInspect", -1, &a->ns1__EndInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndInspect * SOAP_FMAC4 soap_in___ns1__EndInspect(struct soap *soap, const char *tag, struct __ns1__EndInspect *a, const char *type)
{
	size_t soap_flag_ns1__EndInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EndInspect *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EndInspect, sizeof(struct __ns1__EndInspect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EndInspect(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EndInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__EndInspect(soap, "ns1:EndInspect", &a->ns1__EndInspect, ""))
				{	soap_flag_ns1__EndInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EndInspect(struct soap *soap, const struct __ns1__EndInspect *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__EndInspect(soap, tag?tag:"-ns1:EndInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndInspect * SOAP_FMAC4 soap_get___ns1__EndInspect(struct soap *soap, struct __ns1__EndInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EndInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__EndInspect * SOAP_FMAC2 soap_instantiate___ns1__EndInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EndInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__EndInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__EndInspect);
		if (size)
			*size = sizeof(struct __ns1__EndInspect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__EndInspect, n);
		if (size)
			*size = n * sizeof(struct __ns1__EndInspect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__EndInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__EndInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__EndInspect %p -> %p\n", q, p));
	*(struct __ns1__EndInspect*)p = *(struct __ns1__EndInspect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__StopInspect(struct soap *soap, struct __ns1__StopInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__StopInspect(struct soap *soap, const struct __ns1__StopInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__StopInspect(soap, &a->ns1__StopInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__StopInspect(struct soap *soap, const char *tag, int id, const struct __ns1__StopInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__StopInspect(soap, "ns1:StopInspect", -1, &a->ns1__StopInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StopInspect * SOAP_FMAC4 soap_in___ns1__StopInspect(struct soap *soap, const char *tag, struct __ns1__StopInspect *a, const char *type)
{
	size_t soap_flag_ns1__StopInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__StopInspect *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__StopInspect, sizeof(struct __ns1__StopInspect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__StopInspect(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopInspect(soap, "ns1:StopInspect", &a->ns1__StopInspect, ""))
				{	soap_flag_ns1__StopInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__StopInspect(struct soap *soap, const struct __ns1__StopInspect *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__StopInspect(soap, tag?tag:"-ns1:StopInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__StopInspect * SOAP_FMAC4 soap_get___ns1__StopInspect(struct soap *soap, struct __ns1__StopInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__StopInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__StopInspect * SOAP_FMAC2 soap_instantiate___ns1__StopInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__StopInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__StopInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__StopInspect);
		if (size)
			*size = sizeof(struct __ns1__StopInspect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__StopInspect, n);
		if (size)
			*size = n * sizeof(struct __ns1__StopInspect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__StopInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__StopInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__StopInspect %p -> %p\n", q, p));
	*(struct __ns1__StopInspect*)p = *(struct __ns1__StopInspect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__WJTakePhoto(struct soap *soap, struct __ns1__WJTakePhoto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__WJTakePhoto = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__WJTakePhoto(struct soap *soap, const struct __ns1__WJTakePhoto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__WJTakePhoto(soap, &a->ns1__WJTakePhoto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__WJTakePhoto(struct soap *soap, const char *tag, int id, const struct __ns1__WJTakePhoto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__WJTakePhoto(soap, "ns1:WJTakePhoto", -1, &a->ns1__WJTakePhoto, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WJTakePhoto * SOAP_FMAC4 soap_in___ns1__WJTakePhoto(struct soap *soap, const char *tag, struct __ns1__WJTakePhoto *a, const char *type)
{
	size_t soap_flag_ns1__WJTakePhoto = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__WJTakePhoto *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__WJTakePhoto, sizeof(struct __ns1__WJTakePhoto), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__WJTakePhoto(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__WJTakePhoto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__WJTakePhoto(soap, "ns1:WJTakePhoto", &a->ns1__WJTakePhoto, ""))
				{	soap_flag_ns1__WJTakePhoto--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__WJTakePhoto(struct soap *soap, const struct __ns1__WJTakePhoto *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__WJTakePhoto(soap, tag?tag:"-ns1:WJTakePhoto", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WJTakePhoto * SOAP_FMAC4 soap_get___ns1__WJTakePhoto(struct soap *soap, struct __ns1__WJTakePhoto *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__WJTakePhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__WJTakePhoto * SOAP_FMAC2 soap_instantiate___ns1__WJTakePhoto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__WJTakePhoto(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__WJTakePhoto, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__WJTakePhoto);
		if (size)
			*size = sizeof(struct __ns1__WJTakePhoto);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__WJTakePhoto, n);
		if (size)
			*size = n * sizeof(struct __ns1__WJTakePhoto);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__WJTakePhoto*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__WJTakePhoto(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__WJTakePhoto %p -> %p\n", q, p));
	*(struct __ns1__WJTakePhoto*)p = *(struct __ns1__WJTakePhoto*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__TakePhoto(struct soap *soap, struct __ns1__TakePhoto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__TakePhoto = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__TakePhoto(struct soap *soap, const struct __ns1__TakePhoto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__TakePhoto(soap, &a->ns1__TakePhoto);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__TakePhoto(struct soap *soap, const char *tag, int id, const struct __ns1__TakePhoto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__TakePhoto(soap, "ns1:TakePhoto", -1, &a->ns1__TakePhoto, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TakePhoto * SOAP_FMAC4 soap_in___ns1__TakePhoto(struct soap *soap, const char *tag, struct __ns1__TakePhoto *a, const char *type)
{
	size_t soap_flag_ns1__TakePhoto = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__TakePhoto *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__TakePhoto, sizeof(struct __ns1__TakePhoto), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__TakePhoto(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__TakePhoto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__TakePhoto(soap, "ns1:TakePhoto", &a->ns1__TakePhoto, ""))
				{	soap_flag_ns1__TakePhoto--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__TakePhoto(struct soap *soap, const struct __ns1__TakePhoto *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__TakePhoto(soap, tag?tag:"-ns1:TakePhoto", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__TakePhoto * SOAP_FMAC4 soap_get___ns1__TakePhoto(struct soap *soap, struct __ns1__TakePhoto *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__TakePhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__TakePhoto * SOAP_FMAC2 soap_instantiate___ns1__TakePhoto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__TakePhoto(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__TakePhoto, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__TakePhoto);
		if (size)
			*size = sizeof(struct __ns1__TakePhoto);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__TakePhoto, n);
		if (size)
			*size = n * sizeof(struct __ns1__TakePhoto);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__TakePhoto*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__TakePhoto(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__TakePhoto %p -> %p\n", q, p));
	*(struct __ns1__TakePhoto*)p = *(struct __ns1__TakePhoto*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLimit(struct soap *soap, struct __ns1__GetLimit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLimit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLimit(struct soap *soap, const struct __ns1__GetLimit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLimit(soap, &a->ns1__GetLimit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLimit(struct soap *soap, const char *tag, int id, const struct __ns1__GetLimit *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLimit(soap, "ns1:GetLimit", -1, &a->ns1__GetLimit, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLimit * SOAP_FMAC4 soap_in___ns1__GetLimit(struct soap *soap, const char *tag, struct __ns1__GetLimit *a, const char *type)
{
	size_t soap_flag_ns1__GetLimit = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetLimit *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLimit, sizeof(struct __ns1__GetLimit), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLimit(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLimit(soap, "ns1:GetLimit", &a->ns1__GetLimit, ""))
				{	soap_flag_ns1__GetLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLimit(struct soap *soap, const struct __ns1__GetLimit *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLimit(soap, tag?tag:"-ns1:GetLimit", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLimit * SOAP_FMAC4 soap_get___ns1__GetLimit(struct soap *soap, struct __ns1__GetLimit *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetLimit * SOAP_FMAC2 soap_instantiate___ns1__GetLimit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLimit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLimit, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetLimit);
		if (size)
			*size = sizeof(struct __ns1__GetLimit);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetLimit, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetLimit);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetLimit*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLimit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLimit %p -> %p\n", q, p));
	*(struct __ns1__GetLimit*)p = *(struct __ns1__GetLimit*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BeginInspect(struct soap *soap, struct __ns1__BeginInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BeginInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BeginInspect(struct soap *soap, const struct __ns1__BeginInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BeginInspect(soap, &a->ns1__BeginInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BeginInspect(struct soap *soap, const char *tag, int id, const struct __ns1__BeginInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BeginInspect(soap, "ns1:BeginInspect", -1, &a->ns1__BeginInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginInspect * SOAP_FMAC4 soap_in___ns1__BeginInspect(struct soap *soap, const char *tag, struct __ns1__BeginInspect *a, const char *type)
{
	size_t soap_flag_ns1__BeginInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BeginInspect *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BeginInspect, sizeof(struct __ns1__BeginInspect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BeginInspect(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BeginInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BeginInspect(soap, "ns1:BeginInspect", &a->ns1__BeginInspect, ""))
				{	soap_flag_ns1__BeginInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BeginInspect(struct soap *soap, const struct __ns1__BeginInspect *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__BeginInspect(soap, tag?tag:"-ns1:BeginInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginInspect * SOAP_FMAC4 soap_get___ns1__BeginInspect(struct soap *soap, struct __ns1__BeginInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BeginInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__BeginInspect * SOAP_FMAC2 soap_instantiate___ns1__BeginInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BeginInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__BeginInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__BeginInspect);
		if (size)
			*size = sizeof(struct __ns1__BeginInspect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__BeginInspect, n);
		if (size)
			*size = n * sizeof(struct __ns1__BeginInspect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__BeginInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__BeginInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__BeginInspect %p -> %p\n", q, p));
	*(struct __ns1__BeginInspect*)p = *(struct __ns1__BeginInspect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EndRecord(struct soap *soap, struct __ns1__EndRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EndRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EndRecord(struct soap *soap, const struct __ns1__EndRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EndRecord(soap, &a->ns1__EndRecord);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EndRecord(struct soap *soap, const char *tag, int id, const struct __ns1__EndRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EndRecord(soap, "ns1:EndRecord", -1, &a->ns1__EndRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndRecord * SOAP_FMAC4 soap_in___ns1__EndRecord(struct soap *soap, const char *tag, struct __ns1__EndRecord *a, const char *type)
{
	size_t soap_flag_ns1__EndRecord = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EndRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EndRecord, sizeof(struct __ns1__EndRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EndRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EndRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__EndRecord(soap, "ns1:EndRecord", &a->ns1__EndRecord, ""))
				{	soap_flag_ns1__EndRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EndRecord(struct soap *soap, const struct __ns1__EndRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__EndRecord(soap, tag?tag:"-ns1:EndRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EndRecord * SOAP_FMAC4 soap_get___ns1__EndRecord(struct soap *soap, struct __ns1__EndRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EndRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__EndRecord * SOAP_FMAC2 soap_instantiate___ns1__EndRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__EndRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__EndRecord, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__EndRecord);
		if (size)
			*size = sizeof(struct __ns1__EndRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__EndRecord, n);
		if (size)
			*size = n * sizeof(struct __ns1__EndRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__EndRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__EndRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__EndRecord %p -> %p\n", q, p));
	*(struct __ns1__EndRecord*)p = *(struct __ns1__EndRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BeginRecord(struct soap *soap, struct __ns1__BeginRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BeginRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BeginRecord(struct soap *soap, const struct __ns1__BeginRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BeginRecord(soap, &a->ns1__BeginRecord);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BeginRecord(struct soap *soap, const char *tag, int id, const struct __ns1__BeginRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BeginRecord(soap, "ns1:BeginRecord", -1, &a->ns1__BeginRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginRecord * SOAP_FMAC4 soap_in___ns1__BeginRecord(struct soap *soap, const char *tag, struct __ns1__BeginRecord *a, const char *type)
{
	size_t soap_flag_ns1__BeginRecord = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BeginRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BeginRecord, sizeof(struct __ns1__BeginRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BeginRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BeginRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BeginRecord(soap, "ns1:BeginRecord", &a->ns1__BeginRecord, ""))
				{	soap_flag_ns1__BeginRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BeginRecord(struct soap *soap, const struct __ns1__BeginRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__BeginRecord(soap, tag?tag:"-ns1:BeginRecord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BeginRecord * SOAP_FMAC4 soap_get___ns1__BeginRecord(struct soap *soap, struct __ns1__BeginRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BeginRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__BeginRecord * SOAP_FMAC2 soap_instantiate___ns1__BeginRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BeginRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__BeginRecord, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__BeginRecord);
		if (size)
			*size = sizeof(struct __ns1__BeginRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__BeginRecord, n);
		if (size)
			*size = n * sizeof(struct __ns1__BeginRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__BeginRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__BeginRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__BeginRecord %p -> %p\n", q, p));
	*(struct __ns1__BeginRecord*)p = *(struct __ns1__BeginRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AbortInspect(struct soap *soap, struct __ns1__AbortInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AbortInspect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AbortInspect(struct soap *soap, const struct __ns1__AbortInspect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AbortInspect(soap, &a->ns1__AbortInspect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AbortInspect(struct soap *soap, const char *tag, int id, const struct __ns1__AbortInspect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AbortInspect(soap, "ns1:AbortInspect", -1, &a->ns1__AbortInspect, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AbortInspect * SOAP_FMAC4 soap_in___ns1__AbortInspect(struct soap *soap, const char *tag, struct __ns1__AbortInspect *a, const char *type)
{
	size_t soap_flag_ns1__AbortInspect = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__AbortInspect *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AbortInspect, sizeof(struct __ns1__AbortInspect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AbortInspect(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AbortInspect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AbortInspect(soap, "ns1:AbortInspect", &a->ns1__AbortInspect, ""))
				{	soap_flag_ns1__AbortInspect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AbortInspect(struct soap *soap, const struct __ns1__AbortInspect *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__AbortInspect(soap, tag?tag:"-ns1:AbortInspect", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AbortInspect * SOAP_FMAC4 soap_get___ns1__AbortInspect(struct soap *soap, struct __ns1__AbortInspect *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AbortInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__AbortInspect * SOAP_FMAC2 soap_instantiate___ns1__AbortInspect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AbortInspect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__AbortInspect, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__AbortInspect);
		if (size)
			*size = sizeof(struct __ns1__AbortInspect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__AbortInspect, n);
		if (size)
			*size = n * sizeof(struct __ns1__AbortInspect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__AbortInspect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__AbortInspect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__AbortInspect %p -> %p\n", q, p));
	*(struct __ns1__AbortInspect*)p = *(struct __ns1__AbortInspect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetInspectQueueByPlateID(struct soap *soap, struct __ns1__GetInspectQueueByPlateID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInspectQueueByPlateID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetInspectQueueByPlateID(struct soap *soap, const struct __ns1__GetInspectQueueByPlateID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetInspectQueueByPlateID(soap, &a->ns1__GetInspectQueueByPlateID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetInspectQueueByPlateID(struct soap *soap, const char *tag, int id, const struct __ns1__GetInspectQueueByPlateID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetInspectQueueByPlateID(soap, "ns1:GetInspectQueueByPlateID", -1, &a->ns1__GetInspectQueueByPlateID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectQueueByPlateID * SOAP_FMAC4 soap_in___ns1__GetInspectQueueByPlateID(struct soap *soap, const char *tag, struct __ns1__GetInspectQueueByPlateID *a, const char *type)
{
	size_t soap_flag_ns1__GetInspectQueueByPlateID = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetInspectQueueByPlateID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetInspectQueueByPlateID, sizeof(struct __ns1__GetInspectQueueByPlateID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetInspectQueueByPlateID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInspectQueueByPlateID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInspectQueueByPlateID(soap, "ns1:GetInspectQueueByPlateID", &a->ns1__GetInspectQueueByPlateID, ""))
				{	soap_flag_ns1__GetInspectQueueByPlateID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetInspectQueueByPlateID(struct soap *soap, const struct __ns1__GetInspectQueueByPlateID *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetInspectQueueByPlateID(soap, tag?tag:"-ns1:GetInspectQueueByPlateID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectQueueByPlateID * SOAP_FMAC4 soap_get___ns1__GetInspectQueueByPlateID(struct soap *soap, struct __ns1__GetInspectQueueByPlateID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetInspectQueueByPlateID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetInspectQueueByPlateID * SOAP_FMAC2 soap_instantiate___ns1__GetInspectQueueByPlateID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetInspectQueueByPlateID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetInspectQueueByPlateID, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetInspectQueueByPlateID);
		if (size)
			*size = sizeof(struct __ns1__GetInspectQueueByPlateID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetInspectQueueByPlateID, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetInspectQueueByPlateID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetInspectQueueByPlateID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetInspectQueueByPlateID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetInspectQueueByPlateID %p -> %p\n", q, p));
	*(struct __ns1__GetInspectQueueByPlateID*)p = *(struct __ns1__GetInspectQueueByPlateID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetInspectQueueByDate(struct soap *soap, struct __ns1__GetInspectQueueByDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInspectQueueByDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetInspectQueueByDate(struct soap *soap, const struct __ns1__GetInspectQueueByDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetInspectQueueByDate(soap, &a->ns1__GetInspectQueueByDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetInspectQueueByDate(struct soap *soap, const char *tag, int id, const struct __ns1__GetInspectQueueByDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetInspectQueueByDate(soap, "ns1:GetInspectQueueByDate", -1, &a->ns1__GetInspectQueueByDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectQueueByDate * SOAP_FMAC4 soap_in___ns1__GetInspectQueueByDate(struct soap *soap, const char *tag, struct __ns1__GetInspectQueueByDate *a, const char *type)
{
	size_t soap_flag_ns1__GetInspectQueueByDate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetInspectQueueByDate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetInspectQueueByDate, sizeof(struct __ns1__GetInspectQueueByDate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetInspectQueueByDate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInspectQueueByDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInspectQueueByDate(soap, "ns1:GetInspectQueueByDate", &a->ns1__GetInspectQueueByDate, ""))
				{	soap_flag_ns1__GetInspectQueueByDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetInspectQueueByDate(struct soap *soap, const struct __ns1__GetInspectQueueByDate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetInspectQueueByDate(soap, tag?tag:"-ns1:GetInspectQueueByDate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInspectQueueByDate * SOAP_FMAC4 soap_get___ns1__GetInspectQueueByDate(struct soap *soap, struct __ns1__GetInspectQueueByDate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetInspectQueueByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetInspectQueueByDate * SOAP_FMAC2 soap_instantiate___ns1__GetInspectQueueByDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetInspectQueueByDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetInspectQueueByDate, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetInspectQueueByDate);
		if (size)
			*size = sizeof(struct __ns1__GetInspectQueueByDate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetInspectQueueByDate, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetInspectQueueByDate);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetInspectQueueByDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetInspectQueueByDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetInspectQueueByDate %p -> %p\n", q, p));
	*(struct __ns1__GetInspectQueueByDate*)p = *(struct __ns1__GetInspectQueueByDate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Sync(struct soap *soap, struct __ns1__Sync *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Sync = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Sync(struct soap *soap, const struct __ns1__Sync *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Sync(soap, &a->ns1__Sync);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Sync(struct soap *soap, const char *tag, int id, const struct __ns1__Sync *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Sync(soap, "ns1:Sync", -1, &a->ns1__Sync, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Sync * SOAP_FMAC4 soap_in___ns1__Sync(struct soap *soap, const char *tag, struct __ns1__Sync *a, const char *type)
{
	size_t soap_flag_ns1__Sync = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Sync *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Sync, sizeof(struct __ns1__Sync), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Sync(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Sync && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Sync(soap, "ns1:Sync", &a->ns1__Sync, ""))
				{	soap_flag_ns1__Sync--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Sync(struct soap *soap, const struct __ns1__Sync *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Sync(soap, tag?tag:"-ns1:Sync", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Sync * SOAP_FMAC4 soap_get___ns1__Sync(struct soap *soap, struct __ns1__Sync *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Sync(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Sync * SOAP_FMAC2 soap_instantiate___ns1__Sync(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Sync(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Sync, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__Sync);
		if (size)
			*size = sizeof(struct __ns1__Sync);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__Sync, n);
		if (size)
			*size = n * sizeof(struct __ns1__Sync);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Sync*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Sync(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Sync %p -> %p\n", q, p));
	*(struct __ns1__Sync*)p = *(struct __ns1__Sync*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OBDTXCheck(struct soap *soap, _ns1__OBDTXCheck *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OBDTXCheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OBDTXCheck(struct soap *soap, const char *tag, int id, _ns1__OBDTXCheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OBDTXCheck);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__OBDTXCheck ** SOAP_FMAC4 soap_in_PointerTo_ns1__OBDTXCheck(struct soap *soap, const char *tag, _ns1__OBDTXCheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OBDTXCheck **)soap_malloc(soap, sizeof(_ns1__OBDTXCheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OBDTXCheck *)soap_instantiate__ns1__OBDTXCheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__OBDTXCheck ** p = (_ns1__OBDTXCheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OBDTXCheck, sizeof(_ns1__OBDTXCheck), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OBDTXCheck(struct soap *soap, _ns1__OBDTXCheck *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__OBDTXCheck);
	if (soap_out_PointerTo_ns1__OBDTXCheck(soap, tag?tag:"ns1:OBDTXCheck", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OBDTXCheck ** SOAP_FMAC4 soap_get_PointerTo_ns1__OBDTXCheck(struct soap *soap, _ns1__OBDTXCheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OBDTXCheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OBDInspect(struct soap *soap, _ns1__OBDInspect *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OBDInspect))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OBDInspect(struct soap *soap, const char *tag, int id, _ns1__OBDInspect *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OBDInspect);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__OBDInspect ** SOAP_FMAC4 soap_in_PointerTo_ns1__OBDInspect(struct soap *soap, const char *tag, _ns1__OBDInspect **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OBDInspect **)soap_malloc(soap, sizeof(_ns1__OBDInspect *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OBDInspect *)soap_instantiate__ns1__OBDInspect(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__OBDInspect ** p = (_ns1__OBDInspect **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OBDInspect, sizeof(_ns1__OBDInspect), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OBDInspect(struct soap *soap, _ns1__OBDInspect *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__OBDInspect);
	if (soap_out_PointerTo_ns1__OBDInspect(soap, tag?tag:"ns1:OBDInspect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OBDInspect ** SOAP_FMAC4 soap_get_PointerTo_ns1__OBDInspect(struct soap *soap, _ns1__OBDInspect **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OBDInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetOtherInspectQueueByDate(struct soap *soap, _ns1__GetOtherInspectQueueByDate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetOtherInspectQueueByDate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetOtherInspectQueueByDate(struct soap *soap, const char *tag, int id, _ns1__GetOtherInspectQueueByDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetOtherInspectQueueByDate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByDate ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetOtherInspectQueueByDate(struct soap *soap, const char *tag, _ns1__GetOtherInspectQueueByDate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetOtherInspectQueueByDate **)soap_malloc(soap, sizeof(_ns1__GetOtherInspectQueueByDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetOtherInspectQueueByDate *)soap_instantiate__ns1__GetOtherInspectQueueByDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetOtherInspectQueueByDate ** p = (_ns1__GetOtherInspectQueueByDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetOtherInspectQueueByDate, sizeof(_ns1__GetOtherInspectQueueByDate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetOtherInspectQueueByDate(struct soap *soap, _ns1__GetOtherInspectQueueByDate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetOtherInspectQueueByDate);
	if (soap_out_PointerTo_ns1__GetOtherInspectQueueByDate(soap, tag?tag:"ns1:GetOtherInspectQueueByDate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByDate ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetOtherInspectQueueByDate(struct soap *soap, _ns1__GetOtherInspectQueueByDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetOtherInspectQueueByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetOtherInspectQueueByPlateID(struct soap *soap, _ns1__GetOtherInspectQueueByPlateID *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetOtherInspectQueueByPlateID(struct soap *soap, const char *tag, int id, _ns1__GetOtherInspectQueueByPlateID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByPlateID ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetOtherInspectQueueByPlateID(struct soap *soap, const char *tag, _ns1__GetOtherInspectQueueByPlateID **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetOtherInspectQueueByPlateID **)soap_malloc(soap, sizeof(_ns1__GetOtherInspectQueueByPlateID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetOtherInspectQueueByPlateID *)soap_instantiate__ns1__GetOtherInspectQueueByPlateID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetOtherInspectQueueByPlateID ** p = (_ns1__GetOtherInspectQueueByPlateID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetOtherInspectQueueByPlateID, sizeof(_ns1__GetOtherInspectQueueByPlateID), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetOtherInspectQueueByPlateID(struct soap *soap, _ns1__GetOtherInspectQueueByPlateID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetOtherInspectQueueByPlateID);
	if (soap_out_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, tag?tag:"ns1:GetOtherInspectQueueByPlateID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetOtherInspectQueueByPlateID ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetOtherInspectQueueByPlateID(struct soap *soap, _ns1__GetOtherInspectQueueByPlateID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetOtherInspectQueueByPlateID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetInspectParams(struct soap *soap, _ns1__GetInspectParams *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetInspectParams))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetInspectParams(struct soap *soap, const char *tag, int id, _ns1__GetInspectParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetInspectParams);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetInspectParams ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetInspectParams(struct soap *soap, const char *tag, _ns1__GetInspectParams **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetInspectParams **)soap_malloc(soap, sizeof(_ns1__GetInspectParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetInspectParams *)soap_instantiate__ns1__GetInspectParams(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetInspectParams ** p = (_ns1__GetInspectParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetInspectParams, sizeof(_ns1__GetInspectParams), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetInspectParams(struct soap *soap, _ns1__GetInspectParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetInspectParams);
	if (soap_out_PointerTo_ns1__GetInspectParams(soap, tag?tag:"ns1:GetInspectParams", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetInspectParams ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetInspectParams(struct soap *soap, _ns1__GetInspectParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetInspectParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__FuelEvaporationInspect(struct soap *soap, _ns1__FuelEvaporationInspect *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__FuelEvaporationInspect))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__FuelEvaporationInspect(struct soap *soap, const char *tag, int id, _ns1__FuelEvaporationInspect *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__FuelEvaporationInspect);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__FuelEvaporationInspect ** SOAP_FMAC4 soap_in_PointerTo_ns1__FuelEvaporationInspect(struct soap *soap, const char *tag, _ns1__FuelEvaporationInspect **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__FuelEvaporationInspect **)soap_malloc(soap, sizeof(_ns1__FuelEvaporationInspect *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__FuelEvaporationInspect *)soap_instantiate__ns1__FuelEvaporationInspect(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__FuelEvaporationInspect ** p = (_ns1__FuelEvaporationInspect **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__FuelEvaporationInspect, sizeof(_ns1__FuelEvaporationInspect), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__FuelEvaporationInspect(struct soap *soap, _ns1__FuelEvaporationInspect *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__FuelEvaporationInspect);
	if (soap_out_PointerTo_ns1__FuelEvaporationInspect(soap, tag?tag:"ns1:FuelEvaporationInspect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__FuelEvaporationInspect ** SOAP_FMAC4 soap_get_PointerTo_ns1__FuelEvaporationInspect(struct soap *soap, _ns1__FuelEvaporationInspect **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__FuelEvaporationInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TestPhoto(struct soap *soap, _ns1__TestPhoto *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TestPhoto))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TestPhoto(struct soap *soap, const char *tag, int id, _ns1__TestPhoto *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TestPhoto);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__TestPhoto ** SOAP_FMAC4 soap_in_PointerTo_ns1__TestPhoto(struct soap *soap, const char *tag, _ns1__TestPhoto **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__TestPhoto **)soap_malloc(soap, sizeof(_ns1__TestPhoto *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__TestPhoto *)soap_instantiate__ns1__TestPhoto(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__TestPhoto ** p = (_ns1__TestPhoto **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TestPhoto, sizeof(_ns1__TestPhoto), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TestPhoto(struct soap *soap, _ns1__TestPhoto *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__TestPhoto);
	if (soap_out_PointerTo_ns1__TestPhoto(soap, tag?tag:"ns1:TestPhoto", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__TestPhoto ** SOAP_FMAC4 soap_get_PointerTo_ns1__TestPhoto(struct soap *soap, _ns1__TestPhoto **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TestPhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__EndCalibrate(struct soap *soap, _ns1__EndCalibrate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__EndCalibrate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__EndCalibrate(struct soap *soap, const char *tag, int id, _ns1__EndCalibrate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__EndCalibrate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__EndCalibrate ** SOAP_FMAC4 soap_in_PointerTo_ns1__EndCalibrate(struct soap *soap, const char *tag, _ns1__EndCalibrate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__EndCalibrate **)soap_malloc(soap, sizeof(_ns1__EndCalibrate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__EndCalibrate *)soap_instantiate__ns1__EndCalibrate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__EndCalibrate ** p = (_ns1__EndCalibrate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__EndCalibrate, sizeof(_ns1__EndCalibrate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__EndCalibrate(struct soap *soap, _ns1__EndCalibrate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__EndCalibrate);
	if (soap_out_PointerTo_ns1__EndCalibrate(soap, tag?tag:"ns1:EndCalibrate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__EndCalibrate ** SOAP_FMAC4 soap_get_PointerTo_ns1__EndCalibrate(struct soap *soap, _ns1__EndCalibrate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__EndCalibrate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadCalibrateData(struct soap *soap, _ns1__UploadCalibrateData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadCalibrateData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadCalibrateData(struct soap *soap, const char *tag, int id, _ns1__UploadCalibrateData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadCalibrateData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UploadCalibrateData ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadCalibrateData(struct soap *soap, const char *tag, _ns1__UploadCalibrateData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UploadCalibrateData **)soap_malloc(soap, sizeof(_ns1__UploadCalibrateData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UploadCalibrateData *)soap_instantiate__ns1__UploadCalibrateData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UploadCalibrateData ** p = (_ns1__UploadCalibrateData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadCalibrateData, sizeof(_ns1__UploadCalibrateData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadCalibrateData(struct soap *soap, _ns1__UploadCalibrateData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__UploadCalibrateData);
	if (soap_out_PointerTo_ns1__UploadCalibrateData(soap, tag?tag:"ns1:UploadCalibrateData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadCalibrateData ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadCalibrateData(struct soap *soap, _ns1__UploadCalibrateData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UploadCalibrateData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BeginCalibrate(struct soap *soap, _ns1__BeginCalibrate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BeginCalibrate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BeginCalibrate(struct soap *soap, const char *tag, int id, _ns1__BeginCalibrate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BeginCalibrate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__BeginCalibrate ** SOAP_FMAC4 soap_in_PointerTo_ns1__BeginCalibrate(struct soap *soap, const char *tag, _ns1__BeginCalibrate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BeginCalibrate **)soap_malloc(soap, sizeof(_ns1__BeginCalibrate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BeginCalibrate *)soap_instantiate__ns1__BeginCalibrate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__BeginCalibrate ** p = (_ns1__BeginCalibrate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BeginCalibrate, sizeof(_ns1__BeginCalibrate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BeginCalibrate(struct soap *soap, _ns1__BeginCalibrate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__BeginCalibrate);
	if (soap_out_PointerTo_ns1__BeginCalibrate(soap, tag?tag:"ns1:BeginCalibrate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BeginCalibrate ** SOAP_FMAC4 soap_get_PointerTo_ns1__BeginCalibrate(struct soap *soap, _ns1__BeginCalibrate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BeginCalibrate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetInspectionInfo(struct soap *soap, _ns1__GetInspectionInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetInspectionInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetInspectionInfo(struct soap *soap, const char *tag, int id, _ns1__GetInspectionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetInspectionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetInspectionInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetInspectionInfo(struct soap *soap, const char *tag, _ns1__GetInspectionInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetInspectionInfo **)soap_malloc(soap, sizeof(_ns1__GetInspectionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetInspectionInfo *)soap_instantiate__ns1__GetInspectionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetInspectionInfo ** p = (_ns1__GetInspectionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetInspectionInfo, sizeof(_ns1__GetInspectionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetInspectionInfo(struct soap *soap, _ns1__GetInspectionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetInspectionInfo);
	if (soap_out_PointerTo_ns1__GetInspectionInfo(soap, tag?tag:"ns1:GetInspectionInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetInspectionInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetInspectionInfo(struct soap *soap, _ns1__GetInspectionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetInspectionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadRealtimeData(struct soap *soap, _ns1__UploadRealtimeData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadRealtimeData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadRealtimeData(struct soap *soap, const char *tag, int id, _ns1__UploadRealtimeData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadRealtimeData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UploadRealtimeData ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadRealtimeData(struct soap *soap, const char *tag, _ns1__UploadRealtimeData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UploadRealtimeData **)soap_malloc(soap, sizeof(_ns1__UploadRealtimeData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UploadRealtimeData *)soap_instantiate__ns1__UploadRealtimeData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UploadRealtimeData ** p = (_ns1__UploadRealtimeData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadRealtimeData, sizeof(_ns1__UploadRealtimeData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadRealtimeData(struct soap *soap, _ns1__UploadRealtimeData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__UploadRealtimeData);
	if (soap_out_PointerTo_ns1__UploadRealtimeData(soap, tag?tag:"ns1:UploadRealtimeData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadRealtimeData ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadRealtimeData(struct soap *soap, _ns1__UploadRealtimeData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UploadRealtimeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadSelfTestData(struct soap *soap, _ns1__UploadSelfTestData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadSelfTestData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadSelfTestData(struct soap *soap, const char *tag, int id, _ns1__UploadSelfTestData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadSelfTestData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UploadSelfTestData ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadSelfTestData(struct soap *soap, const char *tag, _ns1__UploadSelfTestData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UploadSelfTestData **)soap_malloc(soap, sizeof(_ns1__UploadSelfTestData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UploadSelfTestData *)soap_instantiate__ns1__UploadSelfTestData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UploadSelfTestData ** p = (_ns1__UploadSelfTestData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadSelfTestData, sizeof(_ns1__UploadSelfTestData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadSelfTestData(struct soap *soap, _ns1__UploadSelfTestData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__UploadSelfTestData);
	if (soap_out_PointerTo_ns1__UploadSelfTestData(soap, tag?tag:"ns1:UploadSelfTestData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadSelfTestData ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadSelfTestData(struct soap *soap, _ns1__UploadSelfTestData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UploadSelfTestData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__EndInspect(struct soap *soap, _ns1__EndInspect *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__EndInspect))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__EndInspect(struct soap *soap, const char *tag, int id, _ns1__EndInspect *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__EndInspect);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__EndInspect ** SOAP_FMAC4 soap_in_PointerTo_ns1__EndInspect(struct soap *soap, const char *tag, _ns1__EndInspect **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__EndInspect **)soap_malloc(soap, sizeof(_ns1__EndInspect *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__EndInspect *)soap_instantiate__ns1__EndInspect(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__EndInspect ** p = (_ns1__EndInspect **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__EndInspect, sizeof(_ns1__EndInspect), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__EndInspect(struct soap *soap, _ns1__EndInspect *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__EndInspect);
	if (soap_out_PointerTo_ns1__EndInspect(soap, tag?tag:"ns1:EndInspect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__EndInspect ** SOAP_FMAC4 soap_get_PointerTo_ns1__EndInspect(struct soap *soap, _ns1__EndInspect **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__EndInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopInspect(struct soap *soap, _ns1__StopInspect *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopInspect))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopInspect(struct soap *soap, const char *tag, int id, _ns1__StopInspect *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopInspect);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopInspect ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopInspect(struct soap *soap, const char *tag, _ns1__StopInspect **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopInspect **)soap_malloc(soap, sizeof(_ns1__StopInspect *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopInspect *)soap_instantiate__ns1__StopInspect(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__StopInspect ** p = (_ns1__StopInspect **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopInspect, sizeof(_ns1__StopInspect), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopInspect(struct soap *soap, _ns1__StopInspect *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__StopInspect);
	if (soap_out_PointerTo_ns1__StopInspect(soap, tag?tag:"ns1:StopInspect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StopInspect ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopInspect(struct soap *soap, _ns1__StopInspect **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__WJTakePhoto(struct soap *soap, _ns1__WJTakePhoto *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__WJTakePhoto))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__WJTakePhoto(struct soap *soap, const char *tag, int id, _ns1__WJTakePhoto *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__WJTakePhoto);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__WJTakePhoto ** SOAP_FMAC4 soap_in_PointerTo_ns1__WJTakePhoto(struct soap *soap, const char *tag, _ns1__WJTakePhoto **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__WJTakePhoto **)soap_malloc(soap, sizeof(_ns1__WJTakePhoto *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__WJTakePhoto *)soap_instantiate__ns1__WJTakePhoto(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__WJTakePhoto ** p = (_ns1__WJTakePhoto **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__WJTakePhoto, sizeof(_ns1__WJTakePhoto), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__WJTakePhoto(struct soap *soap, _ns1__WJTakePhoto *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__WJTakePhoto);
	if (soap_out_PointerTo_ns1__WJTakePhoto(soap, tag?tag:"ns1:WJTakePhoto", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__WJTakePhoto ** SOAP_FMAC4 soap_get_PointerTo_ns1__WJTakePhoto(struct soap *soap, _ns1__WJTakePhoto **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__WJTakePhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__TakePhoto(struct soap *soap, _ns1__TakePhoto *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__TakePhoto))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__TakePhoto(struct soap *soap, const char *tag, int id, _ns1__TakePhoto *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__TakePhoto);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__TakePhoto ** SOAP_FMAC4 soap_in_PointerTo_ns1__TakePhoto(struct soap *soap, const char *tag, _ns1__TakePhoto **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__TakePhoto **)soap_malloc(soap, sizeof(_ns1__TakePhoto *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__TakePhoto *)soap_instantiate__ns1__TakePhoto(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__TakePhoto ** p = (_ns1__TakePhoto **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__TakePhoto, sizeof(_ns1__TakePhoto), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__TakePhoto(struct soap *soap, _ns1__TakePhoto *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__TakePhoto);
	if (soap_out_PointerTo_ns1__TakePhoto(soap, tag?tag:"ns1:TakePhoto", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__TakePhoto ** SOAP_FMAC4 soap_get_PointerTo_ns1__TakePhoto(struct soap *soap, _ns1__TakePhoto **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__TakePhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLimit(struct soap *soap, _ns1__GetLimit *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLimit))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLimit(struct soap *soap, const char *tag, int id, _ns1__GetLimit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLimit);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLimit ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLimit(struct soap *soap, const char *tag, _ns1__GetLimit **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLimit **)soap_malloc(soap, sizeof(_ns1__GetLimit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLimit *)soap_instantiate__ns1__GetLimit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLimit ** p = (_ns1__GetLimit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLimit, sizeof(_ns1__GetLimit), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLimit(struct soap *soap, _ns1__GetLimit *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetLimit);
	if (soap_out_PointerTo_ns1__GetLimit(soap, tag?tag:"ns1:GetLimit", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLimit ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLimit(struct soap *soap, _ns1__GetLimit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLimit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BeginInspect(struct soap *soap, _ns1__BeginInspect *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BeginInspect))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BeginInspect(struct soap *soap, const char *tag, int id, _ns1__BeginInspect *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BeginInspect);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__BeginInspect ** SOAP_FMAC4 soap_in_PointerTo_ns1__BeginInspect(struct soap *soap, const char *tag, _ns1__BeginInspect **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BeginInspect **)soap_malloc(soap, sizeof(_ns1__BeginInspect *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BeginInspect *)soap_instantiate__ns1__BeginInspect(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__BeginInspect ** p = (_ns1__BeginInspect **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BeginInspect, sizeof(_ns1__BeginInspect), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BeginInspect(struct soap *soap, _ns1__BeginInspect *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__BeginInspect);
	if (soap_out_PointerTo_ns1__BeginInspect(soap, tag?tag:"ns1:BeginInspect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BeginInspect ** SOAP_FMAC4 soap_get_PointerTo_ns1__BeginInspect(struct soap *soap, _ns1__BeginInspect **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BeginInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__EndRecord(struct soap *soap, _ns1__EndRecord *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__EndRecord))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__EndRecord(struct soap *soap, const char *tag, int id, _ns1__EndRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__EndRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__EndRecord ** SOAP_FMAC4 soap_in_PointerTo_ns1__EndRecord(struct soap *soap, const char *tag, _ns1__EndRecord **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__EndRecord **)soap_malloc(soap, sizeof(_ns1__EndRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__EndRecord *)soap_instantiate__ns1__EndRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__EndRecord ** p = (_ns1__EndRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__EndRecord, sizeof(_ns1__EndRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__EndRecord(struct soap *soap, _ns1__EndRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__EndRecord);
	if (soap_out_PointerTo_ns1__EndRecord(soap, tag?tag:"ns1:EndRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__EndRecord ** SOAP_FMAC4 soap_get_PointerTo_ns1__EndRecord(struct soap *soap, _ns1__EndRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__EndRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BeginRecord(struct soap *soap, _ns1__BeginRecord *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BeginRecord))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BeginRecord(struct soap *soap, const char *tag, int id, _ns1__BeginRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BeginRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__BeginRecord ** SOAP_FMAC4 soap_in_PointerTo_ns1__BeginRecord(struct soap *soap, const char *tag, _ns1__BeginRecord **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BeginRecord **)soap_malloc(soap, sizeof(_ns1__BeginRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BeginRecord *)soap_instantiate__ns1__BeginRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__BeginRecord ** p = (_ns1__BeginRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BeginRecord, sizeof(_ns1__BeginRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BeginRecord(struct soap *soap, _ns1__BeginRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__BeginRecord);
	if (soap_out_PointerTo_ns1__BeginRecord(soap, tag?tag:"ns1:BeginRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BeginRecord ** SOAP_FMAC4 soap_get_PointerTo_ns1__BeginRecord(struct soap *soap, _ns1__BeginRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BeginRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AbortInspect(struct soap *soap, _ns1__AbortInspect *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AbortInspect))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AbortInspect(struct soap *soap, const char *tag, int id, _ns1__AbortInspect *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AbortInspect);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AbortInspect ** SOAP_FMAC4 soap_in_PointerTo_ns1__AbortInspect(struct soap *soap, const char *tag, _ns1__AbortInspect **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AbortInspect **)soap_malloc(soap, sizeof(_ns1__AbortInspect *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AbortInspect *)soap_instantiate__ns1__AbortInspect(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AbortInspect ** p = (_ns1__AbortInspect **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AbortInspect, sizeof(_ns1__AbortInspect), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AbortInspect(struct soap *soap, _ns1__AbortInspect *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__AbortInspect);
	if (soap_out_PointerTo_ns1__AbortInspect(soap, tag?tag:"ns1:AbortInspect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AbortInspect ** SOAP_FMAC4 soap_get_PointerTo_ns1__AbortInspect(struct soap *soap, _ns1__AbortInspect **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AbortInspect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetInspectQueueByPlateID(struct soap *soap, _ns1__GetInspectQueueByPlateID *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetInspectQueueByPlateID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetInspectQueueByPlateID(struct soap *soap, const char *tag, int id, _ns1__GetInspectQueueByPlateID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetInspectQueueByPlateID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetInspectQueueByPlateID ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetInspectQueueByPlateID(struct soap *soap, const char *tag, _ns1__GetInspectQueueByPlateID **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetInspectQueueByPlateID **)soap_malloc(soap, sizeof(_ns1__GetInspectQueueByPlateID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetInspectQueueByPlateID *)soap_instantiate__ns1__GetInspectQueueByPlateID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetInspectQueueByPlateID ** p = (_ns1__GetInspectQueueByPlateID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetInspectQueueByPlateID, sizeof(_ns1__GetInspectQueueByPlateID), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetInspectQueueByPlateID(struct soap *soap, _ns1__GetInspectQueueByPlateID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetInspectQueueByPlateID);
	if (soap_out_PointerTo_ns1__GetInspectQueueByPlateID(soap, tag?tag:"ns1:GetInspectQueueByPlateID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetInspectQueueByPlateID ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetInspectQueueByPlateID(struct soap *soap, _ns1__GetInspectQueueByPlateID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetInspectQueueByPlateID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetInspectQueueByDate(struct soap *soap, _ns1__GetInspectQueueByDate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetInspectQueueByDate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetInspectQueueByDate(struct soap *soap, const char *tag, int id, _ns1__GetInspectQueueByDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetInspectQueueByDate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetInspectQueueByDate ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetInspectQueueByDate(struct soap *soap, const char *tag, _ns1__GetInspectQueueByDate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetInspectQueueByDate **)soap_malloc(soap, sizeof(_ns1__GetInspectQueueByDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetInspectQueueByDate *)soap_instantiate__ns1__GetInspectQueueByDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetInspectQueueByDate ** p = (_ns1__GetInspectQueueByDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetInspectQueueByDate, sizeof(_ns1__GetInspectQueueByDate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetInspectQueueByDate(struct soap *soap, _ns1__GetInspectQueueByDate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetInspectQueueByDate);
	if (soap_out_PointerTo_ns1__GetInspectQueueByDate(soap, tag?tag:"ns1:GetInspectQueueByDate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetInspectQueueByDate ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetInspectQueueByDate(struct soap *soap, _ns1__GetInspectQueueByDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetInspectQueueByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Sync(struct soap *soap, _ns1__Sync *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Sync))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Sync(struct soap *soap, const char *tag, int id, _ns1__Sync *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Sync);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Sync ** SOAP_FMAC4 soap_in_PointerTo_ns1__Sync(struct soap *soap, const char *tag, _ns1__Sync **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Sync **)soap_malloc(soap, sizeof(_ns1__Sync *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Sync *)soap_instantiate__ns1__Sync(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__Sync ** p = (_ns1__Sync **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Sync, sizeof(_ns1__Sync), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Sync(struct soap *soap, _ns1__Sync *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__Sync);
	if (soap_out_PointerTo_ns1__Sync(soap, tag?tag:"ns1:Sync", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Sync ** SOAP_FMAC4 soap_get_PointerTo_ns1__Sync(struct soap *soap, _ns1__Sync **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Sync(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RetValue(struct soap *soap, ns1__RetValue *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RetValue))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RetValue(struct soap *soap, const char *tag, int id, ns1__RetValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RetValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__RetValue ** SOAP_FMAC4 soap_in_PointerTons1__RetValue(struct soap *soap, const char *tag, ns1__RetValue **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RetValue **)soap_malloc(soap, sizeof(ns1__RetValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RetValue *)soap_instantiate_ns1__RetValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__RetValue ** p = (ns1__RetValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RetValue, sizeof(ns1__RetValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RetValue(struct soap *soap, ns1__RetValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__RetValue);
	if (soap_out_PointerTons1__RetValue(soap, tag?tag:"ns1:RetValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RetValue ** SOAP_FMAC4 soap_get_PointerTons1__RetValue(struct soap *soap, ns1__RetValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__wstring(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__wstring))
		soap_serialize_std__wstring(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__wstring(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__wstring);
	if (id < 0)
		return soap->error;
	return soap_out_std__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTostd__wstring(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__wstring(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTostd__wstring);
	if (soap_out_PointerTostd__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTostd__wstring(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
