/* soapStub.h
   Generated by gSOAP 2.8.21 from sjjk.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://www.hnlh.com/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20821
# error "GSOAP VERSION 20821 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__sdsGcsj
#define SOAP_TYPE_ns1__sdsGcsj (8)
/* ns1:sdsGcsj */
class SOAP_CMAC ns1__sdsGcsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *qssx;	/* optional element of type xsd:string */
	std::wstring *gklx;	/* optional element of type xsd:string */
	int jcsxh;	/* required element of type xsd:int */
	double hc;	/* required element of type xsd:double */
	double co;	/* required element of type xsd:double */
	double co2;	/* required element of type xsd:double */
	double o2;	/* required element of type xsd:double */
	double glkqxs;	/* required element of type xsd:double */
	double jyyw;	/* required element of type xsd:double */
	std::wstring *fdjzs;	/* optional element of type xsd:string */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique type id SOAP_TYPE_ns1__sdsGcsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sdsGcsj() { ns1__sdsGcsj::soap_default(NULL); }
	virtual ~ns1__sdsGcsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sdsGcsjResponse
#define SOAP_TYPE_ns1__sdsGcsjResponse (9)
/* ns1:sdsGcsjResponse */
class SOAP_CMAC ns1__sdsGcsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique type id SOAP_TYPE_ns1__sdsGcsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sdsGcsjResponse() { ns1__sdsGcsjResponse::soap_default(NULL); }
	virtual ~ns1__sdsGcsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getAccessToken
#define SOAP_TYPE_ns1__getAccessToken (10)
/* ns1:getAccessToken */
class SOAP_CMAC ns1__getAccessToken
{
public:
	std::wstring *jcxbh;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique type id SOAP_TYPE_ns1__getAccessToken */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getAccessToken() { ns1__getAccessToken::soap_default(NULL); }
	virtual ~ns1__getAccessToken() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getAccessTokenResponse
#define SOAP_TYPE_ns1__getAccessTokenResponse (11)
/* ns1:getAccessTokenResponse */
class SOAP_CMAC ns1__getAccessTokenResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique type id SOAP_TYPE_ns1__getAccessTokenResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getAccessTokenResponse() { ns1__getAccessTokenResponse::soap_default(NULL); }
	virtual ~ns1__getAccessTokenResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gkrjbbh
#define SOAP_TYPE_ns1__gkrjbbh (12)
/* ns1:gkrjbbh */
class SOAP_CMAC ns1__gkrjbbh
{
public:
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *bbh;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique type id SOAP_TYPE_ns1__gkrjbbh */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gkrjbbh() { ns1__gkrjbbh::soap_default(NULL); }
	virtual ~ns1__gkrjbbh() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gkrjbbhResponse
#define SOAP_TYPE_ns1__gkrjbbhResponse (13)
/* ns1:gkrjbbhResponse */
class SOAP_CMAC ns1__gkrjbbhResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique type id SOAP_TYPE_ns1__gkrjbbhResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gkrjbbhResponse() { ns1__gkrjbbhResponse::soap_default(NULL); }
	virtual ~ns1__gkrjbbhResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__obdJgsj
#define SOAP_TYPE_ns1__obdJgsj (14)
/* ns1:obdJgsj */
class SOAP_CMAC ns1__obdJgsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *clsbm;	/* optional element of type xsd:string */
	std::wstring *obdzsbz;	/* optional element of type xsd:string */
	int clxslc;	/* required element of type xsd:int */
	std::wstring *fdjkzdycid;	/* optional element of type xsd:string */
	std::wstring *fdjkzdycvn;	/* optional element of type xsd:string */
	std::wstring *hclkzdycid;	/* optional element of type xsd:string */
	std::wstring *hclkzdycvn;	/* optional element of type xsd:string */
	std::wstring *qtkzdycid;	/* optional element of type xsd:string */
	std::wstring *qtkzdycvn;	/* optional element of type xsd:string */
	std::wstring *obdgzzsq;	/* optional element of type xsd:string */
	std::wstring *obdtxqk;	/* optional element of type xsd:string */
	std::wstring *obdzzqsfdl;	/* optional element of type xsd:string */
	std::wstring *obdjxzt;	/* optional element of type xsd:string */
	std::wstring *obdjcjg;	/* optional element of type xsd:string */
	std::wstring *obdgzxx;	/* optional element of type xsd:string */
	std::wstring *jyymc;	/* optional element of type xsd:string */
	std::wstring *jckssj;	/* optional element of type xsd:string */
	std::wstring *jcjssj;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique type id SOAP_TYPE_ns1__obdJgsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__obdJgsj() { ns1__obdJgsj::soap_default(NULL); }
	virtual ~ns1__obdJgsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__obdJgsjResponse
#define SOAP_TYPE_ns1__obdJgsjResponse (15)
/* ns1:obdJgsjResponse */
class SOAP_CMAC ns1__obdJgsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique type id SOAP_TYPE_ns1__obdJgsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__obdJgsjResponse() { ns1__obdJgsjResponse::soap_default(NULL); }
	virtual ~ns1__obdJgsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ydjzj
#define SOAP_TYPE_ns1__ydjzj (16)
/* ns1:ydjzj */
class SOAP_CMAC ns1__ydjzj
{
public:
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *ldjcjg;	/* optional element of type xsd:string */
	double lgpz1;	/* required element of type xsd:double */
	double lgpz2;	/* required element of type xsd:double */
	double jcz1;	/* required element of type xsd:double */
	double jcz2;	/* required element of type xsd:double */
	double wcl1;	/* required element of type xsd:double */
	double wcl2;	/* required element of type xsd:double */
	std::wstring *jcjg;	/* optional element of type xsd:string */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	std::wstring *bz;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique type id SOAP_TYPE_ns1__ydjzj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ydjzj() { ns1__ydjzj::soap_default(NULL); }
	virtual ~ns1__ydjzj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ydjzjResponse
#define SOAP_TYPE_ns1__ydjzjResponse (17)
/* ns1:ydjzjResponse */
class SOAP_CMAC ns1__ydjzjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique type id SOAP_TYPE_ns1__ydjzjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ydjzjResponse() { ns1__ydjzjResponse::soap_default(NULL); }
	virtual ~ns1__ydjzjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wqfxybd
#define SOAP_TYPE_ns1__wqfxybd (18)
/* ns1:wqfxybd */
class SOAP_CMAC ns1__wqfxybd
{
public:
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *bqlb;	/* optional element of type xsd:string */
	double bzCO2;	/* required element of type xsd:double */
	double sjCO2;	/* required element of type xsd:double */
	double bzCO;	/* required element of type xsd:double */
	double sjCO;	/* required element of type xsd:double */
	double bzNO;	/* required element of type xsd:double */
	double sjNO;	/* required element of type xsd:double */
	double bzHC;	/* required element of type xsd:double */
	double sjHC;	/* required element of type xsd:double */
	double bzO2;	/* required element of type xsd:double */
	double sjO2;	/* required element of type xsd:double */
	double sjPEF;	/* required element of type xsd:double */
	double bzC3H8;	/* required element of type xsd:double */
	std::wstring *jcjg;	/* optional element of type xsd:string */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	std::wstring *bz;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique type id SOAP_TYPE_ns1__wqfxybd */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wqfxybd() { ns1__wqfxybd::soap_default(NULL); }
	virtual ~ns1__wqfxybd() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wqfxybdResponse
#define SOAP_TYPE_ns1__wqfxybdResponse (19)
/* ns1:wqfxybdResponse */
class SOAP_CMAC ns1__wqfxybdResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique type id SOAP_TYPE_ns1__wqfxybdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wqfxybdResponse() { ns1__wqfxybdResponse::soap_default(NULL); }
	virtual ~ns1__wqfxybdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__jystJgsj
#define SOAP_TYPE_ns1__jystJgsj (20)
/* ns1:jystJgsj */
class SOAP_CMAC ns1__jystJgsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	double co;	/* required element of type xsd:double */
	double hc;	/* required element of type xsd:double */
	double no;	/* required element of type xsd:double */
	double sdgl;	/* required element of type xsd:double */
	double sjxsjl;	/* required element of type xsd:double */
	double cssj;	/* required element of type xsd:double */
	double plcs;	/* required element of type xsd:double */
	double zplsj;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	double ynd;	/* required element of type xsd:double */
	double glkqxs;	/* required element of type xsd:double */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique type id SOAP_TYPE_ns1__jystJgsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__jystJgsj() { ns1__jystJgsj::soap_default(NULL); }
	virtual ~ns1__jystJgsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__jystJgsjResponse
#define SOAP_TYPE_ns1__jystJgsjResponse (21)
/* ns1:jystJgsjResponse */
class SOAP_CMAC ns1__jystJgsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique type id SOAP_TYPE_ns1__jystJgsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__jystJgsjResponse() { ns1__jystJgsjResponse::soap_default(NULL); }
	virtual ~ns1__jystJgsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wgjcJgsj
#define SOAP_TYPE_ns1__wgjcJgsj (22)
/* ns1:wgjcJgsj */
class SOAP_CMAC ns1__wgjcJgsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *cljxzk;	/* optional element of type xsd:string */
	std::wstring *pqwrkzzz;	/* optional element of type xsd:string */
	std::wstring *fdjsfdkb;	/* optional element of type xsd:string */
	std::wstring *sfsjymhy;	/* optional element of type xsd:string */
	std::wstring *qzxtfxt;	/* optional element of type xsd:string */
	std::wstring *ryzfkzxt;	/* optional element of type xsd:string */
	std::wstring *ybpgzqk;	/* optional element of type xsd:string */
	std::wstring *sfyjxgz;	/* optional element of type xsd:string */
	std::wstring *pqxtsfxl;	/* optional element of type xsd:string */
	std::wstring *sfyytxl;	/* optional element of type xsd:string */
	std::wstring *sfyobd;	/* optional element of type xsd:string */
	std::wstring *ltqysfzc;	/* optional element of type xsd:string */
	std::wstring *ltsfqjgj;	/* optional element of type xsd:string */
	std::wstring *sfgbktnf;	/* optional element of type xsd:string */
	std::wstring *sfzdmxgn;	/* optional element of type xsd:string */
	std::wstring *yxypsfyc;	/* optional element of type xsd:string */
	std::wstring *sfshgkfjc;	/* optional element of type xsd:string */
	std::wstring *cyjg;	/* optional element of type xsd:string */
	std::wstring *jyymc;	/* optional element of type xsd:string */
	std::wstring *jysj;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique type id SOAP_TYPE_ns1__wgjcJgsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wgjcJgsj() { ns1__wgjcJgsj::soap_default(NULL); }
	virtual ~ns1__wgjcJgsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wgjcJgsjResponse
#define SOAP_TYPE_ns1__wgjcJgsjResponse (23)
/* ns1:wgjcJgsjResponse */
class SOAP_CMAC ns1__wgjcJgsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique type id SOAP_TYPE_ns1__wgjcJgsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wgjcJgsjResponse() { ns1__wgjcJgsjResponse::soap_default(NULL); }
	virtual ~ns1__wgjcJgsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ryzfJysj
#define SOAP_TYPE_ns1__ryzfJysj (24)
/* ns1:ryzfJysj */
class SOAP_CMAC ns1__ryzfJysj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	double jykcsyl;	/* required element of type xsd:double */
	double jykssyl;	/* required element of type xsd:double */
	std::wstring *jykcsjg;	/* optional element of type xsd:string */
	double yxgxlll;	/* required element of type xsd:double */
	double yxgcsyl;	/* required element of type xsd:double */
	double yxgssyl;	/* required element of type xsd:double */
	std::wstring *yxgcsjg;	/* optional element of type xsd:string */
	std::wstring *jcjg;	/* optional element of type xsd:string */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique type id SOAP_TYPE_ns1__ryzfJysj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ryzfJysj() { ns1__ryzfJysj::soap_default(NULL); }
	virtual ~ns1__ryzfJysj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ryzfJysjResponse
#define SOAP_TYPE_ns1__ryzfJysjResponse (25)
/* ns1:ryzfJysjResponse */
class SOAP_CMAC ns1__ryzfJysjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique type id SOAP_TYPE_ns1__ryzfJysjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ryzfJysjResponse() { ns1__ryzfJysjResponse::soap_default(NULL); }
	virtual ~ns1__ryzfJysjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__btgGcsj
#define SOAP_TYPE_ns1__btgGcsj (26)
/* ns1:btgGcsj */
class SOAP_CMAC ns1__btgGcsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *qssx;	/* optional element of type xsd:string */
	std::wstring *gklx;	/* optional element of type xsd:string */
	int jcsxh;	/* required element of type xsd:int */
	double ydz;	/* required element of type xsd:double */
	double fdjzs;	/* required element of type xsd:double */
	double yw;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique type id SOAP_TYPE_ns1__btgGcsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__btgGcsj() { ns1__btgGcsj::soap_default(NULL); }
	virtual ~ns1__btgGcsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__btgGcsjResponse
#define SOAP_TYPE_ns1__btgGcsjResponse (27)
/* ns1:btgGcsjResponse */
class SOAP_CMAC ns1__btgGcsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique type id SOAP_TYPE_ns1__btgGcsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__btgGcsjResponse() { ns1__btgGcsjResponse::soap_default(NULL); }
	virtual ~ns1__btgGcsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lljzj
#define SOAP_TYPE_ns1__lljzj (28)
/* ns1:lljzj */
class SOAP_CMAC ns1__lljzj
{
public:
	std::wstring *accessToken;	/* optional element of type xsd:string */
	double jqglljcjg;	/* required element of type xsd:double */
	double lljylcjcjg;	/* required element of type xsd:double */
	double yqglcbz;	/* required element of type xsd:double */
	double yqglcclz;	/* required element of type xsd:double */
	double yqglcwc;	/* required element of type xsd:double */
	double yqdlcbz;	/* required element of type xsd:double */
	double yqdlcclz;	/* required element of type xsd:double */
	double yqdlcwc;	/* required element of type xsd:double */
	std::wstring *jcjg;	/* optional element of type xsd:string */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	std::wstring *bz;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique type id SOAP_TYPE_ns1__lljzj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lljzj() { ns1__lljzj::soap_default(NULL); }
	virtual ~ns1__lljzj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lljzjResponse
#define SOAP_TYPE_ns1__lljzjResponse (29)
/* ns1:lljzjResponse */
class SOAP_CMAC ns1__lljzjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique type id SOAP_TYPE_ns1__lljzjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lljzjResponse() { ns1__lljzjResponse::soap_default(NULL); }
	virtual ~ns1__lljzjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__fwqsjtb
#define SOAP_TYPE_ns1__fwqsjtb (30)
/* ns1:fwqsjtb */
class SOAP_CMAC ns1__fwqsjtb
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE_ns1__fwqsjtb */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__fwqsjtb() { ns1__fwqsjtb::soap_default(NULL); }
	virtual ~ns1__fwqsjtb() { }
};
#endif

#ifndef SOAP_TYPE_ns1__fwqsjtbResponse
#define SOAP_TYPE_ns1__fwqsjtbResponse (31)
/* ns1:fwqsjtbResponse */
class SOAP_CMAC ns1__fwqsjtbResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique type id SOAP_TYPE_ns1__fwqsjtbResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__fwqsjtbResponse() { ns1__fwqsjtbResponse::soap_default(NULL); }
	virtual ~ns1__fwqsjtbResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__obdDjlb
#define SOAP_TYPE_ns1__obdDjlb (32)
/* ns1:obdDjlb */
class SOAP_CMAC ns1__obdDjlb
{
public:
	std::wstring *jczbh;	/* optional element of type xsd:string */
	std::wstring *cphm;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique type id SOAP_TYPE_ns1__obdDjlb */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__obdDjlb() { ns1__obdDjlb::soap_default(NULL); }
	virtual ~ns1__obdDjlb() { }
};
#endif

#ifndef SOAP_TYPE_ns1__obdDjlbResponse
#define SOAP_TYPE_ns1__obdDjlbResponse (33)
/* ns1:obdDjlbResponse */
class SOAP_CMAC ns1__obdDjlbResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique type id SOAP_TYPE_ns1__obdDjlbResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__obdDjlbResponse() { ns1__obdDjlbResponse::soap_default(NULL); }
	virtual ~ns1__obdDjlbResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lgmhdGcsj
#define SOAP_TYPE_ns1__lgmhdGcsj (34)
/* ns1:lgmhdGcsj */
class SOAP_CMAC ns1__lgmhdGcsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *qssx;	/* optional element of type xsd:string */
	int jcsxh;	/* required element of type xsd:int */
	double lgmhd;	/* required element of type xsd:double */
	double fdjzs;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique type id SOAP_TYPE_ns1__lgmhdGcsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lgmhdGcsj() { ns1__lgmhdGcsj::soap_default(NULL); }
	virtual ~ns1__lgmhdGcsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lgmhdGcsjResponse
#define SOAP_TYPE_ns1__lgmhdGcsjResponse (35)
/* ns1:lgmhdGcsjResponse */
class SOAP_CMAC ns1__lgmhdGcsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique type id SOAP_TYPE_ns1__lgmhdGcsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lgmhdGcsjResponse() { ns1__lgmhdGcsjResponse::soap_default(NULL); }
	virtual ~ns1__lgmhdGcsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDjclxx
#define SOAP_TYPE_ns1__getDjclxx (36)
/* ns1:getDjclxx */
class SOAP_CMAC ns1__getDjclxx
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique type id SOAP_TYPE_ns1__getDjclxx */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDjclxx() { ns1__getDjclxx::soap_default(NULL); }
	virtual ~ns1__getDjclxx() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDjclxxResponse
#define SOAP_TYPE_ns1__getDjclxxResponse (37)
/* ns1:getDjclxxResponse */
class SOAP_CMAC ns1__getDjclxxResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique type id SOAP_TYPE_ns1__getDjclxxResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDjclxxResponse() { ns1__getDjclxxResponse::soap_default(NULL); }
	virtual ~ns1__getDjclxxResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__jzjsJgsj
#define SOAP_TYPE_ns1__jzjsJgsj (38)
/* ns1:jzjsJgsj */
class SOAP_CMAC ns1__jzjsJgsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	double k100;	/* required element of type xsd:double */
	double k80;	/* required element of type xsd:double */
	double nox80;	/* required element of type xsd:double */
	double zdlbgl;	/* required element of type xsd:double */
	double zdsd;	/* required element of type xsd:double */
	double fdjzs;	/* required element of type xsd:double */
	double dszs;	/* required element of type xsd:double */
	double fdjzssx;	/* required element of type xsd:double */
	double fdjzsxx;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique type id SOAP_TYPE_ns1__jzjsJgsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__jzjsJgsj() { ns1__jzjsJgsj::soap_default(NULL); }
	virtual ~ns1__jzjsJgsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__jzjsJgsjResponse
#define SOAP_TYPE_ns1__jzjsJgsjResponse (39)
/* ns1:jzjsJgsjResponse */
class SOAP_CMAC ns1__jzjsJgsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique type id SOAP_TYPE_ns1__jzjsJgsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__jzjsJgsjResponse() { ns1__jzjsJgsjResponse::soap_default(NULL); }
	virtual ~ns1__jzjsJgsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wtGcsj
#define SOAP_TYPE_ns1__wtGcsj (40)
/* ns1:wtGcsj */
class SOAP_CMAC ns1__wtGcsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *qssx;	/* optional element of type xsd:string */
	std::wstring *gklx;	/* optional element of type xsd:string */
	int jcsxh;	/* required element of type xsd:int */
	double wxzhc;	/* required element of type xsd:double */
	double wxzco;	/* required element of type xsd:double */
	double wxzno;	/* required element of type xsd:double */
	double hc;	/* required element of type xsd:double */
	double co;	/* required element of type xsd:double */
	double no;	/* required element of type xsd:double */
	double o2;	/* required element of type xsd:double */
	double co2;	/* required element of type xsd:double */
	double cs;	/* required element of type xsd:double */
	double zs;	/* required element of type xsd:double */
	double xsxzxs;	/* required element of type xsd:double */
	double sdxzxs;	/* required element of type xsd:double */
	double glkqxs;	/* required element of type xsd:double */
	double dpcgjfz;	/* required element of type xsd:double */
	double zjzgl;	/* required element of type xsd:double */
	double jsgl;	/* required element of type xsd:double */
	double zsgl;	/* required element of type xsd:double */
	double nl;	/* required element of type xsd:double */
	double fxyglyl;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	double yw;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique type id SOAP_TYPE_ns1__wtGcsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wtGcsj() { ns1__wtGcsj::soap_default(NULL); }
	virtual ~ns1__wtGcsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wtGcsjResponse
#define SOAP_TYPE_ns1__wtGcsjResponse (41)
/* ns1:wtGcsjResponse */
class SOAP_CMAC ns1__wtGcsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique type id SOAP_TYPE_ns1__wtGcsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wtGcsjResponse() { ns1__wtGcsjResponse::soap_default(NULL); }
	virtual ~ns1__wtGcsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wtJgsj
#define SOAP_TYPE_ns1__wtJgsj (42)
/* ns1:wtJgsj */
class SOAP_CMAC ns1__wtJgsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	double hc5025;	/* required element of type xsd:double */
	double co5025;	/* required element of type xsd:double */
	double no5025;	/* required element of type xsd:double */
	double fdjzs5025;	/* required element of type xsd:double */
	double fdjyw5025;	/* required element of type xsd:double */
	double pjcs5025;	/* required element of type xsd:double */
	double zgl5025;	/* required element of type xsd:double */
	double hc2540;	/* required element of type xsd:double */
	double co2540;	/* required element of type xsd:double */
	double no2540;	/* required element of type xsd:double */
	double fdjzs2540;	/* required element of type xsd:double */
	double fdjyw2540;	/* required element of type xsd:double */
	double pjcs2540;	/* required element of type xsd:double */
	double zgl2540;	/* required element of type xsd:double */
	double glkqxs;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique type id SOAP_TYPE_ns1__wtJgsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wtJgsj() { ns1__wtJgsj::soap_default(NULL); }
	virtual ~ns1__wtJgsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wtJgsjResponse
#define SOAP_TYPE_ns1__wtJgsjResponse (43)
/* ns1:wtJgsjResponse */
class SOAP_CMAC ns1__wtJgsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique type id SOAP_TYPE_ns1__wtJgsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wtJgsjResponse() { ns1__wtJgsjResponse::soap_default(NULL); }
	virtual ~ns1__wtJgsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__obdGcsj
#define SOAP_TYPE_ns1__obdGcsj (44)
/* ns1:obdGcsj */
class SOAP_CMAC ns1__obdGcsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *qssx;	/* optional element of type xsd:string */
	std::wstring *jcsxh;	/* optional element of type xsd:string */
	double jqmjdkd;	/* required element of type xsd:double */
	double fhz;	/* required element of type xsd:double */
	double ycgqxh;	/* required element of type xsd:double */
	double glkqxs;	/* required element of type xsd:double */
	double cs;	/* required element of type xsd:double */
	double fdjgl;	/* required element of type xsd:double */
	double fdjzs;	/* required element of type xsd:double */
	double jql;	/* required element of type xsd:double */
	double jqyl;	/* required element of type xsd:double */
	double zyyl;	/* required element of type xsd:double */
	double ymkd;	/* required element of type xsd:double */
	double hyl;	/* required element of type xsd:double */
	double nycgqnd;	/* required element of type xsd:double */
	double nspsl;	/* required element of type xsd:double */
	double pqwd;	/* required element of type xsd:double */
	double klbzqyc;	/* required element of type xsd:double */
	double egrkd;	/* required element of type xsd:double */
	double rypsyl;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique type id SOAP_TYPE_ns1__obdGcsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__obdGcsj() { ns1__obdGcsj::soap_default(NULL); }
	virtual ~ns1__obdGcsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__obdGcsjResponse
#define SOAP_TYPE_ns1__obdGcsjResponse (45)
/* ns1:obdGcsjResponse */
class SOAP_CMAC ns1__obdGcsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_ns1__obdGcsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__obdGcsjResponse() { ns1__obdGcsjResponse::soap_default(NULL); }
	virtual ~ns1__obdGcsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjzj
#define SOAP_TYPE_ns1__cgjzj (46)
/* ns1:cgjzj */
class SOAP_CMAC ns1__cgjzj
{
public:
	std::wstring *accessToken;	/* optional element of type xsd:string */
	double gsjzllsj;	/* required element of type xsd:double */
	double gsjzsjsj;	/* required element of type xsd:double */
	double dsjzllsj;	/* required element of type xsd:double */
	double dsjzsjsj;	/* required element of type xsd:double */
	double gsjzns;	/* required element of type xsd:double */
	double dsjzns;	/* required element of type xsd:double */
	double gsjzhxgl;	/* required element of type xsd:double */
	double dsjzhxgl;	/* required element of type xsd:double */
	double jbgl;	/* required element of type xsd:double */
	std::wstring *gsjzjcjg;	/* optional element of type xsd:string */
	std::wstring *dsjzjcjg;	/* optional element of type xsd:string */
	std::wstring *jcjg;	/* optional element of type xsd:string */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	std::wstring *bz;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique type id SOAP_TYPE_ns1__cgjzj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjzj() { ns1__cgjzj::soap_default(NULL); }
	virtual ~ns1__cgjzj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cgjzjResponse
#define SOAP_TYPE_ns1__cgjzjResponse (47)
/* ns1:cgjzjResponse */
class SOAP_CMAC ns1__cgjzjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique type id SOAP_TYPE_ns1__cgjzjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cgjzjResponse() { ns1__cgjzjResponse::soap_default(NULL); }
	virtual ~ns1__cgjzjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__xxtz
#define SOAP_TYPE_ns1__xxtz (48)
/* ns1:xxtz */
class SOAP_CMAC ns1__xxtz
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *code;	/* optional element of type xsd:string */
	std::wstring *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique type id SOAP_TYPE_ns1__xxtz */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__xxtz() { ns1__xxtz::soap_default(NULL); }
	virtual ~ns1__xxtz() { }
};
#endif

#ifndef SOAP_TYPE_ns1__xxtzResponse
#define SOAP_TYPE_ns1__xxtzResponse (49)
/* ns1:xxtzResponse */
class SOAP_CMAC ns1__xxtzResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique type id SOAP_TYPE_ns1__xxtzResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__xxtzResponse() { ns1__xxtzResponse::soap_default(NULL); }
	virtual ~ns1__xxtzResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDjzt
#define SOAP_TYPE_ns1__getDjzt (50)
/* ns1:getDjzt */
class SOAP_CMAC ns1__getDjzt
{
public:
	std::wstring *accessToken;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique type id SOAP_TYPE_ns1__getDjzt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDjzt() { ns1__getDjzt::soap_default(NULL); }
	virtual ~ns1__getDjzt() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDjztResponse
#define SOAP_TYPE_ns1__getDjztResponse (51)
/* ns1:getDjztResponse */
class SOAP_CMAC ns1__getDjztResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique type id SOAP_TYPE_ns1__getDjztResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDjztResponse() { ns1__getDjztResponse::soap_default(NULL); }
	virtual ~ns1__getDjztResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__btgJgsj
#define SOAP_TYPE_ns1__btgJgsj (52)
/* ns1:btgJgsj */
class SOAP_CMAC ns1__btgJgsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	double ydz1;	/* required element of type xsd:double */
	double zs1;	/* required element of type xsd:double */
	double ydz2;	/* required element of type xsd:double */
	double zs2;	/* required element of type xsd:double */
	double ydz3;	/* required element of type xsd:double */
	double zs3;	/* required element of type xsd:double */
	double dszs;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique type id SOAP_TYPE_ns1__btgJgsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__btgJgsj() { ns1__btgJgsj::soap_default(NULL); }
	virtual ~ns1__btgJgsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__btgJgsjResponse
#define SOAP_TYPE_ns1__btgJgsjResponse (53)
/* ns1:btgJgsjResponse */
class SOAP_CMAC ns1__btgJgsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique type id SOAP_TYPE_ns1__btgJgsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__btgJgsjResponse() { ns1__btgJgsjResponse::soap_default(NULL); }
	virtual ~ns1__btgJgsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__hjcsyzj
#define SOAP_TYPE_ns1__hjcsyzj (54)
/* ns1:hjcsyzj */
class SOAP_CMAC ns1__hjcsyzj
{
public:
	std::wstring *accessToken;	/* optional element of type xsd:string */
	double sjhjwd;	/* required element of type xsd:double */
	double clhjwd;	/* required element of type xsd:double */
	double sjhjsd;	/* required element of type xsd:double */
	double clhjsd;	/* required element of type xsd:double */
	double sjdqyl;	/* required element of type xsd:double */
	double cldqyl;	/* required element of type xsd:double */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	std::wstring *bz;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique type id SOAP_TYPE_ns1__hjcsyzj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__hjcsyzj() { ns1__hjcsyzj::soap_default(NULL); }
	virtual ~ns1__hjcsyzj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__hjcsyzjResponse
#define SOAP_TYPE_ns1__hjcsyzjResponse (55)
/* ns1:hjcsyzjResponse */
class SOAP_CMAC ns1__hjcsyzjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique type id SOAP_TYPE_ns1__hjcsyzjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__hjcsyzjResponse() { ns1__hjcsyzjResponse::soap_default(NULL); }
	virtual ~ns1__hjcsyzjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lgmhdJgsj
#define SOAP_TYPE_ns1__lgmhdJgsj (56)
/* ns1:lgmhdJgsj */
class SOAP_CMAC ns1__lgmhdJgsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	double lgmhd;	/* required element of type xsd:double */
	double fdjzs;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique type id SOAP_TYPE_ns1__lgmhdJgsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lgmhdJgsj() { ns1__lgmhdJgsj::soap_default(NULL); }
	virtual ~ns1__lgmhdJgsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lgmhdJgsjResponse
#define SOAP_TYPE_ns1__lgmhdJgsjResponse (57)
/* ns1:lgmhdJgsjResponse */
class SOAP_CMAC ns1__lgmhdJgsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique type id SOAP_TYPE_ns1__lgmhdJgsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lgmhdJgsjResponse() { ns1__lgmhdJgsjResponse::soap_default(NULL); }
	virtual ~ns1__lgmhdJgsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__jczrylb
#define SOAP_TYPE_ns1__jczrylb (58)
/* ns1:jczrylb */
class SOAP_CMAC ns1__jczrylb
{
public:
	std::wstring *jczbh;	/* optional element of type xsd:string */
	std::wstring *jsdm;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique type id SOAP_TYPE_ns1__jczrylb */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__jczrylb() { ns1__jczrylb::soap_default(NULL); }
	virtual ~ns1__jczrylb() { }
};
#endif

#ifndef SOAP_TYPE_ns1__jczrylbResponse
#define SOAP_TYPE_ns1__jczrylbResponse (59)
/* ns1:jczrylbResponse */
class SOAP_CMAC ns1__jczrylbResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique type id SOAP_TYPE_ns1__jczrylbResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__jczrylbResponse() { ns1__jczrylbResponse::soap_default(NULL); }
	virtual ~ns1__jczrylbResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__jystGcsj
#define SOAP_TYPE_ns1__jystGcsj (60)
/* ns1:jystGcsj */
class SOAP_CMAC ns1__jystGcsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *qssx;	/* optional element of type xsd:string */
	std::wstring *gklx;	/* optional element of type xsd:string */
	int jcsxh;	/* required element of type xsd:int */
	double wxzhc;	/* required element of type xsd:double */
	double hc;	/* required element of type xsd:double */
	double wxzco;	/* required element of type xsd:double */
	double co;	/* required element of type xsd:double */
	double co2;	/* required element of type xsd:double */
	double wxznox;	/* required element of type xsd:double */
	double nox;	/* required element of type xsd:double */
	double o2;	/* required element of type xsd:double */
	double sjll;	/* required element of type xsd:double */
	double bzll;	/* required element of type xsd:double */
	double wqll;	/* required element of type xsd:double */
	double cs;	/* required element of type xsd:double */
	double bzss;	/* required element of type xsd:double */
	double fdjzs;	/* required element of type xsd:double */
	double glkqxs;	/* required element of type xsd:double */
	double xsxzxs;	/* required element of type xsd:double */
	double nosdxzxs;	/* required element of type xsd:double */
	double xsb;	/* required element of type xsd:double */
	double jzgl;	/* required element of type xsd:double */
	double jsgl;	/* required element of type xsd:double */
	double zsgl;	/* required element of type xsd:double */
	double lljqy;	/* required element of type xsd:double */
	double lljwd;	/* required element of type xsd:double */
	double nl;	/* required element of type xsd:double */
	double fxyglyl;	/* required element of type xsd:double */
	double scfz;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique type id SOAP_TYPE_ns1__jystGcsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__jystGcsj() { ns1__jystGcsj::soap_default(NULL); }
	virtual ~ns1__jystGcsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__jystGcsjResponse
#define SOAP_TYPE_ns1__jystGcsjResponse (61)
/* ns1:jystGcsjResponse */
class SOAP_CMAC ns1__jystGcsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique type id SOAP_TYPE_ns1__jystGcsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__jystGcsjResponse() { ns1__jystGcsjResponse::soap_default(NULL); }
	virtual ~ns1__jystGcsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__jzjsGcsj
#define SOAP_TYPE_ns1__jzjsGcsj (62)
/* ns1:jzjsGcsj */
class SOAP_CMAC ns1__jzjsGcsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *qssx;	/* optional element of type xsd:string */
	std::wstring *gklx;	/* optional element of type xsd:string */
	int jcsxh;	/* required element of type xsd:int */
	double gxsxs;	/* required element of type xsd:double */
	double ydz;	/* required element of type xsd:double */
	double sscs;	/* required element of type xsd:double */
	double fdjzs;	/* required element of type xsd:double */
	double nl;	/* required element of type xsd:double */
	double nj;	/* required element of type xsd:double */
	double scgl;	/* required element of type xsd:double */
	double glxzxs;	/* required element of type xsd:double */
	double xzhgl;	/* required element of type xsd:double */
	double nox;	/* required element of type xsd:double */
	double co2;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique type id SOAP_TYPE_ns1__jzjsGcsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__jzjsGcsj() { ns1__jzjsGcsj::soap_default(NULL); }
	virtual ~ns1__jzjsGcsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__jzjsGcsjResponse
#define SOAP_TYPE_ns1__jzjsGcsjResponse (63)
/* ns1:jzjsGcsjResponse */
class SOAP_CMAC ns1__jzjsGcsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique type id SOAP_TYPE_ns1__jzjsGcsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__jzjsGcsjResponse() { ns1__jzjsGcsjResponse::soap_default(NULL); }
	virtual ~ns1__jzjsGcsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wqfxyzj
#define SOAP_TYPE_ns1__wqfxyzj (64)
/* ns1:wqfxyzj */
class SOAP_CMAC ns1__wqfxyzj
{
public:
	std::wstring *accessToken;	/* optional element of type xsd:string */
	std::wstring *jcjg;	/* optional element of type xsd:string */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	std::wstring *bz;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique type id SOAP_TYPE_ns1__wqfxyzj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wqfxyzj() { ns1__wqfxyzj::soap_default(NULL); }
	virtual ~ns1__wqfxyzj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wqfxyzjResponse
#define SOAP_TYPE_ns1__wqfxyzjResponse (65)
/* ns1:wqfxyzjResponse */
class SOAP_CMAC ns1__wqfxyzjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique type id SOAP_TYPE_ns1__wqfxyzjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wqfxyzjResponse() { ns1__wqfxyzjResponse::soap_default(NULL); }
	virtual ~ns1__wqfxyzjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cycObdIupr
#define SOAP_TYPE_ns1__cycObdIupr (66)
/* ns1:cycObdIupr */
class SOAP_CMAC ns1__cycObdIupr
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	int nmhcchqjccs;	/* required element of type xsd:int */
	int nmhcchqfhtjcs;	/* required element of type xsd:int */
	double nmhcchqiuprl;	/* required element of type xsd:double */
	int noxchqjccs;	/* required element of type xsd:int */
	int noxchqfhtjcs;	/* required element of type xsd:int */
	double noxchqiuprl;	/* required element of type xsd:double */
	int noxxfqjccs;	/* required element of type xsd:int */
	int noxxfqfhtjcs;	/* required element of type xsd:int */
	double noxxfqiuprl;	/* required element of type xsd:double */
	int pmbjqjccs;	/* required element of type xsd:int */
	int pmbjqfhtjcs;	/* required element of type xsd:int */
	double pmbjqiuprl;	/* required element of type xsd:double */
	int fqcgqjccs;	/* required element of type xsd:int */
	int fqcgqfhtjcs;	/* required element of type xsd:int */
	double fqcgqiuprl;	/* required element of type xsd:double */
	int egrvvtjccs;	/* required element of type xsd:int */
	int egrvvtfhtjcs;	/* required element of type xsd:int */
	double egrvvtiuprl;	/* required element of type xsd:double */
	int zyyljccs;	/* required element of type xsd:int */
	int zyylfhtjcs;	/* required element of type xsd:int */
	double zyyliuprl;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique type id SOAP_TYPE_ns1__cycObdIupr */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cycObdIupr() { ns1__cycObdIupr::soap_default(NULL); }
	virtual ~ns1__cycObdIupr() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cycObdIuprResponse
#define SOAP_TYPE_ns1__cycObdIuprResponse (67)
/* ns1:cycObdIuprResponse */
class SOAP_CMAC ns1__cycObdIuprResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique type id SOAP_TYPE_ns1__cycObdIuprResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cycObdIuprResponse() { ns1__cycObdIuprResponse::soap_default(NULL); }
	virtual ~ns1__cycObdIuprResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sdsJgsj
#define SOAP_TYPE_ns1__sdsJgsj (68)
/* ns1:sdsJgsj */
class SOAP_CMAC ns1__sdsJgsj
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	std::wstring *accessToken;	/* optional element of type xsd:string */
	double dszs;	/* required element of type xsd:double */
	double dsyw;	/* required element of type xsd:double */
	double gdszs;	/* required element of type xsd:double */
	double gdsyw;	/* required element of type xsd:double */
	double dsco;	/* required element of type xsd:double */
	double dshc;	/* required element of type xsd:double */
	double gdsco;	/* required element of type xsd:double */
	double gdshc;	/* required element of type xsd:double */
	double glkqxs;	/* required element of type xsd:double */
	double wd;	/* required element of type xsd:double */
	double sd;	/* required element of type xsd:double */
	double dqy;	/* required element of type xsd:double */
	std::wstring *kssj;	/* optional element of type xsd:string */
	std::wstring *jssj;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique type id SOAP_TYPE_ns1__sdsJgsj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sdsJgsj() { ns1__sdsJgsj::soap_default(NULL); }
	virtual ~ns1__sdsJgsj() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sdsJgsjResponse
#define SOAP_TYPE_ns1__sdsJgsjResponse (69)
/* ns1:sdsJgsjResponse */
class SOAP_CMAC ns1__sdsJgsjResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique type id SOAP_TYPE_ns1__sdsJgsjResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sdsJgsjResponse() { ns1__sdsJgsjResponse::soap_default(NULL); }
	virtual ~ns1__sdsJgsjResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__qycObdIupr
#define SOAP_TYPE_ns1__qycObdIupr (70)
/* ns1:qycObdIupr */
class SOAP_CMAC ns1__qycObdIupr
{
public:
	std::wstring *lsh;	/* optional element of type xsd:string */
	int chqz1jccs;	/* required element of type xsd:int */
	int chqz1fhtjcs;	/* required element of type xsd:int */
	double chqz1iuprl;	/* required element of type xsd:double */
	int chqz2jccs;	/* required element of type xsd:int */
	int chqz2fhtjcs;	/* required element of type xsd:int */
	double chqz2iuprl;	/* required element of type xsd:double */
	int qycgqz1jccs;	/* required element of type xsd:int */
	int qycgqz1fhtjcs;	/* required element of type xsd:int */
	double qycgqz1iuprl;	/* required element of type xsd:double */
	int qycgqz2jccs;	/* required element of type xsd:int */
	int qycgqz2fhtjcs;	/* required element of type xsd:int */
	double qycgqz2iuprl;	/* required element of type xsd:double */
	int hycgqz1jccs;	/* required element of type xsd:int */
	int hycgqz1fhtjcs;	/* required element of type xsd:int */
	double hycgqz1iuprl;	/* required element of type xsd:double */
	int hycgqz2jccs;	/* required element of type xsd:int */
	int hycgqz2fhtjcs;	/* required element of type xsd:int */
	double hycgqz2iuprl;	/* required element of type xsd:double */
	int evapjccs;	/* required element of type xsd:int */
	int evapfhtjcs;	/* required element of type xsd:int */
	double evapiuprl;	/* required element of type xsd:double */
	int egrvvtjccs;	/* required element of type xsd:int */
	int egrvvtfhtjcs;	/* required element of type xsd:int */
	double egrvvtiuprl;	/* required element of type xsd:double */
	int gpfz1jccs;	/* required element of type xsd:int */
	int gpfz1fhtjcs;	/* required element of type xsd:int */
	double gpfz1iuprl;	/* required element of type xsd:double */
	int gpfz2jccs;	/* required element of type xsd:int */
	int gpfz2fhtjcs;	/* required element of type xsd:int */
	double gpfz2iuprl;	/* required element of type xsd:double */
	int eckqpsxtjccs;	/* required element of type xsd:int */
	int eckqpsxtfhtjcs;	/* required element of type xsd:int */
	double eckqpsxtiuprl;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique type id SOAP_TYPE_ns1__qycObdIupr */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__qycObdIupr() { ns1__qycObdIupr::soap_default(NULL); }
	virtual ~ns1__qycObdIupr() { }
};
#endif

#ifndef SOAP_TYPE_ns1__qycObdIuprResponse
#define SOAP_TYPE_ns1__qycObdIuprResponse (71)
/* ns1:qycObdIuprResponse */
class SOAP_CMAC ns1__qycObdIuprResponse
{
public:
	std::wstring *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique type id SOAP_TYPE_ns1__qycObdIuprResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__qycObdIuprResponse() { ns1__qycObdIuprResponse::soap_default(NULL); }
	virtual ~ns1__qycObdIuprResponse() { }
};
#endif

#ifndef SOAP_TYPE___ns1__sdsGcsj
#define SOAP_TYPE___ns1__sdsGcsj (79)
/* Operation wrapper: */
struct __ns1__sdsGcsj
{
public:
	ns1__sdsGcsj *ns1__sdsGcsj_;	/* optional element of type ns1:sdsGcsj */
public:
	int soap_type() const { return 79; } /* = unique type id SOAP_TYPE___ns1__sdsGcsj */
};
#endif

#ifndef SOAP_TYPE___ns1__getAccessToken
#define SOAP_TYPE___ns1__getAccessToken (83)
/* Operation wrapper: */
struct __ns1__getAccessToken
{
public:
	ns1__getAccessToken *ns1__getAccessToken_;	/* optional element of type ns1:getAccessToken */
public:
	int soap_type() const { return 83; } /* = unique type id SOAP_TYPE___ns1__getAccessToken */
};
#endif

#ifndef SOAP_TYPE___ns1__gkrjbbh
#define SOAP_TYPE___ns1__gkrjbbh (87)
/* Operation wrapper: */
struct __ns1__gkrjbbh
{
public:
	ns1__gkrjbbh *ns1__gkrjbbh_;	/* optional element of type ns1:gkrjbbh */
public:
	int soap_type() const { return 87; } /* = unique type id SOAP_TYPE___ns1__gkrjbbh */
};
#endif

#ifndef SOAP_TYPE___ns1__obdJgsj
#define SOAP_TYPE___ns1__obdJgsj (91)
/* Operation wrapper: */
struct __ns1__obdJgsj
{
public:
	ns1__obdJgsj *ns1__obdJgsj_;	/* optional element of type ns1:obdJgsj */
public:
	int soap_type() const { return 91; } /* = unique type id SOAP_TYPE___ns1__obdJgsj */
};
#endif

#ifndef SOAP_TYPE___ns1__ydjzj
#define SOAP_TYPE___ns1__ydjzj (95)
/* Operation wrapper: */
struct __ns1__ydjzj
{
public:
	ns1__ydjzj *ns1__ydjzj_;	/* optional element of type ns1:ydjzj */
public:
	int soap_type() const { return 95; } /* = unique type id SOAP_TYPE___ns1__ydjzj */
};
#endif

#ifndef SOAP_TYPE___ns1__wqfxybd
#define SOAP_TYPE___ns1__wqfxybd (99)
/* Operation wrapper: */
struct __ns1__wqfxybd
{
public:
	ns1__wqfxybd *ns1__wqfxybd_;	/* optional element of type ns1:wqfxybd */
public:
	int soap_type() const { return 99; } /* = unique type id SOAP_TYPE___ns1__wqfxybd */
};
#endif

#ifndef SOAP_TYPE___ns1__jystJgsj
#define SOAP_TYPE___ns1__jystJgsj (103)
/* Operation wrapper: */
struct __ns1__jystJgsj
{
public:
	ns1__jystJgsj *ns1__jystJgsj_;	/* optional element of type ns1:jystJgsj */
public:
	int soap_type() const { return 103; } /* = unique type id SOAP_TYPE___ns1__jystJgsj */
};
#endif

#ifndef SOAP_TYPE___ns1__wgjcJgsj
#define SOAP_TYPE___ns1__wgjcJgsj (107)
/* Operation wrapper: */
struct __ns1__wgjcJgsj
{
public:
	ns1__wgjcJgsj *ns1__wgjcJgsj_;	/* optional element of type ns1:wgjcJgsj */
public:
	int soap_type() const { return 107; } /* = unique type id SOAP_TYPE___ns1__wgjcJgsj */
};
#endif

#ifndef SOAP_TYPE___ns1__ryzfJysj
#define SOAP_TYPE___ns1__ryzfJysj (111)
/* Operation wrapper: */
struct __ns1__ryzfJysj
{
public:
	ns1__ryzfJysj *ns1__ryzfJysj_;	/* optional element of type ns1:ryzfJysj */
public:
	int soap_type() const { return 111; } /* = unique type id SOAP_TYPE___ns1__ryzfJysj */
};
#endif

#ifndef SOAP_TYPE___ns1__btgGcsj
#define SOAP_TYPE___ns1__btgGcsj (115)
/* Operation wrapper: */
struct __ns1__btgGcsj
{
public:
	ns1__btgGcsj *ns1__btgGcsj_;	/* optional element of type ns1:btgGcsj */
public:
	int soap_type() const { return 115; } /* = unique type id SOAP_TYPE___ns1__btgGcsj */
};
#endif

#ifndef SOAP_TYPE___ns1__lljzj
#define SOAP_TYPE___ns1__lljzj (119)
/* Operation wrapper: */
struct __ns1__lljzj
{
public:
	ns1__lljzj *ns1__lljzj_;	/* optional element of type ns1:lljzj */
public:
	int soap_type() const { return 119; } /* = unique type id SOAP_TYPE___ns1__lljzj */
};
#endif

#ifndef SOAP_TYPE___ns1__fwqsjtb
#define SOAP_TYPE___ns1__fwqsjtb (123)
/* Operation wrapper: */
struct __ns1__fwqsjtb
{
public:
	ns1__fwqsjtb *ns1__fwqsjtb_;	/* optional element of type ns1:fwqsjtb */
public:
	int soap_type() const { return 123; } /* = unique type id SOAP_TYPE___ns1__fwqsjtb */
};
#endif

#ifndef SOAP_TYPE___ns1__obdDjlb
#define SOAP_TYPE___ns1__obdDjlb (127)
/* Operation wrapper: */
struct __ns1__obdDjlb
{
public:
	ns1__obdDjlb *ns1__obdDjlb_;	/* optional element of type ns1:obdDjlb */
public:
	int soap_type() const { return 127; } /* = unique type id SOAP_TYPE___ns1__obdDjlb */
};
#endif

#ifndef SOAP_TYPE___ns1__lgmhdGcsj
#define SOAP_TYPE___ns1__lgmhdGcsj (131)
/* Operation wrapper: */
struct __ns1__lgmhdGcsj
{
public:
	ns1__lgmhdGcsj *ns1__lgmhdGcsj_;	/* optional element of type ns1:lgmhdGcsj */
public:
	int soap_type() const { return 131; } /* = unique type id SOAP_TYPE___ns1__lgmhdGcsj */
};
#endif

#ifndef SOAP_TYPE___ns1__getDjclxx
#define SOAP_TYPE___ns1__getDjclxx (135)
/* Operation wrapper: */
struct __ns1__getDjclxx
{
public:
	ns1__getDjclxx *ns1__getDjclxx_;	/* optional element of type ns1:getDjclxx */
public:
	int soap_type() const { return 135; } /* = unique type id SOAP_TYPE___ns1__getDjclxx */
};
#endif

#ifndef SOAP_TYPE___ns1__jzjsJgsj
#define SOAP_TYPE___ns1__jzjsJgsj (139)
/* Operation wrapper: */
struct __ns1__jzjsJgsj
{
public:
	ns1__jzjsJgsj *ns1__jzjsJgsj_;	/* optional element of type ns1:jzjsJgsj */
public:
	int soap_type() const { return 139; } /* = unique type id SOAP_TYPE___ns1__jzjsJgsj */
};
#endif

#ifndef SOAP_TYPE___ns1__wtGcsj
#define SOAP_TYPE___ns1__wtGcsj (143)
/* Operation wrapper: */
struct __ns1__wtGcsj
{
public:
	ns1__wtGcsj *ns1__wtGcsj_;	/* optional element of type ns1:wtGcsj */
public:
	int soap_type() const { return 143; } /* = unique type id SOAP_TYPE___ns1__wtGcsj */
};
#endif

#ifndef SOAP_TYPE___ns1__obdGcsj
#define SOAP_TYPE___ns1__obdGcsj (147)
/* Operation wrapper: */
struct __ns1__obdGcsj
{
public:
	ns1__obdGcsj *ns1__obdGcsj_;	/* optional element of type ns1:obdGcsj */
public:
	int soap_type() const { return 147; } /* = unique type id SOAP_TYPE___ns1__obdGcsj */
};
#endif

#ifndef SOAP_TYPE___ns1__wtJgsj
#define SOAP_TYPE___ns1__wtJgsj (151)
/* Operation wrapper: */
struct __ns1__wtJgsj
{
public:
	ns1__wtJgsj *ns1__wtJgsj_;	/* optional element of type ns1:wtJgsj */
public:
	int soap_type() const { return 151; } /* = unique type id SOAP_TYPE___ns1__wtJgsj */
};
#endif

#ifndef SOAP_TYPE___ns1__cgjzj
#define SOAP_TYPE___ns1__cgjzj (155)
/* Operation wrapper: */
struct __ns1__cgjzj
{
public:
	ns1__cgjzj *ns1__cgjzj_;	/* optional element of type ns1:cgjzj */
public:
	int soap_type() const { return 155; } /* = unique type id SOAP_TYPE___ns1__cgjzj */
};
#endif

#ifndef SOAP_TYPE___ns1__getDjzt
#define SOAP_TYPE___ns1__getDjzt (159)
/* Operation wrapper: */
struct __ns1__getDjzt
{
public:
	ns1__getDjzt *ns1__getDjzt_;	/* optional element of type ns1:getDjzt */
public:
	int soap_type() const { return 159; } /* = unique type id SOAP_TYPE___ns1__getDjzt */
};
#endif

#ifndef SOAP_TYPE___ns1__xxtz
#define SOAP_TYPE___ns1__xxtz (163)
/* Operation wrapper: */
struct __ns1__xxtz
{
public:
	ns1__xxtz *ns1__xxtz_;	/* optional element of type ns1:xxtz */
public:
	int soap_type() const { return 163; } /* = unique type id SOAP_TYPE___ns1__xxtz */
};
#endif

#ifndef SOAP_TYPE___ns1__btgJgsj
#define SOAP_TYPE___ns1__btgJgsj (167)
/* Operation wrapper: */
struct __ns1__btgJgsj
{
public:
	ns1__btgJgsj *ns1__btgJgsj_;	/* optional element of type ns1:btgJgsj */
public:
	int soap_type() const { return 167; } /* = unique type id SOAP_TYPE___ns1__btgJgsj */
};
#endif

#ifndef SOAP_TYPE___ns1__hjcsyzj
#define SOAP_TYPE___ns1__hjcsyzj (171)
/* Operation wrapper: */
struct __ns1__hjcsyzj
{
public:
	ns1__hjcsyzj *ns1__hjcsyzj_;	/* optional element of type ns1:hjcsyzj */
public:
	int soap_type() const { return 171; } /* = unique type id SOAP_TYPE___ns1__hjcsyzj */
};
#endif

#ifndef SOAP_TYPE___ns1__jczrylb
#define SOAP_TYPE___ns1__jczrylb (175)
/* Operation wrapper: */
struct __ns1__jczrylb
{
public:
	ns1__jczrylb *ns1__jczrylb_;	/* optional element of type ns1:jczrylb */
public:
	int soap_type() const { return 175; } /* = unique type id SOAP_TYPE___ns1__jczrylb */
};
#endif

#ifndef SOAP_TYPE___ns1__lgmhdJgsj
#define SOAP_TYPE___ns1__lgmhdJgsj (179)
/* Operation wrapper: */
struct __ns1__lgmhdJgsj
{
public:
	ns1__lgmhdJgsj *ns1__lgmhdJgsj_;	/* optional element of type ns1:lgmhdJgsj */
public:
	int soap_type() const { return 179; } /* = unique type id SOAP_TYPE___ns1__lgmhdJgsj */
};
#endif

#ifndef SOAP_TYPE___ns1__jystGcsj
#define SOAP_TYPE___ns1__jystGcsj (183)
/* Operation wrapper: */
struct __ns1__jystGcsj
{
public:
	ns1__jystGcsj *ns1__jystGcsj_;	/* optional element of type ns1:jystGcsj */
public:
	int soap_type() const { return 183; } /* = unique type id SOAP_TYPE___ns1__jystGcsj */
};
#endif

#ifndef SOAP_TYPE___ns1__jzjsGcsj
#define SOAP_TYPE___ns1__jzjsGcsj (187)
/* Operation wrapper: */
struct __ns1__jzjsGcsj
{
public:
	ns1__jzjsGcsj *ns1__jzjsGcsj_;	/* optional element of type ns1:jzjsGcsj */
public:
	int soap_type() const { return 187; } /* = unique type id SOAP_TYPE___ns1__jzjsGcsj */
};
#endif

#ifndef SOAP_TYPE___ns1__wqfxyzj
#define SOAP_TYPE___ns1__wqfxyzj (191)
/* Operation wrapper: */
struct __ns1__wqfxyzj
{
public:
	ns1__wqfxyzj *ns1__wqfxyzj_;	/* optional element of type ns1:wqfxyzj */
public:
	int soap_type() const { return 191; } /* = unique type id SOAP_TYPE___ns1__wqfxyzj */
};
#endif

#ifndef SOAP_TYPE___ns1__cycObdIupr
#define SOAP_TYPE___ns1__cycObdIupr (195)
/* Operation wrapper: */
struct __ns1__cycObdIupr
{
public:
	ns1__cycObdIupr *ns1__cycObdIupr_;	/* optional element of type ns1:cycObdIupr */
public:
	int soap_type() const { return 195; } /* = unique type id SOAP_TYPE___ns1__cycObdIupr */
};
#endif

#ifndef SOAP_TYPE___ns1__sdsJgsj
#define SOAP_TYPE___ns1__sdsJgsj (199)
/* Operation wrapper: */
struct __ns1__sdsJgsj
{
public:
	ns1__sdsJgsj *ns1__sdsJgsj_;	/* optional element of type ns1:sdsJgsj */
public:
	int soap_type() const { return 199; } /* = unique type id SOAP_TYPE___ns1__sdsJgsj */
};
#endif

#ifndef SOAP_TYPE___ns1__qycObdIupr
#define SOAP_TYPE___ns1__qycObdIupr (203)
/* Operation wrapper: */
struct __ns1__qycObdIupr
{
public:
	ns1__qycObdIupr *ns1__qycObdIupr_;	/* optional element of type ns1:qycObdIupr */
public:
	int soap_type() const { return 203; } /* = unique type id SOAP_TYPE___ns1__qycObdIupr */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (204)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 204; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (205)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 205; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (207)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 207; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (210)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 210; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (211)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 211; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
